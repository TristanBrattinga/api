import require$$3$1 from "mock-aws-s3";
import require$$5$2 from "aws-sdk";
import require$$6$1 from "nock";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var main$3 = { exports: {} };
const path$7 = {};
const __viteBrowserExternal = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: path$7
}, Symbol.toStringTag, { value: "Module" }));
const require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal);
var path$6 = { exports: {} };
var util$f = {};
var isBufferBrowser = function isBuffer(arg) {
  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits_browserExports$1 = inherits_browser$1.exports;
(function(exports2) {
  var define_process_env_default2 = {};
  var formatRegExp = /%[sdj%]/g;
  exports2.format = function(f) {
    if (!isString2(f)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect2(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i2 >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i2]; i2 < len; x = args[++i2]) {
      if (isNull2(x) || !isObject2(x)) {
        str += " " + x;
      } else {
        str += " " + inspect2(x);
      }
    }
    return str;
  };
  exports2.deprecate = function(fn, msg) {
    if (isUndefined2(commonjsGlobal.process)) {
      return function() {
        return exports2.deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnviron;
  exports2.debuglog = function(set) {
    if (isUndefined2(debugEnviron))
      debugEnviron = define_process_env_default2.NODE_DEBUG || "";
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
        var pid = process.pid;
        debugs[set] = function() {
          var msg = exports2.format.apply(exports2, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  };
  function inspect2(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean2(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports2._extend(ctx, opts);
    }
    if (isUndefined2(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined2(ctx.depth))
      ctx.depth = 2;
    if (isUndefined2(ctx.colors))
      ctx.colors = false;
    if (isUndefined2(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports2.inspect = inspect2;
  inspect2.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect2.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect2.styles[styleType];
    if (style) {
      return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString2(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value);
    }
    if (isError2(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys2.length === 0) {
      if (isFunction2(value)) {
        var name2 = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name2 + "]", "special");
      }
      if (isRegExp3(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate2(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError2(value)) {
        return formatError(value);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray2(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction2(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp3(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate2(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError2(value)) {
      base = " " + formatError(value);
    }
    if (keys2.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp3(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined2(value))
      return ctx.stylize("undefined", "undefined");
    if (isString2(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean2(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull2(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i2 = 0, l = value.length; i2 < l; ++i2) {
      if (hasOwnProperty2(value, String(i2))) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          String(i2),
          true
        ));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(
          ctx,
          value,
          recurseTimes,
          visibleKeys,
          key,
          true
        ));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name2, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty2(visibleKeys, key)) {
      name2 = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull2(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined2(name2)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name2 = JSON.stringify("" + key);
      if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name2 = name2.substr(1, name2.length - 2);
        name2 = ctx.stylize(name2, "name");
      } else {
        name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name2 = ctx.stylize(name2, "string");
      }
    }
    return name2 + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var length2 = output.reduce(function(prev2, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev2 + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length2 > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  exports2.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean2;
  function isNull2(arg) {
    return arg === null;
  }
  exports2.isNull = isNull2;
  function isNullOrUndefined2(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined2;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString2;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol2;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined2;
  function isRegExp3(re2) {
    return isObject2(re2) && objectToString2(re2) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp3;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject2;
  function isDate2(d2) {
    return isObject2(d2) && objectToString2(d2) === "[object Date]";
  }
  exports2.isDate = isDate2;
  function isError2(e) {
    return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
  }
  exports2.isError = isError2;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction2;
  function isPrimitive2(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive2;
  exports2.isBuffer = isBufferBrowser;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp() {
    var d2 = /* @__PURE__ */ new Date();
    var time = [
      pad(d2.getHours()),
      pad(d2.getMinutes()),
      pad(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time].join(" ");
  }
  exports2.log = function() {
    console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
  };
  exports2.inherits = inherits_browserExports$1;
  exports2._extend = function(origin, add) {
    if (!add || !isObject2(add))
      return origin;
    var keys2 = Object.keys(add);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add[keys2[i2]];
    }
    return origin;
  };
  function hasOwnProperty2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
})(util$f);
var define_process_env_default$a = {};
var isWindows = process.platform === "win32";
var util$e = util$f;
function normalizeArray(parts, allowAboveRoot) {
  var res2 = [];
  for (var i2 = 0; i2 < parts.length; i2++) {
    var p = parts[i2];
    if (!p || p === ".")
      continue;
    if (p === "..") {
      if (res2.length && res2[res2.length - 1] !== "..") {
        res2.pop();
      } else if (allowAboveRoot) {
        res2.push("..");
      }
    } else {
      res2.push(p);
    }
  }
  return res2;
}
function trimArray(arr) {
  var lastIndex = arr.length - 1;
  var start = 0;
  for (; start <= lastIndex; start++) {
    if (arr[start])
      break;
  }
  var end2 = lastIndex;
  for (; end2 >= 0; end2--) {
    if (arr[end2])
      break;
  }
  if (start === 0 && end2 === lastIndex)
    return arr;
  if (start > end2)
    return [];
  return arr.slice(start, end2 + 1);
}
var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
var win32 = {};
function win32SplitPath(filename) {
  var result = splitDeviceRe.exec(filename), device = (result[1] || "") + (result[2] || ""), tail = result[3] || "";
  var result2 = splitTailRe.exec(tail), dir = result2[1], basename2 = result2[2], ext = result2[3];
  return [device, dir, basename2, ext];
}
function win32StatPath(path3) {
  var result = splitDeviceRe.exec(path3), device = result[1] || "", isUnc = !!device && device[1] !== ":";
  return {
    device,
    isUnc,
    isAbsolute: isUnc || !!result[2],
    // UNC paths are always absolute
    tail: result[3]
  };
}
function normalizeUNCRoot(device) {
  return "\\\\" + device.replace(/^[\\\/]+/, "").replace(/[\\\/]+/g, "\\");
}
win32.resolve = function() {
  var resolvedDevice = "", resolvedTail = "", resolvedAbsolute = false;
  for (var i2 = arguments.length - 1; i2 >= -1; i2--) {
    var path3;
    if (i2 >= 0) {
      path3 = arguments[i2];
    } else if (!resolvedDevice) {
      path3 = process.cwd();
    } else {
      path3 = define_process_env_default$a["=" + resolvedDevice];
      if (!path3 || path3.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + "\\") {
        path3 = resolvedDevice + "\\";
      }
    }
    if (!util$e.isString(path3)) {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path3) {
      continue;
    }
    var result = win32StatPath(path3), device = result.device, isUnc = result.isUnc, isAbsolute2 = result.isAbsolute, tail = result.tail;
    if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (!resolvedDevice) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = tail + "\\" + resolvedTail;
      resolvedAbsolute = isAbsolute2;
    }
    if (resolvedDevice && resolvedAbsolute) {
      break;
    }
  }
  if (isUnc) {
    resolvedDevice = normalizeUNCRoot(resolvedDevice);
  }
  resolvedTail = normalizeArray(
    resolvedTail.split(/[\\\/]+/),
    !resolvedAbsolute
  ).join("\\");
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
};
win32.normalize = function(path3) {
  var result = win32StatPath(path3), device = result.device, isUnc = result.isUnc, isAbsolute2 = result.isAbsolute, tail = result.tail, trailingSlash = /[\\\/]$/.test(tail);
  tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute2).join("\\");
  if (!tail && !isAbsolute2) {
    tail = ".";
  }
  if (tail && trailingSlash) {
    tail += "\\";
  }
  if (isUnc) {
    device = normalizeUNCRoot(device);
  }
  return device + (isAbsolute2 ? "\\" : "") + tail;
};
win32.isAbsolute = function(path3) {
  return win32StatPath(path3).isAbsolute;
};
win32.join = function() {
  var paths = [];
  for (var i2 = 0; i2 < arguments.length; i2++) {
    var arg = arguments[i2];
    if (!util$e.isString(arg)) {
      throw new TypeError("Arguments to path.join must be strings");
    }
    if (arg) {
      paths.push(arg);
    }
  }
  var joined = paths.join("\\");
  if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
    joined = joined.replace(/^[\\\/]{2,}/, "\\");
  }
  return win32.normalize(joined);
};
win32.relative = function(from, to) {
  from = win32.resolve(from);
  to = win32.resolve(to);
  var lowerFrom = from.toLowerCase();
  var lowerTo = to.toLowerCase();
  var toParts = trimArray(to.split("\\"));
  var lowerFromParts = trimArray(lowerFrom.split("\\"));
  var lowerToParts = trimArray(lowerTo.split("\\"));
  var length2 = Math.min(lowerFromParts.length, lowerToParts.length);
  var samePartsLength = length2;
  for (var i2 = 0; i2 < length2; i2++) {
    if (lowerFromParts[i2] !== lowerToParts[i2]) {
      samePartsLength = i2;
      break;
    }
  }
  if (samePartsLength == 0) {
    return to;
  }
  var outputParts = [];
  for (var i2 = samePartsLength; i2 < lowerFromParts.length; i2++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("\\");
};
win32._makeLong = function(path3) {
  if (!util$e.isString(path3))
    return path3;
  if (!path3) {
    return "";
  }
  var resolvedPath = win32.resolve(path3);
  if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
    return "\\\\?\\" + resolvedPath;
  } else if (/^\\\\[^?.]/.test(resolvedPath)) {
    return "\\\\?\\UNC\\" + resolvedPath.substring(2);
  }
  return path3;
};
win32.dirname = function(path3) {
  var result = win32SplitPath(path3), root2 = result[0], dir = result[1];
  if (!root2 && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root2 + dir;
};
win32.basename = function(path3, ext) {
  var f = win32SplitPath(path3)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};
win32.extname = function(path3) {
  return win32SplitPath(path3)[3];
};
win32.format = function(pathObject) {
  if (!util$e.isObject(pathObject)) {
    throw new TypeError(
      "Parameter 'pathObject' must be an object, not " + typeof pathObject
    );
  }
  var root2 = pathObject.root || "";
  if (!util$e.isString(root2)) {
    throw new TypeError(
      "'pathObject.root' must be a string or undefined, not " + typeof pathObject.root
    );
  }
  var dir = pathObject.dir;
  var base = pathObject.base || "";
  if (!dir) {
    return base;
  }
  if (dir[dir.length - 1] === win32.sep) {
    return dir + base;
  }
  return dir + win32.sep + base;
};
win32.parse = function(pathString) {
  if (!util$e.isString(pathString)) {
    throw new TypeError(
      "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};
win32.sep = "\\";
win32.delimiter = ";";
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};
function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}
posix.resolve = function() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    var path3 = i2 >= 0 ? arguments[i2] : process.cwd();
    if (!util$e.isString(path3)) {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path3) {
      continue;
    }
    resolvedPath = path3 + "/" + resolvedPath;
    resolvedAbsolute = path3[0] === "/";
  }
  resolvedPath = normalizeArray(
    resolvedPath.split("/"),
    !resolvedAbsolute
  ).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
};
posix.normalize = function(path3) {
  var isAbsolute2 = posix.isAbsolute(path3), trailingSlash = path3 && path3[path3.length - 1] === "/";
  path3 = normalizeArray(path3.split("/"), !isAbsolute2).join("/");
  if (!path3 && !isAbsolute2) {
    path3 = ".";
  }
  if (path3 && trailingSlash) {
    path3 += "/";
  }
  return (isAbsolute2 ? "/" : "") + path3;
};
posix.isAbsolute = function(path3) {
  return path3.charAt(0) === "/";
};
posix.join = function() {
  var path3 = "";
  for (var i2 = 0; i2 < arguments.length; i2++) {
    var segment = arguments[i2];
    if (!util$e.isString(segment)) {
      throw new TypeError("Arguments to path.join must be strings");
    }
    if (segment) {
      if (!path3) {
        path3 += segment;
      } else {
        path3 += "/" + segment;
      }
    }
  }
  return posix.normalize(path3);
};
posix.relative = function(from, to) {
  from = posix.resolve(from).substr(1);
  to = posix.resolve(to).substr(1);
  var fromParts = trimArray(from.split("/"));
  var toParts = trimArray(to.split("/"));
  var length2 = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length2;
  for (var i2 = 0; i2 < length2; i2++) {
    if (fromParts[i2] !== toParts[i2]) {
      samePartsLength = i2;
      break;
    }
  }
  var outputParts = [];
  for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
};
posix._makeLong = function(path3) {
  return path3;
};
posix.dirname = function(path3) {
  var result = posixSplitPath(path3), root2 = result[0], dir = result[1];
  if (!root2 && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root2 + dir;
};
posix.basename = function(path3, ext) {
  var f = posixSplitPath(path3)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};
posix.extname = function(path3) {
  return posixSplitPath(path3)[3];
};
posix.format = function(pathObject) {
  if (!util$e.isObject(pathObject)) {
    throw new TypeError(
      "Parameter 'pathObject' must be an object, not " + typeof pathObject
    );
  }
  var root2 = pathObject.root || "";
  if (!util$e.isString(root2)) {
    throw new TypeError(
      "'pathObject.root' must be a string or undefined, not " + typeof pathObject.root
    );
  }
  var dir = pathObject.dir ? pathObject.dir + posix.sep : "";
  var base = pathObject.base || "";
  return dir + base;
};
posix.parse = function(pathString) {
  if (!util$e.isString(pathString)) {
    throw new TypeError(
      "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 4) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  allParts[1] = allParts[1] || "";
  allParts[2] = allParts[2] || "";
  allParts[3] = allParts[3] || "";
  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
};
posix.sep = "/";
posix.delimiter = ":";
if (isWindows)
  path$6.exports = win32;
else
  path$6.exports = posix;
path$6.exports.posix = posix;
path$6.exports.win32 = win32;
var pathExports = path$6.exports;
const name$2 = "dotenv";
const version$3 = "16.4.5";
const description$2 = "Loads environment variables from .env file";
const main$2 = "lib/main.js";
const types$2 = "lib/main.d.ts";
const exports$1 = {
  ".": {
    types: "./lib/main.d.ts",
    require: "./lib/main.js",
    "default": "./lib/main.js"
  },
  "./config": "./config.js",
  "./config.js": "./config.js",
  "./lib/env-options": "./lib/env-options.js",
  "./lib/env-options.js": "./lib/env-options.js",
  "./lib/cli-options": "./lib/cli-options.js",
  "./lib/cli-options.js": "./lib/cli-options.js",
  "./package.json": "./package.json"
};
const scripts$2 = {
  "dts-check": "tsc --project tests/types/tsconfig.json",
  lint: "standard",
  "lint-readme": "standard-markdown",
  pretest: "npm run lint && npm run dts-check",
  test: "tap tests/*.js --100 -Rspec",
  "test:coverage": "tap --coverage-report=lcov",
  prerelease: "npm test",
  release: "standard-version"
};
const repository$2 = {
  type: "git",
  url: "git://github.com/motdotla/dotenv.git"
};
const funding = "https://dotenvx.com";
const keywords$2 = [
  "dotenv",
  "env",
  ".env",
  "environment",
  "variables",
  "config",
  "settings"
];
const readmeFilename = "README.md";
const license$2 = "BSD-2-Clause";
const devDependencies$2 = {
  "@definitelytyped/dtslint": "^0.0.133",
  "@types/node": "^18.11.3",
  decache: "^4.6.1",
  sinon: "^14.0.1",
  standard: "^17.0.0",
  "standard-markdown": "^7.1.0",
  "standard-version": "^9.5.0",
  tap: "^16.3.0",
  tar: "^6.1.11",
  typescript: "^4.8.4"
};
const engines$1 = {
  node: ">=12"
};
const browser$8 = {
  fs: false
};
const require$$4$1 = {
  name: name$2,
  version: version$3,
  description: description$2,
  main: main$2,
  types: types$2,
  exports: exports$1,
  scripts: scripts$2,
  repository: repository$2,
  funding,
  keywords: keywords$2,
  readmeFilename,
  license: license$2,
  devDependencies: devDependencies$2,
  engines: engines$1,
  browser: browser$8
};
var define_process_env_default$9 = {};
const fs$5 = require$$2$2;
const path$5 = pathExports;
const os$2 = require$$2$2;
const crypto$3 = require$$2$2;
const packageJson = require$$4$1;
const version$2 = packageJson.version;
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse$q(src) {
  const obj = {};
  let lines = src.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match2;
  while ((match2 = LINE.exec(lines)) != null) {
    const key = match2[1];
    let value = match2[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key] = value;
  }
  return obj;
}
function _parseVault(options2) {
  const vaultPath = _vaultPath(options2);
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = "MISSING_DATA";
    throw err;
  }
  const keys2 = _dotenvKey(options2).split(",");
  const length2 = keys2.length;
  let decrypted;
  for (let i2 = 0; i2 < length2; i2++) {
    try {
      const key = keys2[i2].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error3) {
      if (i2 + 1 >= length2) {
        throw error3;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _log(message) {
  console.log(`[dotenv@${version$2}][INFO] ${message}`);
}
function _warn(message) {
  console.log(`[dotenv@${version$2}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version$2}][DEBUG] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (define_process_env_default$9.DOTENV_KEY && define_process_env_default$9.DOTENV_KEY.length > 0) {
    return define_process_env_default$9.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri2;
  try {
    uri2 = new URL(dotenvKey);
  } catch (error3) {
    if (error3.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    throw error3;
  }
  const key = uri2.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environment = uri2.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err;
  }
  return { ciphertext, key };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs$5.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path$5.resolve(process.cwd(), ".env.vault");
  }
  if (fs$5.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path$5.join(os$2.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  _log("Loading env from encrypted .env.vault");
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = define_process_env_default$9;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path$5.resolve(process.cwd(), ".env");
  let encoding3 = "utf8";
  const debug2 = Boolean(options2 && options2.debug);
  if (options2 && options2.encoding) {
    encoding3 = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path22 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs$5.readFileSync(path22, { encoding: encoding3 }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e) {
      if (debug2) {
        _debug(`Failed to load ${path22} ${e.message}`);
      }
      lastError = e;
    }
  }
  let processEnv = define_process_env_default$9;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsedAll, options2);
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config$1(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$3.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error3) {
    const isRange = error3 instanceof RangeError;
    const invalidKeyLength = error3.message === "Invalid key length";
    const decryptionFailed = error3.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err.code = "DECRYPTION_FAILED";
      throw err;
    } else {
      throw error3;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  if (typeof parsed !== "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err.code = "OBJECT_REQUIRED";
    throw err;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config: config$1,
  decrypt,
  parse: parse$q,
  populate
};
main$3.exports.configDotenv = DotenvModule.configDotenv;
main$3.exports._configVault = DotenvModule._configVault;
main$3.exports._parseVault = DotenvModule._parseVault;
main$3.exports.config = DotenvModule.config;
main$3.exports.decrypt = DotenvModule.decrypt;
main$3.exports.parse = DotenvModule.parse;
main$3.exports.populate = DotenvModule.populate;
main$3.exports = DotenvModule;
var mainExports = main$3.exports;
var define_process_env_default$8 = {};
const options = {};
if (define_process_env_default$8.DOTENV_CONFIG_ENCODING != null) {
  options.encoding = define_process_env_default$8.DOTENV_CONFIG_ENCODING;
}
if (define_process_env_default$8.DOTENV_CONFIG_PATH != null) {
  options.path = define_process_env_default$8.DOTENV_CONFIG_PATH;
}
if (define_process_env_default$8.DOTENV_CONFIG_DEBUG != null) {
  options.debug = define_process_env_default$8.DOTENV_CONFIG_DEBUG;
}
if (define_process_env_default$8.DOTENV_CONFIG_OVERRIDE != null) {
  options.override = define_process_env_default$8.DOTENV_CONFIG_OVERRIDE;
}
if (define_process_env_default$8.DOTENV_CONFIG_DOTENV_KEY != null) {
  options.DOTENV_KEY = define_process_env_default$8.DOTENV_CONFIG_DOTENV_KEY;
}
var envOptions = options;
const re$3 = /^dotenv_config_(encoding|path|debug|override|DOTENV_KEY)=(.+)$/;
var cliOptions = function optionMatcher(args) {
  return args.reduce(function(acc, cur) {
    const matches = cur.match(re$3);
    if (matches) {
      acc[matches[1]] = matches[2];
    }
    return acc;
  }, {});
};
(function() {
  mainExports.config(
    Object.assign(
      {},
      envOptions,
      cliOptions(process.argv)
    )
  );
})();
var express$2 = { exports: {} };
var bodyParser = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$7 = depd;
function depd(namespace2) {
  if (!namespace2) {
    throw new TypeError("argument namespace is required");
  }
  function deprecate2(message) {
  }
  deprecate2._file = void 0;
  deprecate2._ignored = true;
  deprecate2._namespace = namespace2;
  deprecate2._traced = false;
  deprecate2._warned = /* @__PURE__ */ Object.create(null);
  deprecate2.function = wrapfunction;
  deprecate2.property = wrapproperty;
  return deprecate2;
}
function wrapfunction(fn, message) {
  if (typeof fn !== "function") {
    throw new TypeError("argument fn must be a function");
  }
  return fn;
}
function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new TypeError("argument obj must be object");
  }
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  if (!descriptor) {
    throw new TypeError("must call property on owner object");
  }
  if (!descriptor.configurable) {
    throw new TypeError("property must be configurable");
  }
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes)
    return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format2;
  bytes.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options2) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format2(value, options2);
    }
    return null;
  }
  function format2(value, options2) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options2 && options2.thousandsSeparator || "";
    var unitSeparator = options2 && options2.unitSeparator || "";
    var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
    var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
    var unit = options2 && options2.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) {
      if (mag >= map2.pb) {
        unit = "PB";
      } else if (mag >= map2.tb) {
        unit = "TB";
      } else if (mag >= map2.gb) {
        unit = "GB";
      } else if (mag >= map2.mb) {
        unit = "MB";
      } else if (mag >= map2.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map2[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s2, i2) {
        return i2 === 0 ? s2.replace(formatThousandsRegExp, thousandsSeparator) : s2;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map2[unit] * floatValue);
  }
  return bytes.exports;
}
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PARAM_REGEXP$1 = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
var TEXT_REGEXP$1 = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
var TOKEN_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
var QESC_REGEXP$1 = /\\([\u000b\u0020-\u00ff])/g;
var QUOTE_REGEXP$1 = /([\\"])/g;
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
contentType.format = format$4;
contentType.parse = parse$p;
function format$4(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || !TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string = type3;
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i2 = 0; i2 < params.length; i2++) {
      param3 = params[i2];
      if (!TOKEN_REGEXP$1.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string += "; " + param3 + "=" + qstring$2(parameters[param3]);
    }
  }
  return string;
}
function parse$p(string) {
  if (!string) {
    throw new TypeError("argument string is required");
  }
  var header3 = typeof string === "object" ? getcontenttype$1(string) : string;
  if (typeof header3 !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = header3.indexOf(";");
  var type3 = index2 !== -1 ? header3.slice(0, index2).trim() : header3.trim();
  if (!TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid media type");
  }
  var obj = new ContentType(type3.toLowerCase());
  if (index2 !== -1) {
    var key;
    var match2;
    var value;
    PARAM_REGEXP$1.lastIndex = index2;
    while (match2 = PARAM_REGEXP$1.exec(header3)) {
      if (match2.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match2[0].length;
      key = match2[1].toLowerCase();
      value = match2[2];
      if (value.charCodeAt(0) === 34) {
        value = value.slice(1, -1);
        if (value.indexOf("\\") !== -1) {
          value = value.replace(QESC_REGEXP$1, "$1");
        }
      }
      obj.parameters[key] = value;
    }
    if (index2 !== header3.length) {
      throw new TypeError("invalid parameter format");
    }
  }
  return obj;
}
function getcontenttype$1(obj) {
  var header3;
  if (typeof obj.getHeader === "function") {
    header3 = obj.getHeader("content-type");
  } else if (typeof obj.headers === "object") {
    header3 = obj.headers && obj.headers["content-type"];
  }
  if (typeof header3 !== "string") {
    throw new TypeError("content-type header is missing from object");
  }
  return header3;
}
function qstring$2(val) {
  var str = String(val);
  if (TOKEN_REGEXP$1.test(str)) {
    return str;
  }
  if (str.length > 0 && !TEXT_REGEXP$1.test(str)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str.replace(QUOTE_REGEXP$1, "\\$1") + '"';
}
function ContentType(type3) {
  this.parameters = /* @__PURE__ */ Object.create(null);
  this.type = type3;
}
var httpErrors = { exports: {} };
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto2) {
  obj.__proto__ = proto2;
  return obj;
}
function mixinProperties(obj, proto2) {
  for (var prop in proto2) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto2[prop];
    }
  }
  return obj;
}
const require$$0$4 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes$1 = require$$0$4;
var statuses$3 = status;
status.message = codes$1;
status.code = createMessageToStatusCodeMap(codes$1);
status.codes = createStatusCodeList(codes$1);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function createMessageToStatusCodeMap(codes2) {
  var map2 = {};
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status3 = Number(code);
    map2[message.toLowerCase()] = status3;
  });
  return map2;
}
function createStatusCodeList(codes2) {
  return Object.keys(codes2).map(function mapCode(code) {
    return Number(code);
  });
}
function getStatusCode(message) {
  var msg = message.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"');
  }
  return status.code[msg];
}
function getStatusMessage(code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error("invalid status code: " + code);
  }
  return status.message[code];
}
function status(code) {
  if (typeof code === "number") {
    return getStatusMessage(code);
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    return getStatusMessage(n);
  }
  return getStatusCode(code);
}
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(str) {
  return str.split(" ").map(function(token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module) {
  browser$7("http-errors");
  var setPrototypeOf2 = setprototypeof;
  var statuses2 = statuses$3;
  var inherits2 = inherits_browserExports;
  var toIdentifier2 = toidentifier;
  module.exports = createError2;
  module.exports.HttpError = createHttpErrorConstructor();
  module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
  populateConstructorExports(module.exports, statuses2.codes, module.exports.HttpError);
  function codeClass(status3) {
    return Number(String(status3).charAt(0) + "00");
  }
  function createError2() {
    var err;
    var msg;
    var status3 = 500;
    var props = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      var arg = arguments[i2];
      var type3 = typeof arg;
      if (type3 === "object" && arg instanceof Error) {
        err = arg;
        status3 = err.status || err.statusCode || status3;
      } else if (type3 === "number" && i2 === 0) {
        status3 = arg;
      } else if (type3 === "string") {
        msg = arg;
      } else if (type3 === "object") {
        props = arg;
      } else {
        throw new TypeError("argument #" + (i2 + 1) + " unsupported type " + type3);
      }
    }
    if (typeof status3 !== "number" || !statuses2.message[status3] && (status3 < 400 || status3 >= 600)) {
      status3 = 500;
    }
    var HttpError = createError2[status3] || createError2[codeClass(status3)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status3]);
      Error.captureStackTrace(err, createError2);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status3) {
      err.expose = status3 < 500;
      err.status = err.statusCode = status3;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits2(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name2, code) {
    var className = toClassName(name2);
    function ClientError(message) {
      var msg = message != null ? message : statuses2.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf2(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name2, code) {
    var className = toClassName(name2);
    function ServerError(message) {
      var msg = message != null ? message : statuses2.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf2(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name2) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name2;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports2, codes2, HttpError) {
    codes2.forEach(function forEachCode(code) {
      var CodeError;
      var name2 = toIdentifier2(statuses2.message[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name2, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name2, code);
          break;
      }
      if (CodeError) {
        exports2[code] = CodeError;
        exports2[name2] = CodeError;
      }
    });
  }
  function toClassName(name2) {
    return name2.substr(-5) !== "Error" ? name2 + "Error" : name2;
  }
})(httpErrors);
var httpErrorsExports = httpErrors.exports;
var browser$6 = { exports: {} };
var debug$n = { exports: {} };
var ms$7;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$7;
  hasRequiredMs$1 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$7 = function(val, options2) {
    options2 = options2 || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options2.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name2) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name2;
    }
    return Math.ceil(ms2 / n) + " " + name2 + "s";
  }
  return ms$7;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug$n.exports;
  hasRequiredDebug = 1;
  (function(module, exports2) {
    exports2 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce2;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = requireMs$1();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace2) {
      var hash = 0, i2;
      for (i2 in namespace2) {
        hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace2) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%")
            return match2;
          index2++;
          var formatter = exports2.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug2.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.enabled = exports2.enabled(namespace2);
      debug2.useColors = exports2.useColors();
      debug2.color = selectColor(namespace2);
      if ("function" === typeof exports2.init) {
        exports2.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split2.length;
      for (var i2 = 0; i2 < len; i2++) {
        if (!split2[i2])
          continue;
        namespaces = split2[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name2) {
      var i2, len;
      for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
        if (exports2.skips[i2].test(name2)) {
          return false;
        }
      }
      for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
        if (exports2.names[i2].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$n, debug$n.exports);
  return debug$n.exports;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$6.exports;
  hasRequiredBrowser = 1;
  (function(module, exports2) {
    var define_process_env_default2 = {};
    exports2 = module.exports = requireDebug();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2)
          return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = define_process_env_default2.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$6, browser$6.exports);
  return browser$6.exports;
}
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var EventEmitter$4 = require$$2$2.EventEmitter;
var ReadStream = require$$2$2.ReadStream;
var Stream$4 = require$$2$2;
var Zlib = require$$2$2;
var destroy_1$2 = destroy$3;
function destroy$3(stream3, suppress) {
  if (isFsReadStream(stream3)) {
    destroyReadStream(stream3);
  } else if (isZlibStream(stream3)) {
    destroyZlibStream(stream3);
  } else if (hasDestroy(stream3)) {
    stream3.destroy();
  }
  if (isEventEmitter(stream3) && suppress) {
    stream3.removeAllListeners("error");
    stream3.addListener("error", noop$4);
  }
  return stream3;
}
function destroyReadStream(stream3) {
  stream3.destroy();
  if (typeof stream3.close === "function") {
    stream3.on("open", onOpenClose);
  }
}
function closeZlibStream(stream3) {
  if (stream3._hadError === true) {
    var prop = stream3._binding === null ? "_binding" : "_handle";
    stream3[prop] = {
      close: function() {
        this[prop] = null;
      }
    };
  }
  stream3.close();
}
function destroyZlibStream(stream3) {
  if (typeof stream3.destroy === "function") {
    if (stream3._binding) {
      stream3.destroy();
      if (stream3._processing) {
        stream3._needDrain = true;
        stream3.once("drain", onDrainClearBinding);
      } else {
        stream3._binding.clear();
      }
    } else if (stream3._destroy && stream3._destroy !== Stream$4.Transform.prototype._destroy) {
      stream3.destroy();
    } else if (stream3._destroy && typeof stream3.close === "function") {
      stream3.destroyed = true;
      stream3.close();
    } else {
      stream3.destroy();
    }
  } else if (typeof stream3.close === "function") {
    closeZlibStream(stream3);
  }
}
function hasDestroy(stream3) {
  return stream3 instanceof Stream$4 && typeof stream3.destroy === "function";
}
function isEventEmitter(val) {
  return val instanceof EventEmitter$4;
}
function isFsReadStream(stream3) {
  return stream3 instanceof ReadStream;
}
function isZlibStream(stream3) {
  return stream3 instanceof Zlib.Gzip || stream3 instanceof Zlib.Gunzip || stream3 instanceof Zlib.Deflate || stream3 instanceof Zlib.DeflateRaw || stream3 instanceof Zlib.Inflate || stream3 instanceof Zlib.InflateRaw || stream3 instanceof Zlib.Unzip;
}
function noop$4() {
}
function onDrainClearBinding() {
  this._binding.clear();
}
function onOpenClose() {
  if (typeof this.fd === "number") {
    this.close();
  }
}
var lib$4 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer)
    return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$2$2;
  var Buffer2 = buffer2.Buffer;
  var safer = {};
  var key;
  for (key in buffer2) {
    if (!buffer2.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer2[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length2) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length2);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding3) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling)
    return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options2) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options2) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options2 || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res2 = this.decoder.write(buf);
    if (this.pass || !res2)
      return res2;
    if (res2[0] === BOMChar) {
      res2 = res2.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res2;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var string_decoder$1 = {};
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports2) {
  var buffer2 = require$$2$2;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length2) {
    return Buffer2(arg, encodingOrOffset, length2);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size, fill, encoding3) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports$1 = safeBuffer$1.exports;
var hasRequiredString_decoder$1;
function requireString_decoder$1() {
  if (hasRequiredString_decoder$1)
    return string_decoder$1;
  hasRequiredString_decoder$1 = 1;
  var Buffer2 = safeBufferExports$1.Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding3) {
    encoding3 = "" + encoding3;
    switch (encoding3 && encoding3.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$1.StringDecoder = StringDecoder;
  function StringDecoder(encoding3) {
    this.encoding = normalizeEncoding(encoding3);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i2;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i2 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i2 = 0;
    }
    if (i2 < buf.length)
      return r ? r + this.text(buf, i2) : this.text(buf, i2);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed)
      return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i2, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r = buf.toString("utf16le", i2);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i2) {
    var n = (buf.length - i2) % 3;
    if (n === 0)
      return buf.toString("base64", i2);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i2, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$1;
}
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal)
    return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = requireString_decoder$1().StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options2, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options2, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options2, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options2, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var charCode = str.charCodeAt(i2);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options2, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res2 = "";
    for (var i2 = 0; i2 < buf.length; i2++) {
      var curByte = buf[i2];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res2 += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res2 += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res2 += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res2 += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res2 += this.defaultCharUnicode;
            else
              res2 += String.fromCharCode(acc);
          }
        } else {
          res2 += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res2;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res2 = 0;
    if (this.contBytes > 0)
      res2 += this.defaultCharUnicode;
    return res2;
  };
  return internal;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16)
    return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i2 = 0; i2 < buf.length; i2 += 2) {
      var tmp = buf[i2];
      buf[i2] = buf[i2 + 1];
      buf[i2 + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i2 = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i2 = 1;
      j = 2;
    }
    for (; i2 < buf.length - 1; i2 += 2, j += 2) {
      buf2[j] = buf[i2 + 1];
      buf2[j + 1] = buf[i2];
    }
    this.overflowByte = i2 == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options2, codec) {
    options2 = options2 || {};
    if (options2.addBOM === void 0)
      options2.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options2);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options2, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options2 || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      var res2 = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res2 + trail : res2;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i2 = 0; i2 < _len; i2 += 2) {
          if (buf[i2] === 0 && buf[i2 + 1] !== 0)
            asciiCharsBE++;
          if (buf[i2] !== 0 && buf[i2 + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7)
    return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options2, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i2 = 0; i2 < 256; i2++)
    base64Chars[i2] = base64Regex.test(String.fromCharCode(i2));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i3 = 0; i3 < buf.length; i3++) {
      if (!inBase64) {
        if (buf[i3] == plusChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i3), "ascii");
          lastI = i3 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i3]]) {
          if (i3 == lastI && buf[i3] == minusChar) {
            res2 += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i3).toString();
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i3] != minusChar)
            i3--;
          lastI = i3 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7Decoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i3 = 0; i3 < str.length; i3++) {
      var uChar = str.charCodeAt(i3);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options2, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i3 = 0; i3 < buf.length; i3++) {
      if (!inBase64) {
        if (buf[i3] == andChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i3), "ascii");
          lastI = i3 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i3]]) {
          if (i3 == lastI && buf[i3] == minusChar) {
            res2 += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i3).toString().replace(/,/g, "/");
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i3] != minusChar)
            i3--;
          lastI = i3 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec)
    return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i2 = 0; i2 < 128; i2++)
        asciiString += String.fromCharCode(i2);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i2 = 0; i2 < codecOptions.chars.length; i2++)
      encodeBuf[codecOptions.chars.charCodeAt(i2)] = i2;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options2, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i2 = 0; i2 < str.length; i2++)
      buf[i2] = this.encodeBuf[str.charCodeAt(i2)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options2, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i2 = 0; i2 < buf.length; i2++) {
      idx1 = buf[i2] * 2;
      idx2 = i2 * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData)
    return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated)
    return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec)
    return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i2 = 0; i2 < 256; i2++)
    UNASSIGNED_NODE[i2] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i3 = 0; i3 < mappingTable.length; i3++)
      this._addDecodeChunk(mappingTable[i3]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i3 = 0; i3 < codecOptions.encodeSkipVals.length; i3++) {
        var val = codecOptions.encodeSkipVals[i3];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i3 = 129; i3 <= 254; i3++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i3];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i3 = 129; i3 <= 254; i3++)
        thirdByteNode[i3] = NODE_START - fourthByteNodeIdx;
      for (var i3 = 48; i3 <= 57; i3++)
        fourthByteNode[i3] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node = this.decodeTables[0];
    for (var i3 = bytes2.length - 1; i3 > 0; i3--) {
      var val = node[bytes2[i3]];
      if (val == UNASSIGNED) {
        node[bytes2[i3]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix2, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i3 = 0; i3 < 256; i3++) {
      var uCode = node[i3];
      var mbCode = prefix2 + i3;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options2, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i3 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i3 == str.length)
          break;
        var uCode = str.charCodeAt(i3++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options2, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i3 = 0, j = 0; i3 < buf.length; i3++) {
      var curByte = i3 >= 0 ? buf[i3] : prevBuf[i3 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0)
        ;
      else if (uCode === UNASSIGNED) {
        i3 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i3 + 1) : prevBuf.slice(seqStart + prevBufOffset, i3 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i3 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$3 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
];
const require$$2$1 = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
];
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
];
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData)
    return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$3;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5$1;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings)
    return encodings;
  hasRequiredEncodings = 1;
  (function(exports2) {
    var modules = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i2 = 0; i2 < modules.length; i2++) {
      var module = modules[i2];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports2[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib$4.exports;
  hasRequiredLib = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode3(str, encoding3, options2) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding3, options2);
      var res2 = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res2, trail]) : res2;
    };
    iconv.decode = function decode2(buf, encoding3, options2) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding3, options2);
      var res2 = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res2 + trail : res2;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding3) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding3);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding3 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding3) {
      return ("" + encoding3).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding3, options2) {
      var codec = iconv.getCodec(encoding3), encoder = new codec.encoder(options2, codec);
      if (codec.bomAware && options2 && options2.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options2);
      return encoder;
    };
    iconv.getDecoder = function getDecoder2(encoding3, options2) {
      var codec = iconv.getCodec(encoding3), decoder = new codec.decoder(options2, codec);
      if (codec.bomAware && !(options2 && options2.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options2);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        require$$2$2(iconv);
      }
      require$$2$2(iconv);
    }
  })(lib$4);
  return lib$4.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1 = unpipe$1;
function hasPipeDataListeners(stream3) {
  var listeners = stream3.listeners("data");
  for (var i2 = 0; i2 < listeners.length; i2++) {
    if (listeners[i2].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream3) {
  if (!stream3) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream3.unpipe === "function") {
    stream3.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream3)) {
    return;
  }
  var listener2;
  var listeners = stream3.listeners("close");
  for (var i2 = 0; i2 < listeners.length; i2++) {
    listener2 = listeners[i2];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream3);
  }
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody)
    return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks2 = tryRequireAsyncHooks2();
  var bytes2 = requireBytes();
  var createError2 = httpErrorsExports;
  var iconv = requireLib();
  var unpipe2 = unpipe_1;
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder2(encoding3) {
    if (!encoding3)
      return null;
    try {
      return iconv.getDecoder(encoding3);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError2(415, "specified encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream3, options2, callback) {
    var done2 = callback;
    var opts = options2 || {};
    if (stream3 === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream3 !== "object" || stream3 === null || typeof stream3.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options2 === true || typeof options2 === "string") {
      opts = {
        encoding: options2
      };
    }
    if (typeof options2 === "function") {
      done2 = options2;
      opts = {};
    }
    if (done2 !== void 0 && typeof done2 !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done2 && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding3 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes2.parse(opts.limit);
    var length2 = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done2) {
      return readStream(stream3, encoding3, length2, limit, wrap2(done2));
    }
    return new Promise(function executor(resolve3, reject) {
      readStream(stream3, encoding3, length2, limit, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve3(buf);
      });
    });
  }
  function halt(stream3) {
    unpipe2(stream3);
    if (typeof stream3.pause === "function") {
      stream3.pause();
    }
  }
  function readStream(stream3, encoding3, length2, limit, callback) {
    var complete = false;
    var sync3 = true;
    if (limit !== null && length2 !== null && length2 > limit) {
      return done2(createError2(413, "request entity too large", {
        expected: length2,
        length: length2,
        limit,
        type: "entity.too.large"
      }));
    }
    var state2 = stream3._readableState;
    if (stream3._decoder || state2 && (state2.encoding || state2.decoder)) {
      return done2(createError2(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream3.readable !== "undefined" && !stream3.readable) {
      return done2(createError2(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder2(encoding3);
    } catch (err) {
      return done2(err);
    }
    var buffer2 = decoder ? "" : [];
    stream3.on("aborted", onAborted);
    stream3.on("close", cleanup);
    stream3.on("data", onData);
    stream3.on("end", onEnd);
    stream3.on("error", onEnd);
    sync3 = false;
    function done2() {
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      complete = true;
      if (sync3) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream3);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done2(createError2(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length2,
        length: length2,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done2(createError2(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer2 += decoder.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done2(err);
      if (length2 !== null && received !== length2) {
        done2(createError2(400, "request size did not match content length", {
          expected: length2,
          length: length2,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder ? buffer2 + (decoder.end() || "") : Buffer.concat(buffer2);
        done2(null, string);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream3.removeListener("aborted", onAborted);
      stream3.removeListener("data", onData);
      stream3.removeListener("end", onEnd);
      stream3.removeListener("error", onEnd);
      stream3.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks2() {
    try {
      return require$$2$2;
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res2;
    if (asyncHooks2.AsyncResource) {
      res2 = new asyncHooks2.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res2 || !res2.runInAsyncScope) {
      return fn;
    }
    return res2.runInAsyncScope.bind(res2, fn, null);
  }
  return rawBody;
}
var onFinished$4 = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst = first$1;
function first$1(stuff, done2) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i2 = 0; i2 < stuff.length; i2++) {
    var arr = stuff[i2];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done2.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i3 = 0; i3 < cleanups.length; i3++) {
      x = cleanups[i3];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done2 = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done2) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === "error" ? arg1 : null;
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    done2(err, ee, event, args);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
onFinished$4.exports = onFinished$3;
onFinished$4.exports.isFinished = isFinished$1;
var asyncHooks = tryRequireAsyncHooks();
var first = eeFirst;
var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$3(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$1(listener2, null, msg);
    return msg;
  }
  attachListener(msg, wrap$1(listener2));
  return msg;
}
function isFinished$1(msg) {
  var socket2 = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket2 && !socket2.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket2 || !socket2.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error3) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error3);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket2) {
    msg.removeListener("socket", onSocket);
    if (finished)
      return;
    if (eeMsg !== eeSocket)
      return;
    eeSocket = first([[socket2, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2)
      msg.__onFinished = null;
    if (!listener2.queue)
      return;
    var queue = listener2.queue;
    listener2.queue = null;
    for (var i2 = 0; i2 < queue.length; i2++) {
      queue[i2](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res2, callback) {
  var assignSocket = res2.assignSocket;
  if (typeof assignSocket !== "function")
    return;
  res2.assignSocket = function _assignSocket(socket2) {
    assignSocket.call(this, socket2);
    callback(socket2);
  };
}
function tryRequireAsyncHooks() {
  try {
    return require$$2$2;
  } catch (e) {
    return {};
  }
}
function wrap$1(fn) {
  var res2;
  if (asyncHooks.AsyncResource) {
    res2 = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
  }
  if (!res2 || !res2.runInAsyncScope) {
    return fn;
  }
  return res2.runInAsyncScope.bind(res2, fn, null);
}
var onFinishedExports = onFinished$4.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead)
    return read_1;
  hasRequiredRead = 1;
  var createError2 = httpErrorsExports;
  var destroy2 = destroy_1$2;
  var getBody = requireRawBody();
  var iconv = requireLib();
  var onFinished2 = onFinishedExports;
  var unpipe2 = unpipe_1;
  var zlib2 = require$$2$2;
  read_1 = read;
  function read(req2, res2, next, parse2, debug2, options2) {
    var length2;
    var opts = options2;
    var stream3;
    req2._body = true;
    var encoding3 = opts.encoding !== null ? opts.encoding : null;
    var verify3 = opts.verify;
    try {
      stream3 = contentstream(req2, debug2, opts.inflate);
      length2 = stream3.length;
      stream3.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length2;
    opts.encoding = verify3 ? null : encoding3;
    if (opts.encoding === null && encoding3 !== null && !iconv.encodingExists(encoding3)) {
      return next(createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
        charset: encoding3.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream3, opts, function(error3, body) {
      if (error3) {
        var _error;
        if (error3.type === "encoding.unsupported") {
          _error = createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
            charset: encoding3.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError2(400, error3);
        }
        if (stream3 !== req2) {
          unpipe2(req2);
          destroy2(stream3, true);
        }
        dump(req2, function onfinished() {
          next(createError2(400, _error));
        });
        return;
      }
      if (verify3) {
        try {
          debug2("verify body");
          verify3(req2, res2, body, encoding3);
        } catch (err) {
          next(createError2(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug2("parse body");
        str = typeof body !== "string" && encoding3 !== null ? iconv.decode(body, encoding3) : body;
        req2.body = parse2(str);
      } catch (err) {
        next(createError2(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req2, debug2, inflate) {
    var encoding3 = (req2.headers["content-encoding"] || "identity").toLowerCase();
    var length2 = req2.headers["content-length"];
    var stream3;
    debug2('content-encoding "%s"', encoding3);
    if (inflate === false && encoding3 !== "identity") {
      throw createError2(415, "content encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
    switch (encoding3) {
      case "deflate":
        stream3 = zlib2.createInflate();
        debug2("inflate body");
        req2.pipe(stream3);
        break;
      case "gzip":
        stream3 = zlib2.createGunzip();
        debug2("gunzip body");
        req2.pipe(stream3);
        break;
      case "identity":
        stream3 = req2;
        stream3.length = length2;
        break;
      default:
        throw createError2(415, 'unsupported content encoding "' + encoding3 + '"', {
          encoding: encoding3,
          type: "encoding.unsupported"
        });
    }
    return stream3;
  }
  function dump(req2, callback) {
    if (onFinished2.isFinished(req2)) {
      callback(null);
    } else {
      onFinished2(req2, callback);
      req2.resume();
    }
  }
  return read_1;
}
var typeIs = { exports: {} };
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
var qescRegExp = /\\([\u0000-\u007f])/g;
var quoteRegExp = /([\\"])/g;
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
mediaTyper.format = format$3;
mediaTyper.parse = parse$o;
function format$3(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type3 = obj.type;
  if (!type3 || !typeNameRegExp.test(type3)) {
    throw new TypeError("invalid type");
  }
  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError("invalid subtype");
  }
  var string = type3 + "/" + subtype;
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError("invalid suffix");
    }
    string += "+" + suffix;
  }
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i2 = 0; i2 < params.length; i2++) {
      param3 = params[i2];
      if (!tokenRegExp.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string += "; " + param3 + "=" + qstring$1(parameters[param3]);
    }
  }
  return string;
}
function parse$o(string) {
  if (!string) {
    throw new TypeError("argument string is required");
  }
  if (typeof string === "object") {
    string = getcontenttype(string);
  }
  if (typeof string !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = string.indexOf(";");
  var type3 = index2 !== -1 ? string.substr(0, index2) : string;
  var key;
  var match2;
  var obj = splitType(type3);
  var params = {};
  var value;
  paramRegExp.lastIndex = index2;
  while (match2 = paramRegExp.exec(string)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value = match2[2];
    if (value[0] === '"') {
      value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
    }
    params[key] = value;
  }
  if (index2 !== -1 && index2 !== string.length) {
    throw new TypeError("invalid parameter format");
  }
  obj.parameters = params;
  return obj;
}
function getcontenttype(obj) {
  if (typeof obj.getHeader === "function") {
    return obj.getHeader("content-type");
  }
  if (typeof obj.headers === "object") {
    return obj.headers && obj.headers["content-type"];
  }
}
function qstring$1(val) {
  var str = String(val);
  if (tokenRegExp.test(str)) {
    return str;
  }
  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str.replace(quoteRegExp, "\\$1") + '"';
}
function splitType(string) {
  var match2 = typeRegExp.exec(string.toLowerCase());
  if (!match2) {
    throw new TypeError("invalid media type");
  }
  var type3 = match2[1];
  var subtype = match2[2];
  var suffix;
  var index2 = subtype.lastIndexOf("+");
  if (index2 !== -1) {
    suffix = subtype.substr(index2 + 1);
    subtype = subtype.substr(0, index2);
  }
  var obj = {
    type: type3,
    subtype,
    suffix
  };
  return obj;
}
var mimeTypes = {};
const require$$0$2 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0$2;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports2) {
  var db2 = mimeDb;
  var extname2 = pathExports.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset3;
  exports2.charsets = { lookup: charset3 };
  exports2.contentType = contentType3;
  exports2.extension = extension2;
  exports2.extensions = /* @__PURE__ */ Object.create(null);
  exports2.lookup = lookup3;
  exports2.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset3(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var mime2 = match2 && db2[match2[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType3(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime2 = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset4 = exports2.charset(mime2);
      if (charset4)
        mime2 += "; charset=" + charset4.toLowerCase();
    }
    return mime2;
  }
  function extension2(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var exts = match2 && exports2.extensions[match2[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup3(path3) {
    if (!path3 || typeof path3 !== "string") {
      return false;
    }
    var extension3 = extname2("x." + path3).toLowerCase().substr(1);
    if (!extension3) {
      return false;
    }
    return exports2.types[extension3] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db2).forEach(function forEachMimeType(type3) {
      var mime2 = db2[type3];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type3] = exts;
      for (var i2 = 0; i2 < exts.length; i2++) {
        var extension3 = exts[i2];
        if (types2[extension3]) {
          var from = preference.indexOf(db2[types2[extension3]].source);
          var to = preference.indexOf(mime2.source);
          if (types2[extension3] !== "application/octet-stream" && (from > to || from === to && types2[extension3].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension3] = type3;
      }
    });
  }
})(mimeTypes);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var typer = mediaTyper;
var mime$4 = mimeTypes;
typeIs.exports = typeofrequest;
typeIs.exports.is = typeis$1;
typeIs.exports.hasBody = hasbody;
typeIs.exports.normalize = normalize$1;
typeIs.exports.match = mimeMatch;
function typeis$1(value, types_) {
  var i2;
  var types2 = types_;
  var val = tryNormalizeType(value);
  if (!val) {
    return false;
  }
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length - 1);
    for (i2 = 0; i2 < types2.length; i2++) {
      types2[i2] = arguments[i2 + 1];
    }
  }
  if (!types2 || !types2.length) {
    return val;
  }
  var type3;
  for (i2 = 0; i2 < types2.length; i2++) {
    if (mimeMatch(normalize$1(type3 = types2[i2]), val)) {
      return type3[0] === "+" || type3.indexOf("*") !== -1 ? val : type3;
    }
  }
  return false;
}
function hasbody(req2) {
  return req2.headers["transfer-encoding"] !== void 0 || !isNaN(req2.headers["content-length"]);
}
function typeofrequest(req2, types_) {
  var types2 = types_;
  if (!hasbody(req2)) {
    return null;
  }
  if (arguments.length > 2) {
    types2 = new Array(arguments.length - 1);
    for (var i2 = 0; i2 < types2.length; i2++) {
      types2[i2] = arguments[i2 + 1];
    }
  }
  var value = req2.headers["content-type"];
  return typeis$1(value, types2);
}
function normalize$1(type3) {
  if (typeof type3 !== "string") {
    return false;
  }
  switch (type3) {
    case "urlencoded":
      return "application/x-www-form-urlencoded";
    case "multipart":
      return "multipart/*";
  }
  if (type3[0] === "+") {
    return "*/*" + type3;
  }
  return type3.indexOf("/") === -1 ? mime$4.lookup(type3) : type3;
}
function mimeMatch(expected, actual) {
  if (expected === false) {
    return false;
  }
  var actualParts = actual.split("/");
  var expectedParts = expected.split("/");
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false;
  }
  if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
    return false;
  }
  if (expectedParts[1].substr(0, 2) === "*+") {
    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
  }
  if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
    return false;
  }
  return true;
}
function normalizeType$1(value) {
  var type3 = typer.parse(value);
  type3.parameters = void 0;
  return typer.format(type3);
}
function tryNormalizeType(value) {
  if (!value) {
    return null;
  }
  try {
    return normalizeType$1(value);
  } catch (err) {
    return null;
  }
}
var typeIsExports = typeIs.exports;
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson)
    return json_1;
  hasRequiredJson = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = requireBrowser()("body-parser:json");
  var read = requireRead();
  var typeis2 = typeIsExports;
  json_1 = json2;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json2(options2) {
    var opts = options2 || {};
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type3 = opts.type || "application/json";
    var verify3 = opts.verify || false;
    if (verify3 !== false && typeof verify3 !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first2 = firstchar(body);
        if (first2 !== "{" && first2 !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first2);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate,
        limit,
        verify: verify3
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index2 = str.indexOf(char);
    var partial = "";
    if (index2 !== -1) {
      partial = str.substring(0, index2) + JSON_SYNTAX_CHAR;
      for (var i2 = index2 + 1; i2 < str.length; i2++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index2, index2 + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match2 = FIRST_CHAR_REGEXP.exec(str);
    return match2 ? match2[1] : void 0;
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error3, obj) {
    var keys2 = Object.getOwnPropertyNames(error3);
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var key = keys2[i2];
      if (key !== "stack" && key !== "message") {
        delete error3[key];
      }
    }
    error3.stack = obj.stack.replace(error3.message, obj.message);
    error3.message = obj.message;
    return error3;
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw)
    return raw_1;
  hasRequiredRaw = 1;
  var bytes2 = requireBytes();
  var debug2 = requireBrowser()("body-parser:raw");
  var read = requireRead();
  var typeis2 = typeIsExports;
  raw_1 = raw;
  function raw(options2) {
    var opts = options2 || {};
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/octet-stream";
    var verify3 = opts.verify || false;
    if (verify3 !== false && typeof verify3 !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: null,
        inflate,
        limit,
        verify: verify3
      });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText)
    return text_1;
  hasRequiredText = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var debug2 = requireBrowser()("body-parser:text");
  var read = requireRead();
  var typeis2 = typeIsExports;
  text_1 = text;
  function text(options2) {
    var opts = options2 || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "text/plain";
    var verify3 = opts.verify || false;
    if (verify3 !== false && typeof verify3 !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || defaultCharset;
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate,
        limit,
        verify: verify3
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return text_1;
}
var esErrors = Error;
var _eval = EvalError;
var range$1 = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type$1 = TypeError;
var uri = URIError;
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  __proto__: null,
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$1 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i2 = 0; i2 < a.length; i2 += 1) {
    arr[i2] = a[i2];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
    arr[j] = arrLike[i2];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i2 = 0; i2 < arr.length; i2 += 1) {
    str += arr[i2];
    if (i2 + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs[i2] = "$" + i2;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var call$1 = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call$1, $hasOwn);
var undefined$1;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range$1;
var $ReferenceError = ref;
var $SyntaxError$1 = syntax;
var $TypeError$3 = type$1;
var $URIError = uri;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var hasProto2 = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
  return x.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = hasown;
var $concat$1 = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first2 = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first2 === "%" && last !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first2 !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match2, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match2;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first2 = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last === '"' || last === "'" || last === "`")) && first2 !== last) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i2 + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true) || false;
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = false;
    }
  }
  esDefineProperty = $defineProperty2;
  return esDefineProperty;
}
var GetIntrinsic$3 = getIntrinsic;
var $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e) {
    $gOPD = null;
  }
}
var gopd$1 = $gOPD;
var $defineProperty$1 = requireEsDefineProperty();
var $SyntaxError = syntax;
var $TypeError$2 = type$1;
var gopd = gopd$1;
var defineDataProperty = function defineDataProperty2(obj, property, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$2("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$2("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty$1) {
    $defineProperty$1(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var $defineProperty = requireEsDefineProperty();
var hasPropertyDescriptors = function hasPropertyDescriptors2() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors;
var GetIntrinsic$2 = getIntrinsic;
var define = defineDataProperty;
var hasDescriptors = hasPropertyDescriptors_1();
var gOPD = gopd$1;
var $TypeError$1 = type$1;
var $floor$1 = GetIntrinsic$2("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length2) {
  if (typeof fn !== "function") {
    throw new $TypeError$1("`fn` is not a function");
  }
  if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor$1(length2) !== length2) {
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD) {
    var desc = gOPD(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length2,
        true,
        true
      );
    } else {
      define(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length2
      );
    }
  }
  return fn;
};
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = type$1;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty2 = requireEsDefineProperty();
  var $max = GetIntrinsic3("%Math.max%");
  module.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind3, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var callBindExports = callBind$1.exports;
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBindExports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString$8 = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$2$2;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol$4(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options2, depth, seen) {
  var opts = options2 || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$6(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function" && !isRegExp$2(obj)) {
    var name2 = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect2);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
  }
  if (isSymbol$4(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$6(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError$1(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber$3(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean$3(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$4(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate$2(obj) && !isRegExp$2(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace.call(String(s2), /"/g, "&quot;");
}
function isArray$6(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate$2(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$2(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError$1(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$4(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber$3(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean$3(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol$4(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString$8.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m2 = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i2 = 0, l = xs.length; i2 < l; i2++) {
    if (xs[i2] === x) {
      return i2;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s2) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m2) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type3) {
  return type3 + " { ? }";
}
function collectionOf(type3, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type3 + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$6(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = type$1;
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  var prev2 = list;
  var curr;
  for (; (curr = prev2.next) !== null; prev2 = curr) {
    if (curr.key === key) {
      prev2.next = curr.next;
      curr.next = /** @type {NonNullable<typeof list.next>} */
      list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = /** @type {import('.').ListNode<typeof value>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$5 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$5(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options2) {
  var obj = options2 && options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge$2 = function merge(target, source, options2) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$5(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$5(target) && !isArray$5(source)) {
    mergeTarget = arrayToObject(target, options2);
  }
  if (isArray$5(target) && isArray$5(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge(targetItem, item, options2);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge(acc[key], value, options2);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode$8 = function(str, decoder, charset3) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset3 === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode$5 = function encode(str, defaultEncoder, charset3, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset3 === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string.length; ++i2) {
    var c = string.charCodeAt(i2);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i2);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i2 += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i2) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j = 0; j < keys2.length; ++j) {
      var key = keys2[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp$1 = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer2 = function isBuffer3(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$5(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$4 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode: decode$8,
  encode: encode$5,
  isBuffer: isBuffer2,
  isRegExp: isRegExp$1,
  maybeMap,
  merge: merge$2
};
var getSideChannel2 = sideChannel;
var utils$3 = utils$4;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix2) {
    return prefix2 + "[]";
  },
  comma: "comma",
  indices: function indices(prefix2, key) {
    return prefix2 + "[" + key + "]";
  },
  repeat: function repeat(prefix2) {
    return prefix2;
  }
};
var isArray$4 = Array.isArray;
var split = String.prototype.split;
var push$2 = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push$2.apply(arr, isArray$4(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$3.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var sentinel = {};
var stringify$2 = function stringify(object, prefix2, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort2, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset3, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix2, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$4(obj)) {
    obj = utils$3.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix2, defaults$1.encoder, charset3, "key", format2) : prefix2;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$3.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix2 : encoder(prefix2, defaults$1.encoder, charset3, "key", format2);
      if (generateArrayPrefix === "comma" && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ",");
        var valuesJoined = "";
        for (var i2 = 0; i2 < valuesArray.length; ++i2) {
          valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults$1.encoder, charset3, "value", format2));
        }
        return [formatter(keyValue) + (commaRoundTrip && isArray$4(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
      }
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset3, "value", format2))];
    }
    return [formatter(prefix2) + "=" + formatter(String(obj))];
  }
  var values2 = [];
  if (typeof obj === "undefined") {
    return values2;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$4(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$4(filter)) {
    objKeys = filter;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort2 ? keys2.sort(sort2) : keys2;
  }
  var adjustedPrefix = commaRoundTrip && isArray$4(obj) && obj.length === 1 ? prefix2 + "[]" : prefix2;
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$4(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values2, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      encoder,
      filter,
      sort2,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset3,
      valueSideChannel
    ));
  }
  return values2;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset3 = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$4(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset: charset3,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options2 = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options2.filter === "function") {
    filter = options2.filter;
    obj = filter("", obj);
  } else if (isArray$4(options2.filter)) {
    filter = options2.filter;
    objKeys = filter;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options2.sort) {
    objKeys.sort(options2.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options2.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys2, stringify$2(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options2.strictNullHandling,
      options2.skipNulls,
      options2.encode ? options2.encoder : null,
      options2.filter,
      options2.sort,
      options2.allowDots,
      options2.serializeDate,
      options2.format,
      options2.formatter,
      options2.encodeValuesOnly,
      options2.charset,
      sideChannel2
    ));
  }
  var joined = keys2.join(options2.delimiter);
  var prefix2 = options2.addQueryPrefix === true ? "?" : "";
  if (options2.charsetSentinel) {
    if (options2.charset === "iso-8859-1") {
      prefix2 += "utf8=%26%2310003%3B&";
    } else {
      prefix2 += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix2 + joined : "";
};
var utils$2 = utils$4;
var has = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils$2.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options2) {
  if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options2) {
  var obj = {};
  var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
  var parts = cleanStr.split(options2.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset3 = options2.charset;
  if (options2.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset3 = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset3 = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options2.decoder(part, defaults.decoder, charset3, "key");
      val = options2.strictNullHandling ? null : "";
    } else {
      key = options2.decoder(part.slice(0, pos), defaults.decoder, charset3, "key");
      val = utils$2.maybeMap(
        parseArrayValue(part.slice(pos + 1), options2),
        function(encodedVal) {
          return options2.decoder(encodedVal, defaults.decoder, charset3, "value");
        }
      );
    }
    if (val && options2.interpretNumericEntities && charset3 === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$3(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils$2.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options2, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options2);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root2 = chain[i2];
    if (root2 === "[]" && options2.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options2.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options2.parseArrays && index2 <= options2.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options2.depth > 0 && brackets2.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;
  var keys2 = [];
  if (parent) {
    if (!options2.plainObjects && has.call(Object.prototype, parent)) {
      if (!options2.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent);
  }
  var i2 = 0;
  while (options2.depth > 0 && (segment = child.exec(key)) !== null && i2 < options2.depth) {
    i2 += 1;
    if (!options2.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options2.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options2, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset3 = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset: charset3,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils$2.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$n = function(str, opts) {
  var options2 = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
  var obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys2.length; ++i2) {
    var key = keys2[i2];
    var newObj = parseKeys(key, tempObj[key], options2, typeof str === "string");
    obj = utils$2.merge(obj, newObj, options2);
  }
  if (options2.allowSparse === true) {
    return obj;
  }
  return utils$2.compact(obj);
};
var stringify$1 = stringify_1;
var parse$m = parse$n;
var formats = formats$3;
var lib$3 = {
  formats,
  parse: parse$m,
  stringify: stringify$1
};
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded)
    return urlencoded_1;
  hasRequiredUrlencoded = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = requireBrowser()("body-parser:urlencoded");
  browser$7("body-parser");
  var read = requireRead();
  var typeis2 = typeIsExports;
  urlencoded_1 = urlencoded2;
  var parsers = /* @__PURE__ */ Object.create(null);
  function urlencoded2(options2) {
    var opts = options2 || {};
    if (opts.extended === void 0)
      ;
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/x-www-form-urlencoded";
    var verify3 = opts.verify || false;
    if (verify3 !== false && typeof verify3 !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3 !== "utf-8") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        debug: debug2,
        encoding: charset3,
        inflate,
        limit,
        verify: verify3
      });
    };
  }
  function extendedparser(options2) {
    var parameterLimit = options2.parameterLimit !== void 0 ? options2.parameterLimit : 1e3;
    var parse2 = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug2("parse extended urlencoding");
      return parse2(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index2 = 0;
    while ((index2 = body.indexOf("&", index2)) !== -1) {
      count++;
      index2++;
      if (count === limit) {
        return void 0;
      }
    }
    return count;
  }
  function parser(name2) {
    var mod = parsers[name2];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name2) {
      case "qs":
        mod = lib$3;
        break;
      case "querystring":
        mod = require$$2$2;
        break;
    }
    parsers[name2] = mod;
    return mod.parse;
  }
  function simpleparser(options2) {
    var parameterLimit = options2.parameterLimit !== void 0 ? options2.parameterLimit : 1e3;
    var parse2 = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug2("parse urlencoding");
      return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module, exports2) {
  var deprecate2 = browser$7("body-parser");
  var parsers = /* @__PURE__ */ Object.create(null);
  exports2 = module.exports = deprecate2.function(
    bodyParser2,
    "bodyParser: use individual json/urlencoded middlewares"
  );
  Object.defineProperty(exports2, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports2, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports2, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports2, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser2(options2) {
    var opts = Object.create(options2 || null, {
      type: {
        configurable: true,
        enumerable: true,
        value: void 0,
        writable: true
      }
    });
    var _urlencoded = exports2.urlencoded(opts);
    var _json = exports2.json(opts);
    return function bodyParser3(req2, res2, next) {
      _json(req2, res2, function(err) {
        if (err)
          return next(err);
        _urlencoded(req2, res2, next);
      });
    };
  }
  function createParserGetter(name2) {
    return function get2() {
      return loadParser(name2);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== void 0) {
      return parser;
    }
    switch (parserName) {
      case "json":
        parser = requireJson();
        break;
      case "raw":
        parser = requireRaw();
        break;
      case "text":
        parser = requireText();
        break;
      case "urlencoded":
        parser = requireUrlencoded();
        break;
    }
    return parsers[parserName] = parser;
  }
})(bodyParser, bodyParser.exports);
var bodyParserExports = bodyParser.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var mergeDescriptors = merge$1;
var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
function merge$1(dest, src, redefine) {
  if (!dest) {
    throw new TypeError("argument dest is required");
  }
  if (!src) {
    throw new TypeError("argument src is required");
  }
  if (redefine === void 0) {
    redefine = true;
  }
  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name2) {
    if (!redefine && hasOwnProperty$5.call(dest, name2)) {
      return;
    }
    var descriptor = Object.getOwnPropertyDescriptor(src, name2);
    Object.defineProperty(dest, name2, descriptor);
  });
  return dest;
}
var application = { exports: {} };
var browser$5 = { exports: {} };
var debug$m = { exports: {} };
var s$3 = 1e3;
var m$3 = s$3 * 60;
var h$3 = m$3 * 60;
var d$3 = h$3 * 24;
var y$3 = d$3 * 365.25;
var ms$6 = function(val, options2) {
  options2 = options2 || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$l(val);
  } else if (type3 === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong$3(val) : fmtShort$3(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$l(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y$3;
    case "days":
    case "day":
    case "d":
      return n * d$3;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h$3;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m$3;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$3;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort$3(ms2) {
  if (ms2 >= d$3) {
    return Math.round(ms2 / d$3) + "d";
  }
  if (ms2 >= h$3) {
    return Math.round(ms2 / h$3) + "h";
  }
  if (ms2 >= m$3) {
    return Math.round(ms2 / m$3) + "m";
  }
  if (ms2 >= s$3) {
    return Math.round(ms2 / s$3) + "s";
  }
  return ms2 + "ms";
}
function fmtLong$3(ms2) {
  return plural$3(ms2, d$3, "day") || plural$3(ms2, h$3, "hour") || plural$3(ms2, m$3, "minute") || plural$3(ms2, s$3, "second") || ms2 + " ms";
}
function plural$3(ms2, n, name2) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name2;
  }
  return Math.ceil(ms2 / n) + " " + name2 + "s";
}
(function(module, exports2) {
  exports2 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce2;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms$6;
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace2) {
    var hash = 0, i2;
    for (i2 in namespace2) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace2) {
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports2.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
        if (match2 === "%%")
          return match2;
        index2++;
        var formatter = exports2.formatters[format2];
        if ("function" === typeof formatter) {
          var val = args[index2];
          match2 = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match2;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.enabled = exports2.enabled(namespace2);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace2);
    if ("function" === typeof exports2.init) {
      exports2.init(debug2);
    }
    return debug2;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split2.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!split2[i2])
        continue;
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name2) {
    var i2, len;
    for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
      if (exports2.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
      if (exports2.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$m, debug$m.exports);
var debugExports$2 = debug$m.exports;
(function(module, exports2) {
  var define_process_env_default2 = {};
  exports2 = module.exports = debugExports$2;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match2) {
      if ("%%" === match2)
        return;
      index2++;
      if ("%c" === match2) {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = define_process_env_default2.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser$5, browser$5.exports);
var browserExports$3 = browser$5.exports;
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl = encodeUrl$3;
var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
function encodeUrl$3(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml$3;
function escapeHtml$3(string) {
  var str = "" + string;
  var match2 = matchHtmlRegExp.exec(str);
  if (!match2) {
    return str;
  }
  var escape2;
  var html = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match2.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escape2;
  }
  return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
}
var parseurl$1 = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var url$1 = require$$2$2;
var parse$k = url$1.parse;
var Url = url$1.Url;
parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str) {
  if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
    return parse$k(str);
  }
  var pathname = str;
  var query2 = null;
  var search = null;
  for (var i2 = 1; i2 < str.length; i2++) {
    switch (str.charCodeAt(i2)) {
      case 63:
        if (search === null) {
          pathname = str.substring(0, i2);
          query2 = str.substring(i2 + 1);
          search = str.substring(i2);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$k(str);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str;
  url2.href = str;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query2;
    url2.search = search;
  }
  return url2;
}
function fresh$3(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var parseurlExports = parseurl$1.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$l = browserExports$3("finalhandler");
var encodeUrl$2 = encodeurl;
var escapeHtml$2 = escapeHtml_1;
var onFinished$2 = onFinishedExports;
var parseUrl$1 = parseurlExports;
var statuses$2 = statuses$3;
var unpipe = unpipe_1;
var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;
var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished = onFinished$2.isFinished;
function createHtmlDocument$1(message) {
  var body = escapeHtml$2(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
var finalhandler_1 = finalhandler;
function finalhandler(req2, res2, options2) {
  var opts = options2 || {};
  var env = opts.env || "production";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status3;
    if (!err && headersSent$1(res2)) {
      debug$l("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status3 = getErrorStatusCode(err);
      if (status3 === void 0) {
        status3 = getResponseStatusCode(res2);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status3, env);
    } else {
      status3 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl$2(getResourceName(req2));
    }
    debug$l("default %s", status3);
    if (err && onerror) {
      defer(onerror, err, req2, res2);
    }
    if (headersSent$1(res2)) {
      debug$l("cannot %d after headers sent", status3);
      req2.socket.destroy();
      return;
    }
    send$3(req2, res2, status3, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys2 = Object.keys(err.headers);
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key = keys2[i2];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status3, env) {
  var msg;
  if (env !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses$2.message[status3];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$1.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res2) {
  var status3 = res2.statusCode;
  if (typeof status3 !== "number" || status3 < 400 || status3 > 599) {
    status3 = 500;
  }
  return status3;
}
function headersSent$1(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function send$3(req2, res2, status3, headers, message) {
  function write2() {
    var body = createHtmlDocument$1(message);
    res2.statusCode = status3;
    res2.statusMessage = statuses$2.message[status3];
    res2.removeHeader("Content-Encoding");
    res2.removeHeader("Content-Language");
    res2.removeHeader("Content-Range");
    setHeaders$1(res2, headers);
    res2.setHeader("Content-Security-Policy", "default-src 'none'");
    res2.setHeader("X-Content-Type-Options", "nosniff");
    res2.setHeader("Content-Type", "text/html; charset=utf-8");
    res2.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res2.end();
      return;
    }
    res2.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write2();
    return;
  }
  unpipe(req2);
  onFinished$2(req2, write2);
  req2.resume();
}
function setHeaders$1(res2, headers) {
  if (!headers) {
    return;
  }
  var keys2 = Object.keys(headers);
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key = keys2[i2];
    res2.setHeader(key, headers[key]);
  }
}
var router$1 = { exports: {} };
var browser$4 = { exports: {} };
var debug$k = { exports: {} };
var s$2 = 1e3;
var m$2 = s$2 * 60;
var h$2 = m$2 * 60;
var d$2 = h$2 * 24;
var y$2 = d$2 * 365.25;
var ms$5 = function(val, options2) {
  options2 = options2 || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$j(val);
  } else if (type3 === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong$2(val) : fmtShort$2(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$j(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y$2;
    case "days":
    case "day":
    case "d":
      return n * d$2;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h$2;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m$2;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$2;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort$2(ms2) {
  if (ms2 >= d$2) {
    return Math.round(ms2 / d$2) + "d";
  }
  if (ms2 >= h$2) {
    return Math.round(ms2 / h$2) + "h";
  }
  if (ms2 >= m$2) {
    return Math.round(ms2 / m$2) + "m";
  }
  if (ms2 >= s$2) {
    return Math.round(ms2 / s$2) + "s";
  }
  return ms2 + "ms";
}
function fmtLong$2(ms2) {
  return plural$2(ms2, d$2, "day") || plural$2(ms2, h$2, "hour") || plural$2(ms2, m$2, "minute") || plural$2(ms2, s$2, "second") || ms2 + " ms";
}
function plural$2(ms2, n, name2) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name2;
  }
  return Math.ceil(ms2 / n) + " " + name2 + "s";
}
(function(module, exports2) {
  exports2 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce2;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms$5;
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace2) {
    var hash = 0, i2;
    for (i2 in namespace2) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace2) {
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports2.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
        if (match2 === "%%")
          return match2;
        index2++;
        var formatter = exports2.formatters[format2];
        if ("function" === typeof formatter) {
          var val = args[index2];
          match2 = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match2;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.enabled = exports2.enabled(namespace2);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace2);
    if ("function" === typeof exports2.init) {
      exports2.init(debug2);
    }
    return debug2;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split2.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!split2[i2])
        continue;
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name2) {
    var i2, len;
    for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
      if (exports2.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
      if (exports2.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$k, debug$k.exports);
var debugExports$1 = debug$k.exports;
(function(module, exports2) {
  var define_process_env_default2 = {};
  exports2 = module.exports = debugExports$1;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match2) {
      if ("%%" === match2)
        return;
      index2++;
      if ("%c" === match2) {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = define_process_env_default2.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser$4, browser$4.exports);
var browserExports$2 = browser$4.exports;
var arrayFlatten_1 = arrayFlatten;
function flattenWithDepth(array, result, depth) {
  for (var i2 = 0; i2 < array.length; i2++) {
    var value = array[i2];
    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1);
    } else {
      result.push(value);
    }
  }
  return result;
}
function flattenForever(array, result) {
  for (var i2 = 0; i2 < array.length; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      flattenForever(value, result);
    } else {
      result.push(value);
    }
  }
  return result;
}
function arrayFlatten(array, depth) {
  if (depth == null) {
    return flattenForever(array, []);
  }
  return flattenWithDepth(array, [], depth);
}
var pathToRegexp = pathtoRegexp;
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
function pathtoRegexp(path3, keys2, options2) {
  options2 = options2 || {};
  keys2 = keys2 || [];
  var strict = options2.strict;
  var end2 = options2.end !== false;
  var flags = options2.sensitive ? "" : "i";
  var extraOffset = 0;
  var keysOffset = keys2.length;
  var i2 = 0;
  var name2 = 0;
  var m2;
  if (path3 instanceof RegExp) {
    while (m2 = MATCHING_GROUP_REGEXP.exec(path3.source)) {
      keys2.push({
        name: name2++,
        optional: false,
        offset: m2.index
      });
    }
    return path3;
  }
  if (Array.isArray(path3)) {
    path3 = path3.map(function(value) {
      return pathtoRegexp(value, keys2, options2).source;
    });
    return new RegExp("(?:" + path3.join("|") + ")", flags);
  }
  path3 = ("^" + path3 + (strict ? "" : path3[path3.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match2, slash, format2, key, capture, star, optional, offset) {
    slash = slash || "";
    format2 = format2 || "";
    capture = capture || "([^\\/" + format2 + "]+?)";
    optional = optional || "";
    keys2.push({
      name: key,
      optional: !!optional,
      offset: offset + extraOffset
    });
    var result = "" + (optional ? "" : slash) + "(?:" + format2 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format2 + "].+?)?)" : "") + ")" + optional;
    extraOffset += result.length - match2.length;
    return result;
  }).replace(/\*/g, function(star, index3) {
    var len = keys2.length;
    while (len-- > keysOffset && keys2[len].offset > index3) {
      keys2[len].offset += 3;
    }
    return "(.*)";
  });
  while (m2 = MATCHING_GROUP_REGEXP.exec(path3)) {
    var escapeCount = 0;
    var index2 = m2.index;
    while (path3.charAt(--index2) === "\\") {
      escapeCount++;
    }
    if (escapeCount % 2 === 1) {
      continue;
    }
    if (keysOffset + i2 === keys2.length || keys2[keysOffset + i2].offset > m2.index) {
      keys2.splice(keysOffset + i2, 0, {
        name: name2++,
        // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m2.index
      });
    }
    i2++;
  }
  path3 += end2 ? "$" : path3[path3.length - 1] === "/" ? "" : "(?=\\/|$)";
  return new RegExp(path3, flags);
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var pathRegexp = pathToRegexp;
var debug$j = browserExports$2("express:router:layer");
var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
var layer = Layer$2;
function Layer$2(path3, options2, fn) {
  if (!(this instanceof Layer$2)) {
    return new Layer$2(path3, options2, fn);
  }
  debug$j("new %o", path3);
  var opts = options2 || {};
  this.handle = fn;
  this.name = fn.name || "<anonymous>";
  this.params = void 0;
  this.path = void 0;
  this.regexp = pathRegexp(path3, this.keys = [], opts);
  this.regexp.fast_star = path3 === "*";
  this.regexp.fast_slash = path3 === "/" && opts.end === false;
}
Layer$2.prototype.handle_error = function handle_error(error3, req2, res2, next) {
  var fn = this.handle;
  if (fn.length !== 4) {
    return next(error3);
  }
  try {
    fn(error3, req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.handle_request = function handle(req2, res2, next) {
  var fn = this.handle;
  if (fn.length > 3) {
    return next();
  }
  try {
    fn(req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.match = function match(path3) {
  var match2;
  if (path3 != null) {
    if (this.regexp.fast_slash) {
      this.params = {};
      this.path = "";
      return true;
    }
    if (this.regexp.fast_star) {
      this.params = { "0": decode_param(path3) };
      this.path = path3;
      return true;
    }
    match2 = this.regexp.exec(path3);
  }
  if (!match2) {
    this.params = void 0;
    this.path = void 0;
    return false;
  }
  this.params = {};
  this.path = match2[0];
  var keys2 = this.keys;
  var params = this.params;
  for (var i2 = 1; i2 < match2.length; i2++) {
    var key = keys2[i2 - 1];
    var prop = key.name;
    var val = decode_param(match2[i2]);
    if (val !== void 0 || !hasOwnProperty$4.call(params, prop)) {
      params[prop] = val;
    }
  }
  return true;
};
function decode_param(val) {
  if (typeof val !== "string" || val.length === 0) {
    return val;
  }
  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = "Failed to decode param '" + val + "'";
      err.status = err.statusCode = 400;
    }
    throw err;
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var http$4 = require$$2$2;
var methods$2 = getCurrentNodeMethods() || getBasicNodeMethods();
function getCurrentNodeMethods() {
  return http$4.METHODS && http$4.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}
function getBasicNodeMethods() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect"
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$i = browserExports$2("express:router:route");
var flatten$1 = arrayFlatten_1;
var Layer$1 = layer;
var methods$1 = methods$2;
var slice$1 = Array.prototype.slice;
var toString$7 = Object.prototype.toString;
var route = Route$1;
function Route$1(path3) {
  this.path = path3;
  this.stack = [];
  debug$i("new %o", path3);
  this.methods = {};
}
Route$1.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }
  var name2 = typeof method === "string" ? method.toLowerCase() : method;
  if (name2 === "head" && !this.methods["head"]) {
    name2 = "get";
  }
  return Boolean(this.methods[name2]);
};
Route$1.prototype._options = function _options() {
  var methods2 = Object.keys(this.methods);
  if (this.methods.get && !this.methods.head) {
    methods2.push("head");
  }
  for (var i2 = 0; i2 < methods2.length; i2++) {
    methods2[i2] = methods2[i2].toUpperCase();
  }
  return methods2;
};
Route$1.prototype.dispatch = function dispatch(req2, res2, done2) {
  var idx = 0;
  var stack = this.stack;
  var sync3 = 0;
  if (stack.length === 0) {
    return done2();
  }
  var method = typeof req2.method === "string" ? req2.method.toLowerCase() : req2.method;
  if (method === "head" && !this.methods["head"]) {
    method = "get";
  }
  req2.route = this;
  next();
  function next(err) {
    if (err && err === "route") {
      return done2();
    }
    if (err && err === "router") {
      return done2(err);
    }
    if (++sync3 > 100) {
      return setImmediate(next, err);
    }
    var layer2 = stack[idx++];
    if (!layer2) {
      return done2(err);
    }
    if (layer2.method && layer2.method !== method) {
      next(err);
    } else if (err) {
      layer2.handle_error(err, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
    sync3 = 0;
  }
};
Route$1.prototype.all = function all() {
  var handles = flatten$1(slice$1.call(arguments));
  for (var i2 = 0; i2 < handles.length; i2++) {
    var handle3 = handles[i2];
    if (typeof handle3 !== "function") {
      var type3 = toString$7.call(handle3);
      var msg = "Route.all() requires a callback function but got a " + type3;
      throw new TypeError(msg);
    }
    var layer2 = Layer$1("/", {}, handle3);
    layer2.method = void 0;
    this.methods._all = true;
    this.stack.push(layer2);
  }
  return this;
};
methods$1.forEach(function(method) {
  Route$1.prototype[method] = function() {
    var handles = flatten$1(slice$1.call(arguments));
    for (var i2 = 0; i2 < handles.length; i2++) {
      var handle3 = handles[i2];
      if (typeof handle3 !== "function") {
        var type3 = toString$7.call(handle3);
        var msg = "Route." + method + "() requires a callback function but got a " + type3;
        throw new Error(msg);
      }
      debug$i("%s %o", method, this.path);
      var layer2 = Layer$1("/", {}, handle3);
      layer2.method = method;
      this.methods[method] = true;
      this.stack.push(layer2);
    }
    return this;
  };
});
var utilsMerge = { exports: {} };
(function(module, exports2) {
  module.exports = function(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
})(utilsMerge);
var utilsMergeExports = utilsMerge.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Route = route;
var Layer = layer;
var methods = methods$2;
var mixin$1 = utilsMergeExports;
var debug$h = browserExports$2("express:router");
var deprecate$4 = browser$7("express");
var flatten = arrayFlatten_1;
var parseUrl = parseurlExports;
var setPrototypeOf$1 = setprototypeof;
var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString$6 = Object.prototype.toString;
var proto = router$1.exports = function(options2) {
  var opts = options2 || {};
  function router2(req2, res2, next) {
    router2.handle(req2, res2, next);
  }
  setPrototypeOf$1(router2, proto);
  router2.params = {};
  router2._params = [];
  router2.caseSensitive = opts.caseSensitive;
  router2.mergeParams = opts.mergeParams;
  router2.strict = opts.strict;
  router2.stack = [];
  return router2;
};
proto.param = function param(name2, fn) {
  if (typeof name2 === "function") {
    this._params.push(name2);
    return;
  }
  var params = this._params;
  var len = params.length;
  var ret;
  if (name2[0] === ":") {
    deprecate$4("router.param(" + JSON.stringify(name2) + ", fn): Use router.param(" + JSON.stringify(name2.slice(1)) + ", fn) instead");
    name2 = name2.slice(1);
  }
  for (var i2 = 0; i2 < len; ++i2) {
    if (ret = params[i2](name2, fn)) {
      fn = ret;
    }
  }
  if ("function" !== typeof fn) {
    throw new Error("invalid param() call for " + name2 + ", got " + fn);
  }
  (this.params[name2] = this.params[name2] || []).push(fn);
  return this;
};
proto.handle = function handle2(req2, res2, out) {
  var self2 = this;
  debug$h("dispatching %s %s", req2.method, req2.url);
  var idx = 0;
  var protohost = getProtohost(req2.url) || "";
  var removed = "";
  var slashAdded = false;
  var sync3 = 0;
  var paramcalled = {};
  var options2 = [];
  var stack = self2.stack;
  var parentParams = req2.params;
  var parentUrl = req2.baseUrl || "";
  var done2 = restore(out, req2, "baseUrl", "next", "params");
  req2.next = next;
  if (req2.method === "OPTIONS") {
    done2 = wrap(done2, function(old2, err) {
      if (err || options2.length === 0)
        return old2(err);
      sendOptionsResponse(res2, options2, old2);
    });
  }
  req2.baseUrl = parentUrl;
  req2.originalUrl = req2.originalUrl || req2.url;
  next();
  function next(err) {
    var layerError = err === "route" ? null : err;
    if (slashAdded) {
      req2.url = req2.url.slice(1);
      slashAdded = false;
    }
    if (removed.length !== 0) {
      req2.baseUrl = parentUrl;
      req2.url = protohost + removed + req2.url.slice(protohost.length);
      removed = "";
    }
    if (layerError === "router") {
      setImmediate(done2, null);
      return;
    }
    if (idx >= stack.length) {
      setImmediate(done2, layerError);
      return;
    }
    if (++sync3 > 100) {
      return setImmediate(next, err);
    }
    var path3 = getPathname(req2);
    if (path3 == null) {
      return done2(layerError);
    }
    var layer2;
    var match2;
    var route3;
    while (match2 !== true && idx < stack.length) {
      layer2 = stack[idx++];
      match2 = matchLayer(layer2, path3);
      route3 = layer2.route;
      if (typeof match2 !== "boolean") {
        layerError = layerError || match2;
      }
      if (match2 !== true) {
        continue;
      }
      if (!route3) {
        continue;
      }
      if (layerError) {
        match2 = false;
        continue;
      }
      var method = req2.method;
      var has_method = route3._handles_method(method);
      if (!has_method && method === "OPTIONS") {
        appendMethods(options2, route3._options());
      }
      if (!has_method && method !== "HEAD") {
        match2 = false;
      }
    }
    if (match2 !== true) {
      return done2(layerError);
    }
    if (route3) {
      req2.route = route3;
    }
    req2.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
    var layerPath = layer2.path;
    self2.process_params(layer2, paramcalled, req2, res2, function(err2) {
      if (err2) {
        next(layerError || err2);
      } else if (route3) {
        layer2.handle_request(req2, res2, next);
      } else {
        trim_prefix(layer2, layerError, layerPath, path3);
      }
      sync3 = 0;
    });
  }
  function trim_prefix(layer2, layerError, layerPath, path3) {
    if (layerPath.length !== 0) {
      if (layerPath !== path3.slice(0, layerPath.length)) {
        next(layerError);
        return;
      }
      var c = path3[layerPath.length];
      if (c && c !== "/" && c !== ".")
        return next(layerError);
      debug$h("trim prefix (%s) from url %s", layerPath, req2.url);
      removed = layerPath;
      req2.url = protohost + req2.url.slice(protohost.length + removed.length);
      if (!protohost && req2.url[0] !== "/") {
        req2.url = "/" + req2.url;
        slashAdded = true;
      }
      req2.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
    }
    debug$h("%s %s : %s", layer2.name, layerPath, req2.originalUrl);
    if (layerError) {
      layer2.handle_error(layerError, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
  }
};
proto.process_params = function process_params(layer2, called, req2, res2, done2) {
  var params = this.params;
  var keys2 = layer2.keys;
  if (!keys2 || keys2.length === 0) {
    return done2();
  }
  var i2 = 0;
  var name2;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;
  function param3(err) {
    if (err) {
      return done2(err);
    }
    if (i2 >= keys2.length) {
      return done2();
    }
    paramIndex = 0;
    key = keys2[i2++];
    name2 = key.name;
    paramVal = req2.params[name2];
    paramCallbacks = params[name2];
    paramCalled = called[name2];
    if (paramVal === void 0 || !paramCallbacks) {
      return param3();
    }
    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
      req2.params[name2] = paramCalled.value;
      return param3(paramCalled.error);
    }
    called[name2] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };
    paramCallback();
  }
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];
    paramCalled.value = req2.params[key.name];
    if (err) {
      paramCalled.error = err;
      param3(err);
      return;
    }
    if (!fn)
      return param3();
    try {
      fn(req2, res2, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }
  param3();
};
proto.use = function use(fn) {
  var offset = 0;
  var path3 = "/";
  if (typeof fn !== "function") {
    var arg = fn;
    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }
    if (typeof arg !== "function") {
      offset = 1;
      path3 = fn;
    }
  }
  var callbacks = flatten(slice.call(arguments, offset));
  if (callbacks.length === 0) {
    throw new TypeError("Router.use() requires a middleware function");
  }
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    var fn = callbacks[i2];
    if (typeof fn !== "function") {
      throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
    }
    debug$h("use %o %s", path3, fn.name || "<anonymous>");
    var layer2 = new Layer(path3, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);
    layer2.route = void 0;
    this.stack.push(layer2);
  }
  return this;
};
proto.route = function route2(path3) {
  var route3 = new Route(path3);
  var layer2 = new Layer(path3, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route3.dispatch.bind(route3));
  layer2.route = route3;
  this.stack.push(layer2);
  return route3;
};
methods.concat("all").forEach(function(method) {
  proto[method] = function(path3) {
    var route3 = this.route(path3);
    route3[method].apply(route3, slice.call(arguments, 1));
    return this;
  };
});
function appendMethods(list, addition) {
  for (var i2 = 0; i2 < addition.length; i2++) {
    var method = addition[i2];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}
function getPathname(req2) {
  try {
    return parseUrl(req2).pathname;
  } catch (err) {
    return void 0;
  }
}
function getProtohost(url2) {
  if (typeof url2 !== "string" || url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var searchIndex = url2.indexOf("?");
  var pathLength = searchIndex !== -1 ? searchIndex : url2.length;
  var fqdnIndex = url2.slice(0, pathLength).indexOf("://");
  return fqdnIndex !== -1 ? url2.substring(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function gettype(obj) {
  var type3 = typeof obj;
  if (type3 !== "object") {
    return type3;
  }
  return toString$6.call(obj).replace(objectRegExp, "$1");
}
function matchLayer(layer2, path3) {
  try {
    return layer2.match(path3);
  } catch (err) {
    return err;
  }
}
function mergeParams(params, parent) {
  if (typeof parent !== "object" || !parent) {
    return params;
  }
  var obj = mixin$1({}, parent);
  if (!(0 in params) || !(0 in parent)) {
    return mixin$1(obj, params);
  }
  var i2 = 0;
  var o = 0;
  while (i2 in params) {
    i2++;
  }
  while (o in parent) {
    o++;
  }
  for (i2--; i2 >= 0; i2--) {
    params[i2 + o] = params[i2];
    if (i2 < o) {
      delete params[i2];
    }
  }
  return mixin$1(obj, params);
}
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);
  for (var i2 = 0; i2 < props.length; i2++) {
    props[i2] = arguments[i2 + 2];
    vals[i2] = obj[props[i2]];
  }
  return function() {
    for (var i3 = 0; i3 < props.length; i3++) {
      obj[props[i3]] = vals[i3];
    }
    return fn.apply(this, arguments);
  };
}
function sendOptionsResponse(res2, options2, next) {
  try {
    var body = options2.join(",");
    res2.set("Allow", body);
    res2.send(body);
  } catch (err) {
    next(err);
  }
}
function wrap(old2, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);
    args[0] = old2;
    for (var i2 = 0, len = arguments.length; i2 < len; i2++) {
      args[i2 + 1] = arguments[i2];
    }
    fn.apply(this, args);
  };
}
var routerExports = router$1.exports;
var init = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var setPrototypeOf = setprototypeof;
init.init = function(app2) {
  return function expressInit(req2, res2, next) {
    if (app2.enabled("x-powered-by"))
      res2.setHeader("X-Powered-By", "Express");
    req2.res = res2;
    res2.req = req2;
    req2.next = next;
    setPrototypeOf(req2, app2.request);
    setPrototypeOf(res2, app2.response);
    res2.locals = res2.locals || /* @__PURE__ */ Object.create(null);
    next();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var query;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery)
    return query;
  hasRequiredQuery = 1;
  var merge3 = utilsMergeExports;
  var parseUrl2 = parseurlExports;
  var qs2 = lib$3;
  query = function query2(options2) {
    var opts = merge3({}, options2);
    var queryparse = qs2.parse;
    if (typeof options2 === "function") {
      queryparse = options2;
      opts = void 0;
    }
    if (opts !== void 0 && opts.allowPrototypes === void 0) {
      opts.allowPrototypes = true;
    }
    return function query3(req2, res2, next) {
      if (!req2.query) {
        var val = parseUrl2(req2).query;
        req2.query = queryparse(val, opts);
      }
      next();
    };
  };
  return query;
}
function commonjsRequire(path3) {
  throw new Error('Could not dynamically require "' + path3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$g = browserExports$2("express:view");
var path$4 = pathExports;
var fs$4 = require$$2$2;
var dirname = path$4.dirname;
var basename$3 = path$4.basename;
var extname$2 = path$4.extname;
var join$1 = path$4.join;
var resolve$2 = path$4.resolve;
var view = View;
function View(name2, options2) {
  var opts = options2 || {};
  this.defaultEngine = opts.defaultEngine;
  this.ext = extname$2(name2);
  this.name = name2;
  this.root = opts.root;
  if (!this.ext && !this.defaultEngine) {
    throw new Error("No default engine was specified and no extension was provided.");
  }
  var fileName = name2;
  if (!this.ext) {
    this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
    fileName += this.ext;
  }
  if (!opts.engines[this.ext]) {
    var mod = this.ext.slice(1);
    debug$g('require "%s"', mod);
    var fn = commonjsRequire(mod).__express;
    if (typeof fn !== "function") {
      throw new Error('Module "' + mod + '" does not provide a view engine.');
    }
    opts.engines[this.ext] = fn;
  }
  this.engine = opts.engines[this.ext];
  this.path = this.lookup(fileName);
}
View.prototype.lookup = function lookup(name2) {
  var path3;
  var roots = [].concat(this.root);
  debug$g('lookup "%s"', name2);
  for (var i2 = 0; i2 < roots.length && !path3; i2++) {
    var root2 = roots[i2];
    var loc = resolve$2(root2, name2);
    var dir = dirname(loc);
    var file = basename$3(loc);
    path3 = this.resolve(dir, file);
  }
  return path3;
};
View.prototype.render = function render(options2, callback) {
  debug$g('render "%s"', this.path);
  this.engine(this.path, options2, callback);
};
View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;
  var path3 = join$1(dir, file);
  var stat = tryStat(path3);
  if (stat && stat.isFile()) {
    return path3;
  }
  path3 = join$1(dir, basename$3(file, ext), "index" + ext);
  stat = tryStat(path3);
  if (stat && stat.isFile()) {
    return path3;
  }
};
function tryStat(path3) {
  debug$g('stat "%s"', path3);
  try {
    return fs$4.statSync(path3);
  } catch (e) {
    return void 0;
  }
}
var utils$1 = {};
var contentDisposition$2 = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
contentDisposition$2.exports = contentDisposition$1;
contentDisposition$2.exports.parse = parse$i;
var basename$2 = pathExports.basename;
var Buffer$9 = safeBufferExports$1.Buffer;
var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
var QESC_REGEXP = /\\([\u0000-\u007f])/g;
var QUOTE_REGEXP = /([\\"])/g;
var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function contentDisposition$1(filename, options2) {
  var opts = options2 || {};
  var type3 = opts.type || "attachment";
  var params = createparams(filename, opts.fallback);
  return format$2(new ContentDisposition(type3, params));
}
function createparams(filename, fallback) {
  if (filename === void 0) {
    return;
  }
  var params = {};
  if (typeof filename !== "string") {
    throw new TypeError("filename must be a string");
  }
  if (fallback === void 0) {
    fallback = true;
  }
  if (typeof fallback !== "string" && typeof fallback !== "boolean") {
    throw new TypeError("fallback must be a string or boolean");
  }
  if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError("fallback must be ISO-8859-1 string");
  }
  var name2 = basename$2(filename);
  var isQuotedString = TEXT_REGEXP.test(name2);
  var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename$2(fallback);
  var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
    params["filename*"] = name2;
  }
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback ? fallbackName : name2;
  }
  return params;
}
function format$2(obj) {
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || typeof type3 !== "string" || !TOKEN_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string = String(type3).toLowerCase();
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i2 = 0; i2 < params.length; i2++) {
      param3 = params[i2];
      var val = param3.substr(-1) === "*" ? ustring(parameters[param3]) : qstring(parameters[param3]);
      string += "; " + param3 + "=" + val;
    }
  }
  return string;
}
function decodefield(str) {
  var match2 = EXT_VALUE_REGEXP.exec(str);
  if (!match2) {
    throw new TypeError("invalid extended field value");
  }
  var charset3 = match2[1].toLowerCase();
  var encoded = match2[2];
  var value;
  var binary2 = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
  switch (charset3) {
    case "iso-8859-1":
      value = getlatin1(binary2);
      break;
    case "utf-8":
      value = Buffer$9.from(binary2, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return value;
}
function getlatin1(val) {
  return String(val).replace(NON_LATIN1_REGEXP, "?");
}
function parse$i(string) {
  if (!string || typeof string !== "string") {
    throw new TypeError("argument string is required");
  }
  var match2 = DISPOSITION_TYPE_REGEXP.exec(string);
  if (!match2) {
    throw new TypeError("invalid type format");
  }
  var index2 = match2[0].length;
  var type3 = match2[1].toLowerCase();
  var key;
  var names = [];
  var params = {};
  var value;
  index2 = PARAM_REGEXP.lastIndex = match2[0].substr(-1) === ";" ? index2 - 1 : index2;
  while (match2 = PARAM_REGEXP.exec(string)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value = match2[2];
    if (names.indexOf(key) !== -1) {
      throw new TypeError("invalid duplicate parameter");
    }
    names.push(key);
    if (key.indexOf("*") + 1 === key.length) {
      key = key.slice(0, -1);
      value = decodefield(value);
      params[key] = value;
      continue;
    }
    if (typeof params[key] === "string") {
      continue;
    }
    if (value[0] === '"') {
      value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
    }
    params[key] = value;
  }
  if (index2 !== -1 && index2 !== string.length) {
    throw new TypeError("invalid parameter format");
  }
  return new ContentDisposition(type3, params);
}
function pdecode(str, hex) {
  return String.fromCharCode(parseInt(hex, 16));
}
function pencode(char) {
  return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
}
function qstring(val) {
  var str = String(val);
  return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function ustring(val) {
  var str = String(val);
  var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
  return "UTF-8''" + encoded;
}
function ContentDisposition(type3, parameters) {
  this.type = type3;
  this.parameters = parameters;
}
var contentDispositionExports = contentDisposition$2.exports;
var send$2 = { exports: {} };
var browser$3 = { exports: {} };
var debug$f = { exports: {} };
var s$1 = 1e3;
var m$1 = s$1 * 60;
var h$1 = m$1 * 60;
var d$1 = h$1 * 24;
var y$1 = d$1 * 365.25;
var ms$4 = function(val, options2) {
  options2 = options2 || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$h(val);
  } else if (type3 === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong$1(val) : fmtShort$1(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$h(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y$1;
    case "days":
    case "day":
    case "d":
      return n * d$1;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h$1;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m$1;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$1;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort$1(ms2) {
  if (ms2 >= d$1) {
    return Math.round(ms2 / d$1) + "d";
  }
  if (ms2 >= h$1) {
    return Math.round(ms2 / h$1) + "h";
  }
  if (ms2 >= m$1) {
    return Math.round(ms2 / m$1) + "m";
  }
  if (ms2 >= s$1) {
    return Math.round(ms2 / s$1) + "s";
  }
  return ms2 + "ms";
}
function fmtLong$1(ms2) {
  return plural$1(ms2, d$1, "day") || plural$1(ms2, h$1, "hour") || plural$1(ms2, m$1, "minute") || plural$1(ms2, s$1, "second") || ms2 + " ms";
}
function plural$1(ms2, n, name2) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name2;
  }
  return Math.ceil(ms2 / n) + " " + name2 + "s";
}
(function(module, exports2) {
  exports2 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce2;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms$4;
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace2) {
    var hash = 0, i2;
    for (i2 in namespace2) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
      hash |= 0;
    }
    return exports2.colors[Math.abs(hash) % exports2.colors.length];
  }
  function createDebug(namespace2) {
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +/* @__PURE__ */ new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports2.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
        if (match2 === "%%")
          return match2;
        index2++;
        var formatter = exports2.formatters[format2];
        if ("function" === typeof formatter) {
          var val = args[index2];
          match2 = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match2;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.enabled = exports2.enabled(namespace2);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace2);
    if ("function" === typeof exports2.init) {
      exports2.init(debug2);
    }
    return debug2;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split2.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!split2[i2])
        continue;
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name2) {
    var i2, len;
    for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
      if (exports2.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
      if (exports2.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function coerce2(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$f, debug$f.exports);
var debugExports = debug$f.exports;
(function(module, exports2) {
  var define_process_env_default2 = {};
  exports2 = module.exports = debugExports;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match2) {
      if ("%%" === match2)
        return;
      index2++;
      if ("%c" === match2) {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = define_process_env_default2.DEBUG;
    }
    return r;
  }
  exports2.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser$3, browser$3.exports);
var browserExports$1 = browser$3.exports;
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1 = etag$1;
var crypto$2 = require$$2$2;
var Stats = require$$2$2.Stats;
var toString$5 = Object.prototype.toString;
function entitytag(entity) {
  if (entity.length === 0) {
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }
  var hash = crypto$2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
  var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
  return '"' + len.toString(16) + "-" + hash + '"';
}
function etag$1(entity, options2) {
  if (entity == null) {
    throw new TypeError("argument entity is required");
  }
  var isStats = isstats(entity);
  var weak = options2 && typeof options2.weak === "boolean" ? options2.weak : isStats;
  if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  }
  var tag = isStats ? stattag(entity) : entitytag(entity);
  return weak ? "W/" + tag : tag;
}
function isstats(obj) {
  if (typeof Stats === "function" && obj instanceof Stats) {
    return true;
  }
  return obj && typeof obj === "object" && "ctime" in obj && toString$5.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString$5.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
}
function stattag(stat) {
  var mtime = stat.mtime.getTime().toString(16);
  var size = stat.size.toString(16);
  return '"' + size + "-" + mtime + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
var fresh_1 = fresh$2;
function fresh$2(reqHeaders, resHeaders) {
  var modifiedSince = reqHeaders["if-modified-since"];
  var noneMatch = reqHeaders["if-none-match"];
  if (!modifiedSince && !noneMatch) {
    return false;
  }
  var cacheControl = reqHeaders["cache-control"];
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false;
  }
  if (noneMatch && noneMatch !== "*") {
    var etag3 = resHeaders["etag"];
    if (!etag3) {
      return false;
    }
    var etagStale = true;
    var matches = parseTokenList$1(noneMatch);
    for (var i2 = 0; i2 < matches.length; i2++) {
      var match2 = matches[i2];
      if (match2 === etag3 || match2 === "W/" + etag3 || "W/" + match2 === etag3) {
        etagStale = false;
        break;
      }
    }
    if (etagStale) {
      return false;
    }
  }
  if (modifiedSince) {
    var lastModified = resHeaders["last-modified"];
    var modifiedStale = !lastModified || !(parseHttpDate$1(lastModified) <= parseHttpDate$1(modifiedSince));
    if (modifiedStale) {
      return false;
    }
  }
  return true;
}
function parseHttpDate$1(date) {
  var timestamp = date && Date.parse(date);
  return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList$1(str) {
  var end2 = 0;
  var list = [];
  var start = 0;
  for (var i2 = 0, len = str.length; i2 < len; i2++) {
    switch (str.charCodeAt(i2)) {
      case 32:
        if (start === end2) {
          start = end2 = i2 + 1;
        }
        break;
      case 44:
        list.push(str.substring(start, end2));
        start = end2 = i2 + 1;
        break;
      default:
        end2 = i2 + 1;
        break;
    }
  }
  list.push(str.substring(start, end2));
  return list;
}
const require$$2 = {
  "application/andrew-inset": [
    "ez"
  ],
  "application/applixware": [
    "aw"
  ],
  "application/atom+xml": [
    "atom"
  ],
  "application/atomcat+xml": [
    "atomcat"
  ],
  "application/atomsvc+xml": [
    "atomsvc"
  ],
  "application/bdoc": [
    "bdoc"
  ],
  "application/ccxml+xml": [
    "ccxml"
  ],
  "application/cdmi-capability": [
    "cdmia"
  ],
  "application/cdmi-container": [
    "cdmic"
  ],
  "application/cdmi-domain": [
    "cdmid"
  ],
  "application/cdmi-object": [
    "cdmio"
  ],
  "application/cdmi-queue": [
    "cdmiq"
  ],
  "application/cu-seeme": [
    "cu"
  ],
  "application/dash+xml": [
    "mpd"
  ],
  "application/davmount+xml": [
    "davmount"
  ],
  "application/docbook+xml": [
    "dbk"
  ],
  "application/dssc+der": [
    "dssc"
  ],
  "application/dssc+xml": [
    "xdssc"
  ],
  "application/ecmascript": [
    "ecma"
  ],
  "application/emma+xml": [
    "emma"
  ],
  "application/epub+zip": [
    "epub"
  ],
  "application/exi": [
    "exi"
  ],
  "application/font-tdpfr": [
    "pfr"
  ],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": [
    "geojson"
  ],
  "application/gml+xml": [
    "gml"
  ],
  "application/gpx+xml": [
    "gpx"
  ],
  "application/gxf": [
    "gxf"
  ],
  "application/gzip": [
    "gz"
  ],
  "application/hyperstudio": [
    "stk"
  ],
  "application/inkml+xml": [
    "ink",
    "inkml"
  ],
  "application/ipfix": [
    "ipfix"
  ],
  "application/java-archive": [
    "jar",
    "war",
    "ear"
  ],
  "application/java-serialized-object": [
    "ser"
  ],
  "application/java-vm": [
    "class"
  ],
  "application/javascript": [
    "js",
    "mjs"
  ],
  "application/json": [
    "json",
    "map"
  ],
  "application/json5": [
    "json5"
  ],
  "application/jsonml+json": [
    "jsonml"
  ],
  "application/ld+json": [
    "jsonld"
  ],
  "application/lost+xml": [
    "lostxml"
  ],
  "application/mac-binhex40": [
    "hqx"
  ],
  "application/mac-compactpro": [
    "cpt"
  ],
  "application/mads+xml": [
    "mads"
  ],
  "application/manifest+json": [
    "webmanifest"
  ],
  "application/marc": [
    "mrc"
  ],
  "application/marcxml+xml": [
    "mrcx"
  ],
  "application/mathematica": [
    "ma",
    "nb",
    "mb"
  ],
  "application/mathml+xml": [
    "mathml"
  ],
  "application/mbox": [
    "mbox"
  ],
  "application/mediaservercontrol+xml": [
    "mscml"
  ],
  "application/metalink+xml": [
    "metalink"
  ],
  "application/metalink4+xml": [
    "meta4"
  ],
  "application/mets+xml": [
    "mets"
  ],
  "application/mods+xml": [
    "mods"
  ],
  "application/mp21": [
    "m21",
    "mp21"
  ],
  "application/mp4": [
    "mp4s",
    "m4p"
  ],
  "application/msword": [
    "doc",
    "dot"
  ],
  "application/mxf": [
    "mxf"
  ],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": [
    "oda"
  ],
  "application/oebps-package+xml": [
    "opf"
  ],
  "application/ogg": [
    "ogx"
  ],
  "application/omdoc+xml": [
    "omdoc"
  ],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg"
  ],
  "application/oxps": [
    "oxps"
  ],
  "application/patch-ops-error+xml": [
    "xer"
  ],
  "application/pdf": [
    "pdf"
  ],
  "application/pgp-encrypted": [
    "pgp"
  ],
  "application/pgp-signature": [
    "asc",
    "sig"
  ],
  "application/pics-rules": [
    "prf"
  ],
  "application/pkcs10": [
    "p10"
  ],
  "application/pkcs7-mime": [
    "p7m",
    "p7c"
  ],
  "application/pkcs7-signature": [
    "p7s"
  ],
  "application/pkcs8": [
    "p8"
  ],
  "application/pkix-attr-cert": [
    "ac"
  ],
  "application/pkix-cert": [
    "cer"
  ],
  "application/pkix-crl": [
    "crl"
  ],
  "application/pkix-pkipath": [
    "pkipath"
  ],
  "application/pkixcmp": [
    "pki"
  ],
  "application/pls+xml": [
    "pls"
  ],
  "application/postscript": [
    "ai",
    "eps",
    "ps"
  ],
  "application/prs.cww": [
    "cww"
  ],
  "application/pskc+xml": [
    "pskcxml"
  ],
  "application/raml+yaml": [
    "raml"
  ],
  "application/rdf+xml": [
    "rdf"
  ],
  "application/reginfo+xml": [
    "rif"
  ],
  "application/relax-ng-compact-syntax": [
    "rnc"
  ],
  "application/resource-lists+xml": [
    "rl"
  ],
  "application/resource-lists-diff+xml": [
    "rld"
  ],
  "application/rls-services+xml": [
    "rs"
  ],
  "application/rpki-ghostbusters": [
    "gbr"
  ],
  "application/rpki-manifest": [
    "mft"
  ],
  "application/rpki-roa": [
    "roa"
  ],
  "application/rsd+xml": [
    "rsd"
  ],
  "application/rss+xml": [
    "rss"
  ],
  "application/rtf": [
    "rtf"
  ],
  "application/sbml+xml": [
    "sbml"
  ],
  "application/scvp-cv-request": [
    "scq"
  ],
  "application/scvp-cv-response": [
    "scs"
  ],
  "application/scvp-vp-request": [
    "spq"
  ],
  "application/scvp-vp-response": [
    "spp"
  ],
  "application/sdp": [
    "sdp"
  ],
  "application/set-payment-initiation": [
    "setpay"
  ],
  "application/set-registration-initiation": [
    "setreg"
  ],
  "application/shf+xml": [
    "shf"
  ],
  "application/smil+xml": [
    "smi",
    "smil"
  ],
  "application/sparql-query": [
    "rq"
  ],
  "application/sparql-results+xml": [
    "srx"
  ],
  "application/srgs": [
    "gram"
  ],
  "application/srgs+xml": [
    "grxml"
  ],
  "application/sru+xml": [
    "sru"
  ],
  "application/ssdl+xml": [
    "ssdl"
  ],
  "application/ssml+xml": [
    "ssml"
  ],
  "application/tei+xml": [
    "tei",
    "teicorpus"
  ],
  "application/thraud+xml": [
    "tfi"
  ],
  "application/timestamped-data": [
    "tsd"
  ],
  "application/vnd.3gpp.pic-bw-large": [
    "plb"
  ],
  "application/vnd.3gpp.pic-bw-small": [
    "psb"
  ],
  "application/vnd.3gpp.pic-bw-var": [
    "pvb"
  ],
  "application/vnd.3gpp2.tcap": [
    "tcap"
  ],
  "application/vnd.3m.post-it-notes": [
    "pwn"
  ],
  "application/vnd.accpac.simply.aso": [
    "aso"
  ],
  "application/vnd.accpac.simply.imp": [
    "imp"
  ],
  "application/vnd.acucobol": [
    "acu"
  ],
  "application/vnd.acucorp": [
    "atc",
    "acutc"
  ],
  "application/vnd.adobe.air-application-installer-package+zip": [
    "air"
  ],
  "application/vnd.adobe.formscentral.fcdt": [
    "fcdt"
  ],
  "application/vnd.adobe.fxp": [
    "fxp",
    "fxpl"
  ],
  "application/vnd.adobe.xdp+xml": [
    "xdp"
  ],
  "application/vnd.adobe.xfdf": [
    "xfdf"
  ],
  "application/vnd.ahead.space": [
    "ahead"
  ],
  "application/vnd.airzip.filesecure.azf": [
    "azf"
  ],
  "application/vnd.airzip.filesecure.azs": [
    "azs"
  ],
  "application/vnd.amazon.ebook": [
    "azw"
  ],
  "application/vnd.americandynamics.acc": [
    "acc"
  ],
  "application/vnd.amiga.ami": [
    "ami"
  ],
  "application/vnd.android.package-archive": [
    "apk"
  ],
  "application/vnd.anser-web-certificate-issue-initiation": [
    "cii"
  ],
  "application/vnd.anser-web-funds-transfer-initiation": [
    "fti"
  ],
  "application/vnd.antix.game-component": [
    "atx"
  ],
  "application/vnd.apple.installer+xml": [
    "mpkg"
  ],
  "application/vnd.apple.mpegurl": [
    "m3u8"
  ],
  "application/vnd.apple.pkpass": [
    "pkpass"
  ],
  "application/vnd.aristanetworks.swi": [
    "swi"
  ],
  "application/vnd.astraea-software.iota": [
    "iota"
  ],
  "application/vnd.audiograph": [
    "aep"
  ],
  "application/vnd.blueice.multipass": [
    "mpm"
  ],
  "application/vnd.bmi": [
    "bmi"
  ],
  "application/vnd.businessobjects": [
    "rep"
  ],
  "application/vnd.chemdraw+xml": [
    "cdxml"
  ],
  "application/vnd.chipnuts.karaoke-mmd": [
    "mmd"
  ],
  "application/vnd.cinderella": [
    "cdy"
  ],
  "application/vnd.claymore": [
    "cla"
  ],
  "application/vnd.cloanto.rp9": [
    "rp9"
  ],
  "application/vnd.clonk.c4group": [
    "c4g",
    "c4d",
    "c4f",
    "c4p",
    "c4u"
  ],
  "application/vnd.cluetrust.cartomobile-config": [
    "c11amc"
  ],
  "application/vnd.cluetrust.cartomobile-config-pkg": [
    "c11amz"
  ],
  "application/vnd.commonspace": [
    "csp"
  ],
  "application/vnd.contact.cmsg": [
    "cdbcmsg"
  ],
  "application/vnd.cosmocaller": [
    "cmc"
  ],
  "application/vnd.crick.clicker": [
    "clkx"
  ],
  "application/vnd.crick.clicker.keyboard": [
    "clkk"
  ],
  "application/vnd.crick.clicker.palette": [
    "clkp"
  ],
  "application/vnd.crick.clicker.template": [
    "clkt"
  ],
  "application/vnd.crick.clicker.wordbank": [
    "clkw"
  ],
  "application/vnd.criticaltools.wbs+xml": [
    "wbs"
  ],
  "application/vnd.ctc-posml": [
    "pml"
  ],
  "application/vnd.cups-ppd": [
    "ppd"
  ],
  "application/vnd.curl.car": [
    "car"
  ],
  "application/vnd.curl.pcurl": [
    "pcurl"
  ],
  "application/vnd.dart": [
    "dart"
  ],
  "application/vnd.data-vision.rdz": [
    "rdz"
  ],
  "application/vnd.dece.data": [
    "uvf",
    "uvvf",
    "uvd",
    "uvvd"
  ],
  "application/vnd.dece.ttml+xml": [
    "uvt",
    "uvvt"
  ],
  "application/vnd.dece.unspecified": [
    "uvx",
    "uvvx"
  ],
  "application/vnd.dece.zip": [
    "uvz",
    "uvvz"
  ],
  "application/vnd.denovo.fcselayout-link": [
    "fe_launch"
  ],
  "application/vnd.dna": [
    "dna"
  ],
  "application/vnd.dolby.mlp": [
    "mlp"
  ],
  "application/vnd.dpgraph": [
    "dpg"
  ],
  "application/vnd.dreamfactory": [
    "dfac"
  ],
  "application/vnd.ds-keypoint": [
    "kpxx"
  ],
  "application/vnd.dvb.ait": [
    "ait"
  ],
  "application/vnd.dvb.service": [
    "svc"
  ],
  "application/vnd.dynageo": [
    "geo"
  ],
  "application/vnd.ecowin.chart": [
    "mag"
  ],
  "application/vnd.enliven": [
    "nml"
  ],
  "application/vnd.epson.esf": [
    "esf"
  ],
  "application/vnd.epson.msf": [
    "msf"
  ],
  "application/vnd.epson.quickanime": [
    "qam"
  ],
  "application/vnd.epson.salt": [
    "slt"
  ],
  "application/vnd.epson.ssf": [
    "ssf"
  ],
  "application/vnd.eszigno3+xml": [
    "es3",
    "et3"
  ],
  "application/vnd.ezpix-album": [
    "ez2"
  ],
  "application/vnd.ezpix-package": [
    "ez3"
  ],
  "application/vnd.fdf": [
    "fdf"
  ],
  "application/vnd.fdsn.mseed": [
    "mseed"
  ],
  "application/vnd.fdsn.seed": [
    "seed",
    "dataless"
  ],
  "application/vnd.flographit": [
    "gph"
  ],
  "application/vnd.fluxtime.clip": [
    "ftc"
  ],
  "application/vnd.framemaker": [
    "fm",
    "frame",
    "maker",
    "book"
  ],
  "application/vnd.frogans.fnc": [
    "fnc"
  ],
  "application/vnd.frogans.ltf": [
    "ltf"
  ],
  "application/vnd.fsc.weblaunch": [
    "fsc"
  ],
  "application/vnd.fujitsu.oasys": [
    "oas"
  ],
  "application/vnd.fujitsu.oasys2": [
    "oa2"
  ],
  "application/vnd.fujitsu.oasys3": [
    "oa3"
  ],
  "application/vnd.fujitsu.oasysgp": [
    "fg5"
  ],
  "application/vnd.fujitsu.oasysprs": [
    "bh2"
  ],
  "application/vnd.fujixerox.ddd": [
    "ddd"
  ],
  "application/vnd.fujixerox.docuworks": [
    "xdw"
  ],
  "application/vnd.fujixerox.docuworks.binder": [
    "xbd"
  ],
  "application/vnd.fuzzysheet": [
    "fzs"
  ],
  "application/vnd.genomatix.tuxedo": [
    "txd"
  ],
  "application/vnd.geogebra.file": [
    "ggb"
  ],
  "application/vnd.geogebra.tool": [
    "ggt"
  ],
  "application/vnd.geometry-explorer": [
    "gex",
    "gre"
  ],
  "application/vnd.geonext": [
    "gxt"
  ],
  "application/vnd.geoplan": [
    "g2w"
  ],
  "application/vnd.geospace": [
    "g3w"
  ],
  "application/vnd.gmx": [
    "gmx"
  ],
  "application/vnd.google-apps.document": [
    "gdoc"
  ],
  "application/vnd.google-apps.presentation": [
    "gslides"
  ],
  "application/vnd.google-apps.spreadsheet": [
    "gsheet"
  ],
  "application/vnd.google-earth.kml+xml": [
    "kml"
  ],
  "application/vnd.google-earth.kmz": [
    "kmz"
  ],
  "application/vnd.grafeq": [
    "gqf",
    "gqs"
  ],
  "application/vnd.groove-account": [
    "gac"
  ],
  "application/vnd.groove-help": [
    "ghf"
  ],
  "application/vnd.groove-identity-message": [
    "gim"
  ],
  "application/vnd.groove-injector": [
    "grv"
  ],
  "application/vnd.groove-tool-message": [
    "gtm"
  ],
  "application/vnd.groove-tool-template": [
    "tpl"
  ],
  "application/vnd.groove-vcard": [
    "vcg"
  ],
  "application/vnd.hal+xml": [
    "hal"
  ],
  "application/vnd.handheld-entertainment+xml": [
    "zmm"
  ],
  "application/vnd.hbci": [
    "hbci"
  ],
  "application/vnd.hhe.lesson-player": [
    "les"
  ],
  "application/vnd.hp-hpgl": [
    "hpgl"
  ],
  "application/vnd.hp-hpid": [
    "hpid"
  ],
  "application/vnd.hp-hps": [
    "hps"
  ],
  "application/vnd.hp-jlyt": [
    "jlt"
  ],
  "application/vnd.hp-pcl": [
    "pcl"
  ],
  "application/vnd.hp-pclxl": [
    "pclxl"
  ],
  "application/vnd.hydrostatix.sof-data": [
    "sfd-hdstx"
  ],
  "application/vnd.ibm.minipay": [
    "mpy"
  ],
  "application/vnd.ibm.modcap": [
    "afp",
    "listafp",
    "list3820"
  ],
  "application/vnd.ibm.rights-management": [
    "irm"
  ],
  "application/vnd.ibm.secure-container": [
    "sc"
  ],
  "application/vnd.iccprofile": [
    "icc",
    "icm"
  ],
  "application/vnd.igloader": [
    "igl"
  ],
  "application/vnd.immervision-ivp": [
    "ivp"
  ],
  "application/vnd.immervision-ivu": [
    "ivu"
  ],
  "application/vnd.insors.igm": [
    "igm"
  ],
  "application/vnd.intercon.formnet": [
    "xpw",
    "xpx"
  ],
  "application/vnd.intergeo": [
    "i2g"
  ],
  "application/vnd.intu.qbo": [
    "qbo"
  ],
  "application/vnd.intu.qfx": [
    "qfx"
  ],
  "application/vnd.ipunplugged.rcprofile": [
    "rcprofile"
  ],
  "application/vnd.irepository.package+xml": [
    "irp"
  ],
  "application/vnd.is-xpr": [
    "xpr"
  ],
  "application/vnd.isac.fcs": [
    "fcs"
  ],
  "application/vnd.jam": [
    "jam"
  ],
  "application/vnd.jcp.javame.midlet-rms": [
    "rms"
  ],
  "application/vnd.jisp": [
    "jisp"
  ],
  "application/vnd.joost.joda-archive": [
    "joda"
  ],
  "application/vnd.kahootz": [
    "ktz",
    "ktr"
  ],
  "application/vnd.kde.karbon": [
    "karbon"
  ],
  "application/vnd.kde.kchart": [
    "chrt"
  ],
  "application/vnd.kde.kformula": [
    "kfo"
  ],
  "application/vnd.kde.kivio": [
    "flw"
  ],
  "application/vnd.kde.kontour": [
    "kon"
  ],
  "application/vnd.kde.kpresenter": [
    "kpr",
    "kpt"
  ],
  "application/vnd.kde.kspread": [
    "ksp"
  ],
  "application/vnd.kde.kword": [
    "kwd",
    "kwt"
  ],
  "application/vnd.kenameaapp": [
    "htke"
  ],
  "application/vnd.kidspiration": [
    "kia"
  ],
  "application/vnd.kinar": [
    "kne",
    "knp"
  ],
  "application/vnd.koan": [
    "skp",
    "skd",
    "skt",
    "skm"
  ],
  "application/vnd.kodak-descriptor": [
    "sse"
  ],
  "application/vnd.las.las+xml": [
    "lasxml"
  ],
  "application/vnd.llamagraphics.life-balance.desktop": [
    "lbd"
  ],
  "application/vnd.llamagraphics.life-balance.exchange+xml": [
    "lbe"
  ],
  "application/vnd.lotus-1-2-3": [
    "123"
  ],
  "application/vnd.lotus-approach": [
    "apr"
  ],
  "application/vnd.lotus-freelance": [
    "pre"
  ],
  "application/vnd.lotus-notes": [
    "nsf"
  ],
  "application/vnd.lotus-organizer": [
    "org"
  ],
  "application/vnd.lotus-screencam": [
    "scm"
  ],
  "application/vnd.lotus-wordpro": [
    "lwp"
  ],
  "application/vnd.macports.portpkg": [
    "portpkg"
  ],
  "application/vnd.mcd": [
    "mcd"
  ],
  "application/vnd.medcalcdata": [
    "mc1"
  ],
  "application/vnd.mediastation.cdkey": [
    "cdkey"
  ],
  "application/vnd.mfer": [
    "mwf"
  ],
  "application/vnd.mfmp": [
    "mfm"
  ],
  "application/vnd.micrografx.flo": [
    "flo"
  ],
  "application/vnd.micrografx.igx": [
    "igx"
  ],
  "application/vnd.mif": [
    "mif"
  ],
  "application/vnd.mobius.daf": [
    "daf"
  ],
  "application/vnd.mobius.dis": [
    "dis"
  ],
  "application/vnd.mobius.mbk": [
    "mbk"
  ],
  "application/vnd.mobius.mqy": [
    "mqy"
  ],
  "application/vnd.mobius.msl": [
    "msl"
  ],
  "application/vnd.mobius.plc": [
    "plc"
  ],
  "application/vnd.mobius.txf": [
    "txf"
  ],
  "application/vnd.mophun.application": [
    "mpn"
  ],
  "application/vnd.mophun.certificate": [
    "mpc"
  ],
  "application/vnd.mozilla.xul+xml": [
    "xul"
  ],
  "application/vnd.ms-artgalry": [
    "cil"
  ],
  "application/vnd.ms-cab-compressed": [
    "cab"
  ],
  "application/vnd.ms-excel": [
    "xls",
    "xlm",
    "xla",
    "xlc",
    "xlt",
    "xlw"
  ],
  "application/vnd.ms-excel.addin.macroenabled.12": [
    "xlam"
  ],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": [
    "xlsb"
  ],
  "application/vnd.ms-excel.sheet.macroenabled.12": [
    "xlsm"
  ],
  "application/vnd.ms-excel.template.macroenabled.12": [
    "xltm"
  ],
  "application/vnd.ms-fontobject": [
    "eot"
  ],
  "application/vnd.ms-htmlhelp": [
    "chm"
  ],
  "application/vnd.ms-ims": [
    "ims"
  ],
  "application/vnd.ms-lrm": [
    "lrm"
  ],
  "application/vnd.ms-officetheme": [
    "thmx"
  ],
  "application/vnd.ms-outlook": [
    "msg"
  ],
  "application/vnd.ms-pki.seccat": [
    "cat"
  ],
  "application/vnd.ms-pki.stl": [
    "stl"
  ],
  "application/vnd.ms-powerpoint": [
    "ppt",
    "pps",
    "pot"
  ],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": [
    "ppam"
  ],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": [
    "pptm"
  ],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": [
    "sldm"
  ],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
    "ppsm"
  ],
  "application/vnd.ms-powerpoint.template.macroenabled.12": [
    "potm"
  ],
  "application/vnd.ms-project": [
    "mpp",
    "mpt"
  ],
  "application/vnd.ms-word.document.macroenabled.12": [
    "docm"
  ],
  "application/vnd.ms-word.template.macroenabled.12": [
    "dotm"
  ],
  "application/vnd.ms-works": [
    "wps",
    "wks",
    "wcm",
    "wdb"
  ],
  "application/vnd.ms-wpl": [
    "wpl"
  ],
  "application/vnd.ms-xpsdocument": [
    "xps"
  ],
  "application/vnd.mseq": [
    "mseq"
  ],
  "application/vnd.musician": [
    "mus"
  ],
  "application/vnd.muvee.style": [
    "msty"
  ],
  "application/vnd.mynfc": [
    "taglet"
  ],
  "application/vnd.neurolanguage.nlu": [
    "nlu"
  ],
  "application/vnd.nitf": [
    "ntf",
    "nitf"
  ],
  "application/vnd.noblenet-directory": [
    "nnd"
  ],
  "application/vnd.noblenet-sealer": [
    "nns"
  ],
  "application/vnd.noblenet-web": [
    "nnw"
  ],
  "application/vnd.nokia.n-gage.data": [
    "ngdat"
  ],
  "application/vnd.nokia.n-gage.symbian.install": [
    "n-gage"
  ],
  "application/vnd.nokia.radio-preset": [
    "rpst"
  ],
  "application/vnd.nokia.radio-presets": [
    "rpss"
  ],
  "application/vnd.novadigm.edm": [
    "edm"
  ],
  "application/vnd.novadigm.edx": [
    "edx"
  ],
  "application/vnd.novadigm.ext": [
    "ext"
  ],
  "application/vnd.oasis.opendocument.chart": [
    "odc"
  ],
  "application/vnd.oasis.opendocument.chart-template": [
    "otc"
  ],
  "application/vnd.oasis.opendocument.database": [
    "odb"
  ],
  "application/vnd.oasis.opendocument.formula": [
    "odf"
  ],
  "application/vnd.oasis.opendocument.formula-template": [
    "odft"
  ],
  "application/vnd.oasis.opendocument.graphics": [
    "odg"
  ],
  "application/vnd.oasis.opendocument.graphics-template": [
    "otg"
  ],
  "application/vnd.oasis.opendocument.image": [
    "odi"
  ],
  "application/vnd.oasis.opendocument.image-template": [
    "oti"
  ],
  "application/vnd.oasis.opendocument.presentation": [
    "odp"
  ],
  "application/vnd.oasis.opendocument.presentation-template": [
    "otp"
  ],
  "application/vnd.oasis.opendocument.spreadsheet": [
    "ods"
  ],
  "application/vnd.oasis.opendocument.spreadsheet-template": [
    "ots"
  ],
  "application/vnd.oasis.opendocument.text": [
    "odt"
  ],
  "application/vnd.oasis.opendocument.text-master": [
    "odm"
  ],
  "application/vnd.oasis.opendocument.text-template": [
    "ott"
  ],
  "application/vnd.oasis.opendocument.text-web": [
    "oth"
  ],
  "application/vnd.olpc-sugar": [
    "xo"
  ],
  "application/vnd.oma.dd2+xml": [
    "dd2"
  ],
  "application/vnd.openofficeorg.extension": [
    "oxt"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
    "xlsx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx"
  ],
  "application/vnd.osgeo.mapguide.package": [
    "mgp"
  ],
  "application/vnd.osgi.dp": [
    "dp"
  ],
  "application/vnd.osgi.subsystem": [
    "esa"
  ],
  "application/vnd.palm": [
    "pdb",
    "pqa",
    "oprc"
  ],
  "application/vnd.pawaafile": [
    "paw"
  ],
  "application/vnd.pg.format": [
    "str"
  ],
  "application/vnd.pg.osasli": [
    "ei6"
  ],
  "application/vnd.picsel": [
    "efif"
  ],
  "application/vnd.pmi.widget": [
    "wg"
  ],
  "application/vnd.pocketlearn": [
    "plf"
  ],
  "application/vnd.powerbuilder6": [
    "pbd"
  ],
  "application/vnd.previewsystems.box": [
    "box"
  ],
  "application/vnd.proteus.magazine": [
    "mgz"
  ],
  "application/vnd.publishare-delta-tree": [
    "qps"
  ],
  "application/vnd.pvi.ptid1": [
    "ptid"
  ],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb"
  ],
  "application/vnd.realvnc.bed": [
    "bed"
  ],
  "application/vnd.recordare.musicxml": [
    "mxl"
  ],
  "application/vnd.recordare.musicxml+xml": [
    "musicxml"
  ],
  "application/vnd.rig.cryptonote": [
    "cryptonote"
  ],
  "application/vnd.rim.cod": [
    "cod"
  ],
  "application/vnd.rn-realmedia": [
    "rm"
  ],
  "application/vnd.rn-realmedia-vbr": [
    "rmvb"
  ],
  "application/vnd.route66.link66+xml": [
    "link66"
  ],
  "application/vnd.sailingtracker.track": [
    "st"
  ],
  "application/vnd.seemail": [
    "see"
  ],
  "application/vnd.sema": [
    "sema"
  ],
  "application/vnd.semd": [
    "semd"
  ],
  "application/vnd.semf": [
    "semf"
  ],
  "application/vnd.shana.informed.formdata": [
    "ifm"
  ],
  "application/vnd.shana.informed.formtemplate": [
    "itp"
  ],
  "application/vnd.shana.informed.interchange": [
    "iif"
  ],
  "application/vnd.shana.informed.package": [
    "ipk"
  ],
  "application/vnd.simtech-mindmapper": [
    "twd",
    "twds"
  ],
  "application/vnd.smaf": [
    "mmf"
  ],
  "application/vnd.smart.teacher": [
    "teacher"
  ],
  "application/vnd.solent.sdkm+xml": [
    "sdkm",
    "sdkd"
  ],
  "application/vnd.spotfire.dxp": [
    "dxp"
  ],
  "application/vnd.spotfire.sfs": [
    "sfs"
  ],
  "application/vnd.stardivision.calc": [
    "sdc"
  ],
  "application/vnd.stardivision.draw": [
    "sda"
  ],
  "application/vnd.stardivision.impress": [
    "sdd"
  ],
  "application/vnd.stardivision.math": [
    "smf"
  ],
  "application/vnd.stardivision.writer": [
    "sdw",
    "vor"
  ],
  "application/vnd.stardivision.writer-global": [
    "sgl"
  ],
  "application/vnd.stepmania.package": [
    "smzip"
  ],
  "application/vnd.stepmania.stepchart": [
    "sm"
  ],
  "application/vnd.sun.wadl+xml": [
    "wadl"
  ],
  "application/vnd.sun.xml.calc": [
    "sxc"
  ],
  "application/vnd.sun.xml.calc.template": [
    "stc"
  ],
  "application/vnd.sun.xml.draw": [
    "sxd"
  ],
  "application/vnd.sun.xml.draw.template": [
    "std"
  ],
  "application/vnd.sun.xml.impress": [
    "sxi"
  ],
  "application/vnd.sun.xml.impress.template": [
    "sti"
  ],
  "application/vnd.sun.xml.math": [
    "sxm"
  ],
  "application/vnd.sun.xml.writer": [
    "sxw"
  ],
  "application/vnd.sun.xml.writer.global": [
    "sxg"
  ],
  "application/vnd.sun.xml.writer.template": [
    "stw"
  ],
  "application/vnd.sus-calendar": [
    "sus",
    "susp"
  ],
  "application/vnd.svd": [
    "svd"
  ],
  "application/vnd.symbian.install": [
    "sis",
    "sisx"
  ],
  "application/vnd.syncml+xml": [
    "xsm"
  ],
  "application/vnd.syncml.dm+wbxml": [
    "bdm"
  ],
  "application/vnd.syncml.dm+xml": [
    "xdm"
  ],
  "application/vnd.tao.intent-module-archive": [
    "tao"
  ],
  "application/vnd.tcpdump.pcap": [
    "pcap",
    "cap",
    "dmp"
  ],
  "application/vnd.tmobile-livetv": [
    "tmo"
  ],
  "application/vnd.trid.tpt": [
    "tpt"
  ],
  "application/vnd.triscape.mxs": [
    "mxs"
  ],
  "application/vnd.trueapp": [
    "tra"
  ],
  "application/vnd.ufdl": [
    "ufd",
    "ufdl"
  ],
  "application/vnd.uiq.theme": [
    "utz"
  ],
  "application/vnd.umajin": [
    "umj"
  ],
  "application/vnd.unity": [
    "unityweb"
  ],
  "application/vnd.uoml+xml": [
    "uoml"
  ],
  "application/vnd.vcx": [
    "vcx"
  ],
  "application/vnd.visio": [
    "vsd",
    "vst",
    "vss",
    "vsw"
  ],
  "application/vnd.visionary": [
    "vis"
  ],
  "application/vnd.vsf": [
    "vsf"
  ],
  "application/vnd.wap.wbxml": [
    "wbxml"
  ],
  "application/vnd.wap.wmlc": [
    "wmlc"
  ],
  "application/vnd.wap.wmlscriptc": [
    "wmlsc"
  ],
  "application/vnd.webturbo": [
    "wtb"
  ],
  "application/vnd.wolfram.player": [
    "nbp"
  ],
  "application/vnd.wordperfect": [
    "wpd"
  ],
  "application/vnd.wqd": [
    "wqd"
  ],
  "application/vnd.wt.stf": [
    "stf"
  ],
  "application/vnd.xara": [
    "xar"
  ],
  "application/vnd.xfdl": [
    "xfdl"
  ],
  "application/vnd.yamaha.hv-dic": [
    "hvd"
  ],
  "application/vnd.yamaha.hv-script": [
    "hvs"
  ],
  "application/vnd.yamaha.hv-voice": [
    "hvp"
  ],
  "application/vnd.yamaha.openscoreformat": [
    "osf"
  ],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": [
    "osfpvg"
  ],
  "application/vnd.yamaha.smaf-audio": [
    "saf"
  ],
  "application/vnd.yamaha.smaf-phrase": [
    "spf"
  ],
  "application/vnd.yellowriver-custom-menu": [
    "cmp"
  ],
  "application/vnd.zul": [
    "zir",
    "zirz"
  ],
  "application/vnd.zzazz.deck+xml": [
    "zaz"
  ],
  "application/voicexml+xml": [
    "vxml"
  ],
  "application/wasm": [
    "wasm"
  ],
  "application/widget": [
    "wgt"
  ],
  "application/winhlp": [
    "hlp"
  ],
  "application/wsdl+xml": [
    "wsdl"
  ],
  "application/wspolicy+xml": [
    "wspolicy"
  ],
  "application/x-7z-compressed": [
    "7z"
  ],
  "application/x-abiword": [
    "abw"
  ],
  "application/x-ace-compressed": [
    "ace"
  ],
  "application/x-apple-diskimage": [],
  "application/x-arj": [
    "arj"
  ],
  "application/x-authorware-bin": [
    "aab",
    "x32",
    "u32",
    "vox"
  ],
  "application/x-authorware-map": [
    "aam"
  ],
  "application/x-authorware-seg": [
    "aas"
  ],
  "application/x-bcpio": [
    "bcpio"
  ],
  "application/x-bdoc": [],
  "application/x-bittorrent": [
    "torrent"
  ],
  "application/x-blorb": [
    "blb",
    "blorb"
  ],
  "application/x-bzip": [
    "bz"
  ],
  "application/x-bzip2": [
    "bz2",
    "boz"
  ],
  "application/x-cbr": [
    "cbr",
    "cba",
    "cbt",
    "cbz",
    "cb7"
  ],
  "application/x-cdlink": [
    "vcd"
  ],
  "application/x-cfs-compressed": [
    "cfs"
  ],
  "application/x-chat": [
    "chat"
  ],
  "application/x-chess-pgn": [
    "pgn"
  ],
  "application/x-chrome-extension": [
    "crx"
  ],
  "application/x-cocoa": [
    "cco"
  ],
  "application/x-conference": [
    "nsc"
  ],
  "application/x-cpio": [
    "cpio"
  ],
  "application/x-csh": [
    "csh"
  ],
  "application/x-debian-package": [
    "udeb"
  ],
  "application/x-dgc-compressed": [
    "dgc"
  ],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa"
  ],
  "application/x-doom": [
    "wad"
  ],
  "application/x-dtbncx+xml": [
    "ncx"
  ],
  "application/x-dtbook+xml": [
    "dtb"
  ],
  "application/x-dtbresource+xml": [
    "res"
  ],
  "application/x-dvi": [
    "dvi"
  ],
  "application/x-envoy": [
    "evy"
  ],
  "application/x-eva": [
    "eva"
  ],
  "application/x-font-bdf": [
    "bdf"
  ],
  "application/x-font-ghostscript": [
    "gsf"
  ],
  "application/x-font-linux-psf": [
    "psf"
  ],
  "application/x-font-pcf": [
    "pcf"
  ],
  "application/x-font-snf": [
    "snf"
  ],
  "application/x-font-type1": [
    "pfa",
    "pfb",
    "pfm",
    "afm"
  ],
  "application/x-freearc": [
    "arc"
  ],
  "application/x-futuresplash": [
    "spl"
  ],
  "application/x-gca-compressed": [
    "gca"
  ],
  "application/x-glulx": [
    "ulx"
  ],
  "application/x-gnumeric": [
    "gnumeric"
  ],
  "application/x-gramps-xml": [
    "gramps"
  ],
  "application/x-gtar": [
    "gtar"
  ],
  "application/x-hdf": [
    "hdf"
  ],
  "application/x-httpd-php": [
    "php"
  ],
  "application/x-install-instructions": [
    "install"
  ],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": [
    "jardiff"
  ],
  "application/x-java-jnlp-file": [
    "jnlp"
  ],
  "application/x-latex": [
    "latex"
  ],
  "application/x-lua-bytecode": [
    "luac"
  ],
  "application/x-lzh-compressed": [
    "lzh",
    "lha"
  ],
  "application/x-makeself": [
    "run"
  ],
  "application/x-mie": [
    "mie"
  ],
  "application/x-mobipocket-ebook": [
    "prc",
    "mobi"
  ],
  "application/x-ms-application": [
    "application"
  ],
  "application/x-ms-shortcut": [
    "lnk"
  ],
  "application/x-ms-wmd": [
    "wmd"
  ],
  "application/x-ms-wmz": [
    "wmz"
  ],
  "application/x-ms-xbap": [
    "xbap"
  ],
  "application/x-msaccess": [
    "mdb"
  ],
  "application/x-msbinder": [
    "obd"
  ],
  "application/x-mscardfile": [
    "crd"
  ],
  "application/x-msclip": [
    "clp"
  ],
  "application/x-msdos-program": [],
  "application/x-msdownload": [
    "com",
    "bat"
  ],
  "application/x-msmediaview": [
    "mvb",
    "m13",
    "m14"
  ],
  "application/x-msmetafile": [
    "wmf",
    "emf",
    "emz"
  ],
  "application/x-msmoney": [
    "mny"
  ],
  "application/x-mspublisher": [
    "pub"
  ],
  "application/x-msschedule": [
    "scd"
  ],
  "application/x-msterminal": [
    "trm"
  ],
  "application/x-mswrite": [
    "wri"
  ],
  "application/x-netcdf": [
    "nc",
    "cdf"
  ],
  "application/x-ns-proxy-autoconfig": [
    "pac"
  ],
  "application/x-nzb": [
    "nzb"
  ],
  "application/x-perl": [
    "pl",
    "pm"
  ],
  "application/x-pilot": [],
  "application/x-pkcs12": [
    "p12",
    "pfx"
  ],
  "application/x-pkcs7-certificates": [
    "p7b",
    "spc"
  ],
  "application/x-pkcs7-certreqresp": [
    "p7r"
  ],
  "application/x-rar-compressed": [
    "rar"
  ],
  "application/x-redhat-package-manager": [
    "rpm"
  ],
  "application/x-research-info-systems": [
    "ris"
  ],
  "application/x-sea": [
    "sea"
  ],
  "application/x-sh": [
    "sh"
  ],
  "application/x-shar": [
    "shar"
  ],
  "application/x-shockwave-flash": [
    "swf"
  ],
  "application/x-silverlight-app": [
    "xap"
  ],
  "application/x-sql": [
    "sql"
  ],
  "application/x-stuffit": [
    "sit"
  ],
  "application/x-stuffitx": [
    "sitx"
  ],
  "application/x-subrip": [
    "srt"
  ],
  "application/x-sv4cpio": [
    "sv4cpio"
  ],
  "application/x-sv4crc": [
    "sv4crc"
  ],
  "application/x-t3vm-image": [
    "t3"
  ],
  "application/x-tads": [
    "gam"
  ],
  "application/x-tar": [
    "tar"
  ],
  "application/x-tcl": [
    "tcl",
    "tk"
  ],
  "application/x-tex": [
    "tex"
  ],
  "application/x-tex-tfm": [
    "tfm"
  ],
  "application/x-texinfo": [
    "texinfo",
    "texi"
  ],
  "application/x-tgif": [
    "obj"
  ],
  "application/x-ustar": [
    "ustar"
  ],
  "application/x-virtualbox-hdd": [
    "hdd"
  ],
  "application/x-virtualbox-ova": [
    "ova"
  ],
  "application/x-virtualbox-ovf": [
    "ovf"
  ],
  "application/x-virtualbox-vbox": [
    "vbox"
  ],
  "application/x-virtualbox-vbox-extpack": [
    "vbox-extpack"
  ],
  "application/x-virtualbox-vdi": [
    "vdi"
  ],
  "application/x-virtualbox-vhd": [
    "vhd"
  ],
  "application/x-virtualbox-vmdk": [
    "vmdk"
  ],
  "application/x-wais-source": [
    "src"
  ],
  "application/x-web-app-manifest+json": [
    "webapp"
  ],
  "application/x-x509-ca-cert": [
    "der",
    "crt",
    "pem"
  ],
  "application/x-xfig": [
    "fig"
  ],
  "application/x-xliff+xml": [
    "xlf"
  ],
  "application/x-xpinstall": [
    "xpi"
  ],
  "application/x-xz": [
    "xz"
  ],
  "application/x-zmachine": [
    "z1",
    "z2",
    "z3",
    "z4",
    "z5",
    "z6",
    "z7",
    "z8"
  ],
  "application/xaml+xml": [
    "xaml"
  ],
  "application/xcap-diff+xml": [
    "xdf"
  ],
  "application/xenc+xml": [
    "xenc"
  ],
  "application/xhtml+xml": [
    "xhtml",
    "xht"
  ],
  "application/xml": [
    "xml",
    "xsl",
    "xsd",
    "rng"
  ],
  "application/xml-dtd": [
    "dtd"
  ],
  "application/xop+xml": [
    "xop"
  ],
  "application/xproc+xml": [
    "xpl"
  ],
  "application/xslt+xml": [
    "xslt"
  ],
  "application/xspf+xml": [
    "xspf"
  ],
  "application/xv+xml": [
    "mxml",
    "xhvml",
    "xvml",
    "xvm"
  ],
  "application/yang": [
    "yang"
  ],
  "application/yin+xml": [
    "yin"
  ],
  "application/zip": [
    "zip"
  ],
  "audio/3gpp": [],
  "audio/adpcm": [
    "adp"
  ],
  "audio/basic": [
    "au",
    "snd"
  ],
  "audio/midi": [
    "mid",
    "midi",
    "kar",
    "rmi"
  ],
  "audio/mp3": [],
  "audio/mp4": [
    "m4a",
    "mp4a"
  ],
  "audio/mpeg": [
    "mpga",
    "mp2",
    "mp2a",
    "mp3",
    "m2a",
    "m3a"
  ],
  "audio/ogg": [
    "oga",
    "ogg",
    "spx"
  ],
  "audio/s3m": [
    "s3m"
  ],
  "audio/silk": [
    "sil"
  ],
  "audio/vnd.dece.audio": [
    "uva",
    "uvva"
  ],
  "audio/vnd.digital-winds": [
    "eol"
  ],
  "audio/vnd.dra": [
    "dra"
  ],
  "audio/vnd.dts": [
    "dts"
  ],
  "audio/vnd.dts.hd": [
    "dtshd"
  ],
  "audio/vnd.lucent.voice": [
    "lvp"
  ],
  "audio/vnd.ms-playready.media.pya": [
    "pya"
  ],
  "audio/vnd.nuera.ecelp4800": [
    "ecelp4800"
  ],
  "audio/vnd.nuera.ecelp7470": [
    "ecelp7470"
  ],
  "audio/vnd.nuera.ecelp9600": [
    "ecelp9600"
  ],
  "audio/vnd.rip": [
    "rip"
  ],
  "audio/wav": [
    "wav"
  ],
  "audio/wave": [],
  "audio/webm": [
    "weba"
  ],
  "audio/x-aac": [
    "aac"
  ],
  "audio/x-aiff": [
    "aif",
    "aiff",
    "aifc"
  ],
  "audio/x-caf": [
    "caf"
  ],
  "audio/x-flac": [
    "flac"
  ],
  "audio/x-m4a": [],
  "audio/x-matroska": [
    "mka"
  ],
  "audio/x-mpegurl": [
    "m3u"
  ],
  "audio/x-ms-wax": [
    "wax"
  ],
  "audio/x-ms-wma": [
    "wma"
  ],
  "audio/x-pn-realaudio": [
    "ram",
    "ra"
  ],
  "audio/x-pn-realaudio-plugin": [
    "rmp"
  ],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": [
    "xm"
  ],
  "chemical/x-cdx": [
    "cdx"
  ],
  "chemical/x-cif": [
    "cif"
  ],
  "chemical/x-cmdf": [
    "cmdf"
  ],
  "chemical/x-cml": [
    "cml"
  ],
  "chemical/x-csml": [
    "csml"
  ],
  "chemical/x-xyz": [
    "xyz"
  ],
  "font/collection": [
    "ttc"
  ],
  "font/otf": [
    "otf"
  ],
  "font/ttf": [
    "ttf"
  ],
  "font/woff": [
    "woff"
  ],
  "font/woff2": [
    "woff2"
  ],
  "image/apng": [
    "apng"
  ],
  "image/bmp": [
    "bmp"
  ],
  "image/cgm": [
    "cgm"
  ],
  "image/g3fax": [
    "g3"
  ],
  "image/gif": [
    "gif"
  ],
  "image/ief": [
    "ief"
  ],
  "image/jp2": [
    "jp2",
    "jpg2"
  ],
  "image/jpeg": [
    "jpeg",
    "jpg",
    "jpe"
  ],
  "image/jpm": [
    "jpm"
  ],
  "image/jpx": [
    "jpx",
    "jpf"
  ],
  "image/ktx": [
    "ktx"
  ],
  "image/png": [
    "png"
  ],
  "image/prs.btif": [
    "btif"
  ],
  "image/sgi": [
    "sgi"
  ],
  "image/svg+xml": [
    "svg",
    "svgz"
  ],
  "image/tiff": [
    "tiff",
    "tif"
  ],
  "image/vnd.adobe.photoshop": [
    "psd"
  ],
  "image/vnd.dece.graphic": [
    "uvi",
    "uvvi",
    "uvg",
    "uvvg"
  ],
  "image/vnd.djvu": [
    "djvu",
    "djv"
  ],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": [
    "dwg"
  ],
  "image/vnd.dxf": [
    "dxf"
  ],
  "image/vnd.fastbidsheet": [
    "fbs"
  ],
  "image/vnd.fpx": [
    "fpx"
  ],
  "image/vnd.fst": [
    "fst"
  ],
  "image/vnd.fujixerox.edmics-mmr": [
    "mmr"
  ],
  "image/vnd.fujixerox.edmics-rlc": [
    "rlc"
  ],
  "image/vnd.ms-modi": [
    "mdi"
  ],
  "image/vnd.ms-photo": [
    "wdp"
  ],
  "image/vnd.net-fpx": [
    "npx"
  ],
  "image/vnd.wap.wbmp": [
    "wbmp"
  ],
  "image/vnd.xiff": [
    "xif"
  ],
  "image/webp": [
    "webp"
  ],
  "image/x-3ds": [
    "3ds"
  ],
  "image/x-cmu-raster": [
    "ras"
  ],
  "image/x-cmx": [
    "cmx"
  ],
  "image/x-freehand": [
    "fh",
    "fhc",
    "fh4",
    "fh5",
    "fh7"
  ],
  "image/x-icon": [
    "ico"
  ],
  "image/x-jng": [
    "jng"
  ],
  "image/x-mrsid-image": [
    "sid"
  ],
  "image/x-ms-bmp": [],
  "image/x-pcx": [
    "pcx"
  ],
  "image/x-pict": [
    "pic",
    "pct"
  ],
  "image/x-portable-anymap": [
    "pnm"
  ],
  "image/x-portable-bitmap": [
    "pbm"
  ],
  "image/x-portable-graymap": [
    "pgm"
  ],
  "image/x-portable-pixmap": [
    "ppm"
  ],
  "image/x-rgb": [
    "rgb"
  ],
  "image/x-tga": [
    "tga"
  ],
  "image/x-xbitmap": [
    "xbm"
  ],
  "image/x-xpixmap": [
    "xpm"
  ],
  "image/x-xwindowdump": [
    "xwd"
  ],
  "message/rfc822": [
    "eml",
    "mime"
  ],
  "model/gltf+json": [
    "gltf"
  ],
  "model/gltf-binary": [
    "glb"
  ],
  "model/iges": [
    "igs",
    "iges"
  ],
  "model/mesh": [
    "msh",
    "mesh",
    "silo"
  ],
  "model/vnd.collada+xml": [
    "dae"
  ],
  "model/vnd.dwf": [
    "dwf"
  ],
  "model/vnd.gdl": [
    "gdl"
  ],
  "model/vnd.gtw": [
    "gtw"
  ],
  "model/vnd.mts": [
    "mts"
  ],
  "model/vnd.vtu": [
    "vtu"
  ],
  "model/vrml": [
    "wrl",
    "vrml"
  ],
  "model/x3d+binary": [
    "x3db",
    "x3dbz"
  ],
  "model/x3d+vrml": [
    "x3dv",
    "x3dvz"
  ],
  "model/x3d+xml": [
    "x3d",
    "x3dz"
  ],
  "text/cache-manifest": [
    "appcache",
    "manifest"
  ],
  "text/calendar": [
    "ics",
    "ifb"
  ],
  "text/coffeescript": [
    "coffee",
    "litcoffee"
  ],
  "text/css": [
    "css"
  ],
  "text/csv": [
    "csv"
  ],
  "text/hjson": [
    "hjson"
  ],
  "text/html": [
    "html",
    "htm",
    "shtml"
  ],
  "text/jade": [
    "jade"
  ],
  "text/jsx": [
    "jsx"
  ],
  "text/less": [
    "less"
  ],
  "text/markdown": [
    "markdown",
    "md"
  ],
  "text/mathml": [
    "mml"
  ],
  "text/n3": [
    "n3"
  ],
  "text/plain": [
    "txt",
    "text",
    "conf",
    "def",
    "list",
    "log",
    "in",
    "ini"
  ],
  "text/prs.lines.tag": [
    "dsc"
  ],
  "text/richtext": [
    "rtx"
  ],
  "text/rtf": [],
  "text/sgml": [
    "sgml",
    "sgm"
  ],
  "text/slim": [
    "slim",
    "slm"
  ],
  "text/stylus": [
    "stylus",
    "styl"
  ],
  "text/tab-separated-values": [
    "tsv"
  ],
  "text/troff": [
    "t",
    "tr",
    "roff",
    "man",
    "me",
    "ms"
  ],
  "text/turtle": [
    "ttl"
  ],
  "text/uri-list": [
    "uri",
    "uris",
    "urls"
  ],
  "text/vcard": [
    "vcard"
  ],
  "text/vnd.curl": [
    "curl"
  ],
  "text/vnd.curl.dcurl": [
    "dcurl"
  ],
  "text/vnd.curl.mcurl": [
    "mcurl"
  ],
  "text/vnd.curl.scurl": [
    "scurl"
  ],
  "text/vnd.dvb.subtitle": [
    "sub"
  ],
  "text/vnd.fly": [
    "fly"
  ],
  "text/vnd.fmi.flexstor": [
    "flx"
  ],
  "text/vnd.graphviz": [
    "gv"
  ],
  "text/vnd.in3d.3dml": [
    "3dml"
  ],
  "text/vnd.in3d.spot": [
    "spot"
  ],
  "text/vnd.sun.j2me.app-descriptor": [
    "jad"
  ],
  "text/vnd.wap.wml": [
    "wml"
  ],
  "text/vnd.wap.wmlscript": [
    "wmls"
  ],
  "text/vtt": [
    "vtt"
  ],
  "text/x-asm": [
    "s",
    "asm"
  ],
  "text/x-c": [
    "c",
    "cc",
    "cxx",
    "cpp",
    "h",
    "hh",
    "dic"
  ],
  "text/x-component": [
    "htc"
  ],
  "text/x-fortran": [
    "f",
    "for",
    "f77",
    "f90"
  ],
  "text/x-handlebars-template": [
    "hbs"
  ],
  "text/x-java-source": [
    "java"
  ],
  "text/x-lua": [
    "lua"
  ],
  "text/x-markdown": [
    "mkd"
  ],
  "text/x-nfo": [
    "nfo"
  ],
  "text/x-opml": [
    "opml"
  ],
  "text/x-org": [],
  "text/x-pascal": [
    "p",
    "pas"
  ],
  "text/x-processing": [
    "pde"
  ],
  "text/x-sass": [
    "sass"
  ],
  "text/x-scss": [
    "scss"
  ],
  "text/x-setext": [
    "etx"
  ],
  "text/x-sfv": [
    "sfv"
  ],
  "text/x-suse-ymp": [
    "ymp"
  ],
  "text/x-uuencode": [
    "uu"
  ],
  "text/x-vcalendar": [
    "vcs"
  ],
  "text/x-vcard": [
    "vcf"
  ],
  "text/xml": [],
  "text/yaml": [
    "yaml",
    "yml"
  ],
  "video/3gpp": [
    "3gp",
    "3gpp"
  ],
  "video/3gpp2": [
    "3g2"
  ],
  "video/h261": [
    "h261"
  ],
  "video/h263": [
    "h263"
  ],
  "video/h264": [
    "h264"
  ],
  "video/jpeg": [
    "jpgv"
  ],
  "video/jpm": [
    "jpgm"
  ],
  "video/mj2": [
    "mj2",
    "mjp2"
  ],
  "video/mp2t": [
    "ts"
  ],
  "video/mp4": [
    "mp4",
    "mp4v",
    "mpg4"
  ],
  "video/mpeg": [
    "mpeg",
    "mpg",
    "mpe",
    "m1v",
    "m2v"
  ],
  "video/ogg": [
    "ogv"
  ],
  "video/quicktime": [
    "qt",
    "mov"
  ],
  "video/vnd.dece.hd": [
    "uvh",
    "uvvh"
  ],
  "video/vnd.dece.mobile": [
    "uvm",
    "uvvm"
  ],
  "video/vnd.dece.pd": [
    "uvp",
    "uvvp"
  ],
  "video/vnd.dece.sd": [
    "uvs",
    "uvvs"
  ],
  "video/vnd.dece.video": [
    "uvv",
    "uvvv"
  ],
  "video/vnd.dvb.file": [
    "dvb"
  ],
  "video/vnd.fvt": [
    "fvt"
  ],
  "video/vnd.mpegurl": [
    "mxu",
    "m4u"
  ],
  "video/vnd.ms-playready.media.pyv": [
    "pyv"
  ],
  "video/vnd.uvvu.mp4": [
    "uvu",
    "uvvu"
  ],
  "video/vnd.vivo": [
    "viv"
  ],
  "video/webm": [
    "webm"
  ],
  "video/x-f4v": [
    "f4v"
  ],
  "video/x-fli": [
    "fli"
  ],
  "video/x-flv": [
    "flv"
  ],
  "video/x-m4v": [
    "m4v"
  ],
  "video/x-matroska": [
    "mkv",
    "mk3d",
    "mks"
  ],
  "video/x-mng": [
    "mng"
  ],
  "video/x-ms-asf": [
    "asf",
    "asx"
  ],
  "video/x-ms-vob": [
    "vob"
  ],
  "video/x-ms-wm": [
    "wm"
  ],
  "video/x-ms-wmv": [
    "wmv"
  ],
  "video/x-ms-wmx": [
    "wmx"
  ],
  "video/x-ms-wvx": [
    "wvx"
  ],
  "video/x-msvideo": [
    "avi"
  ],
  "video/x-sgi-movie": [
    "movie"
  ],
  "video/x-smv": [
    "smv"
  ],
  "x-conference/x-cooltalk": [
    "ice"
  ]
};
var define_process_env_default$7 = {};
var fs$3 = require$$2$2;
function Mime() {
  this.types = /* @__PURE__ */ Object.create(null);
  this.extensions = /* @__PURE__ */ Object.create(null);
}
Mime.prototype.define = function(map2) {
  for (var type3 in map2) {
    var exts = map2[type3];
    for (var i2 = 0; i2 < exts.length; i2++) {
      if (define_process_env_default$7.DEBUG_MIME && this.types[exts[i2]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i2] + '" extension type from ' + this.types[exts[i2]] + " to " + type3);
      }
      this.types[exts[i2]] = type3;
    }
    if (!this.extensions[type3]) {
      this.extensions[type3] = exts[0];
    }
  }
};
Mime.prototype.load = function(file) {
  this._loading = file;
  var map2 = {}, content = fs$3.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
  lines.forEach(function(line) {
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    map2[fields.shift()] = fields;
  });
  this.define(map2);
  this._loading = null;
};
Mime.prototype.lookup = function(path22, fallback) {
  var ext = path22.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[ext] || fallback || this.default_type;
};
Mime.prototype.extension = function(mimeType) {
  var type3 = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type3];
};
var mime$3 = new Mime();
mime$3.define(require$$2);
mime$3.default_type = mime$3.lookup("bin");
mime$3.Mime = Mime;
mime$3.charsets = {
  lookup: function(mimeType, fallback) {
    return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
  }
};
var mime_1 = mime$3;
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms$3 = function(val, options2) {
  options2 = options2 || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$g(val);
  } else if (type3 === "number" && isFinite(val)) {
    return options2.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$g(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name2) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1 = rangeParser;
function rangeParser(size, str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var index2 = str.indexOf("=");
  if (index2 === -1) {
    return -2;
  }
  var arr = str.slice(index2 + 1).split(",");
  var ranges = [];
  ranges.type = str.slice(0, index2);
  for (var i2 = 0; i2 < arr.length; i2++) {
    var range3 = arr[i2].split("-");
    var start = parseInt(range3[0], 10);
    var end2 = parseInt(range3[1], 10);
    if (isNaN(start)) {
      start = size - end2;
      end2 = size - 1;
    } else if (isNaN(end2)) {
      end2 = size - 1;
    }
    if (end2 > size - 1) {
      end2 = size - 1;
    }
    if (isNaN(start) || isNaN(end2) || start > end2 || start < 0) {
      continue;
    }
    ranges.push({
      start,
      end: end2
    });
  }
  if (ranges.length < 1) {
    return -1;
  }
  return options2 && options2.combine ? combineRanges(ranges) : ranges;
}
function combineRanges(ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
  for (var j = 0, i2 = 1; i2 < ordered.length; i2++) {
    var range3 = ordered[i2];
    var current = ordered[j];
    if (range3.start > current.end + 1) {
      ordered[++j] = range3;
    } else if (range3.end > current.end) {
      current.end = range3.end;
      current.index = Math.min(current.index, range3.index);
    }
  }
  ordered.length = j + 1;
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
  combined.type = ranges.type;
  return combined;
}
function mapWithIndex(range3, index2) {
  return {
    start: range3.start,
    end: range3.end,
    index: index2
  };
}
function mapWithoutIndex(range3) {
  return {
    start: range3.start,
    end: range3.end
  };
}
function sortByRangeIndex(a, b) {
  return a.index - b.index;
}
function sortByRangeStart(a, b) {
  return a.start - b.start;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var createError$1 = httpErrorsExports;
var debug$e = browserExports$1("send");
var deprecate$3 = browser$7("send");
var destroy$2 = destroy_1$2;
var encodeUrl$1 = encodeurl;
var escapeHtml$1 = escapeHtml_1;
var etag = etag_1;
var fresh$1 = fresh_1;
var fs$2 = require$$2$2;
var mime$2 = mime_1;
var ms$2 = ms$3;
var onFinished$1 = onFinishedExports;
var parseRange$1 = rangeParser_1;
var path$3 = pathExports;
var statuses$1 = statuses$3;
var Stream$3 = require$$2$2;
var util$d = util$f;
var extname$1 = path$3.extname;
var join = path$3.join;
var normalize = path$3.normalize;
var resolve$1 = path$3.resolve;
var sep = path$3.sep;
var BYTES_RANGE_REGEXP = /^ *bytes=/;
var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
send$2.exports = send$1;
send$2.exports.mime = mime$2;
function send$1(req2, path3, options2) {
  return new SendStream(req2, path3, options2);
}
function SendStream(req2, path3, options2) {
  Stream$3.call(this);
  var opts = options2 || {};
  this.options = opts;
  this.path = path3;
  this.req = req2;
  this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
  this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
  this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
  this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
  if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  }
  this._hidden = Boolean(opts.hidden);
  if (opts.hidden !== void 0) {
    deprecate$3("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
  }
  if (opts.dotfiles === void 0) {
    this._dotfiles = void 0;
  }
  this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
  this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
  this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
  this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
  this._maxage = opts.maxAge || opts.maxage;
  this._maxage = typeof this._maxage === "string" ? ms$2(this._maxage) : Number(this._maxage);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  this._root = opts.root ? resolve$1(opts.root) : null;
  if (!this._root && opts.from) {
    this.from(opts.from);
  }
}
util$d.inherits(SendStream, Stream$3);
SendStream.prototype.etag = deprecate$3.function(function etag2(val) {
  this._etag = Boolean(val);
  debug$e("etag %s", this._etag);
  return this;
}, "send.etag: pass etag as option");
SendStream.prototype.hidden = deprecate$3.function(function hidden(val) {
  this._hidden = Boolean(val);
  this._dotfiles = void 0;
  debug$e("hidden %s", this._hidden);
  return this;
}, "send.hidden: use dotfiles option");
SendStream.prototype.index = deprecate$3.function(function index(paths) {
  var index2 = !paths ? [] : normalizeList(paths, "paths argument");
  debug$e("index %o", paths);
  this._index = index2;
  return this;
}, "send.index: pass index as option");
SendStream.prototype.root = function root(path3) {
  this._root = resolve$1(String(path3));
  debug$e("root %s", this._root);
  return this;
};
SendStream.prototype.from = deprecate$3.function(
  SendStream.prototype.root,
  "send.from: pass root as option"
);
SendStream.prototype.root = deprecate$3.function(
  SendStream.prototype.root,
  "send.root: pass root as option"
);
SendStream.prototype.maxage = deprecate$3.function(function maxage(maxAge) {
  this._maxage = typeof maxAge === "string" ? ms$2(maxAge) : Number(maxAge);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  debug$e("max-age %d", this._maxage);
  return this;
}, "send.maxage: pass maxAge as option");
SendStream.prototype.error = function error(status3, err) {
  if (hasListeners(this, "error")) {
    return this.emit("error", createHttpError(status3, err));
  }
  var res2 = this.res;
  var msg = statuses$1.message[status3] || String(status3);
  var doc = createHtmlDocument("Error", escapeHtml$1(msg));
  clearHeaders(res2);
  if (err && err.headers) {
    setHeaders(res2, err.headers);
  }
  res2.statusCode = status3;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.end(doc);
};
SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
  return this.path[this.path.length - 1] === "/";
};
SendStream.prototype.isConditionalGET = function isConditionalGET() {
  return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
};
SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
  var req2 = this.req;
  var res2 = this.res;
  var match2 = req2.headers["if-match"];
  if (match2) {
    var etag3 = res2.getHeader("ETag");
    return !etag3 || match2 !== "*" && parseTokenList(match2).every(function(match3) {
      return match3 !== etag3 && match3 !== "W/" + etag3 && "W/" + match3 !== etag3;
    });
  }
  var unmodifiedSince = parseHttpDate(req2.headers["if-unmodified-since"]);
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res2.getHeader("Last-Modified"));
    return isNaN(lastModified) || lastModified > unmodifiedSince;
  }
  return false;
};
SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
  var res2 = this.res;
  res2.removeHeader("Content-Encoding");
  res2.removeHeader("Content-Language");
  res2.removeHeader("Content-Length");
  res2.removeHeader("Content-Range");
  res2.removeHeader("Content-Type");
};
SendStream.prototype.notModified = function notModified() {
  var res2 = this.res;
  debug$e("not modified");
  this.removeContentHeaderFields();
  res2.statusCode = 304;
  res2.end();
};
SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
  var err = new Error("Can't set headers after they are sent.");
  debug$e("headers already sent");
  this.error(500, err);
};
SendStream.prototype.isCachable = function isCachable() {
  var statusCode = this.res.statusCode;
  return statusCode >= 200 && statusCode < 300 || statusCode === 304;
};
SendStream.prototype.onStatError = function onStatError(error3) {
  switch (error3.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, error3);
      break;
    default:
      this.error(500, error3);
      break;
  }
};
SendStream.prototype.isFresh = function isFresh() {
  return fresh$1(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified")
  });
};
SendStream.prototype.isRangeFresh = function isRangeFresh() {
  var ifRange = this.req.headers["if-range"];
  if (!ifRange) {
    return true;
  }
  if (ifRange.indexOf('"') !== -1) {
    var etag3 = this.res.getHeader("ETag");
    return Boolean(etag3 && ifRange.indexOf(etag3) !== -1);
  }
  var lastModified = this.res.getHeader("Last-Modified");
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
};
SendStream.prototype.redirect = function redirect(path3) {
  var res2 = this.res;
  if (hasListeners(this, "directory")) {
    this.emit("directory", res2, path3);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var loc = encodeUrl$1(collapseLeadingSlashes(this.path + "/"));
  var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml$1(loc) + '">' + escapeHtml$1(loc) + "</a>");
  res2.statusCode = 301;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.setHeader("Location", loc);
  res2.end(doc);
};
SendStream.prototype.pipe = function pipe(res2) {
  var root2 = this._root;
  this.res = res2;
  var path3 = decode$7(this.path);
  if (path3 === -1) {
    this.error(400);
    return res2;
  }
  if (~path3.indexOf("\0")) {
    this.error(400);
    return res2;
  }
  var parts;
  if (root2 !== null) {
    if (path3) {
      path3 = normalize("." + sep + path3);
    }
    if (UP_PATH_REGEXP.test(path3)) {
      debug$e('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = path3.split(sep);
    path3 = normalize(join(root2, path3));
  } else {
    if (UP_PATH_REGEXP.test(path3)) {
      debug$e('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = normalize(path3).split(sep);
    path3 = resolve$1(path3);
  }
  if (containsDotFile(parts)) {
    var access = this._dotfiles;
    if (access === void 0) {
      access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
    }
    debug$e('%s dotfile "%s"', access, path3);
    switch (access) {
      case "allow":
        break;
      case "deny":
        this.error(403);
        return res2;
      case "ignore":
      default:
        this.error(404);
        return res2;
    }
  }
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path3);
    return res2;
  }
  this.sendFile(path3);
  return res2;
};
SendStream.prototype.send = function send(path3, stat) {
  var len = stat.size;
  var options2 = this.options;
  var opts = {};
  var res2 = this.res;
  var req2 = this.req;
  var ranges = req2.headers.range;
  var offset = options2.start || 0;
  if (headersSent(res2)) {
    this.headersAlreadySent();
    return;
  }
  debug$e('pipe "%s"', path3);
  this.setHeader(path3, stat);
  this.type(path3);
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  len = Math.max(0, len - offset);
  if (options2.end !== void 0) {
    var bytes2 = options2.end - offset + 1;
    if (len > bytes2)
      len = bytes2;
  }
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    ranges = parseRange$1(len, ranges, {
      combine: true
    });
    if (!this.isRangeFresh()) {
      debug$e("range stale");
      ranges = -2;
    }
    if (ranges === -1) {
      debug$e("range unsatisfiable");
      res2.setHeader("Content-Range", contentRange("bytes", len));
      return this.error(416, {
        headers: { "Content-Range": res2.getHeader("Content-Range") }
      });
    }
    if (ranges !== -2 && ranges.length === 1) {
      debug$e("range %j", ranges);
      res2.statusCode = 206;
      res2.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
      offset += ranges[0].start;
      len = ranges[0].end - ranges[0].start + 1;
    }
  }
  for (var prop in options2) {
    opts[prop] = options2[prop];
  }
  opts.start = offset;
  opts.end = Math.max(offset, offset + len - 1);
  res2.setHeader("Content-Length", len);
  if (req2.method === "HEAD") {
    res2.end();
    return;
  }
  this.stream(path3, opts);
};
SendStream.prototype.sendFile = function sendFile(path3) {
  var i2 = 0;
  var self2 = this;
  debug$e('stat "%s"', path3);
  fs$2.stat(path3, function onstat(err, stat) {
    if (err && err.code === "ENOENT" && !extname$1(path3) && path3[path3.length - 1] !== sep) {
      return next(err);
    }
    if (err)
      return self2.onStatError(err);
    if (stat.isDirectory())
      return self2.redirect(path3);
    self2.emit("file", path3, stat);
    self2.send(path3, stat);
  });
  function next(err) {
    if (self2._extensions.length <= i2) {
      return err ? self2.onStatError(err) : self2.error(404);
    }
    var p = path3 + "." + self2._extensions[i2++];
    debug$e('stat "%s"', p);
    fs$2.stat(p, function(err2, stat) {
      if (err2)
        return next(err2);
      if (stat.isDirectory())
        return next();
      self2.emit("file", p, stat);
      self2.send(p, stat);
    });
  }
};
SendStream.prototype.sendIndex = function sendIndex(path3) {
  var i2 = -1;
  var self2 = this;
  function next(err) {
    if (++i2 >= self2._index.length) {
      if (err)
        return self2.onStatError(err);
      return self2.error(404);
    }
    var p = join(path3, self2._index[i2]);
    debug$e('stat "%s"', p);
    fs$2.stat(p, function(err2, stat) {
      if (err2)
        return next(err2);
      if (stat.isDirectory())
        return next();
      self2.emit("file", p, stat);
      self2.send(p, stat);
    });
  }
  next();
};
SendStream.prototype.stream = function stream(path3, options2) {
  var self2 = this;
  var res2 = this.res;
  var stream3 = fs$2.createReadStream(path3, options2);
  this.emit("stream", stream3);
  stream3.pipe(res2);
  function cleanup() {
    destroy$2(stream3, true);
  }
  onFinished$1(res2, cleanup);
  stream3.on("error", function onerror(err) {
    cleanup();
    self2.onStatError(err);
  });
  stream3.on("end", function onend() {
    self2.emit("end");
  });
};
SendStream.prototype.type = function type(path3) {
  var res2 = this.res;
  if (res2.getHeader("Content-Type"))
    return;
  var type3 = mime$2.lookup(path3);
  if (!type3) {
    debug$e("no content-type");
    return;
  }
  var charset3 = mime$2.charsets.lookup(type3);
  debug$e("content-type %s", type3);
  res2.setHeader("Content-Type", type3 + (charset3 ? "; charset=" + charset3 : ""));
};
SendStream.prototype.setHeader = function setHeader(path3, stat) {
  var res2 = this.res;
  this.emit("headers", res2, path3, stat);
  if (this._acceptRanges && !res2.getHeader("Accept-Ranges")) {
    debug$e("accept ranges");
    res2.setHeader("Accept-Ranges", "bytes");
  }
  if (this._cacheControl && !res2.getHeader("Cache-Control")) {
    var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
    if (this._immutable) {
      cacheControl += ", immutable";
    }
    debug$e("cache-control %s", cacheControl);
    res2.setHeader("Cache-Control", cacheControl);
  }
  if (this._lastModified && !res2.getHeader("Last-Modified")) {
    var modified = stat.mtime.toUTCString();
    debug$e("modified %s", modified);
    res2.setHeader("Last-Modified", modified);
  }
  if (this._etag && !res2.getHeader("ETag")) {
    var val = etag(stat);
    debug$e("etag %s", val);
    res2.setHeader("ETag", val);
  }
};
function clearHeaders(res2) {
  var headers = getHeaderNames(res2);
  for (var i2 = 0; i2 < headers.length; i2++) {
    res2.removeHeader(headers[i2]);
  }
}
function collapseLeadingSlashes(str) {
  for (var i2 = 0; i2 < str.length; i2++) {
    if (str[i2] !== "/") {
      break;
    }
  }
  return i2 > 1 ? "/" + str.substr(i2) : str;
}
function containsDotFile(parts) {
  for (var i2 = 0; i2 < parts.length; i2++) {
    var part = parts[i2];
    if (part.length > 1 && part[0] === ".") {
      return true;
    }
  }
  return false;
}
function contentRange(type3, size, range3) {
  return type3 + " " + (range3 ? range3.start + "-" + range3.end : "*") + "/" + size;
}
function createHtmlDocument(title, body) {
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
}
function createHttpError(status3, err) {
  if (!err) {
    return createError$1(status3);
  }
  return err instanceof Error ? createError$1(status3, err, { expose: false }) : createError$1(status3, err);
}
function decode$7(path3) {
  try {
    return decodeURIComponent(path3);
  } catch (err) {
    return -1;
  }
}
function getHeaderNames(res2) {
  return typeof res2.getHeaderNames !== "function" ? Object.keys(res2._headers || {}) : res2.getHeaderNames();
}
function hasListeners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function headersSent(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function normalizeList(val, name2) {
  var list = [].concat(val || []);
  for (var i2 = 0; i2 < list.length; i2++) {
    if (typeof list[i2] !== "string") {
      throw new TypeError(name2 + " must be array of strings or false");
    }
  }
  return list;
}
function parseHttpDate(date) {
  var timestamp = date && Date.parse(date);
  return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList(str) {
  var end2 = 0;
  var list = [];
  var start = 0;
  for (var i2 = 0, len = str.length; i2 < len; i2++) {
    switch (str.charCodeAt(i2)) {
      case 32:
        if (start === end2) {
          start = end2 = i2 + 1;
        }
        break;
      case 44:
        if (start !== end2) {
          list.push(str.substring(start, end2));
        }
        start = end2 = i2 + 1;
        break;
      default:
        end2 = i2 + 1;
        break;
    }
  }
  if (start !== end2) {
    list.push(str.substring(start, end2));
  }
  return list;
}
function setHeaders(res2, headers) {
  var keys2 = Object.keys(headers);
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key = keys2[i2];
    res2.setHeader(key, headers[key]);
  }
}
var sendExports = send$2.exports;
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1 = forwarded$1;
function forwarded$1(req2) {
  if (!req2) {
    throw new TypeError("argument req is required");
  }
  var proxyAddrs = parse$f(req2.headers["x-forwarded-for"] || "");
  var socketAddr = getSocketAddr(req2);
  var addrs = [socketAddr].concat(proxyAddrs);
  return addrs;
}
function getSocketAddr(req2) {
  return req2.socket ? req2.socket.remoteAddress : req2.connection.remoteAddress;
}
function parse$f(header3) {
  var end2 = header3.length;
  var list = [];
  var start = header3.length;
  for (var i2 = header3.length - 1; i2 >= 0; i2--) {
    switch (header3.charCodeAt(i2)) {
      case 32:
        if (start === end2) {
          start = end2 = i2;
        }
        break;
      case 44:
        if (start !== end2) {
          list.push(header3.substring(start, end2));
        }
        start = end2 = i2;
        break;
      default:
        start = i2;
        break;
    }
  }
  if (start !== end2) {
    list.push(header3.substring(start, end2));
  }
  return list;
}
var ipaddr$1 = { exports: {} };
ipaddr$1.exports;
(function(module) {
  (function() {
    var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root2, zoneIndex;
    ipaddr2 = {};
    root2 = this;
    if (module !== null && module.exports) {
      module.exports = ipaddr2;
    } else {
      root2["ipaddr"] = ipaddr2;
    }
    matchCIDR = function(first2, second, partSize, cidrBits) {
      var part, shift;
      if (first2.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first2[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
      var k, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k = 0, len = rangeSubnets.length; k < len; k++) {
          subnet = rangeSubnets[k];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr2.IPv4 = function() {
      function IPv4(octets) {
        var k, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr2.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i2, k, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i2 = k = 3; k >= 0; i2 = k += -1) {
          octet = this.octets[i2];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr2.IPv4.parser = function(string) {
      var match2, parseIntAuto, part, shift, value;
      parseIntAuto = function(string2) {
        if (string2[0] === "0" && string2[1] !== "x") {
          return parseInt(string2, 8);
        } else {
          return parseInt(string2);
        }
      };
      if (match2 = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k, len, ref2, results;
          ref2 = match2.slice(1, 6);
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match2 = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match2[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k, results;
          results = [];
          for (shift = k = 0; k <= 24; shift = k += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr2.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i2, k, l, len, part, ref2;
        if (parts.length === 16) {
          this.parts = [];
          for (i2 = k = 0; k <= 14; i2 = k += 2) {
            this.parts.push(parts[i2] << 8 | parts[i2 + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref2 = this.parts;
        for (l = 0, len = ref2.length; l < len; l++) {
          part = ref2[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match2, regex, string;
        regex = /((^|:)(0(:|$)){2,})/g;
        string = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match2 = regex.exec(string)) {
          if (match2[0].length > bestMatchLength) {
            bestMatchIndex = match2.index;
            bestMatchLength = match2[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes2, k, len, part, ref2;
        bytes2 = [];
        ref2 = this.parts;
        for (k = 0, len = ref2.length; k < len; k++) {
          part = ref2[k];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = (function() {
          var k, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(part.toString(16));
          }
          return results;
        }).call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = (function() {
          var k, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }).call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref2;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
        return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i2, k, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i2 = k = 7; k >= 0; i2 = k += -1) {
          part = this.parts[i2];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        var k, len, ref2, results;
        ref2 = string.split(":");
        results = [];
        for (k = 0, len = ref2.length; k < len; k++) {
          part = ref2[k];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr2.IPv6.parser = function(string) {
      var addr, k, len, match2, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string)) {
        return expandIPv6(string, 8);
      } else if (match2 = string.match(ipv6Regexes["transitional"])) {
        zoneId = match2[6] || "";
        addr = expandIPv6(match2[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match2[2]), parseInt(match2[3]), parseInt(match2[4]), parseInt(match2[5])];
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr2.IPv4.isValid = function(string) {
      try {
        new this(this.parser(string));
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr2.IPv6.isValid = function(string) {
      var addr;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.parse = function(string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr2.IPv6.parse = function(string) {
      var addr;
      addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr2.IPv4.parseCIDR = function(string) {
      var maskLength, match2, parsed;
      if (match2 = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix2) {
      var filledOctetCount, j, octets;
      prefix2 = parseInt(prefix2);
      if (prefix2 < 0 || prefix2 > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j = 0;
      filledOctetCount = Math.floor(prefix2 / 8);
      while (j < filledOctetCount) {
        octets[j] = 255;
        j++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix2 % 8) - 1 << 8 - prefix2 % 8;
      }
      return new this(octets);
    };
    ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
      var cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i2 = 0;
        while (i2 < 4) {
          octets.push(parseInt(ipInterfaceOctets[i2], 10) | parseInt(subnetMaskOctets[i2], 10) ^ 255);
          i2++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
      var cidr, i2, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i2 = 0;
        while (i2 < 4) {
          octets.push(parseInt(ipInterfaceOctets[i2], 10) & parseInt(subnetMaskOctets[i2], 10));
          i2++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv6.parseCIDR = function(string) {
      var maskLength, match2, parsed;
      if (match2 = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr2.isValid = function(string) {
      return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
    };
    ipaddr2.parse = function(string) {
      if (ipaddr2.IPv6.isValid(string)) {
        return ipaddr2.IPv6.parse(string);
      } else if (ipaddr2.IPv4.isValid(string)) {
        return ipaddr2.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr2.parseCIDR = function(string) {
      try {
        return ipaddr2.IPv6.parseCIDR(string);
      } catch (error1) {
        try {
          return ipaddr2.IPv4.parseCIDR(string);
        } catch (error12) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr2.fromByteArray = function(bytes2) {
      var length2;
      length2 = bytes2.length;
      if (length2 === 4) {
        return new ipaddr2.IPv4(bytes2);
      } else if (length2 === 16) {
        return new ipaddr2.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr2.process = function(string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(commonjsGlobal);
})(ipaddr$1);
var ipaddrExports = ipaddr$1.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
proxyAddr.exports = proxyaddr$1;
proxyAddr.exports.all = alladdrs;
proxyAddr.exports.compile = compile;
var forwarded = forwarded_1;
var ipaddr = ipaddrExports;
var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
var IP_RANGES = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function alladdrs(req2, trust) {
  var addrs = forwarded(req2);
  if (!trust) {
    return addrs;
  }
  if (typeof trust !== "function") {
    trust = compile(trust);
  }
  for (var i2 = 0; i2 < addrs.length - 1; i2++) {
    if (trust(addrs[i2], i2))
      continue;
    addrs.length = i2 + 1;
  }
  return addrs;
}
function compile(val) {
  if (!val) {
    throw new TypeError("argument is required");
  }
  var trust;
  if (typeof val === "string") {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError("unsupported trust argument");
  }
  for (var i2 = 0; i2 < trust.length; i2++) {
    val = trust[i2];
    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue;
    }
    val = IP_RANGES[val];
    trust.splice.apply(trust, [i2, 1].concat(val));
    i2 += val.length - 1;
  }
  return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);
  for (var i2 = 0; i2 < arr.length; i2++) {
    rangeSubnets[i2] = parseipNotation(arr[i2]);
  }
  return rangeSubnets;
}
function compileTrust(rangeSubnets) {
  var len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
  var pos = note.lastIndexOf("/");
  var str = pos !== -1 ? note.substring(0, pos) : note;
  if (!isip(str)) {
    throw new TypeError("invalid IP address: " + str);
  }
  var ip2 = parseip(str);
  if (pos === -1 && ip2.kind() === "ipv6" && ip2.isIPv4MappedAddress()) {
    ip2 = ip2.toIPv4Address();
  }
  var max2 = ip2.kind() === "ipv6" ? 128 : 32;
  var range3 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
  if (range3 === null) {
    range3 = max2;
  } else if (DIGIT_REGEXP.test(range3)) {
    range3 = parseInt(range3, 10);
  } else if (ip2.kind() === "ipv4" && isip(range3)) {
    range3 = parseNetmask(range3);
  } else {
    range3 = null;
  }
  if (range3 <= 0 || range3 > max2) {
    throw new TypeError("invalid range on address: " + note);
  }
  return [ip2, range3];
}
function parseNetmask(netmask) {
  var ip2 = parseip(netmask);
  var kind = ip2.kind();
  return kind === "ipv4" ? ip2.prefixLengthFromSubnetMask() : null;
}
function proxyaddr$1(req2, trust) {
  if (!req2) {
    throw new TypeError("req argument is required");
  }
  if (!trust) {
    throw new TypeError("trust argument is required");
  }
  var addrs = alladdrs(req2, trust);
  var addr = addrs[addrs.length - 1];
  return addr;
}
function trustNone() {
  return false;
}
function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr))
      return false;
    var ip2 = parseip(addr);
    var ipconv;
    var kind = ip2.kind();
    for (var i2 = 0; i2 < subnets.length; i2++) {
      var subnet = subnets[i2];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip2;
      if (kind !== subnetkind) {
        if (subnetkind === "ipv4" && !ip2.isIPv4MappedAddress()) {
          continue;
        }
        if (!ipconv) {
          ipconv = subnetkind === "ipv4" ? ip2.toIPv4Address() : ip2.toIPv4MappedAddress();
        }
        trusted = ipconv;
      }
      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }
    return false;
  };
}
function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === "ipv4";
  var subnetrange = subnet[1];
  return function trust(addr) {
    if (!isip(addr))
      return false;
    var ip2 = parseip(addr);
    var kind = ip2.kind();
    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip2.isIPv4MappedAddress()) {
        return false;
      }
      ip2 = subnetisipv4 ? ip2.toIPv4Address() : ip2.toIPv4MappedAddress();
    }
    return ip2.match(subnetip, subnetrange);
  };
}
var proxyAddrExports = proxyAddr.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports2) {
  var Buffer2 = safeBufferExports$1.Buffer;
  var contentDisposition2 = contentDispositionExports;
  var contentType$1 = contentType;
  var deprecate2 = browser$7("express");
  var flatten2 = arrayFlatten_1;
  var mime2 = sendExports.mime;
  var etag3 = etag_1;
  var proxyaddr2 = proxyAddrExports;
  var qs2 = lib$3;
  var querystring = require$$2$2;
  exports2.etag = createETagGenerator({ weak: false });
  exports2.wetag = createETagGenerator({ weak: true });
  exports2.isAbsolute = function(path3) {
    if ("/" === path3[0])
      return true;
    if (":" === path3[1] && ("\\" === path3[2] || "/" === path3[2]))
      return true;
    if ("\\\\" === path3.substring(0, 2))
      return true;
  };
  exports2.flatten = deprecate2.function(
    flatten2,
    "utils.flatten: use array-flatten npm module instead"
  );
  exports2.normalizeType = function(type3) {
    return ~type3.indexOf("/") ? acceptParams(type3) : { value: mime2.lookup(type3), params: {} };
  };
  exports2.normalizeTypes = function(types2) {
    var ret = [];
    for (var i2 = 0; i2 < types2.length; ++i2) {
      ret.push(exports2.normalizeType(types2[i2]));
    }
    return ret;
  };
  exports2.contentDisposition = deprecate2.function(
    contentDisposition2,
    "utils.contentDisposition: use content-disposition npm module instead"
  );
  function acceptParams(str) {
    var parts = str.split(/ *; */);
    var ret = { value: parts[0], quality: 1, params: {} };
    for (var i2 = 1; i2 < parts.length; ++i2) {
      var pms = parts[i2].split(/ *= */);
      if ("q" === pms[0]) {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports2.compileETag = function(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "weak":
        fn = exports2.wetag;
        break;
      case false:
        break;
      case "strong":
        fn = exports2.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn;
  };
  exports2.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "simple":
        fn = querystring.parse;
        break;
      case false:
        fn = newObject;
        break;
      case "extended":
        fn = parseExtendedQueryString;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn;
  };
  exports2.compileTrust = function(val) {
    if (typeof val === "function")
      return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i2) {
        return i2 < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(",").map(function(v) {
        return v.trim();
      });
    }
    return proxyaddr2.compile(val || []);
  };
  exports2.setCharset = function setCharset2(type3, charset3) {
    if (!type3 || !charset3) {
      return type3;
    }
    var parsed = contentType$1.parse(type3);
    parsed.parameters.charset = charset3;
    return contentType$1.format(parsed);
  };
  function createETagGenerator(options2) {
    return function generateETag(body, encoding3) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding3) : body;
      return etag3(buf, options2);
    };
  }
  function parseExtendedQueryString(str) {
    return qs2.parse(str, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
})(utils$1);
(function(module, exports2) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var finalhandler2 = finalhandler_1;
  var Router = routerExports;
  var methods2 = methods$2;
  var middleware = init;
  var query2 = requireQuery();
  var debug2 = browserExports$2("express:application");
  var View2 = view;
  var http2 = require$$2$2;
  var compileETag = utils$1.compileETag;
  var compileQueryParser = utils$1.compileQueryParser;
  var compileTrust2 = utils$1.compileTrust;
  var deprecate2 = browser$7("express");
  var flatten2 = arrayFlatten_1;
  var merge3 = utilsMergeExports;
  var resolve3 = pathExports.resolve;
  var setPrototypeOf2 = setprototypeof;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var slice2 = Array.prototype.slice;
  var app2 = module.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app2.init = function init2() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app2.defaultConfiguration = function defaultConfiguration() {
    var env = "production";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug2("booting in %s mode", env);
    this.on("mount", function onmount(parent) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf2(this.request, parent.request);
      setPrototypeOf2(this.response, parent.response);
      setPrototypeOf2(this.engines, parent.engines);
      setPrototypeOf2(this.settings, parent.settings);
    });
    this.locals = /* @__PURE__ */ Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View2);
    this.set("views", resolve3("views"));
    this.set("jsonp callback name", "callback");
    {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
      }
    });
  };
  app2.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query2(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app2.handle = function handle3(req2, res2, callback) {
    var router2 = this._router;
    var done2 = callback || finalhandler2(req2, res2, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router2) {
      debug2("no routes defined on app");
      done2();
      return;
    }
    router2.handle(req2, res2, done2);
  };
  app2.use = function use2(fn) {
    var offset = 0;
    var path22 = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path22 = fn;
      }
    }
    var fns = flatten2(slice2.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router2 = this._router;
    fns.forEach(function(fn2) {
      if (!fn2 || !fn2.handle || !fn2.set) {
        return router2.use(path22, fn2);
      }
      debug2(".use app under %s", path22);
      fn2.mountpath = path22;
      fn2.parent = this;
      router2.use(path22, function mounted_app(req2, res2, next) {
        var orig = req2.app;
        fn2.handle(req2, res2, function(err) {
          setPrototypeOf2(req2, orig.request);
          setPrototypeOf2(res2, orig.response);
          next(err);
        });
      });
      fn2.emit("mount", this);
    }, this);
    return this;
  };
  app2.route = function route3(path22) {
    this.lazyrouter();
    return this._router.route(path22);
  };
  app2.engine = function engine(ext, fn) {
    if (typeof fn !== "function") {
      throw new Error("callback function required");
    }
    var extension2 = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension2] = fn;
    return this;
  };
  app2.param = function param3(name2, fn) {
    this.lazyrouter();
    if (Array.isArray(name2)) {
      for (var i2 = 0; i2 < name2.length; i2++) {
        this.param(name2[i2], fn);
      }
      return this;
    }
    this._router.param(name2, fn);
    return this;
  };
  app2.set = function set(setting, val) {
    if (arguments.length === 1) {
      var settings = this.settings;
      while (settings && settings !== Object.prototype) {
        if (hasOwnProperty2.call(settings, setting)) {
          return settings[setting];
        }
        settings = Object.getPrototypeOf(settings);
      }
      return void 0;
    }
    debug2('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust2(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app2.path = function path3() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app2.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app2.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app2.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app2.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods2.forEach(function(method) {
    app2[method] = function(path22) {
      if (method === "get" && arguments.length === 1) {
        return this.set(path22);
      }
      this.lazyrouter();
      var route22 = this._router.route(path22);
      route22[method].apply(route22, slice2.call(arguments, 1));
      return this;
    };
  });
  app2.all = function all2(path22) {
    this.lazyrouter();
    var route22 = this._router.route(path22);
    var args = slice2.call(arguments, 1);
    for (var i2 = 0; i2 < methods2.length; i2++) {
      route22[methods2[i2]].apply(route22, args);
    }
    return this;
  };
  app2.del = deprecate2.function(app2.delete, "app.del: Use app.delete instead");
  app2.render = function render3(name2, options2, callback) {
    var cache = this.cache;
    var done2 = callback;
    var engines2 = this.engines;
    var opts = options2;
    var renderOptions = {};
    var view2;
    if (typeof options2 === "function") {
      done2 = options2;
      opts = {};
    }
    merge3(renderOptions, this.locals);
    if (opts._locals) {
      merge3(renderOptions, opts._locals);
    }
    merge3(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view2 = cache[name2];
    }
    if (!view2) {
      var View22 = this.get("view");
      view2 = new View22(name2, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines: engines2
      });
      if (!view2.path) {
        var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
        var err = new Error('Failed to lookup view "' + name2 + '" in views ' + dirs);
        err.view = view2;
        return done2(err);
      }
      if (renderOptions.cache) {
        cache[name2] = view2;
      }
    }
    tryRender(view2, renderOptions, done2);
  };
  app2.listen = function listen() {
    var server2 = http2.createServer(this);
    return server2.listen.apply(server2, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test")
      console.error(err.stack || err.toString());
  }
  function tryRender(view2, options2, callback) {
    try {
      view2.render(options2, callback);
    } catch (err) {
      callback(err);
    }
  }
})(application);
var applicationExports = application.exports;
var negotiator = { exports: {} };
var charset = { exports: {} };
charset.exports = preferredCharsets$1;
charset.exports.preferredCharsets = preferredCharsets$1;
var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
  var accepts2 = accept.split(",");
  for (var i2 = 0, j = 0; i2 < accepts2.length; i2++) {
    var charset3 = parseCharset(accepts2[i2].trim(), i2);
    if (charset3) {
      accepts2[j++] = charset3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseCharset(str, i2) {
  var match2 = simpleCharsetRegExp.exec(str);
  if (!match2)
    return null;
  var charset3 = match2[1];
  var q = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    charset: charset3,
    q,
    i: i2
  };
}
function getCharsetPriority(charset3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i2 = 0; i2 < accepted.length; i2++) {
    var spec = specify$3(charset3, accepted[i2], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$3(charset3, spec, index2) {
  var s2 = 0;
  if (spec.charset.toLowerCase() === charset3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.charset !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredCharsets$1(accept, provided) {
  var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getCharsetPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$3(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullCharset(spec) {
  return spec.charset;
}
function isQuality$3(spec) {
  return spec.q > 0;
}
var charsetExports = charset.exports;
var encoding = { exports: {} };
encoding.exports = preferredEncodings$1;
encoding.exports.preferredEncodings = preferredEncodings$1;
var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
  var accepts2 = accept.split(",");
  var hasIdentity = false;
  var minQuality = 1;
  for (var i2 = 0, j = 0; i2 < accepts2.length; i2++) {
    var encoding3 = parseEncoding(accepts2[i2].trim(), i2);
    if (encoding3) {
      accepts2[j++] = encoding3;
      hasIdentity = hasIdentity || specify$2("identity", encoding3);
      minQuality = Math.min(minQuality, encoding3.q || 1);
    }
  }
  if (!hasIdentity) {
    accepts2[j++] = {
      encoding: "identity",
      q: minQuality,
      i: i2
    };
  }
  accepts2.length = j;
  return accepts2;
}
function parseEncoding(str, i2) {
  var match2 = simpleEncodingRegExp.exec(str);
  if (!match2)
    return null;
  var encoding3 = match2[1];
  var q = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    encoding: encoding3,
    q,
    i: i2
  };
}
function getEncodingPriority(encoding3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i2 = 0; i2 < accepted.length; i2++) {
    var spec = specify$2(encoding3, accepted[i2], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$2(encoding3, spec, index2) {
  var s2 = 0;
  if (spec.encoding.toLowerCase() === encoding3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.encoding !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredEncodings$1(accept, provided) {
  var accepts2 = parseAcceptEncoding(accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getEncodingPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$2(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullEncoding(spec) {
  return spec.encoding;
}
function isQuality$2(spec) {
  return spec.q > 0;
}
var encodingExports = encoding.exports;
var language = { exports: {} };
language.exports = preferredLanguages$1;
language.exports.preferredLanguages = preferredLanguages$1;
var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
  var accepts2 = accept.split(",");
  for (var i2 = 0, j = 0; i2 < accepts2.length; i2++) {
    var language3 = parseLanguage(accepts2[i2].trim(), i2);
    if (language3) {
      accepts2[j++] = language3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseLanguage(str, i2) {
  var match2 = simpleLanguageRegExp.exec(str);
  if (!match2)
    return null;
  var prefix2 = match2[1];
  var suffix = match2[2];
  var full = prefix2;
  if (suffix)
    full += "-" + suffix;
  var q = 1;
  if (match2[3]) {
    var params = match2[3].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split("=");
      if (p[0] === "q")
        q = parseFloat(p[1]);
    }
  }
  return {
    prefix: prefix2,
    suffix,
    q,
    i: i2,
    full
  };
}
function getLanguagePriority(language3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i2 = 0; i2 < accepted.length; i2++) {
    var spec = specify$1(language3, accepted[i2], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$1(language3, spec, index2) {
  var p = parseLanguage(language3);
  if (!p)
    return null;
  var s2 = 0;
  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s2 |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s2 |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s2 |= 1;
  } else if (spec.full !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredLanguages$1(accept, provided) {
  var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getLanguagePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$1(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullLanguage(spec) {
  return spec.full;
}
function isQuality$1(spec) {
  return spec.q > 0;
}
var languageExports = language.exports;
var mediaType = { exports: {} };
mediaType.exports = preferredMediaTypes$1;
mediaType.exports.preferredMediaTypes = preferredMediaTypes$1;
var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
  var accepts2 = splitMediaTypes(accept);
  for (var i2 = 0, j = 0; i2 < accepts2.length; i2++) {
    var mediaType3 = parseMediaType(accepts2[i2].trim(), i2);
    if (mediaType3) {
      accepts2[j++] = mediaType3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseMediaType(str, i2) {
  var match2 = simpleMediaTypeRegExp.exec(str);
  if (!match2)
    return null;
  var params = /* @__PURE__ */ Object.create(null);
  var q = 1;
  var subtype = match2[2];
  var type3 = match2[1];
  if (match2[3]) {
    var kvps = splitParameters(match2[3]).map(splitKeyValuePair);
    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];
      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
      if (key === "q") {
        q = parseFloat(value);
        break;
      }
      params[key] = value;
    }
  }
  return {
    type: type3,
    subtype,
    params,
    q,
    i: i2
  };
}
function getMediaTypePriority(type3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i2 = 0; i2 < accepted.length; i2++) {
    var spec = specify(type3, accepted[i2], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify(type3, spec, index2) {
  var p = parseMediaType(type3);
  var s2 = 0;
  if (!p) {
    return null;
  }
  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s2 |= 4;
  } else if (spec.type != "*") {
    return null;
  }
  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s2 |= 2;
  } else if (spec.subtype != "*") {
    return null;
  }
  var keys2 = Object.keys(spec.params);
  if (keys2.length > 0) {
    if (keys2.every(function(k) {
      return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
    })) {
      s2 |= 1;
    } else {
      return null;
    }
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredMediaTypes$1(accept, provided) {
  var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getMediaTypePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullType(spec) {
  return spec.type + "/" + spec.subtype;
}
function isQuality(spec) {
  return spec.q > 0;
}
function quoteCount(string) {
  var count = 0;
  var index2 = 0;
  while ((index2 = string.indexOf('"', index2)) !== -1) {
    count++;
    index2++;
  }
  return count;
}
function splitKeyValuePair(str) {
  var index2 = str.indexOf("=");
  var key;
  var val;
  if (index2 === -1) {
    key = str;
  } else {
    key = str.substr(0, index2);
    val = str.substr(index2 + 1);
  }
  return [key, val];
}
function splitMediaTypes(accept) {
  var accepts2 = accept.split(",");
  for (var i2 = 1, j = 0; i2 < accepts2.length; i2++) {
    if (quoteCount(accepts2[j]) % 2 == 0) {
      accepts2[++j] = accepts2[i2];
    } else {
      accepts2[j] += "," + accepts2[i2];
    }
  }
  accepts2.length = j + 1;
  return accepts2;
}
function splitParameters(str) {
  var parameters = str.split(";");
  for (var i2 = 1, j = 0; i2 < parameters.length; i2++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i2];
    } else {
      parameters[j] += ";" + parameters[i2];
    }
  }
  parameters.length = j + 1;
  for (var i2 = 0; i2 < parameters.length; i2++) {
    parameters[i2] = parameters[i2].trim();
  }
  return parameters;
}
var mediaTypeExports = mediaType.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var preferredCharsets = charsetExports;
var preferredEncodings = encodingExports;
var preferredLanguages = languageExports;
var preferredMediaTypes = mediaTypeExports;
negotiator.exports = Negotiator$1;
negotiator.exports.Negotiator = Negotiator$1;
function Negotiator$1(request2) {
  if (!(this instanceof Negotiator$1)) {
    return new Negotiator$1(request2);
  }
  this.request = request2;
}
Negotiator$1.prototype.charset = function charset2(available) {
  var set = this.charsets(available);
  return set && set[0];
};
Negotiator$1.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers["accept-charset"], available);
};
Negotiator$1.prototype.encoding = function encoding2(available) {
  var set = this.encodings(available);
  return set && set[0];
};
Negotiator$1.prototype.encodings = function encodings2(available) {
  return preferredEncodings(this.request.headers["accept-encoding"], available);
};
Negotiator$1.prototype.language = function language2(available) {
  var set = this.languages(available);
  return set && set[0];
};
Negotiator$1.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers["accept-language"], available);
};
Negotiator$1.prototype.mediaType = function mediaType2(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};
Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};
Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;
var negotiatorExports = negotiator.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Negotiator = negotiatorExports;
var mime$1 = mimeTypes;
var accepts$3 = Accepts;
function Accepts(req2) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req2);
  }
  this.headers = req2.headers;
  this.negotiator = new Negotiator(req2);
}
Accepts.prototype.type = Accepts.prototype.types = function(types_) {
  var types2 = types_;
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length);
    for (var i2 = 0; i2 < types2.length; i2++) {
      types2[i2] = arguments[i2];
    }
  }
  if (!types2 || types2.length === 0) {
    return this.negotiator.mediaTypes();
  }
  if (!this.headers.accept) {
    return types2[0];
  }
  var mimes = types2.map(extToMime);
  var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first2 = accepts2[0];
  return first2 ? types2[mimes.indexOf(first2)] : false;
};
Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
  var encodings3 = encodings_;
  if (encodings3 && !Array.isArray(encodings3)) {
    encodings3 = new Array(arguments.length);
    for (var i2 = 0; i2 < encodings3.length; i2++) {
      encodings3[i2] = arguments[i2];
    }
  }
  if (!encodings3 || encodings3.length === 0) {
    return this.negotiator.encodings();
  }
  return this.negotiator.encodings(encodings3)[0] || false;
};
Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
  var charsets2 = charsets_;
  if (charsets2 && !Array.isArray(charsets2)) {
    charsets2 = new Array(arguments.length);
    for (var i2 = 0; i2 < charsets2.length; i2++) {
      charsets2[i2] = arguments[i2];
    }
  }
  if (!charsets2 || charsets2.length === 0) {
    return this.negotiator.charsets();
  }
  return this.negotiator.charsets(charsets2)[0] || false;
};
Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
  var languages2 = languages_;
  if (languages2 && !Array.isArray(languages2)) {
    languages2 = new Array(arguments.length);
    for (var i2 = 0; i2 < languages2.length; i2++) {
      languages2[i2] = arguments[i2];
    }
  }
  if (!languages2 || languages2.length === 0) {
    return this.negotiator.languages();
  }
  return this.negotiator.languages(languages2)[0] || false;
};
function extToMime(type3) {
  return type3.indexOf("/") === -1 ? mime$1.lookup(type3) : type3;
}
function validMime(type3) {
  return typeof type3 === "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts$2 = accepts$3;
var deprecate$2 = browser$7("express");
var isIP = require$$2$2.isIP;
var typeis = typeIsExports;
var http$3 = require$$2$2;
var fresh = fresh_1;
var parseRange = rangeParser_1;
var parse$e = parseurlExports;
var proxyaddr = proxyAddrExports;
var req = Object.create(http$3.IncomingMessage.prototype);
var request = req;
req.get = req.header = function header(name2) {
  if (!name2) {
    throw new TypeError("name argument is required to req.get");
  }
  if (typeof name2 !== "string") {
    throw new TypeError("name must be a string to req.get");
  }
  var lc = name2.toLowerCase();
  switch (lc) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[lc];
  }
};
req.accepts = function() {
  var accept = accepts$2(this);
  return accept.types.apply(accept, arguments);
};
req.acceptsEncodings = function() {
  var accept = accepts$2(this);
  return accept.encodings.apply(accept, arguments);
};
req.acceptsEncoding = deprecate$2.function(
  req.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead"
);
req.acceptsCharsets = function() {
  var accept = accepts$2(this);
  return accept.charsets.apply(accept, arguments);
};
req.acceptsCharset = deprecate$2.function(
  req.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead"
);
req.acceptsLanguages = function() {
  var accept = accepts$2(this);
  return accept.languages.apply(accept, arguments);
};
req.acceptsLanguage = deprecate$2.function(
  req.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead"
);
req.range = function range(size, options2) {
  var range3 = this.get("Range");
  if (!range3)
    return;
  return parseRange(size, range3, options2);
};
req.param = function param2(name2, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query2 = this.query || {};
  if (null != params[name2] && params.hasOwnProperty(name2))
    return params[name2];
  if (null != body[name2])
    return body[name2];
  if (null != query2[name2])
    return query2[name2];
  return defaultValue;
};
req.is = function is(types2) {
  var arr = types2;
  if (!Array.isArray(types2)) {
    arr = new Array(arguments.length);
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2] = arguments[i2];
    }
  }
  return typeis(this, arr);
};
defineGetter(req, "protocol", function protocol() {
  var proto2 = this.connection.encrypted ? "https" : "http";
  var trust = this.app.get("trust proxy fn");
  if (!trust(this.connection.remoteAddress, 0)) {
    return proto2;
  }
  var header3 = this.get("X-Forwarded-Proto") || proto2;
  var index2 = header3.indexOf(",");
  return index2 !== -1 ? header3.substring(0, index2).trim() : header3.trim();
});
defineGetter(req, "secure", function secure() {
  return this.protocol === "https";
});
defineGetter(req, "ip", function ip() {
  var trust = this.app.get("trust proxy fn");
  return proxyaddr(this, trust);
});
defineGetter(req, "ips", function ips() {
  var trust = this.app.get("trust proxy fn");
  var addrs = proxyaddr.all(this, trust);
  addrs.reverse().pop();
  return addrs;
});
defineGetter(req, "subdomains", function subdomains() {
  var hostname2 = this.hostname;
  if (!hostname2)
    return [];
  var offset = this.app.get("subdomain offset");
  var subdomains2 = !isIP(hostname2) ? hostname2.split(".").reverse() : [hostname2];
  return subdomains2.slice(offset);
});
defineGetter(req, "path", function path() {
  return parse$e(this).pathname;
});
defineGetter(req, "hostname", function hostname() {
  var trust = this.app.get("trust proxy fn");
  var host2 = this.get("X-Forwarded-Host");
  if (!host2 || !trust(this.connection.remoteAddress, 0)) {
    host2 = this.get("Host");
  } else if (host2.indexOf(",") !== -1) {
    host2 = host2.substring(0, host2.indexOf(",")).trimRight();
  }
  if (!host2)
    return;
  var offset = host2[0] === "[" ? host2.indexOf("]") + 1 : 0;
  var index2 = host2.indexOf(":", offset);
  return index2 !== -1 ? host2.substring(0, index2) : host2;
});
defineGetter(req, "host", deprecate$2.function(function host() {
  return this.hostname;
}, "req.host: Use req.hostname instead"));
defineGetter(req, "fresh", function() {
  var method = this.method;
  var res2 = this.res;
  var status3 = res2.statusCode;
  if ("GET" !== method && "HEAD" !== method)
    return false;
  if (status3 >= 200 && status3 < 300 || 304 === status3) {
    return fresh(this.headers, {
      "etag": res2.get("ETag"),
      "last-modified": res2.get("Last-Modified")
    });
  }
  return false;
});
defineGetter(req, "stale", function stale() {
  return !this.fresh;
});
defineGetter(req, "xhr", function xhr() {
  var val = this.get("X-Requested-With") || "";
  return val.toLowerCase() === "xmlhttprequest";
});
function defineGetter(obj, name2, getter) {
  Object.defineProperty(obj, name2, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}
var cookieSignature = {};
(function(exports2) {
  var crypto2 = require$$2$2;
  exports2.sign = function(val, secret) {
    if ("string" != typeof val)
      throw new TypeError("Cookie value must be provided as a string.");
    if ("string" != typeof secret)
      throw new TypeError("Secret string must be provided.");
    return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports2.unsign = function(val, secret) {
    if ("string" != typeof val)
      throw new TypeError("Signed cookie string must be provided.");
    if ("string" != typeof secret)
      throw new TypeError("Secret string must be provided.");
    var str = val.slice(0, val.lastIndexOf(".")), mac = exports2.sign(str, secret);
    return sha1(mac) == sha1(val) ? str : false;
  };
  function sha1(str) {
    return crypto2.createHash("sha1").update(str).digest("hex");
  }
})(cookieSignature);
var cookie$4 = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie$4.parse = parse$d;
cookie$4.serialize = serialize$2;
var __toString = Object.prototype.toString;
var fieldContentRegExp$2 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$d(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var dec = opt.decode || decode$6;
  var index2 = 0;
  while (index2 < str.length) {
    var eqIdx = str.indexOf("=", index2);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index2);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index2, eqIdx).trim();
    if (void 0 === obj[key]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode$2(val, dec);
    }
    index2 = endIdx + 1;
  }
  return obj;
}
function serialize$2(name2, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode$4;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp$2.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp$2.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp$2.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp$2.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate$1(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode$6(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode$4(val) {
  return encodeURIComponent(val);
}
function isDate$1(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode$2(str, decode2) {
  try {
    return decode2(str);
  } catch (e) {
    return str;
  }
}
var vary$2 = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
vary$2.exports = vary$1;
vary$2.exports.append = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header3, field) {
  if (typeof header3 !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$c(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header3 === "*") {
    return header3;
  }
  var val = header3;
  var vals = parse$c(header3.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i2 = 0; i2 < fields.length; i2++) {
    var fld = fields[i2].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i2] : fields[i2];
    }
  }
  return val;
}
function parse$c(header3) {
  var end2 = 0;
  var list = [];
  var start = 0;
  for (var i2 = 0, len = header3.length; i2 < len; i2++) {
    switch (header3.charCodeAt(i2)) {
      case 32:
        if (start === end2) {
          start = end2 = i2 + 1;
        }
        break;
      case 44:
        list.push(header3.substring(start, end2));
        start = end2 = i2 + 1;
        break;
      default:
        end2 = i2 + 1;
        break;
    }
  }
  list.push(header3.substring(start, end2));
  return list;
}
function vary$1(res2, field) {
  if (!res2 || !res2.getHeader || !res2.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res2.getHeader("Vary") || "";
  var header3 = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header3, field)) {
    res2.setHeader("Vary", val);
  }
}
var varyExports = vary$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Buffer$8 = safeBufferExports$1.Buffer;
var contentDisposition = contentDispositionExports;
var createError = httpErrorsExports;
var deprecate$1 = browser$7("express");
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var http$2 = require$$2$2;
var isAbsolute = utils$1.isAbsolute;
var onFinished = onFinishedExports;
var path$2 = pathExports;
var statuses = statuses$3;
var merge2 = utilsMergeExports;
var sign$1 = cookieSignature.sign;
var normalizeType = utils$1.normalizeType;
var normalizeTypes = utils$1.normalizeTypes;
var setCharset = utils$1.setCharset;
var cookie$3 = cookie$4;
var send2 = sendExports;
var extname = path$2.extname;
var mime = send2.mime;
var resolve2 = path$2.resolve;
var vary = varyExports;
var res = Object.create(http$2.ServerResponse.prototype);
var response = res;
var charsetRegExp = /;\s*charset\s*=/;
var schemaAndHostRegExp = /^(?:[a-zA-Z][a-zA-Z0-9+.-]*:)?\/\/[^\\\/\?]+/;
res.status = function status2(code) {
  if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) {
    deprecate$1("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
  }
  this.statusCode = code;
  return this;
};
res.links = function(links) {
  var link = this.get("Link") || "";
  if (link)
    link += ", ";
  return this.set("Link", link + Object.keys(links).map(function(rel) {
    return "<" + links[rel] + '>; rel="' + rel + '"';
  }).join(", "));
};
res.send = function send3(body) {
  var chunk = body;
  var encoding3;
  var req2 = this.req;
  var type3;
  var app2 = this.app;
  if (arguments.length === 2) {
    if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
      this.statusCode = arguments[1];
    } else {
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }
  if (typeof chunk === "number" && arguments.length === 1) {
    if (!this.get("Content-Type")) {
      this.type("txt");
    }
    this.statusCode = chunk;
    chunk = statuses.message[chunk];
  }
  switch (typeof chunk) {
    case "string":
      if (!this.get("Content-Type")) {
        this.type("html");
      }
      break;
    case "boolean":
    case "number":
    case "object":
      if (chunk === null) {
        chunk = "";
      } else if (Buffer$8.isBuffer(chunk)) {
        if (!this.get("Content-Type")) {
          this.type("bin");
        }
      } else {
        return this.json(chunk);
      }
      break;
  }
  if (typeof chunk === "string") {
    encoding3 = "utf8";
    type3 = this.get("Content-Type");
    if (typeof type3 === "string") {
      this.set("Content-Type", setCharset(type3, "utf-8"));
    }
  }
  var etagFn = app2.get("etag fn");
  var generateETag = !this.get("ETag") && typeof etagFn === "function";
  var len;
  if (chunk !== void 0) {
    if (Buffer$8.isBuffer(chunk)) {
      len = chunk.length;
    } else if (!generateETag && chunk.length < 1e3) {
      len = Buffer$8.byteLength(chunk, encoding3);
    } else {
      chunk = Buffer$8.from(chunk, encoding3);
      encoding3 = void 0;
      len = chunk.length;
    }
    this.set("Content-Length", len);
  }
  var etag3;
  if (generateETag && len !== void 0) {
    if (etag3 = etagFn(chunk, encoding3)) {
      this.set("ETag", etag3);
    }
  }
  if (req2.fresh)
    this.statusCode = 304;
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader("Content-Type");
    this.removeHeader("Content-Length");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (this.statusCode === 205) {
    this.set("Content-Length", "0");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (req2.method === "HEAD") {
    this.end();
  } else {
    this.end(chunk, encoding3);
  }
  return this;
};
res.json = function json(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      this.statusCode = arguments[1];
    } else {
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app2 = this.app;
  var escape2 = app2.get("json escape");
  var replacer = app2.get("json replacer");
  var spaces = app2.get("json spaces");
  var body = stringify2(val, replacer, spaces, escape2);
  if (!this.get("Content-Type")) {
    this.set("Content-Type", "application/json");
  }
  return this.send(body);
};
res.jsonp = function jsonp(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      this.statusCode = arguments[1];
    } else {
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app2 = this.app;
  var escape2 = app2.get("json escape");
  var replacer = app2.get("json replacer");
  var spaces = app2.get("json spaces");
  var body = stringify2(val, replacer, spaces, escape2);
  var callback = this.req.query[app2.get("jsonp callback name")];
  if (!this.get("Content-Type")) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "application/json");
  }
  if (Array.isArray(callback)) {
    callback = callback[0];
  }
  if (typeof callback === "string" && callback.length !== 0) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "text/javascript");
    callback = callback.replace(/[^\[\]\w$.]/g, "");
    if (body === void 0) {
      body = "";
    } else if (typeof body === "string") {
      body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
  }
  return this.send(body);
};
res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode);
  this.statusCode = statusCode;
  this.type("txt");
  return this.send(body);
};
res.sendFile = function sendFile2(path3, options2, callback) {
  var done2 = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options2 || {};
  if (!path3) {
    throw new TypeError("path argument is required to res.sendFile");
  }
  if (typeof path3 !== "string") {
    throw new TypeError("path must be a string to res.sendFile");
  }
  if (typeof options2 === "function") {
    done2 = options2;
    opts = {};
  }
  if (!opts.root && !isAbsolute(path3)) {
    throw new TypeError("path must be absolute or specify root to res.sendFile");
  }
  var pathname = encodeURI(path3);
  var file = send2(req2, pathname, opts);
  sendfile(res2, file, opts, function(err) {
    if (done2)
      return done2(err);
    if (err && err.code === "EISDIR")
      return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = function(path3, options2, callback) {
  var done2 = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options2 || {};
  if (typeof options2 === "function") {
    done2 = options2;
    opts = {};
  }
  var file = send2(req2, path3, opts);
  sendfile(res2, file, opts, function(err) {
    if (done2)
      return done2(err);
    if (err && err.code === "EISDIR")
      return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = deprecate$1.function(
  res.sendfile,
  "res.sendfile: Use res.sendFile instead"
);
res.download = function download(path3, filename, options2, callback) {
  var done2 = callback;
  var name2 = filename;
  var opts = options2 || null;
  if (typeof filename === "function") {
    done2 = filename;
    name2 = null;
    opts = null;
  } else if (typeof options2 === "function") {
    done2 = options2;
    opts = null;
  }
  if (typeof filename === "object" && (typeof options2 === "function" || options2 === void 0)) {
    name2 = null;
    opts = filename;
  }
  var headers = {
    "Content-Disposition": contentDisposition(name2 || path3)
  };
  if (opts && opts.headers) {
    var keys2 = Object.keys(opts.headers);
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var key = keys2[i2];
      if (key.toLowerCase() !== "content-disposition") {
        headers[key] = opts.headers[key];
      }
    }
  }
  opts = Object.create(opts);
  opts.headers = headers;
  var fullPath = !opts.root ? resolve2(path3) : path3;
  return this.sendFile(fullPath, opts, done2);
};
res.contentType = res.type = function contentType2(type3) {
  var ct = type3.indexOf("/") === -1 ? mime.lookup(type3) : type3;
  return this.set("Content-Type", ct);
};
res.format = function(obj) {
  var req2 = this.req;
  var next = req2.next;
  var keys2 = Object.keys(obj).filter(function(v) {
    return v !== "default";
  });
  var key = keys2.length > 0 ? req2.accepts(keys2) : false;
  this.vary("Accept");
  if (key) {
    this.set("Content-Type", normalizeType(key).value);
    obj[key](req2, this, next);
  } else if (obj.default) {
    obj.default(req2, this, next);
  } else {
    next(createError(406, {
      types: normalizeTypes(keys2).map(function(o) {
        return o.value;
      })
    }));
  }
  return this;
};
res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }
  this.set("Content-Disposition", contentDisposition(filename));
  return this;
};
res.append = function append2(field, val) {
  var prev2 = this.get(field);
  var value = val;
  if (prev2) {
    value = Array.isArray(prev2) ? prev2.concat(val) : Array.isArray(val) ? [prev2].concat(val) : [prev2, val];
  }
  return this.set(field, value);
};
res.set = res.header = function header2(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val) ? val.map(String) : String(val);
    if (field.toLowerCase() === "content-type") {
      if (Array.isArray(value)) {
        throw new TypeError("Content-Type cannot be set to an Array");
      }
      if (!charsetRegExp.test(value)) {
        var charset3 = mime.charsets.lookup(value.split(";")[0]);
        if (charset3)
          value += "; charset=" + charset3.toLowerCase();
      }
    }
    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};
res.get = function(field) {
  return this.getHeader(field);
};
res.clearCookie = function clearCookie(name2, options2) {
  var opts = merge2({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options2);
  return this.cookie(name2, "", opts);
};
res.cookie = function(name2, value, options2) {
  var opts = merge2({}, options2);
  var secret = this.req.secret;
  var signed = opts.signed;
  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }
  var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
  if (signed) {
    val = "s:" + sign$1(val, secret);
  }
  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0;
    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge);
      opts.maxAge = Math.floor(maxAge / 1e3);
    }
  }
  if (opts.path == null) {
    opts.path = "/";
  }
  this.append("Set-Cookie", cookie$3.serialize(name2, String(val), opts));
  return this;
};
res.location = function location(url2) {
  var loc;
  if (url2 === "back") {
    loc = this.req.get("Referrer") || "/";
  } else {
    loc = String(url2);
  }
  var m2 = schemaAndHostRegExp.exec(loc);
  var pos = m2 ? m2[0].length + 1 : 0;
  loc = loc.slice(0, pos) + encodeUrl(loc.slice(pos));
  return this.set("Location", loc);
};
res.redirect = function redirect2(url2) {
  var address = url2;
  var body;
  var status3 = 302;
  if (arguments.length === 2) {
    if (typeof arguments[0] === "number") {
      status3 = arguments[0];
      address = arguments[1];
    } else {
      status3 = arguments[1];
    }
  }
  address = this.location(address).get("Location");
  this.format({
    text: function() {
      body = statuses.message[status3] + ". Redirecting to " + address;
    },
    html: function() {
      var u = escapeHtml(address);
      body = "<p>" + statuses.message[status3] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
    },
    default: function() {
      body = "";
    }
  });
  this.statusCode = status3;
  this.set("Content-Length", Buffer$8.byteLength(body));
  if (this.req.method === "HEAD") {
    this.end();
  } else {
    this.end(body);
  }
};
res.vary = function(field) {
  if (!field || Array.isArray(field) && !field.length) {
    return this;
  }
  vary(this, field);
  return this;
};
res.render = function render2(view2, options2, callback) {
  var app2 = this.req.app;
  var done2 = callback;
  var opts = options2 || {};
  var req2 = this.req;
  var self2 = this;
  if (typeof options2 === "function") {
    done2 = options2;
    opts = {};
  }
  opts._locals = self2.locals;
  done2 = done2 || function(err, str) {
    if (err)
      return req2.next(err);
    self2.send(str);
  };
  app2.render(view2, opts, done2);
};
function sendfile(res2, file, options2, callback) {
  var done2 = false;
  var streaming;
  function onaborted() {
    if (done2)
      return;
    done2 = true;
    var err = new Error("Request aborted");
    err.code = "ECONNABORTED";
    callback(err);
  }
  function ondirectory() {
    if (done2)
      return;
    done2 = true;
    var err = new Error("EISDIR, read");
    err.code = "EISDIR";
    callback(err);
  }
  function onerror(err) {
    if (done2)
      return;
    done2 = true;
    callback(err);
  }
  function onend() {
    if (done2)
      return;
    done2 = true;
    callback();
  }
  function onfile() {
    streaming = false;
  }
  function onfinish(err) {
    if (err && err.code === "ECONNRESET")
      return onaborted();
    if (err)
      return onerror(err);
    if (done2)
      return;
    setImmediate(function() {
      if (streaming !== false && !done2) {
        onaborted();
        return;
      }
      if (done2)
        return;
      done2 = true;
      callback();
    });
  }
  function onstream() {
    streaming = true;
  }
  file.on("directory", ondirectory);
  file.on("end", onend);
  file.on("error", onerror);
  file.on("file", onfile);
  file.on("stream", onstream);
  onFinished(res2, onfinish);
  if (options2.headers) {
    file.on("headers", function headers(res3) {
      var obj = options2.headers;
      var keys2 = Object.keys(obj);
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var k = keys2[i2];
        res3.setHeader(k, obj[k]);
      }
    });
  }
  file.pipe(res2);
}
function stringify2(value, replacer, spaces, escape2) {
  var json2 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
  if (escape2 && typeof json2 === "string") {
    json2 = json2.replace(/[<>&]/g, function(c) {
      switch (c.charCodeAt(0)) {
        case 60:
          return "\\u003c";
        case 62:
          return "\\u003e";
        case 38:
          return "\\u0026";
        default:
          return c;
      }
    });
  }
  return json2;
}
var serveStatic = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic)
    return serveStatic.exports;
  hasRequiredServeStatic = 1;
  var encodeUrl2 = encodeurl;
  var escapeHtml2 = escapeHtml_1;
  var parseUrl2 = parseurlExports;
  var resolve3 = pathExports.resolve;
  var send4 = sendExports;
  var url2 = require$$2$2;
  serveStatic.exports = serveStatic$1;
  serveStatic.exports.mime = send4.mime;
  function serveStatic$1(root2, options2) {
    if (!root2) {
      throw new TypeError("root path required");
    }
    if (typeof root2 !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options2 || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect3 = opts.redirect !== false;
    var setHeaders2 = opts.setHeaders;
    if (setHeaders2 && typeof setHeaders2 !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve3(root2);
    var onDirectory = redirect3 ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req2, res2, next) {
      if (req2.method !== "GET" && req2.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res2.statusCode = 405;
        res2.setHeader("Allow", "GET, HEAD");
        res2.setHeader("Content-Length", "0");
        res2.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl2.original(req2);
      var path3 = parseUrl2(req2).pathname;
      if (path3 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path3 = "";
      }
      var stream3 = send4(req2, path3, opts);
      stream3.on("directory", onDirectory);
      if (setHeaders2) {
        stream3.on("headers", setHeaders2);
      }
      if (fallthrough) {
        stream3.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream3.on("error", function error3(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream3.pipe(res2);
    };
  }
  function collapseLeadingSlashes2(str) {
    for (var i2 = 0; i2 < str.length; i2++) {
      if (str.charCodeAt(i2) !== 47) {
        break;
      }
    }
    return i2 > 1 ? "/" + str.substr(i2) : str;
  }
  function createHtmlDocument2(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect3(res2) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl2.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes2(originalUrl.pathname + "/");
      var loc = encodeUrl2(url2.format(originalUrl));
      var doc = createHtmlDocument2("Redirecting", 'Redirecting to <a href="' + escapeHtml2(loc) + '">' + escapeHtml2(loc) + "</a>");
      res2.statusCode = 301;
      res2.setHeader("Content-Type", "text/html; charset=UTF-8");
      res2.setHeader("Content-Length", Buffer.byteLength(doc));
      res2.setHeader("Content-Security-Policy", "default-src 'none'");
      res2.setHeader("X-Content-Type-Options", "nosniff");
      res2.setHeader("Location", loc);
      res2.end(doc);
    };
  }
  return serveStatic.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module, exports2) {
  var bodyParser2 = bodyParserExports;
  var EventEmitter2 = require$$2$2.EventEmitter;
  var mixin2 = mergeDescriptors;
  var proto2 = applicationExports;
  var Route2 = route;
  var Router = routerExports;
  var req2 = request;
  var res2 = response;
  exports2 = module.exports = createApplication;
  function createApplication() {
    var app2 = function(req3, res3, next) {
      app2.handle(req3, res3, next);
    };
    mixin2(app2, EventEmitter2.prototype, false);
    mixin2(app2, proto2, false);
    app2.request = Object.create(req2, {
      app: { configurable: true, enumerable: true, writable: true, value: app2 }
    });
    app2.response = Object.create(res2, {
      app: { configurable: true, enumerable: true, writable: true, value: app2 }
    });
    app2.init();
    return app2;
  }
  exports2.application = proto2;
  exports2.request = req2;
  exports2.response = res2;
  exports2.Route = Route2;
  exports2.Router = Router;
  exports2.json = bodyParser2.json;
  exports2.query = requireQuery();
  exports2.raw = bodyParser2.raw;
  exports2.static = requireServeStatic();
  exports2.text = bodyParser2.text;
  exports2.urlencoded = bodyParser2.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name2) {
    Object.defineProperty(exports2, name2, {
      get: function() {
        throw new Error("Most middleware (like " + name2 + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
})(express$2, express$2.exports);
var expressExports = express$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express = expressExports;
const express$1 = /* @__PURE__ */ getDefaultExportFromCjs(express);
var dist$1 = { exports: {} };
var engine_io = {};
var server = {};
var base64id$1 = { exports: {} };
/*!
 * base64id v0.1.0
 */
(function(module, exports2) {
  var crypto2 = require$$2$2;
  var Base64Id = function() {
  };
  Base64Id.prototype.getRandomBytes = function(bytes2) {
    var BUFFER_SIZE = 4096;
    var self2 = this;
    bytes2 = bytes2 || 12;
    if (bytes2 > BUFFER_SIZE) {
      return crypto2.randomBytes(bytes2);
    }
    var bytesInBuffer = parseInt(BUFFER_SIZE / bytes2);
    var threshold = parseInt(bytesInBuffer * 0.85);
    if (!threshold) {
      return crypto2.randomBytes(bytes2);
    }
    if (this.bytesBufferIndex == null) {
      this.bytesBufferIndex = -1;
    }
    if (this.bytesBufferIndex == bytesInBuffer) {
      this.bytesBuffer = null;
      this.bytesBufferIndex = -1;
    }
    if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
      if (!this.isGeneratingBytes) {
        this.isGeneratingBytes = true;
        crypto2.randomBytes(BUFFER_SIZE, function(err, bytes3) {
          self2.bytesBuffer = bytes3;
          self2.bytesBufferIndex = 0;
          self2.isGeneratingBytes = false;
        });
      }
      if (this.bytesBufferIndex == -1) {
        return crypto2.randomBytes(bytes2);
      }
    }
    var result = this.bytesBuffer.slice(bytes2 * this.bytesBufferIndex, bytes2 * (this.bytesBufferIndex + 1));
    this.bytesBufferIndex++;
    return result;
  };
  Base64Id.prototype.generateId = function() {
    var rand = Buffer.alloc(15);
    if (!rand.writeInt32BE) {
      return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
    }
    this.sequenceNumber = this.sequenceNumber + 1 | 0;
    rand.writeInt32BE(this.sequenceNumber, 11);
    if (crypto2.randomBytes) {
      this.getRandomBytes(12).copy(rand);
    } else {
      [0, 4, 8].forEach(function(i2) {
        rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i2);
      });
    }
    return rand.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
  };
  module.exports = new Base64Id();
})(base64id$1);
var base64idExports = base64id$1.exports;
var transports = {};
var polling$2 = {};
var transport = {};
var cjs$1 = {};
var encodePacket_browser = {};
var commons = {};
Object.defineProperty(commons, "__esModule", { value: true });
commons.ERROR_PACKET = commons.PACKET_TYPES_REVERSE = commons.PACKET_TYPES = void 0;
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
commons.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
commons.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
commons.ERROR_PACKET = ERROR_PACKET;
Object.defineProperty(encodePacket_browser, "__esModule", { value: true });
encodePacket_browser.encodePacket = encodePacket_browser.encodePacketToBinary = void 0;
const commons_js_1$1 = commons;
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type: type3, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(commons_js_1$1.PACKET_TYPES[type3] + (data || ""));
};
encodePacket_browser.encodePacket = encodePacket;
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
encodePacket_browser.encodePacketToBinary = encodePacketToBinary;
var decodePacket_browser = {};
var base64Arraybuffer = {};
Object.defineProperty(base64Arraybuffer, "__esModule", { value: true });
base64Arraybuffer.decode = base64Arraybuffer.encode = void 0;
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup2[chars.charCodeAt(i2)] = i2;
}
const encode$3 = (arraybuffer) => {
  let bytes2 = new Uint8Array(arraybuffer), i2, len = bytes2.length, base64 = "";
  for (i2 = 0; i2 < len; i2 += 3) {
    base64 += chars[bytes2[i2] >> 2];
    base64 += chars[(bytes2[i2] & 3) << 4 | bytes2[i2 + 1] >> 4];
    base64 += chars[(bytes2[i2 + 1] & 15) << 2 | bytes2[i2 + 2] >> 6];
    base64 += chars[bytes2[i2 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
base64Arraybuffer.encode = encode$3;
const decode$5 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup2[base64.charCodeAt(i2)];
    encoded2 = lookup2[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup2[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup2[base64.charCodeAt(i2 + 3)];
    bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
base64Arraybuffer.decode = decode$5;
Object.defineProperty(decodePacket_browser, "__esModule", { value: true });
decodePacket_browser.decodePacket = void 0;
const commons_js_1 = commons;
const base64_arraybuffer_js_1 = base64Arraybuffer;
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type3 = encodedPacket.charAt(0);
  if (type3 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = commons_js_1.PACKET_TYPES_REVERSE[type3];
  if (!packetType) {
    return commons_js_1.ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: commons_js_1.PACKET_TYPES_REVERSE[type3],
    data: encodedPacket.substring(1)
  } : {
    type: commons_js_1.PACKET_TYPES_REVERSE[type3]
  };
};
decodePacket_browser.decodePacket = decodePacket;
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = (0, base64_arraybuffer_js_1.decode)(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodePayload = exports2.decodePacket = exports2.encodePayload = exports2.encodePacket = exports2.protocol = exports2.createPacketDecoderStream = exports2.createPacketEncoderStream = void 0;
  const encodePacket_js_1 = encodePacket_browser;
  Object.defineProperty(exports2, "encodePacket", { enumerable: true, get: function() {
    return encodePacket_js_1.encodePacket;
  } });
  const decodePacket_js_1 = decodePacket_browser;
  Object.defineProperty(exports2, "decodePacket", { enumerable: true, get: function() {
    return decodePacket_js_1.decodePacket;
  } });
  const commons_js_12 = commons;
  const SEPARATOR2 = String.fromCharCode(30);
  const encodePayload = (packets, callback) => {
    const length2 = packets.length;
    const encodedPackets = new Array(length2);
    let count = 0;
    packets.forEach((packet, i2) => {
      (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
        encodedPackets[i2] = encodedPacket;
        if (++count === length2) {
          callback(encodedPackets.join(SEPARATOR2));
        }
      });
    });
  };
  exports2.encodePayload = encodePayload;
  const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR2);
    const packets = [];
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i2], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  exports2.decodePayload = decodePayload;
  function createPacketEncoderStream() {
    return new TransformStream({
      transform(packet, controller) {
        (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
          const payloadLength = encodedPacket.length;
          let header3;
          if (payloadLength < 126) {
            header3 = new Uint8Array(1);
            new DataView(header3.buffer).setUint8(0, payloadLength);
          } else if (payloadLength < 65536) {
            header3 = new Uint8Array(3);
            const view2 = new DataView(header3.buffer);
            view2.setUint8(0, 126);
            view2.setUint16(1, payloadLength);
          } else {
            header3 = new Uint8Array(9);
            const view2 = new DataView(header3.buffer);
            view2.setUint8(0, 127);
            view2.setBigUint64(1, BigInt(payloadLength));
          }
          if (packet.data && typeof packet.data !== "string") {
            header3[0] |= 128;
          }
          controller.enqueue(header3);
          controller.enqueue(encodedPacket);
        });
      }
    });
  }
  exports2.createPacketEncoderStream = createPacketEncoderStream;
  let TEXT_DECODER;
  function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
  }
  function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
      return chunks.shift();
    }
    const buffer2 = new Uint8Array(size);
    let j = 0;
    for (let i2 = 0; i2 < size; i2++) {
      buffer2[i2] = chunks[0][j++];
      if (j === chunks[0].length) {
        chunks.shift();
        j = 0;
      }
    }
    if (chunks.length && j < chunks[0].length) {
      chunks[0] = chunks[0].slice(j);
    }
    return buffer2;
  }
  function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
      TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state2 = 0;
    let expectedLength = -1;
    let isBinary2 = false;
    return new TransformStream({
      transform(chunk, controller) {
        chunks.push(chunk);
        while (true) {
          if (state2 === 0) {
            if (totalLength(chunks) < 1) {
              break;
            }
            const header3 = concatChunks(chunks, 1);
            isBinary2 = (header3[0] & 128) === 128;
            expectedLength = header3[0] & 127;
            if (expectedLength < 126) {
              state2 = 3;
            } else if (expectedLength === 126) {
              state2 = 1;
            } else {
              state2 = 2;
            }
          } else if (state2 === 1) {
            if (totalLength(chunks) < 2) {
              break;
            }
            const headerArray = concatChunks(chunks, 2);
            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
            state2 = 3;
          } else if (state2 === 2) {
            if (totalLength(chunks) < 8) {
              break;
            }
            const headerArray = concatChunks(chunks, 8);
            const view2 = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
            const n = view2.getUint32(0);
            if (n > Math.pow(2, 53 - 32) - 1) {
              controller.enqueue(commons_js_12.ERROR_PACKET);
              break;
            }
            expectedLength = n * Math.pow(2, 32) + view2.getUint32(4);
            state2 = 3;
          } else {
            if (totalLength(chunks) < expectedLength) {
              break;
            }
            const data = concatChunks(chunks, expectedLength);
            controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
            state2 = 0;
          }
          if (expectedLength === 0 || expectedLength > maxPayload) {
            controller.enqueue(commons_js_12.ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  exports2.createPacketDecoderStream = createPacketDecoderStream;
  exports2.protocol = 4;
})(cjs$1);
var parserV3 = {};
/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode;
function ucs2decode(string) {
  var output = [];
  var counter2 = 0;
  var length2 = string.length;
  var value;
  var extra;
  while (counter2 < length2) {
    value = string.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length2) {
      extra = string.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function ucs2encode(array) {
  var length2 = array.length;
  var index2 = -1;
  var value;
  var output = "";
  while (++index2 < length2) {
    value = array[index2];
    if (value > 65535) {
      value -= 65536;
      output += stringFromCharCode(value >>> 10 & 1023 | 55296);
      value = 56320 | value & 1023;
    }
    output += stringFromCharCode(value);
  }
  return output;
}
function checkScalarValue(codePoint, strict) {
  if (codePoint >= 55296 && codePoint <= 57343) {
    if (strict) {
      throw Error("Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value");
    }
    return false;
  }
  return true;
}
function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 63 | 128);
}
function encodeCodePoint(codePoint, strict) {
  if ((codePoint & 4294967168) == 0) {
    return stringFromCharCode(codePoint);
  }
  var symbol = "";
  if ((codePoint & 4294965248) == 0) {
    symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
  } else if ((codePoint & 4294901760) == 0) {
    if (!checkScalarValue(codePoint, strict)) {
      codePoint = 65533;
    }
    symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 4292870144) == 0) {
    symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }
  symbol += stringFromCharCode(codePoint & 63 | 128);
  return symbol;
}
function utf8encode(string, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length2 = codePoints.length;
  var index2 = -1;
  var codePoint;
  var byteString = "";
  while (++index2 < length2) {
    codePoint = codePoints[index2];
    byteString += encodeCodePoint(codePoint, strict);
  }
  return byteString;
}
function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error("Invalid byte index");
  }
  var continuationByte = byteArray[byteIndex] & 255;
  byteIndex++;
  if ((continuationByte & 192) == 128) {
    return continuationByte & 63;
  }
  throw Error("Invalid continuation byte");
}
function decodeSymbol(strict) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;
  if (byteIndex > byteCount) {
    throw Error("Invalid byte index");
  }
  if (byteIndex == byteCount) {
    return false;
  }
  byte1 = byteArray[byteIndex] & 255;
  byteIndex++;
  if ((byte1 & 128) == 0) {
    return byte1;
  }
  if ((byte1 & 224) == 192) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 31) << 6 | byte2;
    if (codePoint >= 128) {
      return codePoint;
    } else {
      throw Error("Invalid continuation byte");
    }
  }
  if ((byte1 & 240) == 224) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
    if (codePoint >= 2048) {
      return checkScalarValue(codePoint, strict) ? codePoint : 65533;
    } else {
      throw Error("Invalid continuation byte");
    }
  }
  if ((byte1 & 248) == 240) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
    if (codePoint >= 65536 && codePoint <= 1114111) {
      return codePoint;
    }
  }
  throw Error("Invalid UTF-8 detected");
}
var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;
  while ((tmp = decodeSymbol(strict)) !== false) {
    codePoints.push(tmp);
  }
  return ucs2encode(codePoints);
}
var utf8 = {
  version: "2.1.2",
  encode: utf8encode,
  decode: utf8decode
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.decodePayloadAsBinary = exports2.encodePayloadAsBinary = exports2.decodePayload = exports2.encodePayload = exports2.decodeBase64Packet = exports2.decodePacket = exports2.encodeBase64Packet = exports2.encodePacket = exports2.packets = exports2.protocol = void 0;
  var utf8$1 = utf8;
  exports2.protocol = 3;
  const hasBinary2 = (packets) => {
    for (const packet of packets) {
      if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return true;
      }
    }
    return false;
  };
  exports2.packets = {
    open: 0,
    close: 1,
    ping: 2,
    pong: 3,
    message: 4,
    upgrade: 5,
    noop: 6
  };
  var packetslist = Object.keys(exports2.packets);
  var err = { type: "error", data: "parser error" };
  const EMPTY_BUFFER2 = Buffer.concat([]);
  function encodePacket2(packet, supportsBinary, utf8encode2, callback) {
    if (typeof supportsBinary === "function") {
      callback = supportsBinary;
      supportsBinary = null;
    }
    if (typeof utf8encode2 === "function") {
      callback = utf8encode2;
      utf8encode2 = null;
    }
    if (Buffer.isBuffer(packet.data)) {
      return encodeBuffer(packet, supportsBinary, callback);
    } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
      return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
    }
    var encoded = exports2.packets[packet.type];
    if (void 0 !== packet.data) {
      encoded += utf8encode2 ? utf8$1.encode(String(packet.data), { strict: false }) : String(packet.data);
    }
    return callback("" + encoded);
  }
  exports2.encodePacket = encodePacket2;
  function encodeBuffer(packet, supportsBinary, callback) {
    if (!supportsBinary) {
      return encodeBase64Packet(packet, callback);
    }
    var data = packet.data;
    var typeBuffer = Buffer.allocUnsafe(1);
    typeBuffer[0] = exports2.packets[packet.type];
    return callback(Buffer.concat([typeBuffer, data]));
  }
  function encodeBase64Packet(packet, callback) {
    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
    var message = "b" + exports2.packets[packet.type];
    message += data.toString("base64");
    return callback(message);
  }
  exports2.encodeBase64Packet = encodeBase64Packet;
  function decodePacket2(data, binaryType, utf8decode2) {
    if (data === void 0) {
      return err;
    }
    var type3;
    if (typeof data === "string") {
      type3 = data.charAt(0);
      if (type3 === "b") {
        return decodeBase64Packet2(data.slice(1), binaryType);
      }
      if (utf8decode2) {
        data = tryDecode2(data);
        if (data === false) {
          return err;
        }
      }
      if (Number(type3) != type3 || !packetslist[type3]) {
        return err;
      }
      if (data.length > 1) {
        return { type: packetslist[type3], data: data.slice(1) };
      } else {
        return { type: packetslist[type3] };
      }
    }
    if (binaryType === "arraybuffer") {
      var intArray = new Uint8Array(data);
      type3 = intArray[0];
      return { type: packetslist[type3], data: intArray.buffer.slice(1) };
    }
    if (data instanceof ArrayBuffer) {
      data = arrayBufferToBuffer(data);
    }
    type3 = data[0];
    return { type: packetslist[type3], data: data.slice(1) };
  }
  exports2.decodePacket = decodePacket2;
  function tryDecode2(data) {
    try {
      data = utf8$1.decode(data, { strict: false });
    } catch (e) {
      return false;
    }
    return data;
  }
  function decodeBase64Packet2(msg, binaryType) {
    var type3 = packetslist[msg.charAt(0)];
    var data = Buffer.from(msg.slice(1), "base64");
    if (binaryType === "arraybuffer") {
      var abv = new Uint8Array(data.length);
      for (var i2 = 0; i2 < abv.length; i2++) {
        abv[i2] = data[i2];
      }
      data = abv.buffer;
    }
    return { type: type3, data };
  }
  exports2.decodeBase64Packet = decodeBase64Packet2;
  function encodePayload(packets, supportsBinary, callback) {
    if (typeof supportsBinary === "function") {
      callback = supportsBinary;
      supportsBinary = null;
    }
    if (supportsBinary && hasBinary2(packets)) {
      return encodePayloadAsBinary(packets, callback);
    }
    if (!packets.length) {
      return callback("0:");
    }
    function encodeOne(packet, doneCallback) {
      encodePacket2(packet, supportsBinary, false, function(message) {
        doneCallback(null, setLengthHeader(message));
      });
    }
    map2(packets, encodeOne, function(err2, results) {
      return callback(results.join(""));
    });
  }
  exports2.encodePayload = encodePayload;
  function setLengthHeader(message) {
    return message.length + ":" + message;
  }
  function map2(ary, each, done2) {
    const results = new Array(ary.length);
    let count = 0;
    for (let i2 = 0; i2 < ary.length; i2++) {
      each(ary[i2], (error3, msg) => {
        results[i2] = msg;
        if (++count === ary.length) {
          done2(null, results);
        }
      });
    }
  }
  function decodePayload(data, binaryType, callback) {
    if (typeof data !== "string") {
      return decodePayloadAsBinary(data, binaryType, callback);
    }
    if (typeof binaryType === "function") {
      callback = binaryType;
      binaryType = null;
    }
    if (data === "") {
      return callback(err, 0, 1);
    }
    var length2 = "", n, msg, packet;
    for (var i2 = 0, l = data.length; i2 < l; i2++) {
      var chr = data.charAt(i2);
      if (chr !== ":") {
        length2 += chr;
        continue;
      }
      if (length2 === "" || length2 != (n = Number(length2))) {
        return callback(err, 0, 1);
      }
      msg = data.slice(i2 + 1, i2 + 1 + n);
      if (length2 != msg.length) {
        return callback(err, 0, 1);
      }
      if (msg.length) {
        packet = decodePacket2(msg, binaryType, false);
        if (err.type === packet.type && err.data === packet.data) {
          return callback(err, 0, 1);
        }
        var more = callback(packet, i2 + n, l);
        if (false === more)
          return;
      }
      i2 += n;
      length2 = "";
    }
    if (length2 !== "") {
      return callback(err, 0, 1);
    }
  }
  exports2.decodePayload = decodePayload;
  function bufferToString(buffer2) {
    var str = "";
    for (var i2 = 0, l = buffer2.length; i2 < l; i2++) {
      str += String.fromCharCode(buffer2[i2]);
    }
    return str;
  }
  function stringToBuffer(string) {
    var buf = Buffer.allocUnsafe(string.length);
    for (var i2 = 0, l = string.length; i2 < l; i2++) {
      buf.writeUInt8(string.charCodeAt(i2), i2);
    }
    return buf;
  }
  function arrayBufferToBuffer(data) {
    var length2 = data.byteLength || data.length;
    var offset = data.byteOffset || 0;
    return Buffer.from(data.buffer || data, offset, length2);
  }
  function encodePayloadAsBinary(packets, callback) {
    if (!packets.length) {
      return callback(EMPTY_BUFFER2);
    }
    map2(packets, encodeOneBinaryPacket, function(err2, results) {
      return callback(Buffer.concat(results));
    });
  }
  exports2.encodePayloadAsBinary = encodePayloadAsBinary;
  function encodeOneBinaryPacket(p, doneCallback) {
    function onBinaryPacketEncode(packet) {
      var encodingLength = "" + packet.length;
      var sizeBuffer;
      if (typeof packet === "string") {
        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
        sizeBuffer[0] = 0;
        for (var i2 = 0; i2 < encodingLength.length; i2++) {
          sizeBuffer[i2 + 1] = parseInt(encodingLength[i2], 10);
        }
        sizeBuffer[sizeBuffer.length - 1] = 255;
        return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
      }
      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
      sizeBuffer[0] = 1;
      for (var i2 = 0; i2 < encodingLength.length; i2++) {
        sizeBuffer[i2 + 1] = parseInt(encodingLength[i2], 10);
      }
      sizeBuffer[sizeBuffer.length - 1] = 255;
      doneCallback(null, Buffer.concat([sizeBuffer, packet]));
    }
    encodePacket2(p, true, true, onBinaryPacketEncode);
  }
  function decodePayloadAsBinary(data, binaryType, callback) {
    if (typeof binaryType === "function") {
      callback = binaryType;
      binaryType = null;
    }
    var bufferTail = data;
    var buffers = [];
    var i2;
    while (bufferTail.length > 0) {
      var strLen = "";
      var isString2 = bufferTail[0] === 0;
      for (i2 = 1; ; i2++) {
        if (bufferTail[i2] === 255)
          break;
        if (strLen.length > 310) {
          return callback(err, 0, 1);
        }
        strLen += "" + bufferTail[i2];
      }
      bufferTail = bufferTail.slice(strLen.length + 1);
      var msgLength = parseInt(strLen, 10);
      var msg = bufferTail.slice(1, msgLength + 1);
      if (isString2)
        msg = bufferToString(msg);
      buffers.push(msg);
      bufferTail = bufferTail.slice(msgLength + 1);
    }
    var total = buffers.length;
    for (i2 = 0; i2 < total; i2++) {
      var buffer2 = buffers[i2];
      callback(decodePacket2(buffer2, binaryType, true), i2, total);
    }
  }
  exports2.decodePayloadAsBinary = decodePayloadAsBinary;
})(parserV3);
var browser$2 = { exports: {} };
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms$1;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options2.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy2;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace2) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace2.length; i2++) {
      hash = (hash << 5) - hash + namespace2.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
        if (match2 === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index2];
          match2 = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match2;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace2;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace2);
    debug2.extend = extend2;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace2);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace2, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split2.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split2[i2]) {
        continue;
      }
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$1 = setup;
(function(module, exports2) {
  var define_process_env_default2 = {};
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index2 = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match2) => {
      if (match2 === "%%") {
        return;
      }
      index2++;
      if (match2 === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error3) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error3) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = define_process_env_default2.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error3) {
    }
  }
  module.exports = common$1(exports2);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error3) {
      return "[UnexpectedJSONParseError]: " + error3.message;
    }
  };
})(browser$2, browser$2.exports);
var browserExports = browser$2.exports;
Object.defineProperty(transport, "__esModule", { value: true });
transport.Transport = void 0;
const events_1$4 = require$$2$2;
const parser_v4 = cjs$1;
const parser_v3 = parserV3;
const debug_1$b = browserExports;
const debug$d = (0, debug_1$b.default)("engine:transport");
function noop$3() {
}
class Transport extends events_1$4.EventEmitter {
  /**
   * Transport constructor.
   *
   * @param {http.IncomingMessage} req
   * @api public
   */
  constructor(req2) {
    super();
    this.writable = false;
    this._readyState = "open";
    this.discarded = false;
    this.protocol = req2._query.EIO === "4" ? 4 : 3;
    this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
    this.supportsBinary = !(req2._query && req2._query.b64);
  }
  get readyState() {
    return this._readyState;
  }
  set readyState(state2) {
    debug$d("readyState updated from %s to %s (%s)", this._readyState, state2, this.name);
    this._readyState = state2;
  }
  /**
   * Flags the transport as discarded.
   *
   * @api private
   */
  discard() {
    this.discarded = true;
  }
  /**
   * Called with an incoming HTTP request.
   *
   * @param {http.IncomingMessage} req
   * @api protected
   */
  onRequest(req2) {
    debug$d("setting request");
    this.req = req2;
  }
  /**
   * Closes the transport.
   *
   * @api private
   */
  close(fn) {
    if ("closed" === this.readyState || "closing" === this.readyState)
      return;
    this.readyState = "closing";
    this.doClose(fn || noop$3);
  }
  /**
   * Called with a transport error.
   *
   * @param {String} msg - message error
   * @param {Object} desc - error description
   * @api protected
   */
  onError(msg, desc) {
    if (this.listeners("error").length) {
      const err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
    } else {
      debug$d("ignored transport error %s (%s)", msg, desc);
    }
  }
  /**
   * Called with parsed out a packets from the data stream.
   *
   * @param {Object} packet
   * @api protected
   */
  onPacket(packet) {
    this.emit("packet", packet);
  }
  /**
   * Called with the encoded packet data.
   *
   * @param {String} data
   * @api protected
   */
  onData(data) {
    this.onPacket(this.parser.decodePacket(data));
  }
  /**
   * Called upon transport close.
   *
   * @api protected
   */
  onClose() {
    this.readyState = "closed";
    this.emit("close");
  }
}
transport.Transport = Transport;
Object.defineProperty(polling$2, "__esModule", { value: true });
polling$2.Polling = void 0;
const transport_1$4 = transport;
const zlib_1$1 = require$$2$2;
const accepts$1 = accepts$3;
const debug_1$a = browserExports;
const debug$c = (0, debug_1$a.default)("engine:polling");
const compressionMethods$1 = {
  gzip: zlib_1$1.createGzip,
  deflate: zlib_1$1.createDeflate
};
let Polling$1 = class Polling extends transport_1$4.Transport {
  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  constructor(req2) {
    super(req2);
    this.closeTimeout = 30 * 1e3;
  }
  /**
   * Transport name
   *
   * @api public
   */
  get name() {
    return "polling";
  }
  get supportsFraming() {
    return false;
  }
  /**
   * Overrides onRequest.
   *
   * @param {http.IncomingMessage}
   * @api private
   */
  onRequest(req2) {
    const res2 = req2.res;
    req2.res = null;
    if ("GET" === req2.method) {
      this.onPollRequest(req2, res2);
    } else if ("POST" === req2.method) {
      this.onDataRequest(req2, res2);
    } else {
      res2.writeHead(500);
      res2.end();
    }
  }
  /**
   * The client sends a request awaiting for us to send data.
   *
   * @api private
   */
  onPollRequest(req2, res2) {
    if (this.req) {
      debug$c("request overlap");
      this.onError("overlap from client");
      res2.writeHead(400);
      res2.end();
      return;
    }
    debug$c("setting request");
    this.req = req2;
    this.res = res2;
    const onClose = () => {
      this.onError("poll connection closed prematurely");
    };
    const cleanup = () => {
      req2.removeListener("close", onClose);
      this.req = this.res = null;
    };
    req2.cleanup = cleanup;
    req2.on("close", onClose);
    this.writable = true;
    this.emit("drain");
    if (this.writable && this.shouldClose) {
      debug$c("triggering empty send to append close packet");
      this.send([{ type: "noop" }]);
    }
  }
  /**
   * The client sends a request with data.
   *
   * @api private
   */
  onDataRequest(req2, res2) {
    if (this.dataReq) {
      this.onError("data request overlap from client");
      res2.writeHead(400);
      res2.end();
      return;
    }
    const isBinary2 = "application/octet-stream" === req2.headers["content-type"];
    if (isBinary2 && this.protocol === 4) {
      return this.onError("invalid content");
    }
    this.dataReq = req2;
    this.dataRes = res2;
    let chunks = isBinary2 ? Buffer.concat([]) : "";
    const cleanup = () => {
      req2.removeListener("data", onData);
      req2.removeListener("end", onEnd);
      req2.removeListener("close", onClose);
      this.dataReq = this.dataRes = chunks = null;
    };
    const onClose = () => {
      cleanup();
      this.onError("data request connection closed prematurely");
    };
    const onData = (data) => {
      let contentLength;
      if (isBinary2) {
        chunks = Buffer.concat([chunks, data]);
        contentLength = chunks.length;
      } else {
        chunks += data;
        contentLength = Buffer.byteLength(chunks);
      }
      if (contentLength > this.maxHttpBufferSize) {
        res2.writeHead(413).end();
        cleanup();
      }
    };
    const onEnd = () => {
      this.onData(chunks);
      const headers = {
        // text/html is required instead of text/plain to avoid an
        // unwanted download dialog on certain user-agents (GH-43)
        "Content-Type": "text/html",
        "Content-Length": 2
      };
      res2.writeHead(200, this.headers(req2, headers));
      res2.end("ok");
      cleanup();
    };
    req2.on("close", onClose);
    if (!isBinary2)
      req2.setEncoding("utf8");
    req2.on("data", onData);
    req2.on("end", onEnd);
  }
  /**
   * Processes the incoming data payload.
   *
   * @param {String} encoded payload
   * @api private
   */
  onData(data) {
    debug$c('received "%s"', data);
    const callback = (packet) => {
      if ("close" === packet.type) {
        debug$c("got xhr close packet");
        this.onClose();
        return false;
      }
      this.onPacket(packet);
    };
    if (this.protocol === 3) {
      this.parser.decodePayload(data, callback);
    } else {
      this.parser.decodePayload(data).forEach(callback);
    }
  }
  /**
   * Overrides onClose.
   *
   * @api private
   */
  onClose() {
    if (this.writable) {
      this.send([{ type: "noop" }]);
    }
    super.onClose();
  }
  /**
   * Writes a packet payload.
   *
   * @param {Object} packet
   * @api private
   */
  send(packets) {
    this.writable = false;
    if (this.shouldClose) {
      debug$c("appending close packet to payload");
      packets.push({ type: "close" });
      this.shouldClose();
      this.shouldClose = null;
    }
    const doWrite = (data) => {
      const compress = packets.some((packet) => {
        return packet.options && packet.options.compress;
      });
      this.write(data, { compress });
    };
    if (this.protocol === 3) {
      this.parser.encodePayload(packets, this.supportsBinary, doWrite);
    } else {
      this.parser.encodePayload(packets, doWrite);
    }
  }
  /**
   * Writes data as response to poll request.
   *
   * @param {String} data
   * @param {Object} options
   * @api private
   */
  write(data, options2) {
    debug$c('writing "%s"', data);
    this.doWrite(data, options2, () => {
      this.req.cleanup();
    });
  }
  /**
   * Performs the write.
   *
   * @api private
   */
  doWrite(data, options2, callback) {
    const isString2 = typeof data === "string";
    const contentType3 = isString2 ? "text/plain; charset=UTF-8" : "application/octet-stream";
    const headers = {
      "Content-Type": contentType3
    };
    const respond = (data2) => {
      headers["Content-Length"] = "string" === typeof data2 ? Buffer.byteLength(data2) : data2.length;
      this.res.writeHead(200, this.headers(this.req, headers));
      this.res.end(data2);
      callback();
    };
    if (!this.httpCompression || !options2.compress) {
      respond(data);
      return;
    }
    const len = isString2 ? Buffer.byteLength(data) : data.length;
    if (len < this.httpCompression.threshold) {
      respond(data);
      return;
    }
    const encoding3 = accepts$1(this.req).encodings(["gzip", "deflate"]);
    if (!encoding3) {
      respond(data);
      return;
    }
    this.compress(data, encoding3, (err, data2) => {
      if (err) {
        this.res.writeHead(500);
        this.res.end();
        callback(err);
        return;
      }
      headers["Content-Encoding"] = encoding3;
      respond(data2);
    });
  }
  /**
   * Compresses data.
   *
   * @api private
   */
  compress(data, encoding3, callback) {
    debug$c("compressing");
    const buffers = [];
    let nread = 0;
    compressionMethods$1[encoding3](this.httpCompression).on("error", callback).on("data", function(chunk) {
      buffers.push(chunk);
      nread += chunk.length;
    }).on("end", function() {
      callback(null, Buffer.concat(buffers, nread));
    }).end(data);
  }
  /**
   * Closes the transport.
   *
   * @api private
   */
  doClose(fn) {
    debug$c("closing");
    let closeTimeoutTimer;
    if (this.dataReq) {
      debug$c("aborting ongoing data request");
      this.dataReq.destroy();
    }
    const onClose = () => {
      clearTimeout(closeTimeoutTimer);
      fn();
      this.onClose();
    };
    if (this.writable) {
      debug$c("transport writable - closing right away");
      this.send([{ type: "close" }]);
      onClose();
    } else if (this.discarded) {
      debug$c("transport discarded - closing right away");
      onClose();
    } else {
      debug$c("transport not writable - buffering orderly close");
      this.shouldClose = onClose;
      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
    }
  }
  /**
   * Returns headers for a response.
   *
   * @param {http.IncomingMessage} request
   * @param {Object} extra headers
   * @api private
   */
  headers(req2, headers) {
    headers = headers || {};
    const ua = req2.headers["user-agent"];
    if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
      headers["X-XSS-Protection"] = "0";
    }
    headers["cache-control"] = "no-store";
    this.emit("headers", headers, req2);
    return headers;
  }
};
polling$2.Polling = Polling$1;
var pollingJsonp = {};
Object.defineProperty(pollingJsonp, "__esModule", { value: true });
pollingJsonp.JSONP = void 0;
const polling_1$2 = polling$2;
const qs$1 = require$$2$2;
const rDoubleSlashes = /\\\\n/g;
const rSlashes = /(\\)?\\n/g;
class JSONP extends polling_1$2.Polling {
  /**
   * JSON-P polling transport.
   *
   * @api public
   */
  constructor(req2) {
    super(req2);
    this.head = "___eio[" + (req2._query.j || "").replace(/[^0-9]/g, "") + "](";
    this.foot = ");";
  }
  /**
   * Handles incoming data.
   * Due to a bug in \n handling by browsers, we expect a escaped string.
   *
   * @api private
   */
  onData(data) {
    data = qs$1.parse(data).d;
    if ("string" === typeof data) {
      data = data.replace(rSlashes, function(match2, slashes) {
        return slashes ? match2 : "\n";
      });
      super.onData(data.replace(rDoubleSlashes, "\\n"));
    }
  }
  /**
   * Performs the write.
   *
   * @api private
   */
  doWrite(data, options2, callback) {
    const js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    data = this.head + js + this.foot;
    super.doWrite(data, options2, callback);
  }
}
pollingJsonp.JSONP = JSONP;
var websocket$2 = {};
Object.defineProperty(websocket$2, "__esModule", { value: true });
websocket$2.WebSocket = void 0;
const transport_1$3 = transport;
const debug_1$9 = browserExports;
const debug$b = (0, debug_1$9.default)("engine:ws");
let WebSocket$5 = class WebSocket extends transport_1$3.Transport {
  /**
   * WebSocket transport
   *
   * @param {http.IncomingMessage}
   * @api public
   */
  constructor(req2) {
    super(req2);
    this.socket = req2.websocket;
    this.socket.on("message", (data, isBinary2) => {
      const message = isBinary2 ? data : data.toString();
      debug$b('received "%s"', message);
      super.onData(message);
    });
    this.socket.once("close", this.onClose.bind(this));
    this.socket.on("error", this.onError.bind(this));
    this.writable = true;
    this.perMessageDeflate = null;
  }
  /**
   * Transport name
   *
   * @api public
   */
  get name() {
    return "websocket";
  }
  /**
   * Advertise upgrade support.
   *
   * @api public
   */
  get handlesUpgrades() {
    return true;
  }
  /**
   * Advertise framing support.
   *
   * @api public
   */
  get supportsFraming() {
    return true;
  }
  /**
   * Writes a packet payload.
   *
   * @param {Array} packets
   * @api private
   */
  send(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const isLast = i2 + 1 === packets.length;
      const opts = {};
      if (packet.options) {
        opts.compress = packet.options.compress;
      }
      const onSent = (err) => {
        if (err) {
          return this.onError("write error", err.stack);
        } else if (isLast) {
          this.writable = true;
          this.emit("drain");
        }
      };
      const send4 = (data) => {
        if (this.perMessageDeflate) {
          const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
          if (len < this.perMessageDeflate.threshold) {
            opts.compress = false;
          }
        }
        debug$b('writing "%s"', data);
        this.socket.send(data, opts, onSent);
      };
      if (packet.options && typeof packet.options.wsPreEncoded === "string") {
        send4(packet.options.wsPreEncoded);
      } else if (this._canSendPreEncodedFrame(packet)) {
        this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, onSent);
      } else {
        this.parser.encodePacket(packet, this.supportsBinary, send4);
      }
    }
  }
  /**
   * Whether the encoding of the WebSocket frame can be skipped.
   * @param packet
   * @private
   */
  _canSendPreEncodedFrame(packet) {
    var _a2, _b, _c;
    return !this.perMessageDeflate && typeof ((_b = (_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === "function" && ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== void 0;
  }
  /**
   * Closes the transport.
   *
   * @api private
   */
  doClose(fn) {
    debug$b("closing");
    this.socket.close();
    fn && fn();
  }
};
websocket$2.WebSocket = WebSocket$5;
var webtransport = {};
Object.defineProperty(webtransport, "__esModule", { value: true });
webtransport.WebTransport = void 0;
const transport_1$2 = transport;
const debug_1$8 = browserExports;
const engine_io_parser_1$1 = cjs$1;
const debug$a = (0, debug_1$8.default)("engine:webtransport");
class WebTransport extends transport_1$2.Transport {
  constructor(session, stream3, reader) {
    super({ _query: { EIO: "4" } });
    this.session = session;
    const transformStream = (0, engine_io_parser_1$1.createPacketEncoderStream)();
    transformStream.readable.pipeTo(stream3.writable).catch(() => {
      debug$a("the stream was closed");
    });
    this.writer = transformStream.writable.getWriter();
    (async () => {
      try {
        while (true) {
          const { value, done: done2 } = await reader.read();
          if (done2) {
            debug$a("session is closed");
            break;
          }
          debug$a("received chunk: %o", value);
          this.onPacket(value);
        }
      } catch (e) {
        debug$a("error while reading: %s", e.message);
      }
    })();
    session.closed.then(() => this.onClose());
    this.writable = true;
  }
  get name() {
    return "webtransport";
  }
  get supportsFraming() {
    return true;
  }
  async send(packets) {
    this.writable = false;
    try {
      for (let i2 = 0; i2 < packets.length; i2++) {
        const packet = packets[i2];
        await this.writer.write(packet);
      }
    } catch (e) {
      debug$a("error while writing: %s", e.message);
    }
    this.writable = true;
    this.emit("drain");
  }
  doClose(fn) {
    debug$a("closing WebTransport session");
    this.session.close();
    fn && fn();
  }
}
webtransport.WebTransport = WebTransport;
Object.defineProperty(transports, "__esModule", { value: true });
const polling_1$1 = polling$2;
const polling_jsonp_1 = pollingJsonp;
const websocket_1$1 = websocket$2;
const webtransport_1$1 = webtransport;
transports.default = {
  polling: polling$1,
  websocket: websocket_1$1.WebSocket,
  webtransport: webtransport_1$1.WebTransport
};
function polling$1(req2) {
  if ("string" === typeof req2._query.j) {
    return new polling_jsonp_1.JSONP(req2);
  } else {
    return new polling_1$1.Polling(req2);
  }
}
polling$1.upgradesTo = ["websocket", "webtransport"];
var socket$1 = {};
Object.defineProperty(socket$1, "__esModule", { value: true });
socket$1.Socket = void 0;
const events_1$3 = require$$2$2;
const debug_1$7 = browserExports;
const timers_1 = require$$2$2;
const debug$9 = (0, debug_1$7.default)("engine:socket");
let Socket$1 = class Socket extends events_1$3.EventEmitter {
  /**
   * Client class (abstract).
   *
   * @api private
   */
  constructor(id, server2, transport2, req2, protocol2) {
    super();
    this._readyState = "opening";
    this.upgrading = false;
    this.upgraded = false;
    this.writeBuffer = [];
    this.packetsFn = [];
    this.sentCallbackFn = [];
    this.cleanupFn = [];
    this.id = id;
    this.server = server2;
    this.request = req2;
    this.protocol = protocol2;
    if (req2) {
      if (req2.websocket && req2.websocket._socket) {
        this.remoteAddress = req2.websocket._socket.remoteAddress;
      } else {
        this.remoteAddress = req2.connection.remoteAddress;
      }
    }
    this.pingTimeoutTimer = null;
    this.pingIntervalTimer = null;
    this.setTransport(transport2);
    this.onOpen();
  }
  get readyState() {
    return this._readyState;
  }
  set readyState(state2) {
    debug$9("readyState updated from %s to %s", this._readyState, state2);
    this._readyState = state2;
  }
  /**
   * Called upon transport considered open.
   *
   * @api private
   */
  onOpen() {
    this.readyState = "open";
    this.transport.sid = this.id;
    this.sendPacket("open", JSON.stringify({
      sid: this.id,
      upgrades: this.getAvailableUpgrades(),
      pingInterval: this.server.opts.pingInterval,
      pingTimeout: this.server.opts.pingTimeout,
      maxPayload: this.server.opts.maxHttpBufferSize
    }));
    if (this.server.opts.initialPacket) {
      this.sendPacket("message", this.server.opts.initialPacket);
    }
    this.emit("open");
    if (this.protocol === 3) {
      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
    } else {
      this.schedulePing();
    }
  }
  /**
   * Called upon transport packet.
   *
   * @param {Object} packet
   * @api private
   */
  onPacket(packet) {
    if ("open" !== this.readyState) {
      return debug$9("packet received with closed socket");
    }
    debug$9(`received packet ${packet.type}`);
    this.emit("packet", packet);
    this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
    switch (packet.type) {
      case "ping":
        if (this.transport.protocol !== 3) {
          this.onError("invalid heartbeat direction");
          return;
        }
        debug$9("got ping");
        this.sendPacket("pong");
        this.emit("heartbeat");
        break;
      case "pong":
        if (this.transport.protocol === 3) {
          this.onError("invalid heartbeat direction");
          return;
        }
        debug$9("got pong");
        this.pingIntervalTimer.refresh();
        this.emit("heartbeat");
        break;
      case "error":
        this.onClose("parse error");
        break;
      case "message":
        this.emit("data", packet.data);
        this.emit("message", packet.data);
        break;
    }
  }
  /**
   * Called upon transport error.
   *
   * @param {Error} err - error object
   * @api private
   */
  onError(err) {
    debug$9("transport error");
    this.onClose("transport error", err);
  }
  /**
   * Pings client every `this.pingInterval` and expects response
   * within `this.pingTimeout` or closes connection.
   *
   * @api private
   */
  schedulePing() {
    this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
      debug$9("writing ping packet - expecting pong within %sms", this.server.opts.pingTimeout);
      this.sendPacket("ping");
      this.resetPingTimeout(this.server.opts.pingTimeout);
    }, this.server.opts.pingInterval);
  }
  /**
   * Resets ping timeout.
   *
   * @api private
   */
  resetPingTimeout(timeout) {
    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {
      if (this.readyState === "closed")
        return;
      this.onClose("ping timeout");
    }, timeout);
  }
  /**
   * Attaches handlers for the given transport.
   *
   * @param {Transport} transport
   * @api private
   */
  setTransport(transport2) {
    const onError = this.onError.bind(this);
    const onPacket = this.onPacket.bind(this);
    const flush = this.flush.bind(this);
    const onClose = this.onClose.bind(this, "transport close");
    this.transport = transport2;
    this.transport.once("error", onError);
    this.transport.on("packet", onPacket);
    this.transport.on("drain", flush);
    this.transport.once("close", onClose);
    this.setupSendCallback();
    this.cleanupFn.push(function() {
      transport2.removeListener("error", onError);
      transport2.removeListener("packet", onPacket);
      transport2.removeListener("drain", flush);
      transport2.removeListener("close", onClose);
    });
  }
  /**
   * Upgrades socket to the given transport
   *
   * @param {Transport} transport
   * @api private
   */
  maybeUpgrade(transport2) {
    debug$9('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport2.name);
    this.upgrading = true;
    const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
      debug$9("client did not complete upgrade - closing transport");
      cleanup();
      if ("open" === transport2.readyState) {
        transport2.close();
      }
    }, this.server.opts.upgradeTimeout);
    let checkIntervalTimer;
    const onPacket = (packet) => {
      if ("ping" === packet.type && "probe" === packet.data) {
        debug$9("got probe ping packet, sending pong");
        transport2.send([{ type: "pong", data: "probe" }]);
        this.emit("upgrading", transport2);
        clearInterval(checkIntervalTimer);
        checkIntervalTimer = setInterval(check, 100);
      } else if ("upgrade" === packet.type && this.readyState !== "closed") {
        debug$9("got upgrade packet - upgrading");
        cleanup();
        this.transport.discard();
        this.upgraded = true;
        this.clearTransport();
        this.setTransport(transport2);
        this.emit("upgrade", transport2);
        this.flush();
        if (this.readyState === "closing") {
          transport2.close(() => {
            this.onClose("forced close");
          });
        }
      } else {
        cleanup();
        transport2.close();
      }
    };
    const check = () => {
      if ("polling" === this.transport.name && this.transport.writable) {
        debug$9("writing a noop packet to polling for fast upgrade");
        this.transport.send([{ type: "noop" }]);
      }
    };
    const cleanup = () => {
      this.upgrading = false;
      clearInterval(checkIntervalTimer);
      (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
      transport2.removeListener("packet", onPacket);
      transport2.removeListener("close", onTransportClose);
      transport2.removeListener("error", onError);
      this.removeListener("close", onClose);
    };
    const onError = (err) => {
      debug$9("client did not complete upgrade - %s", err);
      cleanup();
      transport2.close();
      transport2 = null;
    };
    const onTransportClose = () => {
      onError("transport closed");
    };
    const onClose = () => {
      onError("socket closed");
    };
    transport2.on("packet", onPacket);
    transport2.once("close", onTransportClose);
    transport2.once("error", onError);
    this.once("close", onClose);
  }
  /**
   * Clears listeners and timers associated with current transport.
   *
   * @api private
   */
  clearTransport() {
    let cleanup;
    const toCleanUp = this.cleanupFn.length;
    for (let i2 = 0; i2 < toCleanUp; i2++) {
      cleanup = this.cleanupFn.shift();
      cleanup();
    }
    this.transport.on("error", function() {
      debug$9("error triggered by discarded transport");
    });
    this.transport.close();
    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
  }
  /**
   * Called upon transport considered closed.
   * Possible reasons: `ping timeout`, `client error`, `parse error`,
   * `transport error`, `server close`, `transport close`
   */
  onClose(reason, description2) {
    if ("closed" !== this.readyState) {
      this.readyState = "closed";
      (0, timers_1.clearTimeout)(this.pingIntervalTimer);
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      process.nextTick(() => {
        this.writeBuffer = [];
      });
      this.packetsFn = [];
      this.sentCallbackFn = [];
      this.clearTransport();
      this.emit("close", reason, description2);
    }
  }
  /**
   * Setup and manage send callback
   *
   * @api private
   */
  setupSendCallback() {
    const onDrain = () => {
      if (this.sentCallbackFn.length > 0) {
        const seqFn = this.sentCallbackFn.splice(0, 1)[0];
        if ("function" === typeof seqFn) {
          debug$9("executing send callback");
          seqFn(this.transport);
        } else if (Array.isArray(seqFn)) {
          debug$9("executing batch send callback");
          const l = seqFn.length;
          let i2 = 0;
          for (; i2 < l; i2++) {
            if ("function" === typeof seqFn[i2]) {
              seqFn[i2](this.transport);
            }
          }
        }
      }
    };
    this.transport.on("drain", onDrain);
    this.cleanupFn.push(() => {
      this.transport.removeListener("drain", onDrain);
    });
  }
  /**
   * Sends a message packet.
   *
   * @param {Object} data
   * @param {Object} options
   * @param {Function} callback
   * @return {Socket} for chaining
   * @api public
   */
  send(data, options2, callback) {
    this.sendPacket("message", data, options2, callback);
    return this;
  }
  /**
   * Alias of {@link send}.
   *
   * @param data
   * @param options
   * @param callback
   */
  write(data, options2, callback) {
    this.sendPacket("message", data, options2, callback);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type - packet type
   * @param {String} data
   * @param {Object} options
   * @param {Function} callback
   *
   * @api private
   */
  sendPacket(type3, data, options2 = {}, callback) {
    if ("function" === typeof options2) {
      callback = options2;
      options2 = {};
    }
    if ("closing" !== this.readyState && "closed" !== this.readyState) {
      debug$9('sending packet "%s" (%s)', type3, data);
      options2.compress = options2.compress !== false;
      const packet = {
        type: type3,
        options: options2
      };
      if (data)
        packet.data = data;
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (callback)
        this.packetsFn.push(callback);
      this.flush();
    }
  }
  /**
   * Attempts to flush the packets buffer.
   *
   * @api private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
      debug$9("flushing buffer to transport");
      this.emit("flush", this.writeBuffer);
      this.server.emit("flush", this, this.writeBuffer);
      const wbuf = this.writeBuffer;
      this.writeBuffer = [];
      if (!this.transport.supportsFraming) {
        this.sentCallbackFn.push(this.packetsFn);
      } else {
        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
      }
      this.packetsFn = [];
      this.transport.send(wbuf);
      this.emit("drain");
      this.server.emit("drain", this);
    }
  }
  /**
   * Get available upgrades for this socket.
   *
   * @api private
   */
  getAvailableUpgrades() {
    const availableUpgrades = [];
    const allUpgrades = this.server.upgrades(this.transport.name);
    let i2 = 0;
    const l = allUpgrades.length;
    for (; i2 < l; ++i2) {
      const upg = allUpgrades[i2];
      if (this.server.opts.transports.indexOf(upg) !== -1) {
        availableUpgrades.push(upg);
      }
    }
    return availableUpgrades;
  }
  /**
   * Closes the socket and underlying transport.
   *
   * @param {Boolean} discard - optional, discard the transport
   * @return {Socket} for chaining
   * @api public
   */
  close(discard) {
    if ("open" !== this.readyState)
      return;
    this.readyState = "closing";
    if (this.writeBuffer.length) {
      debug$9("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
      this.once("drain", () => {
        debug$9("all packets have been sent, closing the transport");
        this.closeTransport(discard);
      });
      return;
    }
    debug$9("the buffer is empty, closing the transport right away", discard);
    this.closeTransport(discard);
  }
  /**
   * Closes the underlying transport.
   *
   * @param {Boolean} discard
   * @api private
   */
  closeTransport(discard) {
    debug$9("closing the transport (discard? %s)", discard);
    if (discard)
      this.transport.discard();
    this.transport.close(this.onClose.bind(this, "forced close"));
  }
};
socket$1.Socket = Socket$1;
var cookie$2 = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie$2.parse = parse$b;
cookie$2.serialize = serialize$1;
var decode$4 = decodeURIComponent;
var encode$2 = encodeURIComponent;
var fieldContentRegExp$1 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$b(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var pairs = str.split(";");
  var dec = opt.decode || decode$4;
  for (var i2 = 0; i2 < pairs.length; i2++) {
    var pair = pairs[i2];
    var index2 = pair.indexOf("=");
    if (index2 < 0) {
      continue;
    }
    var key = pair.substring(0, index2).trim();
    if (void 0 == obj[key]) {
      var val = pair.substring(index2 + 1, pair.length).trim();
      if (val[0] === '"') {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode$1(val, dec);
    }
  }
  return obj;
}
function serialize$1(name2, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode$2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp$1.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp$1.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp$1.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp$1.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function tryDecode$1(str, decode2) {
  try {
    return decode2(str);
  } catch (e) {
    return str;
  }
}
var bufferUtil$1 = { exports: {} };
var constants$2 = {
  BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
};
const __viteOptionalPeerDep_bufferutil_ws = {};
const __viteOptionalPeerDep_bufferutil_ws$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteOptionalPeerDep_bufferutil_ws
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_bufferutil_ws$1);
var unmask$1;
var mask;
var define_process_env_default$6 = {};
const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants$2;
function concat$2(list, totalLength) {
  if (list.length === 0)
    return EMPTY_BUFFER$3;
  if (list.length === 1)
    return list[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;
  for (let i2 = 0; i2 < list.length; i2++) {
    const buf = list[i2];
    target.set(buf, offset);
    offset += buf.length;
  }
  if (offset < totalLength)
    return target.slice(0, offset);
  return target;
}
function _mask(source, mask2, output, offset, length2) {
  for (let i2 = 0; i2 < length2; i2++) {
    output[offset + i2] = source[i2] ^ mask2[i2 & 3];
  }
}
function _unmask(buffer2, mask2) {
  for (let i2 = 0; i2 < buffer2.length; i2++) {
    buffer2[i2] ^= mask2[i2 & 3];
  }
}
function toArrayBuffer$2(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}
function toBuffer$2(data) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data))
    return data;
  let buf;
  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
bufferUtil$1.exports = {
  concat: concat$2,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$2,
  toBuffer: toBuffer$2,
  unmask: _unmask
};
if (!define_process_env_default$6.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil2 = require$$1;
    mask = bufferUtil$1.exports.mask = function(source, mask2, output, offset, length2) {
      if (length2 < 48)
        _mask(source, mask2, output, offset, length2);
      else
        bufferUtil2.mask(source, mask2, output, offset, length2);
    };
    unmask$1 = bufferUtil$1.exports.unmask = function(buffer2, mask2) {
      if (buffer2.length < 32)
        _unmask(buffer2, mask2);
      else
        bufferUtil2.unmask(buffer2, mask2);
    };
  } catch (e) {
  }
}
var bufferUtilExports = bufferUtil$1.exports;
const kDone = Symbol("kDone");
const kRun = Symbol("kRun");
let Limiter$1 = class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }
  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency)
      return;
    if (this.jobs.length) {
      const job = this.jobs.shift();
      this.pending++;
      job(this[kDone]);
    }
  }
};
var limiter = Limiter$1;
const zlib = require$$2$2;
const bufferUtil = bufferUtilExports;
const Limiter2 = limiter;
const { kStatusCode: kStatusCode$2 } = constants$2;
const TRAILER = Buffer.from([0, 0, 255, 255]);
const kPerMessageDeflate = Symbol("permessage-deflate");
const kTotalLength = Symbol("total-length");
const kCallback = Symbol("callback");
const kBuffers = Symbol("buffers");
const kError$1 = Symbol("error");
let zlibLimiter;
let PerMessageDeflate$4 = class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options2, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options2 || {};
    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;
    if (!zlibLimiter) {
      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter2(concurrency);
    }
  }
  /**
   * @type {String}
   */
  static get extensionName() {
    return "permessage-deflate";
  }
  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};
    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }
    return params;
  }
  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);
    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
    return this.params;
  }
  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }
    if (this._deflate) {
      const callback = this._deflate[kCallback];
      this._deflate.close();
      this._deflate = null;
      if (callback) {
        callback(
          new Error(
            "The deflate stream was closed while data was being processed"
          )
        );
      }
    }
  }
  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
        return false;
      }
      return true;
    });
    if (!accepted) {
      throw new Error("None of the extension offers can be accepted");
    }
    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === "number") {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === "number") {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
      delete accepted.client_max_window_bits;
    }
    return accepted;
  }
  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response2) {
    const params = response2[0];
    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }
    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === "number") {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }
    return params;
  }
  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];
        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }
        value = value[0];
        if (key === "client_max_window_bits") {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === "server_max_window_bits") {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }
        params[key] = value;
      });
    });
    return configurations;
  }
  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done2) => {
      this._decompress(data, fin, (err, result) => {
        done2();
        callback(err, result);
      });
    });
  }
  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done2) => {
      this._compress(data, fin, (err, result) => {
        done2();
        callback(err, result);
      });
    });
  }
  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on("error", inflateOnError);
      this._inflate.on("data", inflateOnData);
    }
    this._inflate[kCallback] = callback;
    this._inflate.write(data);
    if (fin)
      this._inflate.write(TRAILER);
    this._inflate.flush(() => {
      const err = this._inflate[kError$1];
      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }
      const data2 = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );
      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }
      callback(null, data2);
    });
  }
  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      this._deflate.on("data", deflateOnData);
    }
    this._deflate[kCallback] = callback;
    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        return;
      }
      let data2 = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );
      if (fin)
        data2 = data2.slice(0, data2.length - 4);
      this._deflate[kCallback] = null;
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }
      callback(null, data2);
    });
  }
};
var permessageDeflate = PerMessageDeflate$4;
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err) {
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}
var validation = { exports: {} };
const __viteOptionalPeerDep_utf8Validate_ws = {};
const __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteOptionalPeerDep_utf8Validate_ws
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);
var isValidUTF8_1;
var define_process_env_default$5 = {};
const tokenChars$2 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  // 80 - 95
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
  // 112 - 127
];
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i2 = 0;
  while (i2 < len) {
    if ((buf[i2] & 128) === 0) {
      i2++;
    } else if ((buf[i2] & 224) === 192) {
      if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
        return false;
      }
      i2 += 2;
    } else if ((buf[i2] & 240) === 224) {
      if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || // Overlong
      buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
        return false;
      }
      i2 += 3;
    } else if ((buf[i2] & 248) === 240) {
      if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || // Overlong
      buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
        return false;
      }
      i2 += 4;
    } else {
      return false;
    }
  }
  return true;
}
validation.exports = {
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};
if (!define_process_env_default$5.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF82 = require$$0$1;
    isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF82(buf);
    };
  } catch (e) {
  }
}
var validationExports = validation.exports;
const { Writable: Writable$3 } = require$$2$2;
const PerMessageDeflate$3 = permessageDeflate;
const {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$2
} = constants$2;
const { concat: concat$1, toArrayBuffer: toArrayBuffer$1, unmask } = bufferUtilExports;
const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;
const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
let Receiver$1 = class Receiver extends Writable$3 {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options2 = {}) {
    super();
    this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
    this._extensions = options2.extensions || {};
    this._isServer = !!options2.isServer;
    this._maxPayload = options2.maxPayload | 0;
    this._skipUTF8Validation = !!options2.skipUTF8Validation;
    this[kWebSocket$2] = void 0;
    this._bufferedBytes = 0;
    this._buffers = [];
    this._compressed = false;
    this._payloadLength = 0;
    this._mask = void 0;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];
    this._state = GET_INFO;
    this._loop = false;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding3, cb) {
    if (this._opcode === 8 && this._state == GET_INFO)
      return cb();
    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }
  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;
    if (n === this._buffers[0].length)
      return this._buffers.shift();
    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }
    const dst = Buffer.allocUnsafe(n);
    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;
      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }
      n -= buf.length;
    } while (n > 0);
    return dst;
  }
  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;
    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          this._loop = false;
          return;
      }
    } while (this._loop);
    cb(err);
  }
  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    const buf = this.consume(2);
    if ((buf[0] & 48) !== 0) {
      this._loop = false;
      return error$2(
        RangeError,
        "RSV2 and RSV3 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_2_3"
      );
    }
    const compressed = (buf[0] & 64) === 64;
    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
      this._loop = false;
      return error$2(
        RangeError,
        "RSV1 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_1"
      );
    }
    this._fin = (buf[0] & 128) === 128;
    this._opcode = buf[0] & 15;
    this._payloadLength = buf[1] & 127;
    if (this._opcode === 0) {
      if (compressed) {
        this._loop = false;
        return error$2(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      }
      if (!this._fragmented) {
        this._loop = false;
        return error$2(
          RangeError,
          "invalid opcode 0",
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      }
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented) {
        this._loop = false;
        return error$2(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      }
      this._compressed = compressed;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin) {
        this._loop = false;
        return error$2(
          RangeError,
          "FIN must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_FIN"
        );
      }
      if (compressed) {
        this._loop = false;
        return error$2(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      }
      if (this._payloadLength > 125) {
        this._loop = false;
        return error$2(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
      }
    } else {
      this._loop = false;
      return error$2(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        "WS_ERR_INVALID_OPCODE"
      );
    }
    if (!this._fin && !this._fragmented)
      this._fragmented = this._opcode;
    this._masked = (buf[1] & 128) === 128;
    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error$2(
          RangeError,
          "MASK must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_MASK"
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error$2(
        RangeError,
        "MASK must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_MASK"
      );
    }
    if (this._payloadLength === 126)
      this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127)
      this._state = GET_PAYLOAD_LENGTH_64;
    else
      return this.haveLength();
  }
  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }
  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }
    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error$2(
        RangeError,
        "Unsupported WebSocket frame: payload length > 2^53 - 1",
        false,
        1009,
        "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
      );
    }
    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }
  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 8) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error$2(
          RangeError,
          "Max payload size exceeded",
          false,
          1009,
          "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
        );
      }
    }
    if (this._masked)
      this._state = GET_MASK;
    else
      this._state = GET_DATA;
  }
  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }
    this._mask = this.consume(4);
    this._state = GET_DATA;
  }
  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER$2;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }
      data = this.consume(this._payloadLength);
      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
        unmask(data, this._mask);
      }
    }
    if (this._opcode > 7)
      return this.controlMessage(data);
    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }
    if (data.length) {
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }
    return this.dataMessage();
  }
  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err)
        return cb(err);
      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error$2(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            )
          );
        }
        this._fragments.push(buf);
      }
      const er = this.dataMessage();
      if (er)
        return cb(er);
      this.startLoop(cb);
    });
  }
  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat$1(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer$1(concat$1(fragments, messageLength));
        } else {
          data = fragments;
        }
        this.emit("message", data, true);
      } else {
        const buf = concat$1(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error$2(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        }
        this.emit("message", buf, false);
      }
    }
    this._state = GET_INFO;
  }
  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 8) {
      this._loop = false;
      if (data.length === 0) {
        this.emit("conclude", 1005, EMPTY_BUFFER$2);
        this.end();
      } else if (data.length === 1) {
        return error$2(
          RangeError,
          "invalid payload length 1",
          true,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
      } else {
        const code = data.readUInt16BE(0);
        if (!isValidStatusCode$1(code)) {
          return error$2(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            "WS_ERR_INVALID_CLOSE_CODE"
          );
        }
        const buf = data.slice(2);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error$2(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        }
        this.emit("conclude", code, buf);
        this.end();
      }
    } else if (this._opcode === 9) {
      this.emit("ping", data);
    } else {
      this.emit("pong", data);
    }
    this._state = GET_INFO;
  }
};
var receiver = Receiver$1;
function error$2(ErrorCtor, message, prefix2, statusCode, errorCode) {
  const err = new ErrorCtor(
    prefix2 ? `Invalid WebSocket frame: ${message}` : message
  );
  Error.captureStackTrace(err, error$2);
  err.code = errorCode;
  err[kStatusCode$1] = statusCode;
  return err;
}
const { randomFillSync } = require$$2$2;
const PerMessageDeflate$2 = permessageDeflate;
const { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants$2;
const { isValidStatusCode } = validationExports;
const { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;
const kByteLength = Symbol("kByteLength");
const maskBuffer = Buffer.alloc(4);
let Sender$1 = class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket2, extensions, generateMask) {
    this._extensions = extensions || {};
    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }
    this._socket = socket2;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options2) {
    let mask2;
    let merge3 = false;
    let offset = 2;
    let skipMasking = false;
    if (options2.mask) {
      mask2 = options2.maskBuffer || maskBuffer;
      if (options2.generateMask) {
        options2.generateMask(mask2);
      } else {
        randomFillSync(mask2, 0, 4);
      }
      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;
      offset = 6;
    }
    let dataLength;
    if (typeof data === "string") {
      if ((!options2.mask || skipMasking) && options2[kByteLength] !== void 0) {
        dataLength = options2[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge3 = options2.mask && options2.readOnly && !skipMasking;
    }
    let payloadLength = dataLength;
    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }
    const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
    target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
    if (options2.rsv1)
      target[0] |= 64;
    target[1] = payloadLength;
    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }
    if (!options2.mask)
      return [target, data];
    target[1] |= 128;
    target[offset - 4] = mask2[0];
    target[offset - 3] = mask2[1];
    target[offset - 2] = mask2[2];
    target[offset - 1] = mask2[3];
    if (skipMasking)
      return [target, data];
    if (merge3) {
      applyMask(data, mask2, target, offset, dataLength);
      return [target];
    }
    applyMask(data, mask2, data, 0, dataLength);
    return [target, data];
  }
  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask2, cb) {
    let buf;
    if (code === void 0) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== "number" || !isValidStatusCode(code)) {
      throw new TypeError("First argument must be a valid error code number");
    } else if (data === void 0 || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length2 = Buffer.byteLength(data);
      if (length2 > 123) {
        throw new RangeError("The message must not be greater than 123 bytes");
      }
      buf = Buffer.allocUnsafe(2 + length2);
      buf.writeUInt16BE(code, 0);
      if (typeof data === "string") {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }
    const options2 = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask: mask2,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: false,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options2, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options2), cb);
    }
  }
  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask2, cb) {
    let byteLength;
    let readOnly;
    if (typeof data === "string") {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options2 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask: mask2,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options2, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options2), cb);
    }
  }
  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask2, cb) {
    let byteLength;
    let readOnly;
    if (typeof data === "string") {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options2 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask: mask2,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data, false, options2, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options2), cb);
    }
  }
  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options2, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    let opcode = options2.binary ? 2 : 1;
    let rsv1 = options2.compress;
    let byteLength;
    let readOnly;
    if (typeof data === "string") {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else {
      data = toBuffer$1(data);
      byteLength = data.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }
    if (options2.fin)
      this._firstFragment = true;
    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options2.fin,
        generateMask: this._generateMask,
        mask: options2.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options2.fin,
          generateMask: this._generateMask,
          mask: options2.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }
  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options2, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options2), cb);
      return;
    }
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    this._bufferedBytes += options2[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data, options2.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          "The socket was closed while data was being compressed"
        );
        if (typeof cb === "function")
          cb(err);
        for (let i2 = 0; i2 < this._queue.length; i2++) {
          const params = this._queue[i2];
          const callback = params[params.length - 1];
          if (typeof callback === "function")
            callback(err);
        }
        return;
      }
      this._bufferedBytes -= options2[kByteLength];
      this._deflating = false;
      options2.readOnly = false;
      this.sendFrame(Sender.frame(buf, options2), cb);
      this.dequeue();
    });
  }
  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();
      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }
  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }
  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};
var sender = Sender$1;
const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants$2;
const kCode = Symbol("kCode");
const kData = Symbol("kData");
const kError = Symbol("kError");
const kMessage = Symbol("kMessage");
const kReason = Symbol("kReason");
const kTarget = Symbol("kTarget");
const kType = Symbol("kType");
const kWasClean = Symbol("kWasClean");
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type3) {
    this[kTarget] = null;
    this[kType] = type3;
  }
  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }
  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}
Object.defineProperty(Event.prototype, "target", { enumerable: true });
Object.defineProperty(Event.prototype, "type", { enumerable: true });
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type3, options2 = {}) {
    super(type3);
    this[kCode] = options2.code === void 0 ? 0 : options2.code;
    this[kReason] = options2.reason === void 0 ? "" : options2.reason;
    this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
  }
  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }
  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }
  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}
Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type3, options2 = {}) {
    super(type3);
    this[kError] = options2.error === void 0 ? null : options2.error;
    this[kMessage] = options2.message === void 0 ? "" : options2.message;
  }
  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }
  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}
Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type3, options2 = {}) {
    super(type3);
    this[kData] = options2.data === void 0 ? null : options2.data;
  }
  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}
Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type3, handler, options2 = {}) {
    for (const listener2 of this.listeners(type3)) {
      if (!options2[kForOnEventAttribute$1] && listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        return;
      }
    }
    let wrapper;
    if (type3 === "message") {
      wrapper = function onMessage(data, isBinary2) {
        const event = new MessageEvent("message", {
          data: isBinary2 ? data : data.toString()
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type3 === "close") {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent("close", {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type3 === "error") {
      wrapper = function onError(error3) {
        const event = new ErrorEvent("error", {
          error: error3,
          message: error3.message
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type3 === "open") {
      wrapper = function onOpen() {
        const event = new Event("open");
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }
    wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
    wrapper[kListener$1] = handler;
    if (options2.once) {
      this.once(type3, wrapper);
    } else {
      this.on(type3, wrapper);
    }
  },
  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type3, handler) {
    for (const listener2 of this.listeners(type3)) {
      if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        this.removeListener(type3, listener2);
        break;
      }
    }
  }
};
var eventTarget = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};
function callListener(listener2, thisArg, event) {
  if (typeof listener2 === "object" && listener2.handleEvent) {
    listener2.handleEvent.call(listener2, event);
  } else {
    listener2.call(thisArg, event);
  }
}
const { tokenChars: tokenChars$1 } = validationExports;
function push$1(dest, name2, elem) {
  if (dest[name2] === void 0)
    dest[name2] = [elem];
  else
    dest[name2].push(elem);
}
function parse$a(header3) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end2 = -1;
  let i2 = 0;
  for (; i2 < header3.length; i2++) {
    code = header3.charCodeAt(i2);
    if (extensionName === void 0) {
      if (end2 === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (i2 !== 0 && (code === 32 || code === 9)) {
        if (end2 === -1 && start !== -1)
          end2 = i2;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end2 === -1)
          end2 = i2;
        const name2 = header3.slice(start, end2);
        if (code === 44) {
          push$1(offers, name2, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name2;
        }
        start = end2 = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    } else if (paramName === void 0) {
      if (end2 === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (code === 32 || code === 9) {
        if (end2 === -1 && start !== -1)
          end2 = i2;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end2 === -1)
          end2 = i2;
        push$1(params, header3.slice(start, end2), true);
        if (code === 44) {
          push$1(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start = end2 = -1;
      } else if (code === 61 && start !== -1 && end2 === -1) {
        paramName = header3.slice(start, i2);
        start = end2 = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (start === -1)
          start = i2;
        else if (!mustUnescape)
          mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end2 = i2;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      } else if (code === 34 && header3.charCodeAt(i2 - 1) === 61) {
        inQuotes = true;
      } else if (end2 === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end2 === -1)
          end2 = i2;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end2 === -1)
          end2 = i2;
        let value = header3.slice(start, end2);
        if (mustUnescape) {
          value = value.replace(/\\/g, "");
          mustUnescape = false;
        }
        push$1(params, paramName, value);
        if (code === 44) {
          push$1(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start = end2 = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end2 === -1)
    end2 = i2;
  const token = header3.slice(start, end2);
  if (extensionName === void 0) {
    push$1(offers, token, params);
  } else {
    if (paramName === void 0) {
      push$1(params, token, true);
    } else if (mustUnescape) {
      push$1(params, paramName, token.replace(/\\/g, ""));
    } else {
      push$1(params, paramName, token);
    }
    push$1(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions) {
  return Object.keys(extensions).map((extension2) => {
    let configurations = extensions[extension2];
    if (!Array.isArray(configurations))
      configurations = [configurations];
    return configurations.map((params) => {
      return [extension2].concat(
        Object.keys(params).map((k) => {
          let values2 = params[k];
          if (!Array.isArray(values2))
            values2 = [values2];
          return values2.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
var extension$1 = { format: format$1, parse: parse$a };
const EventEmitter$3 = require$$2$2;
const https = require$$2$2;
const http$1 = require$$2$2;
const net = require$$2$2;
const tls = require$$2$2;
const { randomBytes, createHash: createHash$1 } = require$$2$2;
const { URL: URL$1 } = require$$2$2;
const PerMessageDeflate$1 = permessageDeflate;
const Receiver2 = receiver;
const Sender2 = sender;
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP
} = constants$2;
const {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
const { format, parse: parse$9 } = extension$1;
const { toBuffer } = bufferUtilExports;
const closeTimeout = 30 * 1e3;
const kAborted = Symbol("kAborted");
const protocolVersions = [8, 13];
const readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
let WebSocket$4 = class WebSocket2 extends EventEmitter$3 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options2) {
    super();
    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = "";
    this._readyState = WebSocket2.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;
      if (protocols === void 0) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === "object" && protocols !== null) {
          options2 = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }
      initAsClient(this, address, protocols, options2);
    } else {
      this._isServer = true;
    }
  }
  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(type3) {
    if (!BINARY_TYPES.includes(type3))
      return;
    this._binaryType = type3;
    if (this._receiver)
      this._receiver._binaryType = type3;
  }
  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket)
      return this._bufferedAmount;
    return this._socket._writableState.length + this._sender._bufferedBytes;
  }
  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }
  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }
  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }
  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket2, head, options2) {
    const receiver2 = new Receiver2({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options2.maxPayload,
      skipUTF8Validation: options2.skipUTF8Validation
    });
    this._sender = new Sender2(socket2, this._extensions, options2.generateMask);
    this._receiver = receiver2;
    this._socket = socket2;
    receiver2[kWebSocket$1] = this;
    socket2[kWebSocket$1] = this;
    receiver2.on("conclude", receiverOnConclude);
    receiver2.on("drain", receiverOnDrain);
    receiver2.on("error", receiverOnError);
    receiver2.on("message", receiverOnMessage);
    receiver2.on("ping", receiverOnPing);
    receiver2.on("pong", receiverOnPong);
    socket2.setTimeout(0);
    socket2.setNoDelay();
    if (head.length > 0)
      socket2.unshift(head);
    socket2.on("close", socketOnClose);
    socket2.on("data", socketOnData);
    socket2.on("end", socketOnEnd);
    socket2.on("error", socketOnError$1);
    this._readyState = WebSocket2.OPEN;
    this.emit("open");
  }
  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket2.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    if (this._extensions[PerMessageDeflate$1.extensionName]) {
      this._extensions[PerMessageDeflate$1.extensionName].cleanup();
    }
    this._receiver.removeAllListeners();
    this._readyState = WebSocket2.CLOSED;
    this.emit("close", this._closeCode, this._closeMessage);
  }
  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket2.CLOSED)
      return;
    if (this.readyState === WebSocket2.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      return abortHandshake$1(this, this._req, msg);
    }
    if (this.readyState === WebSocket2.CLOSING) {
      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
        this._socket.end();
      }
      return;
    }
    this._readyState = WebSocket2.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      if (err)
        return;
      this._closeFrameSent = true;
      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
        this._socket.end();
      }
    });
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }
  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
      return;
    }
    this._paused = true;
    this._socket.pause();
  }
  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask2, cb) {
    if (this.readyState === WebSocket2.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data === "function") {
      cb = data;
      data = mask2 = void 0;
    } else if (typeof mask2 === "function") {
      cb = mask2;
      mask2 = void 0;
    }
    if (typeof data === "number")
      data = data.toString();
    if (this.readyState !== WebSocket2.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }
    if (mask2 === void 0)
      mask2 = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);
  }
  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask2, cb) {
    if (this.readyState === WebSocket2.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data === "function") {
      cb = data;
      data = mask2 = void 0;
    } else if (typeof mask2 === "function") {
      cb = mask2;
      mask2 = void 0;
    }
    if (typeof data === "number")
      data = data.toString();
    if (this.readyState !== WebSocket2.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }
    if (mask2 === void 0)
      mask2 = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);
  }
  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
      return;
    }
    this._paused = false;
    if (!this._receiver._writableState.needDrain)
      this._socket.resume();
  }
  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options2, cb) {
    if (this.readyState === WebSocket2.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof options2 === "function") {
      cb = options2;
      options2 = {};
    }
    if (typeof data === "number")
      data = data.toString();
    if (this.readyState !== WebSocket2.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }
    const opts = {
      binary: typeof data !== "string",
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options2
    };
    if (!this._extensions[PerMessageDeflate$1.extensionName]) {
      opts.compress = false;
    }
    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }
  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket2.CLOSED)
      return;
    if (this.readyState === WebSocket2.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      return abortHandshake$1(this, this._req, msg);
    }
    if (this._socket) {
      this._readyState = WebSocket2.CLOSING;
      this._socket.destroy();
    }
  }
};
Object.defineProperty(WebSocket$4, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$4.prototype, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$4, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$4.prototype, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$4, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$4.prototype, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$4, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
Object.defineProperty(WebSocket$4.prototype, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((property) => {
  Object.defineProperty(WebSocket$4.prototype, property, { enumerable: true });
});
["open", "error", "close", "message"].forEach((method) => {
  Object.defineProperty(WebSocket$4.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute])
          return listener2[kListener];
      }
      return null;
    },
    set(handler) {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute]) {
          this.removeListener(method, listener2);
          break;
        }
      }
      if (typeof handler !== "function")
        return;
      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});
WebSocket$4.prototype.addEventListener = addEventListener;
WebSocket$4.prototype.removeEventListener = removeEventListener;
var websocket$1 = WebSocket$4;
function initAsClient(websocket2, address, protocols, options2) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options2,
    createConnection: void 0,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$1) {
    parsedUrl = address;
    websocket2._url = address.href;
  } else {
    try {
      parsedUrl = new URL$1(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
    websocket2._url = address;
  }
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket2, err);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request2 = isSecure ? https.request : http$1.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol2 of protocols) {
      if (typeof protocol2 !== "string" || !subprotocolRegex.test(protocol2) || protocolSet.has(protocol2)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol2);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options2 && options2.headers;
      options2 = { ...options2, headers: {} };
      if (headers) {
        for (const [key2, value] of Object.entries(headers)) {
          options2.headers[key2.toLowerCase()] = value;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost)
          delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options2.headers.authorization) {
      options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket2._req = request2(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req2);
    }
  } else {
    req2 = websocket2._req = request2(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err) => {
    if (req2 === null || req2[kAborted])
      return;
    req2 = websocket2._req = null;
    emitErrorAndClose(websocket2, err);
  });
  req2.on("response", (res2) => {
    const location2 = res2.headers.location;
    const statusCode = res2.statusCode;
    if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$1(location2, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location2}`);
        emitErrorAndClose(websocket2, err);
        return;
      }
      initAsClient(websocket2, addr, protocols, options2);
    } else if (!websocket2.emit("unexpected-response", req2, res2)) {
      abortHandshake$1(
        websocket2,
        req2,
        `Unexpected server response: ${res2.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res2, socket2, head) => {
    websocket2.emit("upgrade", res2);
    if (websocket2.readyState !== WebSocket$4.CONNECTING)
      return;
    req2 = websocket2._req = null;
    if (res2.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket2, socket2, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
    if (res2.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket2, socket2, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res2.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket2, socket2, protError);
      return;
    }
    if (serverProt)
      websocket2._protocol = serverProt;
    const secWebSocketExtensions = res2.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket2, socket2, message);
        return;
      }
      let extensions;
      try {
        extensions = parse$9(secWebSocketExtensions);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket2, message);
        return;
      }
      const extensionNames = Object.keys(extensions);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket2, socket2, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket2, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket2, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  req2.end();
}
function emitErrorAndClose(websocket2, err) {
  websocket2._readyState = WebSocket$4.CLOSING;
  websocket2.emit("error", err);
  websocket2.emitClose();
}
function netConnect(options2) {
  options2.path = options2.socketPath;
  return net.connect(options2);
}
function tlsConnect(options2) {
  options2.path = void 0;
  if (!options2.servername && options2.servername !== "") {
    options2.servername = net.isIP(options2.host) ? "" : options2.host;
  }
  return tls.connect(options2);
}
function abortHandshake$1(websocket2, stream3, message) {
  websocket2._readyState = WebSocket$4.CLOSING;
  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);
  if (stream3.setHeader) {
    stream3[kAborted] = true;
    stream3.abort();
    if (stream3.socket && !stream3.socket.destroyed) {
      stream3.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err);
  } else {
    stream3.destroy(err);
    stream3.once("error", websocket2.emit.bind(websocket2, "error"));
    stream3.once("close", websocket2.emitClose.bind(websocket2));
  }
}
function sendAfterClose(websocket2, data, cb) {
  if (data) {
    const length2 = toBuffer(data).length;
    if (websocket2._socket)
      websocket2._sender._bufferedBytes += length2;
    else
      websocket2._bufferedAmount += length2;
  }
  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
    );
    cb(err);
  }
}
function receiverOnConclude(code, reason) {
  const websocket2 = this[kWebSocket$1];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket$1] === void 0)
    return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005)
    websocket2.close();
  else
    websocket2.close(code, reason);
}
function receiverOnDrain() {
  const websocket2 = this[kWebSocket$1];
  if (!websocket2.isPaused)
    websocket2._socket.resume();
}
function receiverOnError(err) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._socket[kWebSocket$1] !== void 0) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err[kStatusCode]);
  }
  websocket2.emit("error", err);
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data, isBinary2) {
  this[kWebSocket$1].emit("message", data, isBinary2);
}
function receiverOnPing(data) {
  const websocket2 = this[kWebSocket$1];
  websocket2.pong(data, !websocket2._isServer, NOOP);
  websocket2.emit("ping", data);
}
function receiverOnPong(data) {
  this[kWebSocket$1].emit("pong", data);
}
function resume(stream3) {
  stream3.resume();
}
function socketOnClose() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket$4.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket2 = this[kWebSocket$1];
  websocket2._readyState = WebSocket$4.CLOSING;
  websocket2._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP);
  if (websocket2) {
    websocket2._readyState = WebSocket$4.CLOSING;
    this.destroy();
  }
}
const { Duplex: Duplex$2 } = require$$2$2;
function emitClose$1(stream3) {
  stream3.emit("close");
}
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}
function duplexOnError(err) {
  this.removeListener("error", duplexOnError);
  this.destroy();
  if (this.listenerCount("error") === 0) {
    this.emit("error", err);
  }
}
function createWebSocketStream(ws2, options2) {
  let terminateOnDestroy = true;
  const duplex = new Duplex$2({
    ...options2,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });
  ws2.on("message", function message(msg, isBinary2) {
    const data = !isBinary2 && duplex._readableState.objectMode ? msg.toString() : msg;
    if (!duplex.push(data))
      ws2.pause();
  });
  ws2.once("error", function error3(err) {
    if (duplex.destroyed)
      return;
    terminateOnDestroy = false;
    duplex.destroy(err);
  });
  ws2.once("close", function close() {
    if (duplex.destroyed)
      return;
    duplex.push(null);
  });
  duplex._destroy = function(err, callback) {
    if (ws2.readyState === ws2.CLOSED) {
      callback(err);
      process.nextTick(emitClose$1, duplex);
      return;
    }
    let called = false;
    ws2.once("error", function error3(err2) {
      called = true;
      callback(err2);
    });
    ws2.once("close", function close() {
      if (!called)
        callback(err);
      process.nextTick(emitClose$1, duplex);
    });
    if (terminateOnDestroy)
      ws2.terminate();
  };
  duplex._final = function(callback) {
    if (ws2.readyState === ws2.CONNECTING) {
      ws2.once("open", function open() {
        duplex._final(callback);
      });
      return;
    }
    if (ws2._socket === null)
      return;
    if (ws2._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted)
        duplex.destroy();
    } else {
      ws2._socket.once("finish", function finish() {
        callback();
      });
      ws2.close();
    }
  };
  duplex._read = function() {
    if (ws2.isPaused)
      ws2.resume();
  };
  duplex._write = function(chunk, encoding3, callback) {
    if (ws2.readyState === ws2.CONNECTING) {
      ws2.once("open", function open() {
        duplex._write(chunk, encoding3, callback);
      });
      return;
    }
    ws2.send(chunk, callback);
  };
  duplex.on("end", duplexOnEnd);
  duplex.on("error", duplexOnError);
  return duplex;
}
var stream$1 = createWebSocketStream;
const { tokenChars } = validationExports;
function parse$8(header3) {
  const protocols = /* @__PURE__ */ new Set();
  let start = -1;
  let end2 = -1;
  let i2 = 0;
  for (i2; i2 < header3.length; i2++) {
    const code = header3.charCodeAt(i2);
    if (end2 === -1 && tokenChars[code] === 1) {
      if (start === -1)
        start = i2;
    } else if (i2 !== 0 && (code === 32 || code === 9)) {
      if (end2 === -1 && start !== -1)
        end2 = i2;
    } else if (code === 44) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
      if (end2 === -1)
        end2 = i2;
      const protocol3 = header3.slice(start, end2);
      if (protocols.has(protocol3)) {
        throw new SyntaxError(`The "${protocol3}" subprotocol is duplicated`);
      }
      protocols.add(protocol3);
      start = end2 = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i2}`);
    }
  }
  if (start === -1 || end2 !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol2 = header3.slice(start, i2);
  if (protocols.has(protocol2)) {
    throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
  }
  protocols.add(protocol2);
  return protocols;
}
var subprotocol$1 = { parse: parse$8 };
const EventEmitter$2 = require$$2$2;
const http = require$$2$2;
const { createHash } = require$$2$2;
const extension = extension$1;
const PerMessageDeflate2 = permessageDeflate;
const subprotocol = subprotocol$1;
const WebSocket$3 = websocket$1;
const { GUID, kWebSocket } = constants$2;
const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;
class WebSocketServer extends EventEmitter$2 {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options2, callback) {
    super();
    options2 = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket: WebSocket$3,
      ...options2
    };
    if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options must be specified'
      );
    }
    if (options2.port != null) {
      this._server = http.createServer((req2, res2) => {
        const body = http.STATUS_CODES[426];
        res2.writeHead(426, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res2.end(body);
      });
      this._server.listen(
        options2.port,
        options2.host,
        options2.backlog,
        callback
      );
    } else if (options2.server) {
      this._server = options2.server;
    }
    if (this._server) {
      const emitConnection = this.emit.bind(this, "connection");
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, "listening"),
        error: this.emit.bind(this, "error"),
        upgrade: (req2, socket2, head) => {
          this.handleUpgrade(req2, socket2, head, emitConnection);
        }
      });
    }
    if (options2.perMessageDeflate === true)
      options2.perMessageDeflate = {};
    if (options2.clientTracking) {
      this.clients = /* @__PURE__ */ new Set();
      this._shouldEmitClose = false;
    }
    this.options = options2;
    this._state = RUNNING;
  }
  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }
    if (!this._server)
      return null;
    return this._server.address();
  }
  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once("close", () => {
          cb(new Error("The server is not running"));
        });
      }
      process.nextTick(emitClose, this);
      return;
    }
    if (cb)
      this.once("close", cb);
    if (this._state === CLOSING)
      return;
    this._state = CLOSING;
    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }
      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server2 = this._server;
      this._removeListeners();
      this._removeListeners = this._server = null;
      server2.close(() => {
        emitClose(this);
      });
    }
  }
  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req2) {
    if (this.options.path) {
      const index2 = req2.url.indexOf("?");
      const pathname = index2 !== -1 ? req2.url.slice(0, index2) : req2.url;
      if (pathname !== this.options.path)
        return false;
    }
    return true;
  }
  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req2, socket2, head, cb) {
    socket2.on("error", socketOnError);
    const key = req2.headers["sec-websocket-key"];
    const version2 = +req2.headers["sec-websocket-version"];
    if (req2.method !== "GET") {
      const message = "Invalid HTTP method";
      abortHandshakeOrEmitwsClientError(this, req2, socket2, 405, message);
      return;
    }
    if (req2.headers.upgrade.toLowerCase() !== "websocket") {
      const message = "Invalid Upgrade header";
      abortHandshakeOrEmitwsClientError(this, req2, socket2, 400, message);
      return;
    }
    if (!key || !keyRegex.test(key)) {
      const message = "Missing or invalid Sec-WebSocket-Key header";
      abortHandshakeOrEmitwsClientError(this, req2, socket2, 400, message);
      return;
    }
    if (version2 !== 8 && version2 !== 13) {
      const message = "Missing or invalid Sec-WebSocket-Version header";
      abortHandshakeOrEmitwsClientError(this, req2, socket2, 400, message);
      return;
    }
    if (!this.shouldHandle(req2)) {
      abortHandshake(socket2, 400);
      return;
    }
    const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
    let protocols = /* @__PURE__ */ new Set();
    if (secWebSocketProtocol !== void 0) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Protocol header";
        abortHandshakeOrEmitwsClientError(this, req2, socket2, 400, message);
        return;
      }
    }
    const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
    const extensions = {};
    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
      const perMessageDeflate = new PerMessageDeflate2(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );
      try {
        const offers = extension.parse(secWebSocketExtensions);
        if (offers[PerMessageDeflate2.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);
          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
        abortHandshakeOrEmitwsClientError(this, req2, socket2, 400, message);
        return;
      }
    }
    if (this.options.verifyClient) {
      const info = {
        origin: req2.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
        secure: !!(req2.socket.authorized || req2.socket.encrypted),
        req: req2
      };
      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket2, code || 401, message, headers);
          }
          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req2,
            socket2,
            head,
            cb
          );
        });
        return;
      }
      if (!this.options.verifyClient(info))
        return abortHandshake(socket2, 401);
    }
    this.completeUpgrade(extensions, key, protocols, req2, socket2, head, cb);
  }
  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req2, socket2, head, cb) {
    if (!socket2.readable || !socket2.writable)
      return socket2.destroy();
    if (socket2[kWebSocket]) {
      throw new Error(
        "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
      );
    }
    if (this._state > RUNNING)
      return abortHandshake(socket2, 503);
    const digest = createHash("sha1").update(key + GUID).digest("base64");
    const headers = [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${digest}`
    ];
    const ws2 = new this.options.WebSocket(null);
    if (protocols.size) {
      const protocol2 = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
      if (protocol2) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol2}`);
        ws2._protocol = protocol2;
      }
    }
    if (extensions[PerMessageDeflate2.extensionName]) {
      const params = extensions[PerMessageDeflate2.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate2.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws2._extensions = extensions;
    }
    this.emit("headers", headers, req2);
    socket2.write(headers.concat("\r\n").join("\r\n"));
    socket2.removeListener("error", socketOnError);
    ws2.setSocket(socket2, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });
    if (this.clients) {
      this.clients.add(ws2);
      ws2.on("close", () => {
        this.clients.delete(ws2);
        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }
    cb(ws2, req2);
  }
}
var websocketServer = WebSocketServer;
function addListeners(server2, map2) {
  for (const event of Object.keys(map2))
    server2.on(event, map2[event]);
  return function removeListeners() {
    for (const event of Object.keys(map2)) {
      server2.removeListener(event, map2[event]);
    }
  };
}
function emitClose(server2) {
  server2._state = CLOSED;
  server2.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(socket2, code, message, headers) {
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket2.once("finish", socket2.destroy);
  socket2.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message
  );
}
function abortHandshakeOrEmitwsClientError(server2, req2, socket2, code, message) {
  if (server2.listenerCount("wsClientError")) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
    server2.emit("wsClientError", err, socket2, req2);
  } else {
    abortHandshake(socket2, code, message);
  }
}
const WebSocket$2 = websocket$1;
WebSocket$2.createWebSocketStream = stream$1;
WebSocket$2.Server = websocketServer;
WebSocket$2.Receiver = receiver;
WebSocket$2.Sender = sender;
WebSocket$2.WebSocket = WebSocket$2;
WebSocket$2.WebSocketServer = WebSocket$2.Server;
var ws = WebSocket$2;
var lib$2 = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign$2 = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty$3.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from, symbols[i2])) {
          to[symbols[i2]] = from[symbols[i2]];
        }
      }
    }
  }
  return to;
};
(function() {
  var assign2 = objectAssign$2;
  var vary2 = varyExports;
  var defaults2 = {
    origin: "*",
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
    preflightContinue: false,
    optionsSuccessStatus: 204
  };
  function isString2(s2) {
    return typeof s2 === "string" || s2 instanceof String;
  }
  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i2 = 0; i2 < allowedOrigin.length; ++i2) {
        if (isOriginAllowed(origin, allowedOrigin[i2])) {
          return true;
        }
      }
      return false;
    } else if (isString2(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }
  function configureOrigin(options2, req2) {
    var requestOrigin = req2.headers.origin, headers = [], isAllowed;
    if (!options2.origin || options2.origin === "*") {
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: "*"
      }]);
    } else if (isString2(options2.origin)) {
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: options2.origin
      }]);
      headers.push([{
        key: "Vary",
        value: "Origin"
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options2.origin);
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: "Vary",
        value: "Origin"
      }]);
    }
    return headers;
  }
  function configureMethods(options2) {
    var methods2 = options2.methods;
    if (methods2.join) {
      methods2 = options2.methods.join(",");
    }
    return {
      key: "Access-Control-Allow-Methods",
      value: methods2
    };
  }
  function configureCredentials(options2) {
    if (options2.credentials === true) {
      return {
        key: "Access-Control-Allow-Credentials",
        value: "true"
      };
    }
    return null;
  }
  function configureAllowedHeaders(options2, req2) {
    var allowedHeaders = options2.allowedHeaders || options2.headers;
    var headers = [];
    if (!allowedHeaders) {
      allowedHeaders = req2.headers["access-control-request-headers"];
      headers.push([{
        key: "Vary",
        value: "Access-Control-Request-Headers"
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(",");
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: "Access-Control-Allow-Headers",
        value: allowedHeaders
      }]);
    }
    return headers;
  }
  function configureExposedHeaders(options2) {
    var headers = options2.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(",");
    }
    if (headers && headers.length) {
      return {
        key: "Access-Control-Expose-Headers",
        value: headers
      };
    }
    return null;
  }
  function configureMaxAge(options2) {
    var maxAge = (typeof options2.maxAge === "number" || options2.maxAge) && options2.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: "Access-Control-Max-Age",
        value: maxAge
      };
    }
    return null;
  }
  function applyHeaders(headers, res2) {
    for (var i2 = 0, n = headers.length; i2 < n; i2++) {
      var header3 = headers[i2];
      if (header3) {
        if (Array.isArray(header3)) {
          applyHeaders(header3, res2);
        } else if (header3.key === "Vary" && header3.value) {
          vary2(res2, header3.value);
        } else if (header3.value) {
          res2.setHeader(header3.key, header3.value);
        }
      }
    }
  }
  function cors2(options2, req2, res2, next) {
    var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
    if (method === "OPTIONS") {
      headers.push(configureOrigin(options2, req2));
      headers.push(configureCredentials(options2));
      headers.push(configureMethods(options2));
      headers.push(configureAllowedHeaders(options2, req2));
      headers.push(configureMaxAge(options2));
      headers.push(configureExposedHeaders(options2));
      applyHeaders(headers, res2);
      if (options2.preflightContinue) {
        next();
      } else {
        res2.statusCode = options2.optionsSuccessStatus;
        res2.setHeader("Content-Length", "0");
        res2.end();
      }
    } else {
      headers.push(configureOrigin(options2, req2));
      headers.push(configureCredentials(options2));
      headers.push(configureExposedHeaders(options2));
      applyHeaders(headers, res2);
      next();
    }
  }
  function middlewareWrapper(o) {
    var optionsCallback = null;
    if (typeof o === "function") {
      optionsCallback = o;
    } else {
      optionsCallback = function(req2, cb) {
        cb(null, o);
      };
    }
    return function corsMiddleware(req2, res2, next) {
      optionsCallback(req2, function(err, options2) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign2({}, defaults2, options2);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === "function") {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function(origin, cb) {
              cb(null, corsOptions.origin);
            };
          }
          if (originCallback) {
            originCallback(req2.headers.origin, function(err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors2(corsOptions, req2, res2, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }
  lib$2.exports = middlewareWrapper;
})();
var libExports = lib$2.exports;
const cors = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
Object.defineProperty(server, "__esModule", { value: true });
server.Server = server.BaseServer = void 0;
const qs = require$$2$2;
const url_1 = require$$2$2;
const base64id = base64idExports;
const transports_1 = transports;
const events_1$2 = require$$2$2;
const socket_1 = socket$1;
const debug_1$6 = browserExports;
const cookie_1 = cookie$2;
const ws_1 = ws;
const webtransport_1 = webtransport;
const engine_io_parser_1 = cjs$1;
const debug$8 = (0, debug_1$6.default)("engine");
const kResponseHeaders = Symbol("responseHeaders");
function parseSessionId(data) {
  try {
    const parsed = JSON.parse(data);
    if (typeof parsed.sid === "string") {
      return parsed.sid;
    }
  } catch (e) {
  }
}
class BaseServer extends events_1$2.EventEmitter {
  /**
   * Server constructor.
   *
   * @param {Object} opts - options
   * @api public
   */
  constructor(opts = {}) {
    super();
    this.middlewares = [];
    this.clients = {};
    this.clientsCount = 0;
    this.opts = Object.assign({
      wsEngine: ws_1.Server,
      pingTimeout: 2e4,
      pingInterval: 25e3,
      upgradeTimeout: 1e4,
      maxHttpBufferSize: 1e6,
      transports: ["polling", "websocket"],
      allowUpgrades: true,
      httpCompression: {
        threshold: 1024
      },
      cors: false,
      allowEIO3: false
    }, opts);
    if (opts.cookie) {
      this.opts.cookie = Object.assign({
        name: "io",
        path: "/",
        // @ts-ignore
        httpOnly: opts.cookie.path !== false,
        sameSite: "lax"
      }, opts.cookie);
    }
    if (this.opts.cors) {
      this.use(libExports(this.opts.cors));
    }
    if (opts.perMessageDeflate) {
      this.opts.perMessageDeflate = Object.assign({
        threshold: 1024
      }, opts.perMessageDeflate);
    }
    this.init();
  }
  /**
   * Compute the pathname of the requests that are handled by the server
   * @param options
   * @protected
   */
  _computePath(options2) {
    let path3 = (options2.path || "/engine.io").replace(/\/$/, "");
    if (options2.addTrailingSlash !== false) {
      path3 += "/";
    }
    return path3;
  }
  /**
   * Returns a list of available transports for upgrade given a certain transport.
   *
   * @return {Array}
   * @api public
   */
  upgrades(transport2) {
    if (!this.opts.allowUpgrades)
      return [];
    return transports_1.default[transport2].upgradesTo || [];
  }
  /**
   * Verifies a request.
   *
   * @param {http.IncomingMessage}
   * @return {Boolean} whether the request is valid
   * @api private
   */
  verify(req2, upgrade, fn) {
    const transport2 = req2._query.transport;
    if (!~this.opts.transports.indexOf(transport2) || transport2 === "webtransport") {
      debug$8('unknown transport "%s"', transport2);
      return fn(Server$1.errors.UNKNOWN_TRANSPORT, { transport: transport2 });
    }
    const isOriginInvalid = checkInvalidHeaderChar(req2.headers.origin);
    if (isOriginInvalid) {
      const origin = req2.headers.origin;
      req2.headers.origin = null;
      debug$8("origin header invalid");
      return fn(Server$1.errors.BAD_REQUEST, {
        name: "INVALID_ORIGIN",
        origin
      });
    }
    const sid = req2._query.sid;
    if (sid) {
      if (!this.clients.hasOwnProperty(sid)) {
        debug$8('unknown sid "%s"', sid);
        return fn(Server$1.errors.UNKNOWN_SID, {
          sid
        });
      }
      const previousTransport = this.clients[sid].transport.name;
      if (!upgrade && previousTransport !== transport2) {
        debug$8("bad request: unexpected transport without upgrade");
        return fn(Server$1.errors.BAD_REQUEST, {
          name: "TRANSPORT_MISMATCH",
          transport: transport2,
          previousTransport
        });
      }
    } else {
      if ("GET" !== req2.method) {
        return fn(Server$1.errors.BAD_HANDSHAKE_METHOD, {
          method: req2.method
        });
      }
      if (transport2 === "websocket" && !upgrade) {
        debug$8("invalid transport upgrade");
        return fn(Server$1.errors.BAD_REQUEST, {
          name: "TRANSPORT_HANDSHAKE_ERROR"
        });
      }
      if (!this.opts.allowRequest)
        return fn();
      return this.opts.allowRequest(req2, (message, success) => {
        if (!success) {
          return fn(Server$1.errors.FORBIDDEN, {
            message
          });
        }
        fn();
      });
    }
    fn();
  }
  /**
   * Adds a new middleware.
   *
   * @example
   * import helmet from "helmet";
   *
   * engine.use(helmet());
   *
   * @param fn
   */
  use(fn) {
    this.middlewares.push(fn);
  }
  /**
   * Apply the middlewares to the request.
   *
   * @param req
   * @param res
   * @param callback
   * @protected
   */
  _applyMiddlewares(req2, res2, callback) {
    if (this.middlewares.length === 0) {
      debug$8("no middleware to apply, skipping");
      return callback();
    }
    const apply = (i2) => {
      debug$8("applying middleware n%d", i2 + 1);
      this.middlewares[i2](req2, res2, (err) => {
        if (err) {
          return callback(err);
        }
        if (i2 + 1 < this.middlewares.length) {
          apply(i2 + 1);
        } else {
          callback();
        }
      });
    };
    apply(0);
  }
  /**
   * Closes all clients.
   *
   * @api public
   */
  close() {
    debug$8("closing all open clients");
    for (let i2 in this.clients) {
      if (this.clients.hasOwnProperty(i2)) {
        this.clients[i2].close(true);
      }
    }
    this.cleanup();
    return this;
  }
  /**
   * generate a socket id.
   * Overwrite this method to generate your custom socket id
   *
   * @param {Object} request object
   * @api public
   */
  generateId(req2) {
    return base64id.generateId();
  }
  /**
   * Handshakes a new client.
   *
   * @param {String} transport name
   * @param {Object} request object
   * @param {Function} closeConnection
   *
   * @api protected
   */
  async handshake(transportName, req2, closeConnection) {
    const protocol2 = req2._query.EIO === "4" ? 4 : 3;
    if (protocol2 === 3 && !this.opts.allowEIO3) {
      debug$8("unsupported protocol version");
      this.emit("connection_error", {
        req: req2,
        code: Server$1.errors.UNSUPPORTED_PROTOCOL_VERSION,
        message: Server$1.errorMessages[Server$1.errors.UNSUPPORTED_PROTOCOL_VERSION],
        context: {
          protocol: protocol2
        }
      });
      closeConnection(Server$1.errors.UNSUPPORTED_PROTOCOL_VERSION);
      return;
    }
    let id;
    try {
      id = await this.generateId(req2);
    } catch (e) {
      debug$8("error while generating an id");
      this.emit("connection_error", {
        req: req2,
        code: Server$1.errors.BAD_REQUEST,
        message: Server$1.errorMessages[Server$1.errors.BAD_REQUEST],
        context: {
          name: "ID_GENERATION_ERROR",
          error: e
        }
      });
      closeConnection(Server$1.errors.BAD_REQUEST);
      return;
    }
    debug$8('handshaking client "%s"', id);
    try {
      var transport2 = this.createTransport(transportName, req2);
      if ("polling" === transportName) {
        transport2.maxHttpBufferSize = this.opts.maxHttpBufferSize;
        transport2.httpCompression = this.opts.httpCompression;
      } else if ("websocket" === transportName) {
        transport2.perMessageDeflate = this.opts.perMessageDeflate;
      }
    } catch (e) {
      debug$8('error handshaking to transport "%s"', transportName);
      this.emit("connection_error", {
        req: req2,
        code: Server$1.errors.BAD_REQUEST,
        message: Server$1.errorMessages[Server$1.errors.BAD_REQUEST],
        context: {
          name: "TRANSPORT_HANDSHAKE_ERROR",
          error: e
        }
      });
      closeConnection(Server$1.errors.BAD_REQUEST);
      return;
    }
    const socket2 = new socket_1.Socket(id, this, transport2, req2, protocol2);
    transport2.on("headers", (headers, req3) => {
      const isInitialRequest = !req3._query.sid;
      if (isInitialRequest) {
        if (this.opts.cookie) {
          headers["Set-Cookie"] = [
            // @ts-ignore
            (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)
          ];
        }
        this.emit("initial_headers", headers, req3);
      }
      this.emit("headers", headers, req3);
    });
    transport2.onRequest(req2);
    this.clients[id] = socket2;
    this.clientsCount++;
    socket2.once("close", () => {
      delete this.clients[id];
      this.clientsCount--;
    });
    this.emit("connection", socket2);
    return transport2;
  }
  async onWebTransportSession(session) {
    const timeout = setTimeout(() => {
      debug$8("the client failed to establish a bidirectional stream in the given period");
      session.close();
    }, this.opts.upgradeTimeout);
    const streamReader = session.incomingBidirectionalStreams.getReader();
    const result = await streamReader.read();
    if (result.done) {
      debug$8("session is closed");
      return;
    }
    const stream3 = result.value;
    const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
    const reader = stream3.readable.pipeThrough(transformStream).getReader();
    const { value, done: done2 } = await reader.read();
    if (done2) {
      debug$8("stream is closed");
      return;
    }
    clearTimeout(timeout);
    if (value.type !== "open") {
      debug$8("invalid WebTransport handshake");
      return session.close();
    }
    if (value.data === void 0) {
      const transport2 = new webtransport_1.WebTransport(session, stream3, reader);
      const id = base64id.generateId();
      debug$8('handshaking client "%s" (WebTransport)', id);
      const socket2 = new socket_1.Socket(id, this, transport2, null, 4);
      this.clients[id] = socket2;
      this.clientsCount++;
      socket2.once("close", () => {
        delete this.clients[id];
        this.clientsCount--;
      });
      this.emit("connection", socket2);
      return;
    }
    const sid = parseSessionId(value.data);
    if (!sid) {
      debug$8("invalid WebTransport handshake");
      return session.close();
    }
    const client2 = this.clients[sid];
    if (!client2) {
      debug$8("upgrade attempt for closed client");
      session.close();
    } else if (client2.upgrading) {
      debug$8("transport has already been trying to upgrade");
      session.close();
    } else if (client2.upgraded) {
      debug$8("transport had already been upgraded");
      session.close();
    } else {
      debug$8("upgrading existing transport");
      const transport2 = new webtransport_1.WebTransport(session, stream3, reader);
      client2.maybeUpgrade(transport2);
    }
  }
}
server.BaseServer = BaseServer;
BaseServer.errors = {
  UNKNOWN_TRANSPORT: 0,
  UNKNOWN_SID: 1,
  BAD_HANDSHAKE_METHOD: 2,
  BAD_REQUEST: 3,
  FORBIDDEN: 4,
  UNSUPPORTED_PROTOCOL_VERSION: 5
};
BaseServer.errorMessages = {
  0: "Transport unknown",
  1: "Session ID unknown",
  2: "Bad handshake method",
  3: "Bad request",
  4: "Forbidden",
  5: "Unsupported protocol version"
};
class WebSocketResponse {
  constructor(req2, socket2) {
    this.req = req2;
    this.socket = socket2;
    req2[kResponseHeaders] = {};
  }
  setHeader(name2, value) {
    this.req[kResponseHeaders][name2] = value;
  }
  getHeader(name2) {
    return this.req[kResponseHeaders][name2];
  }
  removeHeader(name2) {
    delete this.req[kResponseHeaders][name2];
  }
  write() {
  }
  writeHead() {
  }
  end() {
    this.socket.destroy();
  }
}
let Server$1 = class Server extends BaseServer {
  /**
   * Initialize websocket server
   *
   * @api protected
   */
  init() {
    if (!~this.opts.transports.indexOf("websocket"))
      return;
    if (this.ws)
      this.ws.close();
    this.ws = new this.opts.wsEngine({
      noServer: true,
      clientTracking: false,
      perMessageDeflate: this.opts.perMessageDeflate,
      maxPayload: this.opts.maxHttpBufferSize
    });
    if (typeof this.ws.on === "function") {
      this.ws.on("headers", (headersArray, req2) => {
        const additionalHeaders = req2[kResponseHeaders] || {};
        delete req2[kResponseHeaders];
        const isInitialRequest = !req2._query.sid;
        if (isInitialRequest) {
          this.emit("initial_headers", additionalHeaders, req2);
        }
        this.emit("headers", additionalHeaders, req2);
        debug$8("writing headers: %j", additionalHeaders);
        Object.keys(additionalHeaders).forEach((key) => {
          headersArray.push(`${key}: ${additionalHeaders[key]}`);
        });
      });
    }
  }
  cleanup() {
    if (this.ws) {
      debug$8("closing webSocketServer");
      this.ws.close();
    }
  }
  /**
   * Prepares a request by processing the query string.
   *
   * @api private
   */
  prepare(req2) {
    if (!req2._query) {
      req2._query = ~req2.url.indexOf("?") ? qs.parse((0, url_1.parse)(req2.url).query) : {};
    }
  }
  createTransport(transportName, req2) {
    return new transports_1.default[transportName](req2);
  }
  /**
   * Handles an Engine.IO HTTP request.
   *
   * @param {IncomingMessage} req
   * @param {ServerResponse} res
   * @api public
   */
  handleRequest(req2, res2) {
    debug$8('handling "%s" http request "%s"', req2.method, req2.url);
    this.prepare(req2);
    req2.res = res2;
    const callback = (errorCode, errorContext) => {
      if (errorCode !== void 0) {
        this.emit("connection_error", {
          req: req2,
          code: errorCode,
          message: Server.errorMessages[errorCode],
          context: errorContext
        });
        abortRequest(res2, errorCode, errorContext);
        return;
      }
      if (req2._query.sid) {
        debug$8("setting new request for existing client");
        this.clients[req2._query.sid].transport.onRequest(req2);
      } else {
        const closeConnection = (errorCode2, errorContext2) => abortRequest(res2, errorCode2, errorContext2);
        this.handshake(req2._query.transport, req2, closeConnection);
      }
    };
    this._applyMiddlewares(req2, res2, (err) => {
      if (err) {
        callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
      } else {
        this.verify(req2, false, callback);
      }
    });
  }
  /**
   * Handles an Engine.IO HTTP Upgrade.
   *
   * @api public
   */
  handleUpgrade(req2, socket2, upgradeHead) {
    this.prepare(req2);
    const res2 = new WebSocketResponse(req2, socket2);
    const callback = (errorCode, errorContext) => {
      if (errorCode !== void 0) {
        this.emit("connection_error", {
          req: req2,
          code: errorCode,
          message: Server.errorMessages[errorCode],
          context: errorContext
        });
        abortUpgrade(socket2, errorCode, errorContext);
        return;
      }
      const head = Buffer.from(upgradeHead);
      upgradeHead = null;
      res2.writeHead();
      this.ws.handleUpgrade(req2, socket2, head, (websocket2) => {
        this.onWebSocket(req2, socket2, websocket2);
      });
    };
    this._applyMiddlewares(req2, res2, (err) => {
      if (err) {
        callback(Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
      } else {
        this.verify(req2, true, callback);
      }
    });
  }
  /**
   * Called upon a ws.io connection.
   *
   * @param {ws.Socket} websocket
   * @api private
   */
  onWebSocket(req2, socket2, websocket2) {
    websocket2.on("error", onUpgradeError);
    if (transports_1.default[req2._query.transport] !== void 0 && !transports_1.default[req2._query.transport].prototype.handlesUpgrades) {
      debug$8("transport doesnt handle upgraded requests");
      websocket2.close();
      return;
    }
    const id = req2._query.sid;
    req2.websocket = websocket2;
    if (id) {
      const client2 = this.clients[id];
      if (!client2) {
        debug$8("upgrade attempt for closed client");
        websocket2.close();
      } else if (client2.upgrading) {
        debug$8("transport has already been trying to upgrade");
        websocket2.close();
      } else if (client2.upgraded) {
        debug$8("transport had already been upgraded");
        websocket2.close();
      } else {
        debug$8("upgrading existing transport");
        websocket2.removeListener("error", onUpgradeError);
        const transport2 = this.createTransport(req2._query.transport, req2);
        transport2.perMessageDeflate = this.opts.perMessageDeflate;
        client2.maybeUpgrade(transport2);
      }
    } else {
      const closeConnection = (errorCode, errorContext) => abortUpgrade(socket2, errorCode, errorContext);
      this.handshake(req2._query.transport, req2, closeConnection);
    }
    function onUpgradeError() {
      debug$8("websocket error before upgrade");
    }
  }
  /**
   * Captures upgrade requests for a http.Server.
   *
   * @param {http.Server} server
   * @param {Object} options
   * @api public
   */
  attach(server2, options2 = {}) {
    const path3 = this._computePath(options2);
    const destroyUpgradeTimeout = options2.destroyUpgradeTimeout || 1e3;
    function check(req2) {
      return path3 === req2.url.slice(0, path3.length);
    }
    const listeners = server2.listeners("request").slice(0);
    server2.removeAllListeners("request");
    server2.on("close", this.close.bind(this));
    server2.on("listening", this.init.bind(this));
    server2.on("request", (req2, res2) => {
      if (check(req2)) {
        debug$8('intercepting request for path "%s"', path3);
        this.handleRequest(req2, res2);
      } else {
        let i2 = 0;
        const l = listeners.length;
        for (; i2 < l; i2++) {
          listeners[i2].call(server2, req2, res2);
        }
      }
    });
    if (~this.opts.transports.indexOf("websocket")) {
      server2.on("upgrade", (req2, socket2, head) => {
        if (check(req2)) {
          this.handleUpgrade(req2, socket2, head);
        } else if (false !== options2.destroyUpgrade) {
          setTimeout(function() {
            if (socket2.writable && socket2.bytesWritten <= 0) {
              socket2.on("error", (e) => {
                debug$8("error while destroying upgrade: %s", e.message);
              });
              return socket2.end();
            }
          }, destroyUpgradeTimeout);
        }
      });
    }
  }
};
server.Server = Server$1;
function abortRequest(res2, errorCode, errorContext) {
  const statusCode = errorCode === Server$1.errors.FORBIDDEN ? 403 : 400;
  const message = errorContext && errorContext.message ? errorContext.message : Server$1.errorMessages[errorCode];
  res2.writeHead(statusCode, { "Content-Type": "application/json" });
  res2.end(JSON.stringify({
    code: errorCode,
    message
  }));
}
function abortUpgrade(socket2, errorCode, errorContext = {}) {
  socket2.on("error", () => {
    debug$8("ignoring error from closed connection");
  });
  if (socket2.writable) {
    const message = errorContext.message || Server$1.errorMessages[errorCode];
    const length2 = Buffer.byteLength(message);
    socket2.write("HTTP/1.1 400 Bad Request\r\nConnection: close\r\nContent-type: text/html\r\nContent-Length: " + length2 + "\r\n\r\n" + message);
  }
  socket2.destroy();
}
const validHdrChars = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1
  // ... 255
];
function checkInvalidHeaderChar(val) {
  val += "";
  if (val.length < 1)
    return false;
  if (!validHdrChars[val.charCodeAt(0)]) {
    debug$8('invalid header, index 0, char "%s"', val.charCodeAt(0));
    return true;
  }
  if (val.length < 2)
    return false;
  if (!validHdrChars[val.charCodeAt(1)]) {
    debug$8('invalid header, index 1, char "%s"', val.charCodeAt(1));
    return true;
  }
  if (val.length < 3)
    return false;
  if (!validHdrChars[val.charCodeAt(2)]) {
    debug$8('invalid header, index 2, char "%s"', val.charCodeAt(2));
    return true;
  }
  if (val.length < 4)
    return false;
  if (!validHdrChars[val.charCodeAt(3)]) {
    debug$8('invalid header, index 3, char "%s"', val.charCodeAt(3));
    return true;
  }
  for (let i2 = 4; i2 < val.length; ++i2) {
    if (!validHdrChars[val.charCodeAt(i2)]) {
      debug$8('invalid header, index "%i", char "%s"', i2, val.charCodeAt(i2));
      return true;
    }
  }
  return false;
}
var userver = {};
var transportsUws = {};
var polling = {};
Object.defineProperty(polling, "__esModule", { value: true });
polling.Polling = void 0;
const transport_1$1 = transport;
const zlib_1 = require$$2$2;
const accepts = accepts$3;
const debug_1$5 = browserExports;
const debug$7 = (0, debug_1$5.default)("engine:polling");
const compressionMethods = {
  gzip: zlib_1.createGzip,
  deflate: zlib_1.createDeflate
};
class Polling2 extends transport_1$1.Transport {
  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  constructor(req2) {
    super(req2);
    this.closeTimeout = 30 * 1e3;
  }
  /**
   * Transport name
   *
   * @api public
   */
  get name() {
    return "polling";
  }
  get supportsFraming() {
    return false;
  }
  /**
   * Overrides onRequest.
   *
   * @param req
   *
   * @api private
   */
  onRequest(req2) {
    const res2 = req2.res;
    req2.res = null;
    if (req2.getMethod() === "get") {
      this.onPollRequest(req2, res2);
    } else if (req2.getMethod() === "post") {
      this.onDataRequest(req2, res2);
    } else {
      res2.writeStatus("500 Internal Server Error");
      res2.end();
    }
  }
  /**
   * The client sends a request awaiting for us to send data.
   *
   * @api private
   */
  onPollRequest(req2, res2) {
    if (this.req) {
      debug$7("request overlap");
      this.onError("overlap from client");
      res2.writeStatus("500 Internal Server Error");
      res2.end();
      return;
    }
    debug$7("setting request");
    this.req = req2;
    this.res = res2;
    const onClose = () => {
      this.writable = false;
      this.onError("poll connection closed prematurely");
    };
    const cleanup = () => {
      this.req = this.res = null;
    };
    req2.cleanup = cleanup;
    res2.onAborted(onClose);
    this.writable = true;
    this.emit("drain");
    if (this.writable && this.shouldClose) {
      debug$7("triggering empty send to append close packet");
      this.send([{ type: "noop" }]);
    }
  }
  /**
   * The client sends a request with data.
   *
   * @api private
   */
  onDataRequest(req2, res2) {
    if (this.dataReq) {
      this.onError("data request overlap from client");
      res2.writeStatus("500 Internal Server Error");
      res2.end();
      return;
    }
    const expectedContentLength = Number(req2.headers["content-length"]);
    if (!expectedContentLength) {
      this.onError("content-length header required");
      res2.writeStatus("411 Length Required").end();
      return;
    }
    if (expectedContentLength > this.maxHttpBufferSize) {
      this.onError("payload too large");
      res2.writeStatus("413 Payload Too Large").end();
      return;
    }
    const isBinary2 = "application/octet-stream" === req2.headers["content-type"];
    if (isBinary2 && this.protocol === 4) {
      return this.onError("invalid content");
    }
    this.dataReq = req2;
    this.dataRes = res2;
    let buffer2;
    let offset = 0;
    const headers = {
      // text/html is required instead of text/plain to avoid an
      // unwanted download dialog on certain user-agents (GH-43)
      "Content-Type": "text/html"
    };
    this.headers(req2, headers);
    for (let key in headers) {
      res2.writeHeader(key, String(headers[key]));
    }
    const onEnd = (buffer3) => {
      this.onData(buffer3.toString());
      this.onDataRequestCleanup();
      res2.cork(() => {
        res2.end("ok");
      });
    };
    res2.onAborted(() => {
      this.onDataRequestCleanup();
      this.onError("data request connection closed prematurely");
    });
    res2.onData((arrayBuffer, isLast) => {
      const totalLength = offset + arrayBuffer.byteLength;
      if (totalLength > expectedContentLength) {
        this.onError("content-length mismatch");
        res2.close();
        return;
      }
      if (!buffer2) {
        if (isLast) {
          onEnd(Buffer.from(arrayBuffer));
          return;
        }
        buffer2 = Buffer.allocUnsafe(expectedContentLength);
      }
      Buffer.from(arrayBuffer).copy(buffer2, offset);
      if (isLast) {
        if (totalLength != expectedContentLength) {
          this.onError("content-length mismatch");
          res2.writeStatus("400 Content-Length Mismatch").end();
          this.onDataRequestCleanup();
          return;
        }
        onEnd(buffer2);
        return;
      }
      offset = totalLength;
    });
  }
  /**
   * Cleanup request.
   *
   * @api private
   */
  onDataRequestCleanup() {
    this.dataReq = this.dataRes = null;
  }
  /**
   * Processes the incoming data payload.
   *
   * @param {String} encoded payload
   * @api private
   */
  onData(data) {
    debug$7('received "%s"', data);
    const callback = (packet) => {
      if ("close" === packet.type) {
        debug$7("got xhr close packet");
        this.onClose();
        return false;
      }
      this.onPacket(packet);
    };
    if (this.protocol === 3) {
      this.parser.decodePayload(data, callback);
    } else {
      this.parser.decodePayload(data).forEach(callback);
    }
  }
  /**
   * Overrides onClose.
   *
   * @api private
   */
  onClose() {
    if (this.writable) {
      this.send([{ type: "noop" }]);
    }
    super.onClose();
  }
  /**
   * Writes a packet payload.
   *
   * @param {Object} packet
   * @api private
   */
  send(packets) {
    this.writable = false;
    if (this.shouldClose) {
      debug$7("appending close packet to payload");
      packets.push({ type: "close" });
      this.shouldClose();
      this.shouldClose = null;
    }
    const doWrite = (data) => {
      const compress = packets.some((packet) => {
        return packet.options && packet.options.compress;
      });
      this.write(data, { compress });
    };
    if (this.protocol === 3) {
      this.parser.encodePayload(packets, this.supportsBinary, doWrite);
    } else {
      this.parser.encodePayload(packets, doWrite);
    }
  }
  /**
   * Writes data as response to poll request.
   *
   * @param {String} data
   * @param {Object} options
   * @api private
   */
  write(data, options2) {
    debug$7('writing "%s"', data);
    this.doWrite(data, options2, () => {
      this.req.cleanup();
    });
  }
  /**
   * Performs the write.
   *
   * @api private
   */
  doWrite(data, options2, callback) {
    const isString2 = typeof data === "string";
    const contentType3 = isString2 ? "text/plain; charset=UTF-8" : "application/octet-stream";
    const headers = {
      "Content-Type": contentType3
    };
    const respond = (data2) => {
      this.headers(this.req, headers);
      this.res.cork(() => {
        Object.keys(headers).forEach((key) => {
          this.res.writeHeader(key, String(headers[key]));
        });
        this.res.end(data2);
      });
      callback();
    };
    if (!this.httpCompression || !options2.compress) {
      respond(data);
      return;
    }
    const len = isString2 ? Buffer.byteLength(data) : data.length;
    if (len < this.httpCompression.threshold) {
      respond(data);
      return;
    }
    const encoding3 = accepts(this.req).encodings(["gzip", "deflate"]);
    if (!encoding3) {
      respond(data);
      return;
    }
    this.compress(data, encoding3, (err, data2) => {
      if (err) {
        this.res.writeStatus("500 Internal Server Error");
        this.res.end();
        callback(err);
        return;
      }
      headers["Content-Encoding"] = encoding3;
      respond(data2);
    });
  }
  /**
   * Compresses data.
   *
   * @api private
   */
  compress(data, encoding3, callback) {
    debug$7("compressing");
    const buffers = [];
    let nread = 0;
    compressionMethods[encoding3](this.httpCompression).on("error", callback).on("data", function(chunk) {
      buffers.push(chunk);
      nread += chunk.length;
    }).on("end", function() {
      callback(null, Buffer.concat(buffers, nread));
    }).end(data);
  }
  /**
   * Closes the transport.
   *
   * @api private
   */
  doClose(fn) {
    debug$7("closing");
    let closeTimeoutTimer;
    const onClose = () => {
      clearTimeout(closeTimeoutTimer);
      fn();
      this.onClose();
    };
    if (this.writable) {
      debug$7("transport writable - closing right away");
      this.send([{ type: "close" }]);
      onClose();
    } else if (this.discarded) {
      debug$7("transport discarded - closing right away");
      onClose();
    } else {
      debug$7("transport not writable - buffering orderly close");
      this.shouldClose = onClose;
      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
    }
  }
  /**
   * Returns headers for a response.
   *
   * @param req - request
   * @param {Object} extra headers
   * @api private
   */
  headers(req2, headers) {
    headers = headers || {};
    const ua = req2.headers["user-agent"];
    if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
      headers["X-XSS-Protection"] = "0";
    }
    headers["cache-control"] = "no-store";
    this.emit("headers", headers, req2);
    return headers;
  }
}
polling.Polling = Polling2;
var websocket = {};
Object.defineProperty(websocket, "__esModule", { value: true });
websocket.WebSocket = void 0;
const transport_1 = transport;
const debug_1$4 = browserExports;
const debug$6 = (0, debug_1$4.default)("engine:ws");
let WebSocket$1 = class WebSocket3 extends transport_1.Transport {
  /**
   * WebSocket transport
   *
   * @param req
   * @api public
   */
  constructor(req2) {
    super(req2);
    this.writable = false;
    this.perMessageDeflate = null;
  }
  /**
   * Transport name
   *
   * @api public
   */
  get name() {
    return "websocket";
  }
  /**
   * Advertise upgrade support.
   *
   * @api public
   */
  get handlesUpgrades() {
    return true;
  }
  /**
   * Advertise framing support.
   *
   * @api public
   */
  get supportsFraming() {
    return true;
  }
  /**
   * Writes a packet payload.
   *
   * @param {Array} packets
   * @api private
   */
  send(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const isLast = i2 + 1 === packets.length;
      const send4 = (data) => {
        const isBinary2 = typeof data !== "string";
        const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
        debug$6('writing "%s"', data);
        this.socket.send(data, isBinary2, compress);
        if (isLast) {
          this.writable = true;
          this.emit("drain");
        }
      };
      if (packet.options && typeof packet.options.wsPreEncoded === "string") {
        send4(packet.options.wsPreEncoded);
      } else {
        this.parser.encodePacket(packet, this.supportsBinary, send4);
      }
    }
  }
  /**
   * Closes the transport.
   *
   * @api private
   */
  doClose(fn) {
    debug$6("closing");
    fn && fn();
    this.socket.end();
  }
};
websocket.WebSocket = WebSocket$1;
Object.defineProperty(transportsUws, "__esModule", { value: true });
const polling_1 = polling;
const websocket_1 = websocket;
transportsUws.default = {
  polling: polling_1.Polling,
  websocket: websocket_1.WebSocket
};
Object.defineProperty(userver, "__esModule", { value: true });
userver.uServer = void 0;
const debug_1$3 = browserExports;
const server_1 = server;
const transports_uws_1 = transportsUws;
const debug$5 = (0, debug_1$3.default)("engine:uws");
class uServer extends server_1.BaseServer {
  init() {
  }
  cleanup() {
  }
  /**
   * Prepares a request by processing the query string.
   *
   * @api private
   */
  prepare(req2, res2) {
    req2.method = req2.getMethod().toUpperCase();
    req2.url = req2.getUrl();
    const params = new URLSearchParams(req2.getQuery());
    req2._query = Object.fromEntries(params.entries());
    req2.headers = {};
    req2.forEach((key, value) => {
      req2.headers[key] = value;
    });
    req2.connection = {
      remoteAddress: Buffer.from(res2.getRemoteAddressAsText()).toString()
    };
    res2.onAborted(() => {
      debug$5("response has been aborted");
    });
  }
  createTransport(transportName, req2) {
    return new transports_uws_1.default[transportName](req2);
  }
  /**
   * Attach the engine to a WebSockets.js server
   * @param app
   * @param options
   */
  attach(app2, options2 = {}) {
    const path3 = this._computePath(options2);
    app2.any(path3, this.handleRequest.bind(this)).ws(path3, {
      compression: options2.compression,
      idleTimeout: options2.idleTimeout,
      maxBackpressure: options2.maxBackpressure,
      maxPayloadLength: this.opts.maxHttpBufferSize,
      upgrade: this.handleUpgrade.bind(this),
      open: (ws2) => {
        const transport2 = ws2.getUserData().transport;
        transport2.socket = ws2;
        transport2.writable = true;
        transport2.emit("drain");
      },
      message: (ws2, message, isBinary2) => {
        ws2.getUserData().transport.onData(isBinary2 ? message : Buffer.from(message).toString());
      },
      close: (ws2, code, message) => {
        ws2.getUserData().transport.onClose(code, message);
      }
    });
  }
  _applyMiddlewares(req2, res2, callback) {
    if (this.middlewares.length === 0) {
      return callback();
    }
    req2.res = new ResponseWrapper(res2);
    super._applyMiddlewares(req2, req2.res, (err) => {
      req2.res.writeHead();
      callback(err);
    });
  }
  handleRequest(res2, req2) {
    debug$5('handling "%s" http request "%s"', req2.getMethod(), req2.getUrl());
    this.prepare(req2, res2);
    req2.res = res2;
    const callback = (errorCode, errorContext) => {
      if (errorCode !== void 0) {
        this.emit("connection_error", {
          req: req2,
          code: errorCode,
          message: server_1.Server.errorMessages[errorCode],
          context: errorContext
        });
        this.abortRequest(req2.res, errorCode, errorContext);
        return;
      }
      if (req2._query.sid) {
        debug$5("setting new request for existing client");
        this.clients[req2._query.sid].transport.onRequest(req2);
      } else {
        const closeConnection = (errorCode2, errorContext2) => this.abortRequest(res2, errorCode2, errorContext2);
        this.handshake(req2._query.transport, req2, closeConnection);
      }
    };
    this._applyMiddlewares(req2, res2, (err) => {
      if (err) {
        callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
      } else {
        this.verify(req2, false, callback);
      }
    });
  }
  handleUpgrade(res2, req2, context) {
    debug$5("on upgrade");
    this.prepare(req2, res2);
    req2.res = res2;
    const callback = async (errorCode, errorContext) => {
      if (errorCode !== void 0) {
        this.emit("connection_error", {
          req: req2,
          code: errorCode,
          message: server_1.Server.errorMessages[errorCode],
          context: errorContext
        });
        this.abortRequest(res2, errorCode, errorContext);
        return;
      }
      const id = req2._query.sid;
      let transport2;
      if (id) {
        const client2 = this.clients[id];
        if (!client2) {
          debug$5("upgrade attempt for closed client");
          res2.close();
        } else if (client2.upgrading) {
          debug$5("transport has already been trying to upgrade");
          res2.close();
        } else if (client2.upgraded) {
          debug$5("transport had already been upgraded");
          res2.close();
        } else {
          debug$5("upgrading existing transport");
          transport2 = this.createTransport(req2._query.transport, req2);
          client2.maybeUpgrade(transport2);
        }
      } else {
        transport2 = await this.handshake(req2._query.transport, req2, (errorCode2, errorContext2) => this.abortRequest(res2, errorCode2, errorContext2));
        if (!transport2) {
          return;
        }
      }
      req2.res.writeStatus("101 Switching Protocols");
      res2.upgrade({
        transport: transport2
      }, req2.getHeader("sec-websocket-key"), req2.getHeader("sec-websocket-protocol"), req2.getHeader("sec-websocket-extensions"), context);
    };
    this._applyMiddlewares(req2, res2, (err) => {
      if (err) {
        callback(server_1.Server.errors.BAD_REQUEST, { name: "MIDDLEWARE_FAILURE" });
      } else {
        this.verify(req2, true, callback);
      }
    });
  }
  abortRequest(res2, errorCode, errorContext) {
    const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
    const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
    res2.writeStatus(statusCode);
    res2.writeHeader("Content-Type", "application/json");
    res2.end(JSON.stringify({
      code: errorCode,
      message
    }));
  }
}
userver.uServer = uServer;
class ResponseWrapper {
  constructor(res2) {
    this.res = res2;
    this.statusWritten = false;
    this.headers = [];
    this.isAborted = false;
  }
  set statusCode(status3) {
    if (!status3) {
      return;
    }
    this.writeStatus(status3 === 200 ? "200 OK" : "204 No Content");
  }
  writeHead(status3) {
    this.statusCode = status3;
  }
  setHeader(key, value) {
    if (Array.isArray(value)) {
      value.forEach((val) => {
        this.writeHeader(key, val);
      });
    } else {
      this.writeHeader(key, value);
    }
  }
  removeHeader() {
  }
  // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134
  getHeader() {
  }
  writeStatus(status3) {
    if (this.isAborted)
      return;
    this.res.writeStatus(status3);
    this.statusWritten = true;
    this.writeBufferedHeaders();
    return this;
  }
  writeHeader(key, value) {
    if (this.isAborted)
      return;
    if (key === "Content-Length") {
      return;
    }
    if (this.statusWritten) {
      this.res.writeHeader(key, value);
    } else {
      this.headers.push([key, value]);
    }
  }
  writeBufferedHeaders() {
    this.headers.forEach(([key, value]) => {
      this.res.writeHeader(key, value);
    });
  }
  end(data) {
    if (this.isAborted)
      return;
    this.res.cork(() => {
      if (!this.statusWritten) {
        this.writeBufferedHeaders();
      }
      this.res.end(data);
    });
  }
  onData(fn) {
    if (this.isAborted)
      return;
    this.res.onData(fn);
  }
  onAborted(fn) {
    if (this.isAborted)
      return;
    this.res.onAborted(() => {
      this.isAborted = true;
      fn();
    });
  }
  cork(fn) {
    if (this.isAborted)
      return;
    this.res.cork(fn);
  }
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.protocol = exports2.Transport = exports2.Socket = exports2.uServer = exports2.parser = exports2.attach = exports2.listen = exports2.transports = exports2.Server = void 0;
  const http_1 = require$$2$2;
  const server_12 = server;
  Object.defineProperty(exports2, "Server", { enumerable: true, get: function() {
    return server_12.Server;
  } });
  const index_1 = transports;
  exports2.transports = index_1.default;
  const parser = cjs$1;
  exports2.parser = parser;
  var userver_1 = userver;
  Object.defineProperty(exports2, "uServer", { enumerable: true, get: function() {
    return userver_1.uServer;
  } });
  var socket_12 = socket$1;
  Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
    return socket_12.Socket;
  } });
  var transport_12 = transport;
  Object.defineProperty(exports2, "Transport", { enumerable: true, get: function() {
    return transport_12.Transport;
  } });
  exports2.protocol = parser.protocol;
  function listen(port2, options2, fn) {
    if ("function" === typeof options2) {
      fn = options2;
      options2 = {};
    }
    const server2 = (0, http_1.createServer)(function(req2, res2) {
      res2.writeHead(501);
      res2.end("Not Implemented");
    });
    const engine = attach(server2, options2);
    engine.httpServer = server2;
    server2.listen(port2, fn);
    return engine;
  }
  exports2.listen = listen;
  function attach(server2, options2) {
    const engine = new server_12.Server(options2);
    engine.attach(server2, options2);
    return engine;
  }
  exports2.attach = attach;
})(engine_io);
var client = {};
var cjs = {};
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }
  on.fn = fn;
  this.on(event, on);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Emitter
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esm);
var binary = {};
var isBinary$1 = {};
Object.defineProperty(isBinary$1, "__esModule", { value: true });
isBinary$1.hasBinary = isBinary$1.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString$4 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$4.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$4.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
isBinary$1.isBinary = isBinary;
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
isBinary$1.hasBinary = hasBinary;
Object.defineProperty(binary, "__esModule", { value: true });
binary.reconstructPacket = binary.deconstructPacket = void 0;
const is_binary_js_1 = isBinary$1;
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
binary.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if ((0, is_binary_js_1.isBinary)(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
binary.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Decoder = exports2.Encoder = exports2.PacketType = exports2.protocol = void 0;
  const component_emitter_1 = require$$0;
  const binary_js_1 = binary;
  const is_binary_js_12 = isBinary$1;
  const debug_12 = browserExports;
  const debug2 = (0, debug_12.default)("socket.io-parser");
  const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
    // used by the Node.js EventEmitter
  ];
  exports2.protocol = 5;
  var PacketType;
  (function(PacketType2) {
    PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
    PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
    PacketType2[PacketType2["ACK"] = 3] = "ACK";
    PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType = exports2.PacketType || (exports2.PacketType = {}));
  class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
      this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
      debug2("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if ((0, is_binary_js_12.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
      let str = "" + obj.type;
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      if (null != obj.id) {
        str += obj.id;
      }
      if (null != obj.data) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      debug2("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
      const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers = deconstruction.buffers;
      buffers.unshift(pack);
      return buffers;
    }
  }
  exports2.Encoder = Encoder;
  function isObject2(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  class Decoder extends component_emitter_1.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
      super();
      this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          this.reconstructor = new BinaryReconstructor(packet);
          if (packet.attachments === 0) {
            super.emitReserved("decoded", packet);
          }
        } else {
          super.emitReserved("decoded", packet);
        }
      } else if ((0, is_binary_js_12.isBinary)(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emitReserved("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
      let i2 = 0;
      const p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === void 0) {
        throw new Error("unknown packet type " + p.type);
      }
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        const start = i2 + 1;
        while (str.charAt(++i2) !== "-" && i2 != str.length) {
        }
        const buf = str.substring(start, i2);
        if (buf != Number(buf) || str.charAt(i2) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      if ("/" === str.charAt(i2 + 1)) {
        const start = i2 + 1;
        while (++i2) {
          const c = str.charAt(i2);
          if ("," === c)
            break;
          if (i2 === str.length)
            break;
        }
        p.nsp = str.substring(start, i2);
      } else {
        p.nsp = "/";
      }
      const next = str.charAt(i2 + 1);
      if ("" !== next && Number(next) == next) {
        const start = i2 + 1;
        while (++i2) {
          const c = str.charAt(i2);
          if (null == c || Number(c) != c) {
            --i2;
            break;
          }
          if (i2 === str.length)
            break;
        }
        p.id = Number(str.substring(start, i2 + 1));
      }
      if (str.charAt(++i2)) {
        const payload = this.tryParse(str.substr(i2));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug2("decoded %s as %j", str, p);
      return p;
    }
    tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    }
    static isPayloadValid(type3, payload) {
      switch (type3) {
        case PacketType.CONNECT:
          return isObject2(payload);
        case PacketType.DISCONNECT:
          return payload === void 0;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject2(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }
  exports2.Decoder = Decoder;
  class BinaryReconstructor {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }
})(cjs);
Object.defineProperty(client, "__esModule", { value: true });
client.Client = void 0;
const socket_io_parser_1 = cjs;
const debugModule = browserExports;
const url = require$$2$2;
const debug$4 = debugModule("socket.io:client");
class Client {
  /**
   * Client constructor.
   *
   * @param server instance
   * @param conn
   * @package
   */
  constructor(server2, conn) {
    this.sockets = /* @__PURE__ */ new Map();
    this.nsps = /* @__PURE__ */ new Map();
    this.server = server2;
    this.conn = conn;
    this.encoder = server2.encoder;
    this.decoder = new server2._parser.Decoder();
    this.id = conn.id;
    this.setup();
  }
  /**
   * @return the reference to the request that originated the Engine.IO connection
   *
   * @public
   */
  get request() {
    return this.conn.request;
  }
  /**
   * Sets up event listeners.
   *
   * @private
   */
  setup() {
    this.onclose = this.onclose.bind(this);
    this.ondata = this.ondata.bind(this);
    this.onerror = this.onerror.bind(this);
    this.ondecoded = this.ondecoded.bind(this);
    this.decoder.on("decoded", this.ondecoded);
    this.conn.on("data", this.ondata);
    this.conn.on("error", this.onerror);
    this.conn.on("close", this.onclose);
    this.connectTimeout = setTimeout(() => {
      if (this.nsps.size === 0) {
        debug$4("no namespace joined yet, close the client");
        this.close();
      } else {
        debug$4("the client has already joined a namespace, nothing to do");
      }
    }, this.server._connectTimeout);
  }
  /**
   * Connects a client to a namespace.
   *
   * @param {String} name - the namespace
   * @param {Object} auth - the auth parameters
   * @private
   */
  connect(name2, auth = {}) {
    if (this.server._nsps.has(name2)) {
      debug$4("connecting to namespace %s", name2);
      return this.doConnect(name2, auth);
    }
    this.server._checkNamespace(name2, auth, (dynamicNspName) => {
      if (dynamicNspName) {
        this.doConnect(name2, auth);
      } else {
        debug$4("creation of namespace %s was denied", name2);
        this._packet({
          type: socket_io_parser_1.PacketType.CONNECT_ERROR,
          nsp: name2,
          data: {
            message: "Invalid namespace"
          }
        });
      }
    });
  }
  /**
   * Connects a client to a namespace.
   *
   * @param name - the namespace
   * @param {Object} auth - the auth parameters
   *
   * @private
   */
  doConnect(name2, auth) {
    const nsp = this.server.of(name2);
    nsp._add(this, auth, (socket2) => {
      this.sockets.set(socket2.id, socket2);
      this.nsps.set(nsp.name, socket2);
      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = void 0;
      }
    });
  }
  /**
   * Disconnects from all namespaces and closes transport.
   *
   * @private
   */
  _disconnect() {
    for (const socket2 of this.sockets.values()) {
      socket2.disconnect();
    }
    this.sockets.clear();
    this.close();
  }
  /**
   * Removes a socket. Called by each `Socket`.
   *
   * @private
   */
  _remove(socket2) {
    if (this.sockets.has(socket2.id)) {
      const nsp = this.sockets.get(socket2.id).nsp.name;
      this.sockets.delete(socket2.id);
      this.nsps.delete(nsp);
    } else {
      debug$4("ignoring remove for %s", socket2.id);
    }
  }
  /**
   * Closes the underlying connection.
   *
   * @private
   */
  close() {
    if ("open" === this.conn.readyState) {
      debug$4("forcing transport close");
      this.conn.close();
      this.onclose("forced server close");
    }
  }
  /**
   * Writes a packet to the transport.
   *
   * @param {Object} packet object
   * @param {Object} opts
   * @private
   */
  _packet(packet, opts = {}) {
    if (this.conn.readyState !== "open") {
      debug$4("ignoring packet write %j", packet);
      return;
    }
    const encodedPackets = opts.preEncoded ? packet : this.encoder.encode(packet);
    this.writeToEngine(encodedPackets, opts);
  }
  writeToEngine(encodedPackets, opts) {
    if (opts.volatile && !this.conn.transport.writable) {
      debug$4("volatile packet is discarded since the transport is not currently writable");
      return;
    }
    const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];
    for (const encodedPacket of packets) {
      this.conn.write(encodedPacket, opts);
    }
  }
  /**
   * Called with incoming transport data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      debug$4("invalid packet format");
      this.onerror(e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    let namespace2;
    let authPayload;
    if (this.conn.protocol === 3) {
      const parsed = url.parse(packet.nsp, true);
      namespace2 = parsed.pathname;
      authPayload = parsed.query;
    } else {
      namespace2 = packet.nsp;
      authPayload = packet.data;
    }
    const socket2 = this.nsps.get(namespace2);
    if (!socket2 && packet.type === socket_io_parser_1.PacketType.CONNECT) {
      this.connect(namespace2, authPayload);
    } else if (socket2 && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {
      process.nextTick(function() {
        socket2._onpacket(packet);
      });
    } else {
      debug$4("invalid state (packet type: %s)", packet.type);
      this.close();
    }
  }
  /**
   * Handles an error.
   *
   * @param {Object} err object
   * @private
   */
  onerror(err) {
    for (const socket2 of this.sockets.values()) {
      socket2._onerror(err);
    }
    this.conn.close();
  }
  /**
   * Called upon transport close.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description2) {
    debug$4("client close with reason %s", reason);
    this.destroy();
    for (const socket2 of this.sockets.values()) {
      socket2._onclose(reason, description2);
    }
    this.sockets.clear();
    this.decoder.destroy();
  }
  /**
   * Cleans up event listeners.
   * @private
   */
  destroy() {
    this.conn.removeListener("data", this.ondata);
    this.conn.removeListener("error", this.onerror);
    this.conn.removeListener("close", this.onclose);
    this.decoder.removeListener("decoded", this.ondecoded);
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
  }
}
client.Client = Client;
var namespace = {};
var socket = {};
var typedEvents = {};
Object.defineProperty(typedEvents, "__esModule", { value: true });
typedEvents.StrictEventEmitter = void 0;
const events_1$1 = require$$2$2;
class StrictEventEmitter extends events_1$1.EventEmitter {
  /**
   * Adds the `listener` function as an event listener for `ev`.
   *
   * @param ev Name of the event
   * @param listener Callback function
   */
  on(ev, listener2) {
    return super.on(ev, listener2);
  }
  /**
   * Adds a one-time `listener` function as an event listener for `ev`.
   *
   * @param ev Name of the event
   * @param listener Callback function
   */
  once(ev, listener2) {
    return super.once(ev, listener2);
  }
  /**
   * Emits an event.
   *
   * @param ev Name of the event
   * @param args Values to send to listeners of this event
   */
  emit(ev, ...args) {
    return super.emit(ev, ...args);
  }
  /**
   * Emits a reserved event.
   *
   * This method is `protected`, so that only a class extending
   * `StrictEventEmitter` can emit its own reserved events.
   *
   * @param ev Reserved event name
   * @param args Arguments to emit along with the event
   */
  emitReserved(ev, ...args) {
    return super.emit(ev, ...args);
  }
  /**
   * Emits an event.
   *
   * This method is `protected`, so that only a class extending
   * `StrictEventEmitter` can get around the strict typing. This is useful for
   * calling `emit.apply`, which can be called as `emitUntyped.apply`.
   *
   * @param ev Event name
   * @param args Arguments to emit along with the event
   */
  emitUntyped(ev, ...args) {
    return super.emit(ev, ...args);
  }
  /**
   * Returns the listeners listening to an event.
   *
   * @param event Event name
   * @returns Array of listeners subscribed to `event`
   */
  listeners(event) {
    return super.listeners(event);
  }
}
typedEvents.StrictEventEmitter = StrictEventEmitter;
var broadcastOperator = {};
var hasRequiredBroadcastOperator;
function requireBroadcastOperator() {
  if (hasRequiredBroadcastOperator)
    return broadcastOperator;
  hasRequiredBroadcastOperator = 1;
  Object.defineProperty(broadcastOperator, "__esModule", { value: true });
  broadcastOperator.RemoteSocket = broadcastOperator.BroadcastOperator = void 0;
  const socket_12 = requireSocket();
  const socket_io_parser_12 = cjs;
  class BroadcastOperator {
    constructor(adapter, rooms = /* @__PURE__ */ new Set(), exceptRooms = /* @__PURE__ */ new Set(), flags = {}) {
      this.adapter = adapter;
      this.rooms = rooms;
      this.exceptRooms = exceptRooms;
      this.flags = flags;
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
      const rooms = new Set(this.rooms);
      if (Array.isArray(room)) {
        room.forEach((r) => rooms.add(r));
      } else {
        rooms.add(room);
      }
      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
      return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
      const exceptRooms = new Set(this.exceptRooms);
      if (Array.isArray(room)) {
        room.forEach((r) => exceptRooms.add(r));
      } else {
        exceptRooms.add(room);
      }
      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     */
    compress(compress) {
      const flags = Object.assign({}, this.flags, { compress });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new BroadcastOperator instance
     */
    get volatile() {
      const flags = Object.assign({}, this.flags, { volatile: true });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the foo event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
      const flags = Object.assign({}, this.flags, { local: true });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Adds a timeout in milliseconds for the next operation
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
      const flags = Object.assign({}, this.flags, { timeout });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Emits to all clients.
     *
     * @example
     * // the foo event will be broadcast to all connected clients
     * io.emit("foo", "bar");
     *
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an acknowledgement expected from all connected clients
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */
    emit(ev, ...args) {
      if (socket_12.RESERVED_EVENTS.has(ev)) {
        throw new Error(`"${String(ev)}" is a reserved event name`);
      }
      const data = [ev, ...args];
      const packet = {
        type: socket_io_parser_12.PacketType.EVENT,
        data
      };
      const withAck = typeof data[data.length - 1] === "function";
      if (!withAck) {
        this.adapter.broadcast(packet, {
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        });
        return true;
      }
      const ack = data.pop();
      let timedOut = false;
      let responses = [];
      const timer = setTimeout(() => {
        timedOut = true;
        ack.apply(this, [
          new Error("operation has timed out"),
          this.flags.expectSingleResponse ? null : responses
        ]);
      }, this.flags.timeout);
      let expectedServerCount = -1;
      let actualServerCount = 0;
      let expectedClientCount = 0;
      const checkCompleteness = () => {
        if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
          clearTimeout(timer);
          ack.apply(this, [
            null,
            this.flags.expectSingleResponse ? responses[0] : responses
          ]);
        }
      };
      this.adapter.broadcastWithAck(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, (clientCount) => {
        expectedClientCount += clientCount;
        actualServerCount++;
        checkCompleteness();
      }, (clientResponse) => {
        responses.push(clientResponse);
        checkCompleteness();
      });
      this.adapter.serverCount().then((serverCount) => {
        expectedServerCount = serverCount;
        checkCompleteness();
      });
      return true;
    }
    /**
     * Emits an event and waits for an acknowledgement from all clients.
     *
     * @example
     * try {
     *   const responses = await io.timeout(1000).emitWithAck("some-event");
     *   console.log(responses); // one response per client
     * } catch (e) {
     *   // some clients did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when all clients have acknowledged the event
     */
    emitWithAck(ev, ...args) {
      return new Promise((resolve3, reject) => {
        args.push((err, responses) => {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve3(responses);
          }
        });
        this.emit(ev, ...args);
      });
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link fetchSockets} instead.
     */
    allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }
      return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }).then((sockets) => {
        return sockets.map((socket2) => {
          if (socket2 instanceof socket_12.Socket) {
            return socket2;
          } else {
            return new RemoteSocket(this.adapter, socket2);
          }
        });
      });
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, close);
    }
  }
  broadcastOperator.BroadcastOperator = BroadcastOperator;
  class RemoteSocket {
    constructor(adapter, details) {
      this.id = details.id;
      this.handshake = details.handshake;
      this.rooms = new Set(details.rooms);
      this.data = details.data;
      this.operator = new BroadcastOperator(adapter, /* @__PURE__ */ new Set([this.id]), /* @__PURE__ */ new Set(), {
        expectSingleResponse: true
        // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()
      });
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const sockets = await io.fetchSockets();
     *
     * for (const socket of sockets) {
     *   if (someCondition) {
     *     socket.timeout(1000).emit("some-event", (err) => {
     *       if (err) {
     *         // the client did not acknowledge the event in the given delay
     *       }
     *     });
     *   }
     * }
     *
     * // note: if possible, using a room instead of looping over all sockets is preferable
     * io.timeout(1000).to(someConditionRoom).emit("some-event", (err, responses) => {
     *   // ...
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
      return this.operator.timeout(timeout);
    }
    emit(ev, ...args) {
      return this.operator.emit(ev, ...args);
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     */
    join(room) {
      return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     */
    leave(room) {
      return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     */
    disconnect(close = false) {
      this.operator.disconnectSockets(close);
      return this;
    }
  }
  broadcastOperator.RemoteSocket = RemoteSocket;
  return broadcastOperator;
}
var hasRequiredSocket;
function requireSocket() {
  if (hasRequiredSocket)
    return socket;
  hasRequiredSocket = 1;
  (function(exports2) {
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Socket = exports2.RESERVED_EVENTS = void 0;
    const socket_io_parser_12 = cjs;
    const debug_12 = __importDefault2(browserExports);
    const typed_events_1 = typedEvents;
    const base64id_1 = __importDefault2(base64idExports);
    const broadcast_operator_1 = requireBroadcastOperator();
    const debug2 = (0, debug_12.default)("socket.io:socket");
    const RECOVERABLE_DISCONNECT_REASONS = /* @__PURE__ */ new Set([
      "transport error",
      "transport close",
      "forced close",
      "ping timeout",
      "server shutting down",
      "forced server close"
    ]);
    exports2.RESERVED_EVENTS = /* @__PURE__ */ new Set([
      "connect",
      "connect_error",
      "disconnect",
      "disconnecting",
      "newListener",
      "removeListener"
    ]);
    function noop2() {
    }
    class Socket3 extends typed_events_1.StrictEventEmitter {
      /**
       * Interface to a `Client` for a given `Namespace`.
       *
       * @param {Namespace} nsp
       * @param {Client} client
       * @param {Object} auth
       * @package
       */
      constructor(nsp, client2, auth, previousSession) {
        super();
        this.nsp = nsp;
        this.client = client2;
        this.recovered = false;
        this.data = {};
        this.connected = false;
        this.acks = /* @__PURE__ */ new Map();
        this.fns = [];
        this.flags = {};
        this.server = nsp.server;
        this.adapter = this.nsp.adapter;
        if (previousSession) {
          this.id = previousSession.sid;
          this.pid = previousSession.pid;
          previousSession.rooms.forEach((room) => this.join(room));
          this.data = previousSession.data;
          previousSession.missedPackets.forEach((packet) => {
            this.packet({
              type: socket_io_parser_12.PacketType.EVENT,
              data: packet
            });
          });
          this.recovered = true;
        } else {
          if (client2.conn.protocol === 3) {
            this.id = nsp.name !== "/" ? nsp.name + "#" + client2.id : client2.id;
          } else {
            this.id = base64id_1.default.generateId();
          }
          if (this.server._opts.connectionStateRecovery) {
            this.pid = base64id_1.default.generateId();
          }
        }
        this.handshake = this.buildHandshake(auth);
        this.on("error", noop2);
      }
      /**
       * Builds the `handshake` BC object
       *
       * @private
       */
      buildHandshake(auth) {
        var _a2, _b, _c, _d;
        return {
          headers: ((_a2 = this.request) === null || _a2 === void 0 ? void 0 : _a2.headers) || {},
          time: /* @__PURE__ */ new Date() + "",
          address: this.conn.remoteAddress,
          xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),
          // @ts-ignore
          secure: !this.request || !!this.request.connection.encrypted,
          issued: +/* @__PURE__ */ new Date(),
          url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,
          // @ts-ignore
          query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},
          auth
        };
      }
      /**
       * Emits to this client.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.emit("hello", "world");
       *
       *   // all serializable datastructures are supported (no need to call JSON.stringify)
       *   socket.emit("hello", 1, "2", { 3: ["4"], 5: Buffer.from([6]) });
       *
       *   // with an acknowledgement from the client
       *   socket.emit("hello", "world", (val) => {
       *     // ...
       *   });
       * });
       *
       * @return Always returns `true`.
       */
      emit(ev, ...args) {
        if (exports2.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        const data = [ev, ...args];
        const packet = {
          type: socket_io_parser_12.PacketType.EVENT,
          data
        };
        if (typeof data[data.length - 1] === "function") {
          const id = this.nsp._ids++;
          debug2("emitting packet with ack id %d", id);
          this.registerAckCallback(id, data.pop());
          packet.id = id;
        }
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        if (this.nsp.server.opts.connectionStateRecovery) {
          this.adapter.broadcast(packet, {
            rooms: /* @__PURE__ */ new Set([this.id]),
            except: /* @__PURE__ */ new Set(),
            flags
          });
        } else {
          this.notifyOutgoingListeners(packet);
          this.packet(packet, flags);
        }
        return true;
      }
      /**
       * Emits an event and waits for an acknowledgement
       *
       * @example
       * io.on("connection", async (socket) => {
       *   // without timeout
       *   const response = await socket.emitWithAck("hello", "world");
       *
       *   // with a specific timeout
       *   try {
       *     const response = await socket.timeout(1000).emitWithAck("hello", "world");
       *   } catch (err) {
       *     // the client did not acknowledge the event in the given delay
       *   }
       * });
       *
       * @return a Promise that will be fulfilled when the client acknowledges the event
       */
      emitWithAck(ev, ...args) {
        const withErr = this.flags.timeout !== void 0;
        return new Promise((resolve3, reject) => {
          args.push((arg1, arg2) => {
            if (withErr) {
              return arg1 ? reject(arg1) : resolve3(arg2);
            } else {
              return resolve3(arg1);
            }
          });
          this.emit(ev, ...args);
        });
      }
      /**
       * @private
       */
      registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === void 0) {
          this.acks.set(id, ack);
          return;
        }
        const timer = setTimeout(() => {
          debug2("event with ack id %d has timed out after %d ms", id, timeout);
          this.acks.delete(id);
          ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks.set(id, (...args) => {
          clearTimeout(timer);
          ack.apply(this, [null, ...args]);
        });
      }
      /**
       * Targets a room when broadcasting.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the foo event will be broadcast to all connected clients in the room-101 room, except this socket
       *   socket.to("room-101").emit("foo", "bar");
       *
       *   // the code above is equivalent to:
       *   io.to("room-101").except(socket.id).emit("foo", "bar");
       *
       *   // with an array of rooms (a client will be notified at most once)
       *   socket.to(["room-101", "room-102"]).emit("foo", "bar");
       *
       *   // with multiple chained calls
       *   socket.to("room-101").to("room-102").emit("foo", "bar");
       * });
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      to(room) {
        return this.newBroadcastOperator().to(room);
      }
      /**
       * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:
       *
       * @example
       * io.on("connection", (socket) => {
       *   // disconnect all clients in the "room-101" room, except this socket
       *   socket.in("room-101").disconnectSockets();
       * });
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      in(room) {
        return this.newBroadcastOperator().in(room);
      }
      /**
       * Excludes a room when broadcasting.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
       *   // and this socket
       *   socket.except("room-101").emit("foo", "bar");
       *
       *   // with an array of rooms
       *   socket.except(["room-101", "room-102"]).emit("foo", "bar");
       *
       *   // with multiple chained calls
       *   socket.except("room-101").except("room-102").emit("foo", "bar");
       * });
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      except(room) {
        return this.newBroadcastOperator().except(room);
      }
      /**
       * Sends a `message` event.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.send("hello");
       *
       *   // this is equivalent to
       *   socket.emit("message", "hello");
       * });
       *
       * @return self
       */
      send(...args) {
        this.emit("message", ...args);
        return this;
      }
      /**
       * Sends a `message` event. Alias of {@link send}.
       *
       * @return self
       */
      write(...args) {
        this.emit("message", ...args);
        return this;
      }
      /**
       * Writes a packet.
       *
       * @param {Object} packet - packet object
       * @param {Object} opts - options
       * @private
       */
      packet(packet, opts = {}) {
        packet.nsp = this.nsp.name;
        opts.compress = false !== opts.compress;
        this.client._packet(packet, opts);
      }
      /**
       * Joins a room.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // join a single room
       *   socket.join("room1");
       *
       *   // join multiple rooms
       *   socket.join(["room1", "room2"]);
       * });
       *
       * @param {String|Array} rooms - room or array of rooms
       * @return a Promise or nothing, depending on the adapter
       */
      join(rooms) {
        debug2("join room %s", rooms);
        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
      }
      /**
       * Leaves a room.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // leave a single room
       *   socket.leave("room1");
       *
       *   // leave multiple rooms
       *   socket.leave("room1").leave("room2");
       * });
       *
       * @param {String} room
       * @return a Promise or nothing, depending on the adapter
       */
      leave(room) {
        debug2("leave room %s", room);
        return this.adapter.del(this.id, room);
      }
      /**
       * Leave all rooms.
       *
       * @private
       */
      leaveAll() {
        this.adapter.delAll(this.id);
      }
      /**
       * Called by `Namespace` upon successful
       * middleware execution (ie: authorization).
       * Socket is added to namespace array before
       * call to join, so adapters can access it.
       *
       * @private
       */
      _onconnect() {
        debug2("socket connected - writing packet");
        this.connected = true;
        this.join(this.id);
        if (this.conn.protocol === 3) {
          this.packet({ type: socket_io_parser_12.PacketType.CONNECT });
        } else {
          this.packet({
            type: socket_io_parser_12.PacketType.CONNECT,
            data: { sid: this.id, pid: this.pid }
          });
        }
      }
      /**
       * Called with each packet. Called by `Client`.
       *
       * @param {Object} packet
       * @private
       */
      _onpacket(packet) {
        debug2("got packet %j", packet);
        switch (packet.type) {
          case socket_io_parser_12.PacketType.EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_12.PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_12.PacketType.ACK:
            this.onack(packet);
            break;
          case socket_io_parser_12.PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_io_parser_12.PacketType.DISCONNECT:
            this.ondisconnect();
            break;
        }
      }
      /**
       * Called upon event packet.
       *
       * @param {Packet} packet - packet object
       * @private
       */
      onevent(packet) {
        const args = packet.data || [];
        debug2("emitting event %j", args);
        if (null != packet.id) {
          debug2("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener2 of listeners) {
            listener2.apply(this, args);
          }
        }
        this.dispatch(args);
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @param {Number} id - packet id
       * @private
       */
      ack(id) {
        const self2 = this;
        let sent = false;
        return function() {
          if (sent)
            return;
          const args = Array.prototype.slice.call(arguments);
          debug2("sending ack %j", args);
          self2.packet({
            id,
            type: socket_io_parser_12.PacketType.ACK,
            data: args
          });
          sent = true;
        };
      }
      /**
       * Called upon ack packet.
       *
       * @private
       */
      onack(packet) {
        const ack = this.acks.get(packet.id);
        if ("function" == typeof ack) {
          debug2("calling ack %s with %j", packet.id, packet.data);
          ack.apply(this, packet.data);
          this.acks.delete(packet.id);
        } else {
          debug2("bad ack %s", packet.id);
        }
      }
      /**
       * Called upon client disconnect packet.
       *
       * @private
       */
      ondisconnect() {
        debug2("got disconnect packet");
        this._onclose("client namespace disconnect");
      }
      /**
       * Handles a client error.
       *
       * @private
       */
      _onerror(err) {
        this.emitReserved("error", err);
      }
      /**
       * Called upon closing. Called by `Client`.
       *
       * @param {String} reason
       * @param description
       * @throw {Error} optional error object
       *
       * @private
       */
      _onclose(reason, description2) {
        if (!this.connected)
          return this;
        debug2("closing socket - reason %s", reason);
        this.emitReserved("disconnecting", reason, description2);
        if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
          debug2("connection state recovery is enabled for sid %s", this.id);
          this.adapter.persistSession({
            sid: this.id,
            pid: this.pid,
            rooms: [...this.rooms],
            data: this.data
          });
        }
        this._cleanup();
        this.client._remove(this);
        this.connected = false;
        this.emitReserved("disconnect", reason, description2);
        return;
      }
      /**
       * Makes the socket leave all the rooms it was part of and prevents it from joining any other room
       *
       * @private
       */
      _cleanup() {
        this.leaveAll();
        this.nsp._remove(this);
        this.join = noop2;
      }
      /**
       * Produces an `error` packet.
       *
       * @param {Object} err - error object
       *
       * @private
       */
      _error(err) {
        this.packet({ type: socket_io_parser_12.PacketType.CONNECT_ERROR, data: err });
      }
      /**
       * Disconnects this client.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // disconnect this socket (the connection might be kept alive for other namespaces)
       *   socket.disconnect();
       *
       *   // disconnect this socket and close the underlying connection
       *   socket.disconnect(true);
       * })
       *
       * @param {Boolean} close - if `true`, closes the underlying connection
       * @return self
       */
      disconnect(close = false) {
        if (!this.connected)
          return this;
        if (close) {
          this.client._disconnect();
        } else {
          this.packet({ type: socket_io_parser_12.PacketType.DISCONNECT });
          this._onclose("server namespace disconnect");
        }
        return this;
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.compress(false).emit("hello");
       * });
       *
       * @param {Boolean} compress - if `true`, compresses the sending data
       * @return {Socket} self
       */
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
       * receive messages (because of network slowness or other issues, or because theyre connected through long polling
       * and is in the middle of a request-response cycle).
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.volatile.emit("hello"); // the client may or may not receive it
       * });
       *
       * @return {Socket} self
       */
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the
       * sender.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the foo event will be broadcast to all connected clients, except this socket
       *   socket.broadcast.emit("foo", "bar");
       * });
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get broadcast() {
        return this.newBroadcastOperator();
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the foo event will be broadcast to all connected clients on this node, except this socket
       *   socket.local.emit("foo", "bar");
       * });
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get local() {
        return this.newBroadcastOperator().local;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the client:
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.timeout(5000).emit("my-event", (err) => {
       *     if (err) {
       *       // the client did not acknowledge the event in the given delay
       *     }
       *   });
       * });
       *
       * @returns self
       */
      timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
      }
      /**
       * Dispatch incoming event to socket listeners.
       *
       * @param {Array} event - event that will get emitted
       * @private
       */
      dispatch(event) {
        debug2("dispatching an event %j", event);
        this.run(event, (err) => {
          process.nextTick(() => {
            if (err) {
              return this._onerror(err);
            }
            if (this.connected) {
              super.emitUntyped.apply(this, event);
            } else {
              debug2("ignore packet received after disconnection");
            }
          });
        });
      }
      /**
       * Sets up socket middleware.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.use(([event, ...args], next) => {
       *     if (isUnauthorized(event)) {
       *       return next(new Error("unauthorized event"));
       *     }
       *     // do not forget to call next
       *     next();
       *   });
       *
       *   socket.on("error", (err) => {
       *     if (err && err.message === "unauthorized event") {
       *       socket.disconnect();
       *     }
       *   });
       * });
       *
       * @param {Function} fn - middleware function (event, next)
       * @return {Socket} self
       */
      use(fn) {
        this.fns.push(fn);
        return this;
      }
      /**
       * Executes the middleware for an incoming event.
       *
       * @param {Array} event - event that will get emitted
       * @param {Function} fn - last fn call in the middleware
       * @private
       */
      run(event, fn) {
        const fns = this.fns.slice(0);
        if (!fns.length)
          return fn(null);
        function run(i2) {
          fns[i2](event, function(err) {
            if (err)
              return fn(err);
            if (!fns[i2 + 1])
              return fn(null);
            run(i2 + 1);
          });
        }
        run(0);
      }
      /**
       * Whether the socket is currently disconnected
       */
      get disconnected() {
        return !this.connected;
      }
      /**
       * A reference to the request that originated the underlying Engine.IO Socket.
       */
      get request() {
        return this.client.request;
      }
      /**
       * A reference to the underlying Client transport connection (Engine.IO Socket object).
       *
       * @example
       * io.on("connection", (socket) => {
       *   console.log(socket.conn.transport.name); // prints "polling" or "websocket"
       *
       *   socket.conn.once("upgrade", () => {
       *     console.log(socket.conn.transport.name); // prints "websocket"
       *   });
       * });
       */
      get conn() {
        return this.client.conn;
      }
      /**
       * Returns the rooms the socket is currently in.
       *
       * @example
       * io.on("connection", (socket) => {
       *   console.log(socket.rooms); // Set { <socket.id> }
       *
       *   socket.join("room1");
       *
       *   console.log(socket.rooms); // Set { <socket.id>, "room1" }
       * });
       */
      get rooms() {
        return this.adapter.socketRooms(this.id) || /* @__PURE__ */ new Set();
      }
      /**
       * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
       * the callback.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.onAny((event, ...args) => {
       *     console.log(`got event ${event}`);
       *   });
       * });
       *
       * @param listener
       */
      onAny(listener2) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener2);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
       * the callback. The listener is added to the beginning of the listeners array.
       *
       * @param listener
       */
      prependAny(listener2) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener2);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is received.
       *
       * @example
       * io.on("connection", (socket) => {
       *   const catchAllListener = (event, ...args) => {
       *     console.log(`got event ${event}`);
       *   }
       *
       *   socket.onAny(catchAllListener);
       *
       *   // remove a specific listener
       *   socket.offAny(catchAllListener);
       *
       *   // or remove all listeners
       *   socket.offAny();
       * });
       *
       * @param listener
       */
      offAny(listener2) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener2) {
          const listeners = this._anyListeners;
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listener2 === listeners[i2]) {
              listeners.splice(i2, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAny() {
        return this._anyListeners || [];
      }
      /**
       * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to
       * the callback.
       *
       * Note: acknowledgements sent to the client are not included.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.onAnyOutgoing((event, ...args) => {
       *     console.log(`sent event ${event}`);
       *   });
       * });
       *
       * @param listener
       */
      onAnyOutgoing(listener2) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener2);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.prependAnyOutgoing((event, ...args) => {
       *     console.log(`sent event ${event}`);
       *   });
       * });
       *
       * @param listener
       */
      prependAnyOutgoing(listener2) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener2);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is sent.
       *
       * @example
       * io.on("connection", (socket) => {
       *   const catchAllListener = (event, ...args) => {
       *     console.log(`sent event ${event}`);
       *   }
       *
       *   socket.onAnyOutgoing(catchAllListener);
       *
       *   // remove a specific listener
       *   socket.offAnyOutgoing(catchAllListener);
       *
       *   // or remove all listeners
       *   socket.offAnyOutgoing();
       * });
       *
       * @param listener - the catch-all listener
       */
      offAnyOutgoing(listener2) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener2) {
          const listeners = this._anyOutgoingListeners;
          for (let i2 = 0; i2 < listeners.length; i2++) {
            if (listener2 === listeners[i2]) {
              listeners.splice(i2, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      /**
       * Notify the listeners for each packet sent (emit or broadcast)
       *
       * @param packet
       *
       * @private
       */
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener2 of listeners) {
            listener2.apply(this, packet.data);
          }
        }
      }
      newBroadcastOperator() {
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        return new broadcast_operator_1.BroadcastOperator(this.adapter, /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set([this.id]), flags);
      }
    }
    exports2.Socket = Socket3;
  })(socket);
  return socket;
}
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Namespace = exports2.RESERVED_EVENTS = void 0;
  const socket_12 = requireSocket();
  const typed_events_1 = typedEvents;
  const debug_12 = __importDefault2(browserExports);
  const broadcast_operator_1 = requireBroadcastOperator();
  const debug2 = (0, debug_12.default)("socket.io:namespace");
  exports2.RESERVED_EVENTS = /* @__PURE__ */ new Set(["connect", "connection", "new_namespace"]);
  class Namespace2 extends typed_events_1.StrictEventEmitter {
    /**
     * Namespace constructor.
     *
     * @param server instance
     * @param name
     */
    constructor(server2, name2) {
      super();
      this.sockets = /* @__PURE__ */ new Map();
      this._fns = [];
      this._ids = 0;
      this.server = server2;
      this.name = name2;
      this._initAdapter();
    }
    /**
     * Initializes the `Adapter` for this nsp.
     * Run upon changing adapter by `Server#adapter`
     * in addition to the constructor.
     *
     * @private
     */
    _initAdapter() {
      this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.use((socket, next) => {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn) {
      this._fns.push(fn);
      return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */
    run(socket2, fn) {
      const fns = this._fns.slice(0);
      if (!fns.length)
        return fn(null);
      function run(i2) {
        fns[i2](socket2, function(err) {
          if (err)
            return fn(err);
          if (!fns[i2 + 1])
            return fn(null);
          run(i2 + 1);
        });
      }
      run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * myNamespace.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * myNamespace.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // disconnect all clients in the "room-101" room
     * myNamespace.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * myNamespace.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * myNamespace.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * myNamespace.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */
    async _add(client2, auth, fn) {
      var _a2;
      debug2("adding socket to nsp %s", this.name);
      const socket2 = await this._createSocket(client2, auth);
      if (
        // @ts-ignore
        ((_a2 = this.server.opts.connectionStateRecovery) === null || _a2 === void 0 ? void 0 : _a2.skipMiddlewares) && socket2.recovered && client2.conn.readyState === "open"
      ) {
        return this._doConnect(socket2, fn);
      }
      this.run(socket2, (err) => {
        process.nextTick(() => {
          if ("open" !== client2.conn.readyState) {
            debug2("next called after client was closed - ignoring socket");
            socket2._cleanup();
            return;
          }
          if (err) {
            debug2("middleware error, sending CONNECT_ERROR packet to the client");
            socket2._cleanup();
            if (client2.conn.protocol === 3) {
              return socket2._error(err.data || err.message);
            } else {
              return socket2._error({
                message: err.message,
                data: err.data
              });
            }
          }
          this._doConnect(socket2, fn);
        });
      });
    }
    async _createSocket(client2, auth) {
      const sessionId = auth.pid;
      const offset = auth.offset;
      if (
        // @ts-ignore
        this.server.opts.connectionStateRecovery && typeof sessionId === "string" && typeof offset === "string"
      ) {
        let session;
        try {
          session = await this.adapter.restoreSession(sessionId, offset);
        } catch (e) {
          debug2("error while restoring session: %s", e);
        }
        if (session) {
          debug2("connection state recovered for sid %s", session.sid);
          return new socket_12.Socket(this, client2, auth, session);
        }
      }
      return new socket_12.Socket(this, client2, auth);
    }
    _doConnect(socket2, fn) {
      this.sockets.set(socket2.id, socket2);
      socket2._onconnect();
      if (fn)
        fn(socket2);
      this.emitReserved("connect", socket2);
      this.emitReserved("connection", socket2);
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */
    _remove(socket2) {
      if (this.sockets.has(socket2.id)) {
        this.sockets.delete(socket2.id);
      } else {
        debug2("ignoring remove for %s", socket2.id);
      }
    }
    /**
     * Emits to all connected clients.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * myNamespace.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the clients
     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */
    emit(ev, ...args) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.send("hello");
     *
     * // this is equivalent to
     * myNamespace.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
      this.emit("message", ...args);
      return this;
    }
    /**
     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
      this.emit("message", ...args);
      return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.serverSideEmit("hello", "world");
     *
     * myNamespace.on("hello", (arg1) => {
     *   console.log(arg1); // prints "world"
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * myNamespace.serverSideEmit("ping", (err, responses) => {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * myNamespace.on("ping", (cb) => {
     *   cb("pong");
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(ev, ...args) {
      if (exports2.RESERVED_EVENTS.has(ev)) {
        throw new Error(`"${String(ev)}" is a reserved event name`);
      }
      args.unshift(ev);
      this.adapter.serverSideEmit(args);
      return true;
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * try {
     *   const responses = await myNamespace.serverSideEmitWithAck("ping");
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck(ev, ...args) {
      return new Promise((resolve3, reject) => {
        args.push((err, responses) => {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve3(responses);
          }
        });
        this.serverSideEmit(ev, ...args);
      });
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */
    _onServerSideEmit(args) {
      super.emitUntyped.apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or
     * {@link Namespace#fetchSockets} instead.
     */
    allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return self
     */
    get volatile() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the foo event will be broadcast to all connected clients on this node
     * myNamespace.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // return all Socket instances
     * const sockets = await myNamespace.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await myNamespace.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances join the "room1" room
     * myNamespace.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * myNamespace.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances leave the "room1" room
     * myNamespace.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * myNamespace.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * myNamespace.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * myNamespace.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }
  exports2.Namespace = Namespace2;
})(namespace);
var parentNamespace = {};
var dist = {};
var inMemoryAdapter = {};
var yeast$1 = {};
Object.defineProperty(yeast$1, "__esModule", { value: true });
yeast$1.yeast = yeast$1.decode = yeast$1.encode = void 0;
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i = 0, prev;
function encode$1(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
yeast$1.encode = encode$1;
function decode$3(str) {
  let decoded = 0;
  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }
  return decoded;
}
yeast$1.decode = decode$3;
function yeast() {
  const now = encode$1(+/* @__PURE__ */ new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode$1(seed++);
}
yeast$1.yeast = yeast;
for (; i < length; i++)
  map[alphabet[i]] = i;
var _a;
Object.defineProperty(inMemoryAdapter, "__esModule", { value: true });
inMemoryAdapter.SessionAwareAdapter = inMemoryAdapter.Adapter = void 0;
const events_1 = require$$2$2;
const yeast_1 = yeast$1;
const WebSocket4 = ws;
const canPreComputeFrame = typeof ((_a = WebSocket4 === null || WebSocket4 === void 0 ? void 0 : WebSocket4.Sender) === null || _a === void 0 ? void 0 : _a.frame) === "function";
class Adapter extends events_1.EventEmitter {
  /**
   * In-memory adapter constructor.
   *
   * @param {Namespace} nsp
   */
  constructor(nsp) {
    super();
    this.nsp = nsp;
    this.rooms = /* @__PURE__ */ new Map();
    this.sids = /* @__PURE__ */ new Map();
    this.encoder = nsp.server.encoder;
  }
  /**
   * To be overridden
   */
  init() {
  }
  /**
   * To be overridden
   */
  close() {
  }
  /**
   * Returns the number of Socket.IO servers in the cluster
   *
   * @public
   */
  serverCount() {
    return Promise.resolve(1);
  }
  /**
   * Adds a socket to a list of room.
   *
   * @param {SocketId}  id      the socket id
   * @param {Set<Room>} rooms   a set of rooms
   * @public
   */
  addAll(id, rooms) {
    if (!this.sids.has(id)) {
      this.sids.set(id, /* @__PURE__ */ new Set());
    }
    for (const room of rooms) {
      this.sids.get(id).add(room);
      if (!this.rooms.has(room)) {
        this.rooms.set(room, /* @__PURE__ */ new Set());
        this.emit("create-room", room);
      }
      if (!this.rooms.get(room).has(id)) {
        this.rooms.get(room).add(id);
        this.emit("join-room", room, id);
      }
    }
  }
  /**
   * Removes a socket from a room.
   *
   * @param {SocketId} id     the socket id
   * @param {Room}     room   the room name
   */
  del(id, room) {
    if (this.sids.has(id)) {
      this.sids.get(id).delete(room);
    }
    this._del(room, id);
  }
  _del(room, id) {
    const _room = this.rooms.get(room);
    if (_room != null) {
      const deleted = _room.delete(id);
      if (deleted) {
        this.emit("leave-room", room, id);
      }
      if (_room.size === 0 && this.rooms.delete(room)) {
        this.emit("delete-room", room);
      }
    }
  }
  /**
   * Removes a socket from all rooms it's joined.
   *
   * @param {SocketId} id   the socket id
   */
  delAll(id) {
    if (!this.sids.has(id)) {
      return;
    }
    for (const room of this.sids.get(id)) {
      this._del(room, id);
    }
    this.sids.delete(id);
  }
  /**
   * Broadcasts a packet.
   *
   * Options:
   *  - `flags` {Object} flags for this packet
   *  - `except` {Array} sids that should be excluded
   *  - `rooms` {Array} list of rooms to broadcast to
   *
   * @param {Object} packet   the packet object
   * @param {Object} opts     the options
   * @public
   */
  broadcast(packet, opts) {
    const flags = opts.flags || {};
    const packetOpts = {
      preEncoded: true,
      volatile: flags.volatile,
      compress: flags.compress
    };
    packet.nsp = this.nsp.name;
    const encodedPackets = this._encode(packet, packetOpts);
    this.apply(opts, (socket2) => {
      if (typeof socket2.notifyOutgoingListeners === "function") {
        socket2.notifyOutgoingListeners(packet);
      }
      socket2.client.writeToEngine(encodedPackets, packetOpts);
    });
  }
  /**
   * Broadcasts a packet and expects multiple acknowledgements.
   *
   * Options:
   *  - `flags` {Object} flags for this packet
   *  - `except` {Array} sids that should be excluded
   *  - `rooms` {Array} list of rooms to broadcast to
   *
   * @param {Object} packet   the packet object
   * @param {Object} opts     the options
   * @param clientCountCallback - the number of clients that received the packet
   * @param ack                 - the callback that will be called for each client response
   *
   * @public
   */
  broadcastWithAck(packet, opts, clientCountCallback, ack) {
    const flags = opts.flags || {};
    const packetOpts = {
      preEncoded: true,
      volatile: flags.volatile,
      compress: flags.compress
    };
    packet.nsp = this.nsp.name;
    packet.id = this.nsp._ids++;
    const encodedPackets = this._encode(packet, packetOpts);
    let clientCount = 0;
    this.apply(opts, (socket2) => {
      clientCount++;
      socket2.acks.set(packet.id, ack);
      if (typeof socket2.notifyOutgoingListeners === "function") {
        socket2.notifyOutgoingListeners(packet);
      }
      socket2.client.writeToEngine(encodedPackets, packetOpts);
    });
    clientCountCallback(clientCount);
  }
  _encode(packet, packetOpts) {
    const encodedPackets = this.encoder.encode(packet);
    if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === "string") {
      const data = Buffer.from("4" + encodedPackets[0]);
      packetOpts.wsPreEncodedFrame = WebSocket4.Sender.frame(data, {
        readOnly: false,
        mask: false,
        rsv1: false,
        opcode: 1,
        fin: true
      });
    }
    return encodedPackets;
  }
  /**
   * Gets a list of sockets by sid.
   *
   * @param {Set<Room>} rooms   the explicit set of rooms to check.
   */
  sockets(rooms) {
    const sids = /* @__PURE__ */ new Set();
    this.apply({ rooms }, (socket2) => {
      sids.add(socket2.id);
    });
    return Promise.resolve(sids);
  }
  /**
   * Gets the list of rooms a given socket has joined.
   *
   * @param {SocketId} id   the socket id
   */
  socketRooms(id) {
    return this.sids.get(id);
  }
  /**
   * Returns the matching socket instances
   *
   * @param opts - the filters to apply
   */
  fetchSockets(opts) {
    const sockets = [];
    this.apply(opts, (socket2) => {
      sockets.push(socket2);
    });
    return Promise.resolve(sockets);
  }
  /**
   * Makes the matching socket instances join the specified rooms
   *
   * @param opts - the filters to apply
   * @param rooms - the rooms to join
   */
  addSockets(opts, rooms) {
    this.apply(opts, (socket2) => {
      socket2.join(rooms);
    });
  }
  /**
   * Makes the matching socket instances leave the specified rooms
   *
   * @param opts - the filters to apply
   * @param rooms - the rooms to leave
   */
  delSockets(opts, rooms) {
    this.apply(opts, (socket2) => {
      rooms.forEach((room) => socket2.leave(room));
    });
  }
  /**
   * Makes the matching socket instances disconnect
   *
   * @param opts - the filters to apply
   * @param close - whether to close the underlying connection
   */
  disconnectSockets(opts, close) {
    this.apply(opts, (socket2) => {
      socket2.disconnect(close);
    });
  }
  apply(opts, callback) {
    const rooms = opts.rooms;
    const except = this.computeExceptSids(opts.except);
    if (rooms.size) {
      const ids = /* @__PURE__ */ new Set();
      for (const room of rooms) {
        if (!this.rooms.has(room))
          continue;
        for (const id of this.rooms.get(room)) {
          if (ids.has(id) || except.has(id))
            continue;
          const socket2 = this.nsp.sockets.get(id);
          if (socket2) {
            callback(socket2);
            ids.add(id);
          }
        }
      }
    } else {
      for (const [id] of this.sids) {
        if (except.has(id))
          continue;
        const socket2 = this.nsp.sockets.get(id);
        if (socket2)
          callback(socket2);
      }
    }
  }
  computeExceptSids(exceptRooms) {
    const exceptSids = /* @__PURE__ */ new Set();
    if (exceptRooms && exceptRooms.size > 0) {
      for (const room of exceptRooms) {
        if (this.rooms.has(room)) {
          this.rooms.get(room).forEach((sid) => exceptSids.add(sid));
        }
      }
    }
    return exceptSids;
  }
  /**
   * Send a packet to the other Socket.IO servers in the cluster
   * @param packet - an array of arguments, which may include an acknowledgement callback at the end
   */
  serverSideEmit(packet) {
    console.warn("this adapter does not support the serverSideEmit() functionality");
  }
  /**
   * Save the client session in order to restore it upon reconnection.
   */
  persistSession(session) {
  }
  /**
   * Restore the session and find the packets that were missed by the client.
   * @param pid
   * @param offset
   */
  restoreSession(pid, offset) {
    return null;
  }
}
inMemoryAdapter.Adapter = Adapter;
class SessionAwareAdapter extends Adapter {
  constructor(nsp) {
    super(nsp);
    this.nsp = nsp;
    this.sessions = /* @__PURE__ */ new Map();
    this.packets = [];
    this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
    const timer = setInterval(() => {
      const threshold = Date.now() - this.maxDisconnectionDuration;
      this.sessions.forEach((session, sessionId) => {
        const hasExpired = session.disconnectedAt < threshold;
        if (hasExpired) {
          this.sessions.delete(sessionId);
        }
      });
      for (let i2 = this.packets.length - 1; i2 >= 0; i2--) {
        const hasExpired = this.packets[i2].emittedAt < threshold;
        if (hasExpired) {
          this.packets.splice(0, i2 + 1);
          break;
        }
      }
    }, 60 * 1e3);
    timer.unref();
  }
  persistSession(session) {
    session.disconnectedAt = Date.now();
    this.sessions.set(session.pid, session);
  }
  restoreSession(pid, offset) {
    const session = this.sessions.get(pid);
    if (!session) {
      return null;
    }
    const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
    if (hasExpired) {
      this.sessions.delete(pid);
      return null;
    }
    const index2 = this.packets.findIndex((packet) => packet.id === offset);
    if (index2 === -1) {
      return null;
    }
    const missedPackets = [];
    for (let i2 = index2 + 1; i2 < this.packets.length; i2++) {
      const packet = this.packets[i2];
      if (shouldIncludePacket(session.rooms, packet.opts)) {
        missedPackets.push(packet.data);
      }
    }
    return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
  }
  broadcast(packet, opts) {
    var _a2;
    const isEventPacket = packet.type === 2;
    const withoutAcknowledgement = packet.id === void 0;
    const notVolatile = ((_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.volatile) === void 0;
    if (isEventPacket && withoutAcknowledgement && notVolatile) {
      const id = (0, yeast_1.yeast)();
      packet.data.push(id);
      this.packets.push({
        id,
        opts,
        data: packet.data,
        emittedAt: Date.now()
      });
    }
    super.broadcast(packet, opts);
  }
}
inMemoryAdapter.SessionAwareAdapter = SessionAwareAdapter;
function shouldIncludePacket(sessionRooms, opts) {
  const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));
  const notExcluded = sessionRooms.every((room) => !opts.except.has(room));
  return included && notExcluded;
}
var clusterAdapter = {};
(function(exports2) {
  var __rest = commonjsGlobal && commonjsGlobal.__rest || function(s2, e) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ClusterAdapterWithHeartbeat = exports2.ClusterAdapter = exports2.MessageType = void 0;
  const in_memory_adapter_1 = inMemoryAdapter;
  const debug_12 = browserExports;
  const crypto_1 = require$$2$2;
  const debug2 = (0, debug_12.debug)("socket.io-adapter");
  const EMITTER_UID = "emitter";
  const DEFAULT_TIMEOUT = 5e3;
  function randomId() {
    return (0, crypto_1.randomBytes)(8).toString("hex");
  }
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
    MessageType2[MessageType2["HEARTBEAT"] = 2] = "HEARTBEAT";
    MessageType2[MessageType2["BROADCAST"] = 3] = "BROADCAST";
    MessageType2[MessageType2["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
    MessageType2[MessageType2["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
    MessageType2[MessageType2["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
    MessageType2[MessageType2["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
    MessageType2[MessageType2["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
    MessageType2[MessageType2["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
    MessageType2[MessageType2["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
    MessageType2[MessageType2["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
    MessageType2[MessageType2["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
    MessageType2[MessageType2["ADAPTER_CLOSE"] = 13] = "ADAPTER_CLOSE";
  })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
  function encodeOptions(opts) {
    return {
      rooms: [...opts.rooms],
      except: [...opts.except],
      flags: opts.flags
    };
  }
  function decodeOptions(opts) {
    return {
      rooms: new Set(opts.rooms),
      except: new Set(opts.except),
      flags: opts.flags
    };
  }
  class ClusterAdapter extends in_memory_adapter_1.Adapter {
    constructor(nsp) {
      super(nsp);
      this.requests = /* @__PURE__ */ new Map();
      this.ackRequests = /* @__PURE__ */ new Map();
      this.uid = randomId();
    }
    /**
     * Called when receiving a message from another member of the cluster.
     *
     * @param message
     * @param offset
     * @protected
     */
    onMessage(message, offset) {
      if (message.uid === this.uid) {
        return debug2("[%s] ignore message from self", this.uid);
      }
      debug2("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
      switch (message.type) {
        case MessageType.BROADCAST: {
          const withAck = message.data.requestId !== void 0;
          if (withAck) {
            super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount) => {
              debug2("[%s] waiting for %d client acknowledgements", this.uid, clientCount);
              this.publishResponse(message.uid, {
                type: MessageType.BROADCAST_CLIENT_COUNT,
                data: {
                  requestId: message.data.requestId,
                  clientCount
                }
              });
            }, (arg) => {
              debug2("[%s] received acknowledgement with value %j", this.uid, arg);
              this.publishResponse(message.uid, {
                type: MessageType.BROADCAST_ACK,
                data: {
                  requestId: message.data.requestId,
                  packet: arg
                }
              });
            });
          } else {
            const packet = message.data.packet;
            const opts = decodeOptions(message.data.opts);
            this.addOffsetIfNecessary(packet, opts, offset);
            super.broadcast(packet, opts);
          }
          break;
        }
        case MessageType.SOCKETS_JOIN:
          super.addSockets(decodeOptions(message.data.opts), message.data.rooms);
          break;
        case MessageType.SOCKETS_LEAVE:
          super.delSockets(decodeOptions(message.data.opts), message.data.rooms);
          break;
        case MessageType.DISCONNECT_SOCKETS:
          super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);
          break;
        case MessageType.FETCH_SOCKETS: {
          debug2("[%s] calling fetchSockets with opts %j", this.uid, message.data.opts);
          super.fetchSockets(decodeOptions(message.data.opts)).then((localSockets) => {
            this.publishResponse(message.uid, {
              type: MessageType.FETCH_SOCKETS_RESPONSE,
              data: {
                requestId: message.data.requestId,
                sockets: localSockets.map((socket2) => {
                  const _a2 = socket2.handshake, handshake = __rest(_a2, ["sessionStore"]);
                  return {
                    id: socket2.id,
                    handshake,
                    rooms: [...socket2.rooms],
                    data: socket2.data
                  };
                })
              }
            });
          });
          break;
        }
        case MessageType.SERVER_SIDE_EMIT: {
          const packet = message.data.packet;
          const withAck = message.data.requestId !== void 0;
          if (!withAck) {
            this.nsp._onServerSideEmit(packet);
            return;
          }
          let called = false;
          const callback = (arg) => {
            if (called) {
              return;
            }
            called = true;
            debug2("[%s] calling acknowledgement with %j", this.uid, arg);
            this.publishResponse(message.uid, {
              type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
              data: {
                requestId: message.data.requestId,
                packet: arg
              }
            });
          };
          this.nsp._onServerSideEmit([...packet, callback]);
          break;
        }
        case MessageType.BROADCAST_CLIENT_COUNT:
        case MessageType.BROADCAST_ACK:
        case MessageType.FETCH_SOCKETS_RESPONSE:
        case MessageType.SERVER_SIDE_EMIT_RESPONSE:
          this.onResponse(message);
          break;
        default:
          debug2("[%s] unknown message type: %s", this.uid, message.type);
      }
    }
    /**
     * Called when receiving a response from another member of the cluster.
     *
     * @param response
     * @protected
     */
    onResponse(response2) {
      var _a2, _b;
      const requestId = response2.data.requestId;
      debug2("[%s] received response %s to request %s", this.uid, response2.type, requestId);
      switch (response2.type) {
        case MessageType.BROADCAST_CLIENT_COUNT: {
          (_a2 = this.ackRequests.get(requestId)) === null || _a2 === void 0 ? void 0 : _a2.clientCountCallback(response2.data.clientCount);
          break;
        }
        case MessageType.BROADCAST_ACK: {
          (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response2.data.packet);
          break;
        }
        case MessageType.FETCH_SOCKETS_RESPONSE: {
          const request2 = this.requests.get(requestId);
          if (!request2) {
            return;
          }
          request2.current++;
          response2.data.sockets.forEach((socket2) => request2.responses.push(socket2));
          if (request2.current === request2.expected) {
            clearTimeout(request2.timeout);
            request2.resolve(request2.responses);
            this.requests.delete(requestId);
          }
          break;
        }
        case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
          const request2 = this.requests.get(requestId);
          if (!request2) {
            return;
          }
          request2.current++;
          request2.responses.push(response2.data.packet);
          if (request2.current === request2.expected) {
            clearTimeout(request2.timeout);
            request2.resolve(null, request2.responses);
            this.requests.delete(requestId);
          }
          break;
        }
        default:
          debug2("[%s] unknown response type: %s", this.uid, response2.type);
      }
    }
    async broadcast(packet, opts) {
      var _a2;
      const onlyLocal = (_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local;
      if (!onlyLocal) {
        try {
          const offset = await this.publishAndReturnOffset({
            type: MessageType.BROADCAST,
            data: {
              packet,
              opts: encodeOptions(opts)
            }
          });
          this.addOffsetIfNecessary(packet, opts, offset);
        } catch (e) {
          return debug2("[%s] error while broadcasting message: %s", this.uid, e.message);
        }
      }
      super.broadcast(packet, opts);
    }
    /**
     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it
     * reconnects after a temporary disconnection.
     *
     * @param packet
     * @param opts
     * @param offset
     * @private
     */
    addOffsetIfNecessary(packet, opts, offset) {
      var _a2;
      if (!this.nsp.server.opts.connectionStateRecovery) {
        return;
      }
      const isEventPacket = packet.type === 2;
      const withoutAcknowledgement = packet.id === void 0;
      const notVolatile = ((_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.volatile) === void 0;
      if (isEventPacket && withoutAcknowledgement && notVolatile) {
        packet.data.push(offset);
      }
    }
    broadcastWithAck(packet, opts, clientCountCallback, ack) {
      var _a2;
      const onlyLocal = (_a2 = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local;
      if (!onlyLocal) {
        const requestId = randomId();
        this.ackRequests.set(requestId, {
          clientCountCallback,
          ack
        });
        this.publish({
          type: MessageType.BROADCAST,
          data: {
            packet,
            requestId,
            opts: encodeOptions(opts)
          }
        });
        setTimeout(() => {
          this.ackRequests.delete(requestId);
        }, opts.flags.timeout);
      }
      super.broadcastWithAck(packet, opts, clientCountCallback, ack);
    }
    async addSockets(opts, rooms) {
      var _a2;
      const onlyLocal = (_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local;
      if (!onlyLocal) {
        try {
          await this.publishAndReturnOffset({
            type: MessageType.SOCKETS_JOIN,
            data: {
              opts: encodeOptions(opts),
              rooms
            }
          });
        } catch (e) {
          debug2("[%s] error while publishing message: %s", this.uid, e.message);
        }
      }
      super.addSockets(opts, rooms);
    }
    async delSockets(opts, rooms) {
      var _a2;
      const onlyLocal = (_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local;
      if (!onlyLocal) {
        try {
          await this.publishAndReturnOffset({
            type: MessageType.SOCKETS_LEAVE,
            data: {
              opts: encodeOptions(opts),
              rooms
            }
          });
        } catch (e) {
          debug2("[%s] error while publishing message: %s", this.uid, e.message);
        }
      }
      super.delSockets(opts, rooms);
    }
    async disconnectSockets(opts, close) {
      var _a2;
      const onlyLocal = (_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local;
      if (!onlyLocal) {
        try {
          await this.publishAndReturnOffset({
            type: MessageType.DISCONNECT_SOCKETS,
            data: {
              opts: encodeOptions(opts),
              close
            }
          });
        } catch (e) {
          debug2("[%s] error while publishing message: %s", this.uid, e.message);
        }
      }
      super.disconnectSockets(opts, close);
    }
    async fetchSockets(opts) {
      var _a2;
      const [localSockets, serverCount] = await Promise.all([
        super.fetchSockets(opts),
        this.serverCount()
      ]);
      const expectedResponseCount = serverCount - 1;
      if (((_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local) || expectedResponseCount <= 0) {
        return localSockets;
      }
      const requestId = randomId();
      return new Promise((resolve3, reject) => {
        const timeout = setTimeout(() => {
          const storedRequest2 = this.requests.get(requestId);
          if (storedRequest2) {
            reject(new Error(`timeout reached: only ${storedRequest2.current} responses received out of ${storedRequest2.expected}`));
            this.requests.delete(requestId);
          }
        }, opts.flags.timeout || DEFAULT_TIMEOUT);
        const storedRequest = {
          type: MessageType.FETCH_SOCKETS,
          resolve: resolve3,
          timeout,
          current: 0,
          expected: expectedResponseCount,
          responses: localSockets
        };
        this.requests.set(requestId, storedRequest);
        this.publish({
          type: MessageType.FETCH_SOCKETS,
          data: {
            opts: encodeOptions(opts),
            requestId
          }
        });
      });
    }
    async serverSideEmit(packet) {
      const withAck = typeof packet[packet.length - 1] === "function";
      if (!withAck) {
        return this.publish({
          type: MessageType.SERVER_SIDE_EMIT,
          data: {
            packet
          }
        });
      }
      const ack = packet.pop();
      const expectedResponseCount = await this.serverCount() - 1;
      debug2('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
      if (expectedResponseCount <= 0) {
        return ack(null, []);
      }
      const requestId = randomId();
      const timeout = setTimeout(() => {
        const storedRequest2 = this.requests.get(requestId);
        if (storedRequest2) {
          ack(new Error(`timeout reached: only ${storedRequest2.current} responses received out of ${storedRequest2.expected}`), storedRequest2.responses);
          this.requests.delete(requestId);
        }
      }, DEFAULT_TIMEOUT);
      const storedRequest = {
        type: MessageType.SERVER_SIDE_EMIT,
        resolve: ack,
        timeout,
        current: 0,
        expected: expectedResponseCount,
        responses: []
      };
      this.requests.set(requestId, storedRequest);
      this.publish({
        type: MessageType.SERVER_SIDE_EMIT,
        data: {
          requestId,
          packet
        }
      });
    }
    publish(message) {
      this.publishAndReturnOffset(message).catch((err) => {
        debug2("[%s] error while publishing message: %s", this.uid, err);
      });
    }
    publishAndReturnOffset(message) {
      message.uid = this.uid;
      message.nsp = this.nsp.name;
      return this.doPublish(message);
    }
    publishResponse(requesterUid, response2) {
      response2.uid = this.uid;
      response2.nsp = this.nsp.name;
      this.doPublishResponse(requesterUid, response2).catch((err) => {
        debug2("[%s] error while publishing response: %s", this.uid, err);
      });
    }
  }
  exports2.ClusterAdapter = ClusterAdapter;
  class ClusterAdapterWithHeartbeat extends ClusterAdapter {
    constructor(nsp, opts) {
      super(nsp);
      this.nodesMap = /* @__PURE__ */ new Map();
      this.customRequests = /* @__PURE__ */ new Map();
      this._opts = Object.assign({
        heartbeatInterval: 5e3,
        heartbeatTimeout: 1e4
      }, opts);
      this.cleanupTimer = setInterval(() => {
        const now = Date.now();
        this.nodesMap.forEach((lastSeen, uid) => {
          const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;
          if (nodeSeemsDown) {
            debug2("[%s] node %s seems down", this.uid, uid);
            this.removeNode(uid);
          }
        });
      }, 1e3);
    }
    init() {
      this.publish({
        type: MessageType.INITIAL_HEARTBEAT
      });
    }
    scheduleHeartbeat() {
      if (this.heartbeatTimer) {
        this.heartbeatTimer.refresh();
      } else {
        this.heartbeatTimer = setTimeout(() => {
          this.publish({
            type: MessageType.HEARTBEAT
          });
        }, this._opts.heartbeatInterval);
      }
    }
    close() {
      this.publish({
        type: MessageType.ADAPTER_CLOSE
      });
      clearTimeout(this.heartbeatTimer);
      if (this.cleanupTimer) {
        clearInterval(this.cleanupTimer);
      }
    }
    onMessage(message, offset) {
      if (message.uid === this.uid) {
        return debug2("[%s] ignore message from self", this.uid);
      }
      if (message.uid && message.uid !== EMITTER_UID) {
        this.nodesMap.set(message.uid, Date.now());
      }
      debug2("[%s] new event of type %d from %s", this.uid, message.type, message.uid);
      switch (message.type) {
        case MessageType.INITIAL_HEARTBEAT:
          this.publish({
            type: MessageType.HEARTBEAT
          });
          break;
        case MessageType.HEARTBEAT:
          break;
        case MessageType.ADAPTER_CLOSE:
          this.removeNode(message.uid);
          break;
        default:
          super.onMessage(message, offset);
      }
    }
    serverCount() {
      return Promise.resolve(1 + this.nodesMap.size);
    }
    publish(message) {
      this.scheduleHeartbeat();
      return super.publish(message);
    }
    async serverSideEmit(packet) {
      const withAck = typeof packet[packet.length - 1] === "function";
      if (!withAck) {
        return this.publish({
          type: MessageType.SERVER_SIDE_EMIT,
          data: {
            packet
          }
        });
      }
      const ack = packet.pop();
      const expectedResponseCount = this.nodesMap.size;
      debug2('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
      if (expectedResponseCount <= 0) {
        return ack(null, []);
      }
      const requestId = randomId();
      const timeout = setTimeout(() => {
        const storedRequest2 = this.customRequests.get(requestId);
        if (storedRequest2) {
          ack(new Error(`timeout reached: missing ${storedRequest2.missingUids.size} responses`), storedRequest2.responses);
          this.customRequests.delete(requestId);
        }
      }, DEFAULT_TIMEOUT);
      const storedRequest = {
        type: MessageType.SERVER_SIDE_EMIT,
        resolve: ack,
        timeout,
        missingUids: /* @__PURE__ */ new Set([...this.nodesMap.keys()]),
        responses: []
      };
      this.customRequests.set(requestId, storedRequest);
      this.publish({
        type: MessageType.SERVER_SIDE_EMIT,
        data: {
          requestId,
          packet
        }
      });
    }
    async fetchSockets(opts) {
      var _a2;
      const [localSockets, serverCount] = await Promise.all([
        super.fetchSockets({
          rooms: opts.rooms,
          except: opts.except,
          flags: {
            local: true
          }
        }),
        this.serverCount()
      ]);
      const expectedResponseCount = serverCount - 1;
      if (((_a2 = opts.flags) === null || _a2 === void 0 ? void 0 : _a2.local) || expectedResponseCount <= 0) {
        return localSockets;
      }
      const requestId = randomId();
      return new Promise((resolve3, reject) => {
        const timeout = setTimeout(() => {
          const storedRequest2 = this.customRequests.get(requestId);
          if (storedRequest2) {
            reject(new Error(`timeout reached: missing ${storedRequest2.missingUids.size} responses`));
            this.customRequests.delete(requestId);
          }
        }, opts.flags.timeout || DEFAULT_TIMEOUT);
        const storedRequest = {
          type: MessageType.FETCH_SOCKETS,
          resolve: resolve3,
          timeout,
          missingUids: /* @__PURE__ */ new Set([...this.nodesMap.keys()]),
          responses: localSockets
        };
        this.customRequests.set(requestId, storedRequest);
        this.publish({
          type: MessageType.FETCH_SOCKETS,
          data: {
            opts: encodeOptions(opts),
            requestId
          }
        });
      });
    }
    onResponse(response2) {
      const requestId = response2.data.requestId;
      debug2("[%s] received response %s to request %s", this.uid, response2.type, requestId);
      switch (response2.type) {
        case MessageType.FETCH_SOCKETS_RESPONSE: {
          const request2 = this.customRequests.get(requestId);
          if (!request2) {
            return;
          }
          response2.data.sockets.forEach((socket2) => request2.responses.push(socket2));
          request2.missingUids.delete(response2.uid);
          if (request2.missingUids.size === 0) {
            clearTimeout(request2.timeout);
            request2.resolve(request2.responses);
            this.customRequests.delete(requestId);
          }
          break;
        }
        case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
          const request2 = this.customRequests.get(requestId);
          if (!request2) {
            return;
          }
          request2.responses.push(response2.data.packet);
          request2.missingUids.delete(response2.uid);
          if (request2.missingUids.size === 0) {
            clearTimeout(request2.timeout);
            request2.resolve(null, request2.responses);
            this.customRequests.delete(requestId);
          }
          break;
        }
        default:
          super.onResponse(response2);
      }
    }
    removeNode(uid) {
      this.customRequests.forEach((request2, requestId) => {
        request2.missingUids.delete(uid);
        if (request2.missingUids.size === 0) {
          clearTimeout(request2.timeout);
          if (request2.type === MessageType.FETCH_SOCKETS) {
            request2.resolve(request2.responses);
          } else if (request2.type === MessageType.SERVER_SIDE_EMIT) {
            request2.resolve(null, request2.responses);
          }
          this.customRequests.delete(requestId);
        }
      });
      this.nodesMap.delete(uid);
    }
  }
  exports2.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;
})(clusterAdapter);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MessageType = exports2.ClusterAdapterWithHeartbeat = exports2.ClusterAdapter = exports2.SessionAwareAdapter = exports2.Adapter = void 0;
  var in_memory_adapter_1 = inMemoryAdapter;
  Object.defineProperty(exports2, "Adapter", { enumerable: true, get: function() {
    return in_memory_adapter_1.Adapter;
  } });
  Object.defineProperty(exports2, "SessionAwareAdapter", { enumerable: true, get: function() {
    return in_memory_adapter_1.SessionAwareAdapter;
  } });
  var cluster_adapter_1 = clusterAdapter;
  Object.defineProperty(exports2, "ClusterAdapter", { enumerable: true, get: function() {
    return cluster_adapter_1.ClusterAdapter;
  } });
  Object.defineProperty(exports2, "ClusterAdapterWithHeartbeat", { enumerable: true, get: function() {
    return cluster_adapter_1.ClusterAdapterWithHeartbeat;
  } });
  Object.defineProperty(exports2, "MessageType", { enumerable: true, get: function() {
    return cluster_adapter_1.MessageType;
  } });
})(dist);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parentNamespace, "__esModule", { value: true });
parentNamespace.ParentNamespace = void 0;
const namespace_1 = namespace;
const socket_io_adapter_1$1 = dist;
const debug_1$2 = __importDefault$1(browserExports);
const debug$3 = (0, debug_1$2.default)("socket.io:parent-namespace");
class ParentNamespace extends namespace_1.Namespace {
  constructor(server2) {
    super(server2, "/_" + ParentNamespace.count++);
    this.children = /* @__PURE__ */ new Set();
  }
  /**
   * @private
   */
  _initAdapter() {
    this.adapter = new ParentBroadcastAdapter(this, this.children);
  }
  emit(ev, ...args) {
    this.children.forEach((nsp) => {
      nsp.emit(ev, ...args);
    });
    return true;
  }
  createChild(name2) {
    debug$3("creating child namespace %s", name2);
    const namespace2 = new namespace_1.Namespace(this.server, name2);
    namespace2._fns = this._fns.slice(0);
    this.listeners("connect").forEach((listener2) => namespace2.on("connect", listener2));
    this.listeners("connection").forEach((listener2) => namespace2.on("connection", listener2));
    this.children.add(namespace2);
    if (this.server._opts.cleanupEmptyChildNamespaces) {
      const remove = namespace2._remove;
      namespace2._remove = (socket2) => {
        remove.call(namespace2, socket2);
        if (namespace2.sockets.size === 0) {
          debug$3("closing child namespace %s", name2);
          namespace2.adapter.close();
          this.server._nsps.delete(namespace2.name);
          this.children.delete(namespace2);
        }
      };
    }
    this.server._nsps.set(name2, namespace2);
    this.server.sockets.emitReserved("new_namespace", namespace2);
    return namespace2;
  }
  fetchSockets() {
    throw new Error("fetchSockets() is not supported on parent namespaces");
  }
}
parentNamespace.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;
class ParentBroadcastAdapter extends socket_io_adapter_1$1.Adapter {
  constructor(parentNsp, children) {
    super(parentNsp);
    this.children = children;
  }
  broadcast(packet, opts) {
    this.children.forEach((nsp) => {
      nsp.adapter.broadcast(packet, opts);
    });
  }
}
var uws = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(uws, "__esModule", { value: true });
uws.serveFile = uws.restoreAdapter = uws.patchAdapter = void 0;
const socket_io_adapter_1 = dist;
const fs_1 = require$$2$2;
const debug_1$1 = __importDefault(browserExports);
const debug$2 = (0, debug_1$1.default)("socket.io:adapter-uws");
const SEPARATOR = "";
const { addAll, del: del$1, broadcast } = socket_io_adapter_1.Adapter.prototype;
function patchAdapter(app2) {
  socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {
    const isNew = !this.sids.has(id);
    addAll.call(this, id, rooms);
    const socket2 = this.nsp.sockets.get(id);
    if (!socket2) {
      return;
    }
    if (socket2.conn.transport.name === "websocket") {
      subscribe(this.nsp.name, socket2, isNew, rooms);
      return;
    }
    if (isNew) {
      socket2.conn.on("upgrade", () => {
        const rooms2 = this.sids.get(id);
        if (rooms2) {
          subscribe(this.nsp.name, socket2, isNew, rooms2);
        }
      });
    }
  };
  socket_io_adapter_1.Adapter.prototype.del = function(id, room) {
    del$1.call(this, id, room);
    const socket2 = this.nsp.sockets.get(id);
    if (socket2 && socket2.conn.transport.name === "websocket") {
      const sessionId = socket2.conn.id;
      const websocket2 = socket2.conn.transport.socket;
      const topic = `${this.nsp.name}${SEPARATOR}${room}`;
      debug$2("unsubscribe connection %s from topic %s", sessionId, topic);
      websocket2.unsubscribe(topic);
    }
  };
  socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {
    const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
    if (!useFastPublish) {
      broadcast.call(this, packet, opts);
      return;
    }
    const flags = opts.flags || {};
    const basePacketOpts = {
      preEncoded: true,
      volatile: flags.volatile,
      compress: flags.compress
    };
    packet.nsp = this.nsp.name;
    const encodedPackets = this.encoder.encode(packet);
    const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
    debug$2("fast publish to %s", topic);
    encodedPackets.forEach((encodedPacket) => {
      const isBinary2 = typeof encodedPacket !== "string";
      app2.publish(topic, isBinary2 ? encodedPacket : "4" + encodedPacket, isBinary2);
    });
    this.apply(opts, (socket2) => {
      if (socket2.conn.transport.name !== "websocket") {
        socket2.client.writeToEngine(encodedPackets, basePacketOpts);
      }
    });
  };
}
uws.patchAdapter = patchAdapter;
function subscribe(namespaceName, socket2, isNew, rooms) {
  const sessionId = socket2.conn.id;
  const websocket2 = socket2.conn.transport.socket;
  if (isNew) {
    debug$2("subscribe connection %s to topic %s", sessionId, namespaceName);
    websocket2.subscribe(namespaceName);
  }
  rooms.forEach((room) => {
    const topic = `${namespaceName}${SEPARATOR}${room}`;
    debug$2("subscribe connection %s to topic %s", sessionId, topic);
    websocket2.subscribe(topic);
  });
}
function restoreAdapter() {
  socket_io_adapter_1.Adapter.prototype.addAll = addAll;
  socket_io_adapter_1.Adapter.prototype.del = del$1;
  socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
}
uws.restoreAdapter = restoreAdapter;
const toArrayBuffer = (buffer2) => {
  const { buffer: arrayBuffer, byteOffset, byteLength } = buffer2;
  return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
};
function serveFile(res2, filepath) {
  const { size } = (0, fs_1.statSync)(filepath);
  const readStream = (0, fs_1.createReadStream)(filepath);
  const destroyReadStream2 = () => !readStream.destroyed && readStream.destroy();
  const onError = (error3) => {
    destroyReadStream2();
    throw error3;
  };
  const onDataChunk = (chunk) => {
    const arrayBufferChunk = toArrayBuffer(chunk);
    const lastOffset = res2.getWriteOffset();
    const [ok, done2] = res2.tryEnd(arrayBufferChunk, size);
    if (!done2 && !ok) {
      readStream.pause();
      res2.onWritable((offset) => {
        const [ok2, done3] = res2.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
        if (!done3 && ok2) {
          readStream.resume();
        }
        return ok2;
      });
    }
  };
  res2.onAborted(destroyReadStream2);
  readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream2);
}
uws.serveFile = serveFile;
const name$1 = "socket.io";
const version$1 = "4.7.5";
const description$1 = "node.js realtime framework server";
const keywords$1 = [
  "realtime",
  "framework",
  "websocket",
  "tcp",
  "events",
  "socket",
  "io"
];
const files = [
  "dist/",
  "client-dist/",
  "wrapper.mjs",
  "!**/*.tsbuildinfo"
];
const directories = {
  doc: "docs/",
  example: "example/",
  lib: "lib/",
  test: "test/"
};
const type2 = "commonjs";
const main$1 = "./dist/index.js";
const exports = {
  types: "./dist/index.d.ts",
  "import": "./wrapper.mjs",
  require: "./dist/index.js"
};
const types$1 = "./dist/index.d.ts";
const license$1 = "MIT";
const repository$1 = {
  type: "git",
  url: "git://github.com/socketio/socket.io"
};
const scripts$1 = {
  compile: "rimraf ./dist && tsc",
  test: "npm run format:check && npm run compile && npm run test:types && npm run test:unit",
  "test:types": "tsd",
  "test:unit": "nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts",
  "format:check": 'prettier --check "lib/**/*.ts" "test/**/*.ts"',
  "format:fix": 'prettier --write "lib/**/*.ts" "test/**/*.ts"',
  prepack: "npm run compile"
};
const dependencies$1 = {
  accepts: "~1.3.4",
  base64id: "~2.0.0",
  cors: "~2.8.5",
  debug: "~4.3.2",
  "engine.io": "~6.5.2",
  "socket.io-adapter": "~2.5.2",
  "socket.io-parser": "~4.2.4"
};
const devDependencies$1 = {
  "@types/mocha": "^9.0.0",
  "expect.js": "0.3.1",
  mocha: "^10.0.0",
  nyc: "^15.1.0",
  prettier: "^2.3.2",
  rimraf: "^3.0.2",
  "socket.io-client": "4.7.5",
  "socket.io-client-v2": "npm:socket.io-client@^2.4.0",
  superagent: "^8.0.0",
  supertest: "^6.1.6",
  "ts-node": "^10.2.1",
  tsd: "^0.27.0",
  typescript: "^4.4.2",
  "uWebSockets.js": "github:uNetworking/uWebSockets.js#v20.30.0"
};
const contributors = [
  {
    name: "Guillermo Rauch",
    email: "rauchg@gmail.com"
  },
  {
    name: "Arnout Kazemier",
    email: "info@3rd-eden.com"
  },
  {
    name: "Vladimir Dronnikov",
    email: "dronnikov@gmail.com"
  },
  {
    name: "Einar Otto Stangvik",
    email: "einaros@gmail.com"
  }
];
const engines = {
  node: ">=10.2.0"
};
const tsd = {
  directory: "test"
};
const require$$18 = {
  name: name$1,
  version: version$1,
  description: description$1,
  keywords: keywords$1,
  files,
  directories,
  type: type2,
  main: main$1,
  exports,
  types: types$1,
  license: license$1,
  repository: repository$1,
  scripts: scripts$1,
  dependencies: dependencies$1,
  devDependencies: devDependencies$1,
  contributors,
  engines,
  tsd
};
(function(module, exports2) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Namespace = exports2.Socket = exports2.Server = void 0;
  const http2 = require$$2$2;
  const fs_12 = require$$2$2;
  const zlib_12 = require$$2$2;
  const accepts2 = accepts$3;
  const stream_1 = require$$2$2;
  const path3 = pathExports;
  const engine_io_1 = engine_io;
  const client_1 = client;
  const events_12 = require$$2$2;
  const namespace_12 = namespace;
  Object.defineProperty(exports2, "Namespace", { enumerable: true, get: function() {
    return namespace_12.Namespace;
  } });
  const parent_namespace_1 = parentNamespace;
  const socket_io_adapter_12 = dist;
  const parser = __importStar(cjs);
  const debug_12 = __importDefault2(browserExports);
  const socket_12 = requireSocket();
  Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
    return socket_12.Socket;
  } });
  const typed_events_1 = typedEvents;
  const uws_1 = uws;
  const cors_1 = __importDefault2(libExports);
  const debug2 = (0, debug_12.default)("socket.io:server");
  const clientVersion = require$$18.version;
  const dotMapRegex = /\.map/;
  class Server3 extends typed_events_1.StrictEventEmitter {
    constructor(srv, opts = {}) {
      super();
      this._nsps = /* @__PURE__ */ new Map();
      this.parentNsps = /* @__PURE__ */ new Map();
      this.parentNamespacesFromRegExp = /* @__PURE__ */ new Map();
      if ("object" === typeof srv && srv instanceof Object && !srv.listen) {
        opts = srv;
        srv = void 0;
      }
      this.path(opts.path || "/socket.io");
      this.connectTimeout(opts.connectTimeout || 45e3);
      this.serveClient(false !== opts.serveClient);
      this._parser = opts.parser || parser;
      this.encoder = new this._parser.Encoder();
      this.opts = opts;
      if (opts.connectionStateRecovery) {
        opts.connectionStateRecovery = Object.assign({
          maxDisconnectionDuration: 2 * 60 * 1e3,
          skipMiddlewares: true
        }, opts.connectionStateRecovery);
        this.adapter(opts.adapter || socket_io_adapter_12.SessionAwareAdapter);
      } else {
        this.adapter(opts.adapter || socket_io_adapter_12.Adapter);
      }
      opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
      this.sockets = this.of("/");
      if (srv || typeof srv == "number")
        this.attach(srv);
      if (this.opts.cors) {
        this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
      }
    }
    get _opts() {
      return this.opts;
    }
    serveClient(v) {
      if (!arguments.length)
        return this._serveClient;
      this._serveClient = v;
      return this;
    }
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */
    _checkNamespace(name2, auth, fn) {
      if (this.parentNsps.size === 0)
        return fn(false);
      const keysIterator = this.parentNsps.keys();
      const run = () => {
        const nextFn = keysIterator.next();
        if (nextFn.done) {
          return fn(false);
        }
        nextFn.value(name2, auth, (err, allow) => {
          if (err || !allow) {
            return run();
          }
          if (this._nsps.has(name2)) {
            debug2("dynamic namespace %s already exists", name2);
            return fn(this._nsps.get(name2));
          }
          const namespace2 = this.parentNsps.get(nextFn.value).createChild(name2);
          debug2("dynamic namespace %s was created", name2);
          fn(namespace2);
        });
      };
      run();
    }
    path(v) {
      if (!arguments.length)
        return this._path;
      this._path = v.replace(/\/$/, "");
      const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
      return this;
    }
    connectTimeout(v) {
      if (v === void 0)
        return this._connectTimeout;
      this._connectTimeout = v;
      return this;
    }
    adapter(v) {
      if (!arguments.length)
        return this._adapter;
      this._adapter = v;
      for (const nsp of this._nsps.values()) {
        nsp._initAdapter();
      }
      return this;
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    listen(srv, opts = {}) {
      return this.attach(srv, opts);
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     */
    attach(srv, opts = {}) {
      if ("function" == typeof srv) {
        const msg = "You are trying to attach socket.io to an express request handler function. Please pass a http.Server instance.";
        throw new Error(msg);
      }
      if (Number(srv) == srv) {
        srv = Number(srv);
      }
      if ("number" == typeof srv) {
        debug2("creating http server and binding to %d", srv);
        const port2 = srv;
        srv = http2.createServer((req2, res2) => {
          res2.writeHead(404);
          res2.end();
        });
        srv.listen(port2);
      }
      Object.assign(opts, this.opts);
      opts.path = opts.path || this._path;
      this.initEngine(srv, opts);
      return this;
    }
    attachApp(app2, opts = {}) {
      Object.assign(opts, this.opts);
      opts.path = opts.path || this._path;
      debug2("creating uWebSockets.js-based engine with opts %j", opts);
      const engine = new engine_io_1.uServer(opts);
      engine.attach(app2, opts);
      this.bind(engine);
      if (this._serveClient) {
        app2.get(`${this._path}/*`, (res2, req2) => {
          if (!this.clientPathRegex.test(req2.getUrl())) {
            req2.setYield(true);
            return;
          }
          const filename = req2.getUrl().replace(this._path, "").replace(/\?.*$/, "").replace(/^\//, "");
          const isMap2 = dotMapRegex.test(filename);
          const type3 = isMap2 ? "map" : "source";
          const expectedEtag = '"' + clientVersion + '"';
          const weakEtag = "W/" + expectedEtag;
          const etag3 = req2.getHeader("if-none-match");
          if (etag3) {
            if (expectedEtag === etag3 || weakEtag === etag3) {
              debug2("serve client %s 304", type3);
              res2.writeStatus("304 Not Modified");
              res2.end();
              return;
            }
          }
          debug2("serve client %s", type3);
          res2.writeHeader("cache-control", "public, max-age=0");
          res2.writeHeader("content-type", "application/" + (isMap2 ? "json" : "javascript") + "; charset=utf-8");
          res2.writeHeader("etag", expectedEtag);
          const filepath = path3.join(__dirname, "../client-dist/", filename);
          (0, uws_1.serveFile)(res2, filepath);
        });
      }
      (0, uws_1.patchAdapter)(app2);
    }
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */
    initEngine(srv, opts) {
      debug2("creating engine.io instance with opts %j", opts);
      this.eio = (0, engine_io_1.attach)(srv, opts);
      if (this._serveClient)
        this.attachServe(srv);
      this.httpServer = srv;
      this.bind(this.eio);
    }
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */
    attachServe(srv) {
      debug2("attaching client serving req handler");
      const evs = srv.listeners("request").slice(0);
      srv.removeAllListeners("request");
      srv.on("request", (req2, res2) => {
        if (this.clientPathRegex.test(req2.url)) {
          if (this._corsMiddleware) {
            this._corsMiddleware(req2, res2, () => {
              this.serve(req2, res2);
            });
          } else {
            this.serve(req2, res2);
          }
        } else {
          for (let i2 = 0; i2 < evs.length; i2++) {
            evs[i2].call(srv, req2, res2);
          }
        }
      });
    }
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */
    serve(req2, res2) {
      const filename = req2.url.replace(this._path, "").replace(/\?.*$/, "");
      const isMap2 = dotMapRegex.test(filename);
      const type3 = isMap2 ? "map" : "source";
      const expectedEtag = '"' + clientVersion + '"';
      const weakEtag = "W/" + expectedEtag;
      const etag3 = req2.headers["if-none-match"];
      if (etag3) {
        if (expectedEtag === etag3 || weakEtag === etag3) {
          debug2("serve client %s 304", type3);
          res2.writeHead(304);
          res2.end();
          return;
        }
      }
      debug2("serve client %s", type3);
      res2.setHeader("Cache-Control", "public, max-age=0");
      res2.setHeader("Content-Type", "application/" + (isMap2 ? "json" : "javascript") + "; charset=utf-8");
      res2.setHeader("ETag", expectedEtag);
      Server3.sendFile(filename, req2, res2);
    }
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */
    static sendFile(filename, req2, res2) {
      const readStream = (0, fs_12.createReadStream)(path3.join(__dirname, "../client-dist/", filename));
      const encoding3 = accepts2(req2).encodings(["br", "gzip", "deflate"]);
      const onError = (err) => {
        if (err) {
          res2.end();
        }
      };
      switch (encoding3) {
        case "br":
          res2.writeHead(200, { "content-encoding": "br" });
          (0, stream_1.pipeline)(readStream, (0, zlib_12.createBrotliCompress)(), res2, onError);
          break;
        case "gzip":
          res2.writeHead(200, { "content-encoding": "gzip" });
          (0, stream_1.pipeline)(readStream, (0, zlib_12.createGzip)(), res2, onError);
          break;
        case "deflate":
          res2.writeHead(200, { "content-encoding": "deflate" });
          (0, stream_1.pipeline)(readStream, (0, zlib_12.createDeflate)(), res2, onError);
          break;
        default:
          res2.writeHead(200);
          (0, stream_1.pipeline)(readStream, res2, onError);
      }
    }
    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param engine engine.io (or compatible) server
     * @return self
     */
    bind(engine) {
      this.engine = engine;
      this.engine.on("connection", this.onconnection.bind(this));
      return this;
    }
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */
    onconnection(conn) {
      debug2("incoming connection with id %s", conn.id);
      const client2 = new client_1.Client(this, conn);
      if (conn.protocol === 3) {
        client2.connect("/");
      }
      return this;
    }
    /**
     * Looks up a namespace.
     *
     * @example
     * // with a simple string
     * const myNamespace = io.of("/my-namespace");
     *
     * // with a regex
     * const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
     *   const namespace = socket.nsp; // newNamespace.name === "/dynamic-101"
     *
     *   // broadcast to all clients in the given sub-namespace
     *   namespace.emit("hello");
     * });
     *
     * @param name - nsp name
     * @param fn optional, nsp `connection` ev handler
     */
    of(name2, fn) {
      if (typeof name2 === "function" || name2 instanceof RegExp) {
        const parentNsp = new parent_namespace_1.ParentNamespace(this);
        debug2("initializing parent namespace %s", parentNsp.name);
        if (typeof name2 === "function") {
          this.parentNsps.set(name2, parentNsp);
        } else {
          this.parentNsps.set((nsp2, conn, next) => next(null, name2.test(nsp2)), parentNsp);
          this.parentNamespacesFromRegExp.set(name2, parentNsp);
        }
        if (fn) {
          parentNsp.on("connect", fn);
        }
        return parentNsp;
      }
      if (String(name2)[0] !== "/")
        name2 = "/" + name2;
      let nsp = this._nsps.get(name2);
      if (!nsp) {
        for (const [regex, parentNamespace2] of this.parentNamespacesFromRegExp) {
          if (regex.test(name2)) {
            debug2("attaching namespace %s to parent namespace %s", name2, regex);
            return parentNamespace2.createChild(name2);
          }
        }
        debug2("initializing namespace %s", name2);
        nsp = new namespace_12.Namespace(this, name2);
        this._nsps.set(name2, nsp);
        if (name2 !== "/") {
          this.sockets.emitReserved("new_namespace", nsp);
        }
      }
      if (fn)
        nsp.on("connect", fn);
      return nsp;
    }
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     */
    close(fn) {
      this._nsps.forEach((nsp) => {
        nsp.sockets.forEach((socket2) => {
          socket2._onclose("server shutting down");
        });
        nsp.adapter.close();
      });
      this.engine.close();
      (0, uws_1.restoreAdapter)();
      if (this.httpServer) {
        this.httpServer.close(fn);
      } else {
        fn && fn();
      }
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * io.use((socket, next) => {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */
    use(fn) {
      this.sockets.use(fn);
      return this;
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * // the foo event will be broadcast to all connected clients in the room-101 room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * io.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    to(room) {
      return this.sockets.to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    in(room) {
      return this.sockets.in(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    except(room) {
      return this.sockets.except(room);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * io.send("hello");
     *
     * // this is equivalent to
     * io.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
      this.sockets.emit("message", ...args);
      return this;
    }
    /**
     * Sends a `message` event to all clients. Alias of {@link send}.
     *
     * @return self
     */
    write(...args) {
      this.sockets.emit("message", ...args);
      return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * io.serverSideEmit("hello", "world");
     *
     * io.on("hello", (arg1) => {
     *   console.log(arg1); // prints "world"
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * io.serverSideEmit("ping", (err, responses) => {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * io.on("ping", (cb) => {
     *   cb("pong");
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */
    serverSideEmit(ev, ...args) {
      return this.sockets.serverSideEmit(ev, ...args);
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * try {
     *   const responses = await io.serverSideEmitWithAck("ping");
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */
    serverSideEmitWithAck(ev, ...args) {
      return this.sockets.serverSideEmitWithAck(ev, ...args);
    }
    /**
     * Gets a list of socket ids.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link Server#fetchSockets} instead.
     */
    allSockets() {
      return this.sockets.allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    compress(compress) {
      return this.sockets.compress(compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get volatile() {
      return this.sockets.volatile;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the foo event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */
    get local() {
      return this.sockets.local;
    }
    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    timeout(timeout) {
      return this.sockets.timeout(timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */
    fetchSockets() {
      return this.sockets.fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsJoin(room) {
      return this.sockets.socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */
    socketsLeave(room) {
      return this.sockets.socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */
    disconnectSockets(close = false) {
      return this.sockets.disconnectSockets(close);
    }
  }
  exports2.Server = Server3;
  const emitterMethods = Object.keys(events_12.EventEmitter.prototype).filter(function(key) {
    return typeof events_12.EventEmitter.prototype[key] === "function";
  });
  emitterMethods.forEach(function(fn) {
    Server3.prototype[fn] = function() {
      return this.sockets[fn].apply(this.sockets, arguments);
    };
  });
  module.exports = (srv, opts) => new Server3(srv, opts);
  module.exports.Server = Server3;
  module.exports.Namespace = namespace_12.Namespace;
  module.exports.Socket = socket_12.Socket;
  requireSocket();
})(dist$1, dist$1.exports);
var distExports = dist$1.exports;
const io$1 = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const { Server: Server2, Namespace, Socket: Socket2 } = io$1;
var browser_umd = { exports: {} };
/*! For license information please see browser.umd.js.LICENSE.txt */
(function(module, exports2) {
  !function(t2, e) {
    module.exports = e();
  }("undefined" != typeof self ? self : commonjsGlobal, () => (() => {
    var t2 = { 4986: (t3, e2, r2) => {
      t3.exports = r2(254);
    }, 254: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      function o(t4, e3, r3) {
        return e3 = s2(e3), function(t5, e4) {
          if (e4 && ("object" === i2(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, a() ? Reflect.construct(e3, r3 || [], s2(t4).constructor) : e3.apply(t4, r3));
      }
      function a() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (a = function() {
          return !!t4;
        })();
      }
      function s2(t4) {
        return s2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, s2(t4);
      }
      function c(t4, e3) {
        return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, c(t4, e3);
      }
      r2(8582).set(r2(5221));
      var u = r2(3300);
      u.setBrowser(true), e2.Error = r2(9507), e2.Schema = r2(9703), e2.Types = r2(1148), e2.VirtualType = r2(5165), e2.SchemaType = r2(2319), e2.utils = r2(335), e2.Document = u(), e2.model = function(t4, r3) {
        var n2 = function(t5) {
          function e3(t6, n4) {
            return function(t7, e4) {
              if (!(t7 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, e3), o(this, e3, [t6, r3, n4]);
          }
          return function(t6, e4) {
            if ("function" != typeof e4 && null !== e4)
              throw new TypeError("Super expression must either be null or a function");
            t6.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t6, writable: true, configurable: true } }), Object.defineProperty(t6, "prototype", { writable: false }), e4 && c(t6, e4);
          }(e3, t5), n3 = e3, Object.defineProperty(n3, "prototype", { writable: false }), n3;
          var n3;
        }(e2.Document);
        return n2.modelName = t4, n2;
      }, "undefined" != typeof window && (window.mongoose = t3.exports, window.Buffer = n);
    }, 6024: (t3, e2, r2) => {
      var n = r2(3293), i2 = r2(3550).EventEmitter, o = r2(9507), a = r2(9703), s2 = r2(6704), c = o.ValidationError, u = r2(8892), f = r2(4797);
      function l(t4, e3, r3, i3, c2) {
        if (!(this instanceof l))
          return new l(t4, e3, r3, i3, c2);
        if (f(e3) && !e3.instanceOfSchema && (e3 = new a(e3)), e3 = this.schema || e3, !this.schema && e3.options._id && void 0 === (t4 = t4 || {})._id && (t4._id = new s2()), !e3)
          throw new o.MissingSchemaError();
        for (var h2 in this.$__setSchema(e3), n.call(this, t4, r3, i3, c2), u(this, e3, { decorateDoc: true }), e3.methods)
          this[h2] = e3.methods[h2];
        for (var p in e3.statics)
          this[p] = e3.statics[p];
      }
      l.prototype = Object.create(n.prototype), l.prototype.constructor = l, l.events = new i2(), l.$emitter = new i2(), ["on", "once", "emit", "listeners", "removeListener", "setMaxListeners", "removeAllListeners", "addListener"].forEach(function(t4) {
        l[t4] = function() {
          return l.$emitter[t4].apply(l.$emitter, arguments);
        };
      }), l.ValidationError = c, t3.exports = l;
    }, 8447: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return i2(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i2(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a = r2(6148), s2 = r2(6166), c = r2(2176), u = r2(8385), f = r2(2503), l = r2(5132), h2 = r2(1654), p = r2(499), d2 = r2(7352), y2 = r2(4797), b = r2(6504), m2 = r2(335), v = ["Polygon", "MultiPolygon"];
      function g(t4, e3, r3) {
        if (Array.isArray(t4))
          t4.forEach(function(n3, i4) {
            if (Array.isArray(n3) || y2(n3))
              return g(n3, e3, r3);
            t4[i4] = e3.castForQuery(null, n3, r3);
          });
        else
          for (var n2 = Object.keys(t4), i3 = n2.length; i3--; ) {
            var o2 = n2[i3], a2 = t4[o2];
            Array.isArray(a2) || y2(a2) ? (g(a2, e3, r3), t4[o2] = a2) : t4[o2] = e3.castForQuery({ val: a2, context: r3 });
          }
      }
      function _(t4, e3, r3, n2) {
        if ("strictQuery" in t4)
          return t4.strictQuery;
        if ("strictQuery" in e3)
          return e3.strictQuery;
        var i3 = n2 && n2.mongooseCollection && n2.mongooseCollection.conn && n2.mongooseCollection.conn.base && n2.mongooseCollection.conn.base.options;
        return i3 && "strictQuery" in i3 ? i3.strictQuery : r3.strictQuery;
      }
      t3.exports = function t4(e3, r3, i3, w2) {
        if (Array.isArray(r3))
          throw new Error("Query filter must be an object, got an array ", d2.inspect(r3));
        if (null == r3)
          return r3;
        null != e3 && null != e3.discriminators && null != r3[e3.options.discriminatorKey] && (e3 = h2(e3, r3[e3.options.discriminatorKey]) || e3);
        var S, O, j, $, A, E, x = Object.keys(r3), P = x.length;
        for (i3 = i3 || {}; P--; )
          if (E = r3[$ = x[P]], "$or" === $ || "$nor" === $ || "$and" === $) {
            if (!Array.isArray(E))
              throw new a("Array", E, $);
            for (var k = 0; k < E.length; ++k) {
              if (null == E[k] || "object" !== o(E[k]))
                throw new a("Object", E[k], $ + "." + k);
              var M = E[k][e3.options.discriminatorKey];
              if (null == M)
                E[k] = t4(e3, E[k], i3, w2);
              else {
                var I = h2(w2.schema, M);
                E[k] = t4(I || e3, E[k], i3, w2);
              }
            }
          } else {
            if ("$where" === $) {
              if ("string" !== (A = o(E)) && "function" !== A)
                throw new Error("Must have a string or function for $where");
              "function" === A && (r3[$] = E.toString());
              continue;
            }
            if ("$expr" === $) {
              E = u(E, e3);
              continue;
            }
            if ("$elemMatch" === $)
              E = t4(e3, E, i3, w2);
            else if ("$text" === $)
              E = f(E, $);
            else {
              if (!e3)
                continue;
              if (!(O = e3.path($)))
                for (var B = $.split("."), T = B.length; T--; ) {
                  var R = B.slice(0, T).join("."), N = B.slice(T).join("."), D = e3.path(R), L = D && D.schema && D.schema.options && D.schema.options.discriminatorKey;
                  if (null != D && null != (D.schema && D.schema.discriminators) && null != L && N !== L) {
                    var U = l(r3, R + "." + L), C = D.schema.discriminators;
                    "string" == typeof U && null != C[U] ? O = C[U].path(N) : null != U && 1 === Object.keys(U).length && Array.isArray(U.$in) && 1 === U.$in.length && "string" == typeof U.$in[0] && null != C[U.$in[0]] && (O = C[U.$in[0]].path(N));
                  }
                }
              if (O) {
                if (null == E)
                  continue;
                if (m2.isPOJO(E))
                  if (Object.keys(E).some(p))
                    for (var q = Object.keys(E), F = void 0, V = q.length; V--; )
                      if (j = E[F = q[V]], "$elemMatch" === F)
                        j && null != O && null != O.schema ? t4(O.schema, j, i3, w2) : j && null != O && O.$isMongooseArray && (m2.isPOJO(j) && null != j.$not ? t4(e3, j, i3, w2) : E[F] = O.castForQuery(F, j, w2));
                      else if ("$not" === F) {
                        if (j && O) {
                          if ((S = Object.keys(j)).length && p(S[0]))
                            for (var z in j)
                              j[z] = O.castForQuery(z, j[z], w2);
                          else
                            E[F] = O.castForQuery(F, j, w2);
                          continue;
                        }
                      } else
                        E[F] = O.castForQuery(F, j, w2);
                  else
                    r3[$] = O.castForQuery(null, E, w2);
                else if (Array.isArray(E) && -1 === ["Buffer", "Array"].indexOf(O.instance)) {
                  var K, H = [], W = n(E);
                  try {
                    for (W.s(); !(K = W.n()).done; ) {
                      var J = K.value;
                      H.push(O.castForQuery(null, J, w2));
                    }
                  } catch (t5) {
                    W.e(t5);
                  } finally {
                    W.f();
                  }
                  r3[$] = { $in: H };
                } else
                  r3[$] = O.castForQuery(null, E, w2);
              } else {
                for (var G = $.split("."), Y = G.length, Q = void 0, X = void 0, Z = void 0; Y-- && (Q = G.slice(0, Y).join("."), !(O = e3.path(Q))); )
                  ;
                if (O) {
                  if (O.caster && O.caster.schema) {
                    (Z = {})[X = G.slice(Y).join(".")] = E;
                    var tt = t4(O.caster.schema, Z, i3, w2)[X];
                    void 0 === tt ? delete r3[$] : r3[$] = tt;
                  } else
                    r3[$] = E;
                  continue;
                }
                if (y2(E)) {
                  var et = "";
                  if (E.$near ? et = "$near" : E.$nearSphere ? et = "$nearSphere" : E.$within ? et = "$within" : E.$geoIntersects ? et = "$geoIntersects" : E.$geoWithin && (et = "$geoWithin"), et) {
                    var rt = new c.Number("__QueryCasting__"), nt = E[et];
                    if (null != E.$maxDistance && (E.$maxDistance = rt.castForQuery(null, E.$maxDistance, w2)), null != E.$minDistance && (E.$minDistance = rt.castForQuery(null, E.$minDistance, w2)), "$within" === et) {
                      var it = nt.$center || nt.$centerSphere || nt.$box || nt.$polygon;
                      if (!it)
                        throw new Error("Bad $within parameter: " + JSON.stringify(E));
                      nt = it;
                    } else if ("$near" === et && "string" == typeof nt.type && Array.isArray(nt.coordinates))
                      nt = nt.coordinates;
                    else if (("$near" === et || "$nearSphere" === et || "$geoIntersects" === et) && nt.$geometry && "string" == typeof nt.$geometry.type && Array.isArray(nt.$geometry.coordinates))
                      null != nt.$maxDistance && (nt.$maxDistance = rt.castForQuery(null, nt.$maxDistance, w2)), null != nt.$minDistance && (nt.$minDistance = rt.castForQuery(null, nt.$minDistance, w2)), b(nt.$geometry) && (nt.$geometry = nt.$geometry.toObject({ transform: false, virtuals: false })), nt = nt.$geometry.coordinates;
                    else if ("$geoWithin" === et)
                      if (nt.$geometry) {
                        b(nt.$geometry) && (nt.$geometry = nt.$geometry.toObject({ virtuals: false }));
                        var ot = nt.$geometry.type;
                        if (-1 === v.indexOf(ot))
                          throw new Error('Invalid geoJSON type for $geoWithin "' + ot + '", must be "Polygon" or "MultiPolygon"');
                        nt = nt.$geometry.coordinates;
                      } else
                        nt = nt.$box || nt.$polygon || nt.$center || nt.$centerSphere, b(nt) && (nt = nt.toObject({ virtuals: false }));
                    g(nt, rt, w2);
                    continue;
                  }
                }
                if (e3.nested[$])
                  continue;
                var at = "strict" in i3 ? i3.strict : e3.options.strict, st = _(i3, e3._userProvidedOptions, e3.options, w2);
                if (i3.upsert && at) {
                  if ("throw" === at)
                    throw new s2($);
                  throw new s2($, 'Path "' + $ + '" is not in schema, strict mode is `true`, and upsert is `true`.');
                }
                if ("throw" === st)
                  throw new s2($, 'Path "' + $ + `" is not in schema and strictQuery is 'throw'.`);
                st && delete r3[$];
              }
            }
          }
        return r3;
      };
    }, 6237: (t3, e2, r2) => {
      var n = r2(2402), i2 = r2(3633).Long;
      t3.exports = function(t4) {
        return null == t4 ? t4 : "" === t4 ? null : "bigint" == typeof t4 ? t4 : t4 instanceof i2 ? t4.toBigInt() : "string" == typeof t4 || "number" == typeof t4 ? BigInt(t4) : void n.ok(false);
      };
    }, 7092: (t3, e2, r2) => {
      var n = r2(6148);
      t3.exports = function(e3, r3) {
        if (t3.exports.convertToTrue.has(e3))
          return true;
        if (t3.exports.convertToFalse.has(e3))
          return false;
        if (null == e3)
          return e3;
        throw new n("boolean", e3, r3);
      }, t3.exports.convertToTrue = /* @__PURE__ */ new Set([true, "true", 1, "1", "yes"]), t3.exports.convertToFalse = /* @__PURE__ */ new Set([false, "false", 0, "0", "no"]);
    }, 9973: (t3, e2, r2) => {
      var n = r2(2402);
      t3.exports = function(t4) {
        return null == t4 || "" === t4 ? null : t4 instanceof Date ? (n.ok(!isNaN(t4.valueOf())), t4) : (n.ok("boolean" != typeof t4), e3 = t4 instanceof Number || "number" == typeof t4 ? new Date(t4) : "string" == typeof t4 && !isNaN(Number(t4)) && (Number(t4) >= 275761 || Number(t4) < -271820) ? new Date(Number(t4)) : "function" == typeof t4.valueOf ? new Date(t4.valueOf()) : new Date(t4), isNaN(e3.valueOf()) ? void n.ok(false) : e3);
        var e3;
      };
    }, 3854: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      var o = r2(9394), a = r2(2402);
      t3.exports = function(t4) {
        return null == t4 ? t4 : "object" === i2(t4) && "string" == typeof t4.$numberDecimal ? o.fromString(t4.$numberDecimal) : t4 instanceof o ? t4 : "string" == typeof t4 ? o.fromString(t4) : "function" == typeof n && n.isBuffer(t4) || "function" == typeof Uint8Array && t4 instanceof Uint8Array ? new o(t4) : "number" == typeof t4 ? o.fromString(String(t4)) : "function" == typeof t4.valueOf && "string" == typeof t4.valueOf() ? o.fromString(t4.valueOf()) : void a.ok(false);
      };
    }, 247: (t3, e2, r2) => {
      var n = r2(2402);
      t3.exports = function(t4) {
        return null == t4 ? t4 : "" === t4 ? null : ("string" != typeof t4 && "boolean" != typeof t4 || (t4 = Number(t4)), n.ok(!isNaN(t4)), t4 instanceof Number ? t4.valueOf() : "number" == typeof t4 ? t4 : Array.isArray(t4) || "function" != typeof t4.valueOf ? t4.toString && !Array.isArray(t4) && t4.toString() == Number(t4) ? Number(t4) : void n.ok(false) : Number(t4.valueOf()));
      };
    }, 8092: (t3, e2, r2) => {
      var n = r2(2128), i2 = r2(6704);
      t3.exports = function(t4) {
        if (null == t4)
          return t4;
        if (n(t4, "ObjectId"))
          return t4;
        if (t4._id) {
          if (n(t4._id, "ObjectId"))
            return t4._id;
          if (t4._id.toString instanceof Function)
            return new i2(t4._id.toString());
        }
        return t4.toString instanceof Function ? new i2(t4.toString()) : new i2(t4);
      };
    }, 8471: (t3, e2, r2) => {
      var n = r2(6148);
      t3.exports = function(t4, e3) {
        if (null == t4)
          return t4;
        if (t4._id && "string" == typeof t4._id)
          return t4._id;
        if (t4.toString && t4.toString !== Object.prototype.toString && !Array.isArray(t4))
          return t4.toString();
        throw new n("string", t4, e3);
      };
    }, 991: (t3, e2) => {
      var r2 = Object.freeze(["countDocuments", "distinct", "estimatedDocumentCount", "find", "findOne", "findOneAndReplace", "findOneAndUpdate", "replaceOne", "updateMany", "updateOne", "deleteMany", "deleteOne", "findOneAndDelete"]).concat(["validate"]);
      e2.U = r2;
    }, 3293: (t3, e2, r2) => {
      function n(t4) {
        return function(t5) {
          if (Array.isArray(t5))
            return h2(t5);
        }(t4) || function(t5) {
          if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
            return Array.from(t5);
        }(t4) || l(t4) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function i2() {
        i2 = function() {
          return e3;
        };
        var t4, e3 = {}, r3 = Object.prototype, n2 = r3.hasOwnProperty, o2 = Object.defineProperty || function(t5, e4, r4) {
          t5[e4] = r4.value;
        }, a2 = "function" == typeof Symbol ? Symbol : {}, s3 = a2.iterator || "@@iterator", c2 = a2.asyncIterator || "@@asyncIterator", u2 = a2.toStringTag || "@@toStringTag";
        function f2(t5, e4, r4) {
          return Object.defineProperty(t5, e4, { value: r4, enumerable: true, configurable: true, writable: true }), t5[e4];
        }
        try {
          f2({}, "");
        } catch (t5) {
          f2 = function(t6, e4, r4) {
            return t6[e4] = r4;
          };
        }
        function l2(t5, e4, r4, n3) {
          var i3 = e4 && e4.prototype instanceof g2 ? e4 : g2, a3 = Object.create(i3.prototype), s4 = new I2(n3 || []);
          return o2(a3, "_invoke", { value: x2(t5, r4, s4) }), a3;
        }
        function h3(t5, e4, r4) {
          try {
            return { type: "normal", arg: t5.call(e4, r4) };
          } catch (t6) {
            return { type: "throw", arg: t6 };
          }
        }
        e3.wrap = l2;
        var d3 = "suspendedStart", y3 = "suspendedYield", b2 = "executing", m3 = "completed", v2 = {};
        function g2() {
        }
        function _2() {
        }
        function w3() {
        }
        var S2 = {};
        f2(S2, s3, function() {
          return this;
        });
        var O2 = Object.getPrototypeOf, j2 = O2 && O2(O2(B2([])));
        j2 && j2 !== r3 && n2.call(j2, s3) && (S2 = j2);
        var $2 = w3.prototype = g2.prototype = Object.create(S2);
        function A2(t5) {
          ["next", "throw", "return"].forEach(function(e4) {
            f2(t5, e4, function(t6) {
              return this._invoke(e4, t6);
            });
          });
        }
        function E2(t5, e4) {
          function r4(i4, o3, a3, s4) {
            var c3 = h3(t5[i4], t5, o3);
            if ("throw" !== c3.type) {
              var u3 = c3.arg, f3 = u3.value;
              return f3 && "object" == p(f3) && n2.call(f3, "__await") ? e4.resolve(f3.__await).then(function(t6) {
                r4("next", t6, a3, s4);
              }, function(t6) {
                r4("throw", t6, a3, s4);
              }) : e4.resolve(f3).then(function(t6) {
                u3.value = t6, a3(u3);
              }, function(t6) {
                return r4("throw", t6, a3, s4);
              });
            }
            s4(c3.arg);
          }
          var i3;
          o2(this, "_invoke", { value: function(t6, n3) {
            function o3() {
              return new e4(function(e5, i4) {
                r4(t6, n3, e5, i4);
              });
            }
            return i3 = i3 ? i3.then(o3, o3) : o3();
          } });
        }
        function x2(e4, r4, n3) {
          var i3 = d3;
          return function(o3, a3) {
            if (i3 === b2)
              throw Error("Generator is already running");
            if (i3 === m3) {
              if ("throw" === o3)
                throw a3;
              return { value: t4, done: true };
            }
            for (n3.method = o3, n3.arg = a3; ; ) {
              var s4 = n3.delegate;
              if (s4) {
                var c3 = P2(s4, n3);
                if (c3) {
                  if (c3 === v2)
                    continue;
                  return c3;
                }
              }
              if ("next" === n3.method)
                n3.sent = n3._sent = n3.arg;
              else if ("throw" === n3.method) {
                if (i3 === d3)
                  throw i3 = m3, n3.arg;
                n3.dispatchException(n3.arg);
              } else
                "return" === n3.method && n3.abrupt("return", n3.arg);
              i3 = b2;
              var u3 = h3(e4, r4, n3);
              if ("normal" === u3.type) {
                if (i3 = n3.done ? m3 : y3, u3.arg === v2)
                  continue;
                return { value: u3.arg, done: n3.done };
              }
              "throw" === u3.type && (i3 = m3, n3.method = "throw", n3.arg = u3.arg);
            }
          };
        }
        function P2(e4, r4) {
          var n3 = r4.method, i3 = e4.iterator[n3];
          if (i3 === t4)
            return r4.delegate = null, "throw" === n3 && e4.iterator.return && (r4.method = "return", r4.arg = t4, P2(e4, r4), "throw" === r4.method) || "return" !== n3 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), v2;
          var o3 = h3(i3, e4.iterator, r4.arg);
          if ("throw" === o3.type)
            return r4.method = "throw", r4.arg = o3.arg, r4.delegate = null, v2;
          var a3 = o3.arg;
          return a3 ? a3.done ? (r4[e4.resultName] = a3.value, r4.next = e4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = t4), r4.delegate = null, v2) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, v2);
        }
        function k2(t5) {
          var e4 = { tryLoc: t5[0] };
          1 in t5 && (e4.catchLoc = t5[1]), 2 in t5 && (e4.finallyLoc = t5[2], e4.afterLoc = t5[3]), this.tryEntries.push(e4);
        }
        function M2(t5) {
          var e4 = t5.completion || {};
          e4.type = "normal", delete e4.arg, t5.completion = e4;
        }
        function I2(t5) {
          this.tryEntries = [{ tryLoc: "root" }], t5.forEach(k2, this), this.reset(true);
        }
        function B2(e4) {
          if (e4 || "" === e4) {
            var r4 = e4[s3];
            if (r4)
              return r4.call(e4);
            if ("function" == typeof e4.next)
              return e4;
            if (!isNaN(e4.length)) {
              var i3 = -1, o3 = function r5() {
                for (; ++i3 < e4.length; )
                  if (n2.call(e4, i3))
                    return r5.value = e4[i3], r5.done = false, r5;
                return r5.value = t4, r5.done = true, r5;
              };
              return o3.next = o3;
            }
          }
          throw new TypeError(p(e4) + " is not iterable");
        }
        return _2.prototype = w3, o2($2, "constructor", { value: w3, configurable: true }), o2(w3, "constructor", { value: _2, configurable: true }), _2.displayName = f2(w3, u2, "GeneratorFunction"), e3.isGeneratorFunction = function(t5) {
          var e4 = "function" == typeof t5 && t5.constructor;
          return !!e4 && (e4 === _2 || "GeneratorFunction" === (e4.displayName || e4.name));
        }, e3.mark = function(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, w3) : (t5.__proto__ = w3, f2(t5, u2, "GeneratorFunction")), t5.prototype = Object.create($2), t5;
        }, e3.awrap = function(t5) {
          return { __await: t5 };
        }, A2(E2.prototype), f2(E2.prototype, c2, function() {
          return this;
        }), e3.AsyncIterator = E2, e3.async = function(t5, r4, n3, i3, o3) {
          void 0 === o3 && (o3 = Promise);
          var a3 = new E2(l2(t5, r4, n3, i3), o3);
          return e3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(t6) {
            return t6.done ? t6.value : a3.next();
          });
        }, A2($2), f2($2, u2, "Generator"), f2($2, s3, function() {
          return this;
        }), f2($2, "toString", function() {
          return "[object Generator]";
        }), e3.keys = function(t5) {
          var e4 = Object(t5), r4 = [];
          for (var n3 in e4)
            r4.push(n3);
          return r4.reverse(), function t6() {
            for (; r4.length; ) {
              var n4 = r4.pop();
              if (n4 in e4)
                return t6.value = n4, t6.done = false, t6;
            }
            return t6.done = true, t6;
          };
        }, e3.values = B2, I2.prototype = { constructor: I2, reset: function(e4) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(M2), !e4)
            for (var r4 in this)
              "t" === r4.charAt(0) && n2.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = t4);
        }, stop: function() {
          this.done = true;
          var t5 = this.tryEntries[0].completion;
          if ("throw" === t5.type)
            throw t5.arg;
          return this.rval;
        }, dispatchException: function(e4) {
          if (this.done)
            throw e4;
          var r4 = this;
          function i3(n3, i4) {
            return s4.type = "throw", s4.arg = e4, r4.next = n3, i4 && (r4.method = "next", r4.arg = t4), !!i4;
          }
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var a3 = this.tryEntries[o3], s4 = a3.completion;
            if ("root" === a3.tryLoc)
              return i3("end");
            if (a3.tryLoc <= this.prev) {
              var c3 = n2.call(a3, "catchLoc"), u3 = n2.call(a3, "finallyLoc");
              if (c3 && u3) {
                if (this.prev < a3.catchLoc)
                  return i3(a3.catchLoc, true);
                if (this.prev < a3.finallyLoc)
                  return i3(a3.finallyLoc);
              } else if (c3) {
                if (this.prev < a3.catchLoc)
                  return i3(a3.catchLoc, true);
              } else {
                if (!u3)
                  throw Error("try statement without catch or finally");
                if (this.prev < a3.finallyLoc)
                  return i3(a3.finallyLoc);
              }
            }
          }
        }, abrupt: function(t5, e4) {
          for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
            var i3 = this.tryEntries[r4];
            if (i3.tryLoc <= this.prev && n2.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
              var o3 = i3;
              break;
            }
          }
          o3 && ("break" === t5 || "continue" === t5) && o3.tryLoc <= e4 && e4 <= o3.finallyLoc && (o3 = null);
          var a3 = o3 ? o3.completion : {};
          return a3.type = t5, a3.arg = e4, o3 ? (this.method = "next", this.next = o3.finallyLoc, v2) : this.complete(a3);
        }, complete: function(t5, e4) {
          if ("throw" === t5.type)
            throw t5.arg;
          return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && e4 && (this.next = e4), v2;
        }, finish: function(t5) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r4 = this.tryEntries[e4];
            if (r4.finallyLoc === t5)
              return this.complete(r4.completion, r4.afterLoc), M2(r4), v2;
          }
        }, catch: function(t5) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r4 = this.tryEntries[e4];
            if (r4.tryLoc === t5) {
              var n3 = r4.completion;
              if ("throw" === n3.type) {
                var i3 = n3.arg;
                M2(r4);
              }
              return i3;
            }
          }
          throw Error("illegal catch attempt");
        }, delegateYield: function(e4, r4, n3) {
          return this.delegate = { iterator: B2(e4), resultName: r4, nextLoc: n3 }, "next" === this.method && (this.arg = t4), v2;
        } }, e3;
      }
      function o(t4, e3, r3, n2, i3, o2, a2) {
        try {
          var s3 = t4[o2](a2), c2 = s3.value;
        } catch (t5) {
          return void r3(t5);
        }
        s3.done ? e3(c2) : Promise.resolve(c2).then(n2, i3);
      }
      function a(t4) {
        return function() {
          var e3 = this, r3 = arguments;
          return new Promise(function(n2, i3) {
            var a2 = t4.apply(e3, r3);
            function s3(t5) {
              o(a2, n2, i3, s3, c2, "next", t5);
            }
            function c2(t5) {
              o(a2, n2, i3, s3, c2, "throw", t5);
            }
            s3(void 0);
          });
        };
      }
      function s2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function c(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? s2(Object(r3), true).forEach(function(e4) {
            u(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : s2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function u(t4, e3, r3) {
        return e3 = function(t5) {
          var e4 = function(t6, e5) {
            if ("object" != p(t6) || !t6)
              return t6;
            var r4 = t6[Symbol.toPrimitive];
            if (void 0 !== r4) {
              var n2 = r4.call(t6, "string");
              if ("object" != p(n2))
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return "symbol" == p(e4) ? e4 : e4 + "";
        }(e3), e3 in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function f(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = l(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o2, a2 = true, s3 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          s3 = true, o2 = t5;
        }, f: function() {
          try {
            a2 || null == r3.return || r3.return();
          } finally {
            if (s3)
              throw o2;
          }
        } };
      }
      function l(t4, e3) {
        if (t4) {
          if ("string" == typeof t4)
            return h2(t4, e3);
          var r3 = Object.prototype.toString.call(t4).slice(8, -1);
          return "Object" === r3 && t4.constructor && (r3 = t4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? h2(t4, e3) : void 0;
        }
      }
      function h2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function p(t4) {
        return p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, p(t4);
      }
      var d2, y2, b, m2 = r2(3550).EventEmitter, v = r2(641), g = r2(9507), _ = r2(1895), w2 = r2(2260), S = r2(1857), O = r2(3810), j = r2(9703), $ = r2(6166), A = r2(5368), E = r2(8393), x = r2(8279), P = r2(6690), k = r2(8208), M = r2(1829), I = r2(9725).w, B = r2(9725).X, T = r2(9563).B, R = r2(5132), N = r2(8239), D = r2(4051), L = r2(8825), U = r2(8145), C = r2(3933), q = r2(6239), F = r2(1384), V = r2(7352).inspect, z = r2(3920)._, K = r2(1096), H = r2(6470), W = r2(5678), J = r2(2205), G = r2(335), Y = r2(3165), Q = G.deepEqual, X = G.isMongooseObject, Z = r2(5625).arrayAtomicsBackupSymbol, tt = r2(5625).arrayAtomicsSymbol, et = r2(5625).documentArrayParent, rt = r2(5625).documentIsModified, nt = r2(5625).documentModifiedPaths, it = r2(5625).documentSchemaSymbol, ot = r2(5625).getSymbol, at = r2(5625).populateModelSymbol, st = r2(5625).scopeSymbol, ct = r2(3089).schemaMixedSymbol, ut = r2(4094), ft = r2(2609), lt2 = r2(5625).sessionNewDocuments, ht = G.specialProperties;
      function pt(t4, e3, r3, n2) {
        if ("object" === p(r3) && null != r3 && (r3 = (n2 = r3).skipId), n2 = Object.assign({}, n2), null == this.$__schema) {
          var i3 = G.isObject(e3) && !e3.instanceOfSchema ? new j(e3) : e3;
          this.$__setSchema(i3), e3 = r3, r3 = n2, n2 = arguments[4] || {};
        }
        if (this.$__ = new v(), null != n2.isNew && true !== n2.isNew && (this.$isNew = n2.isNew), null != n2.priorDoc && (this.$__.priorDoc = n2.priorDoc), r3 && (this.$__.skipId = r3), null != t4 && "object" !== p(t4))
          throw new S(t4, "obj", "Document");
        var o2 = true;
        void 0 !== n2.defaults && (this.$__.defaults = n2.defaults, o2 = n2.defaults);
        var a2 = this.$__schema;
        "boolean" == typeof e3 || "throw" === e3 ? (true !== e3 && (this.$__.strictMode = e3), e3 = void 0) : true !== a2.options.strict && (this.$__.strictMode = a2.options.strict);
        var s3, c2 = f(a2.requiredPaths(true));
        try {
          for (c2.s(); !(s3 = c2.n()).done; ) {
            var u2 = s3.value;
            this.$__.activePaths.require(u2);
          }
        } catch (t5) {
          c2.e(t5);
        } finally {
          c2.f();
        }
        var l2 = null;
        G.isPOJO(e3) && Object.keys(e3).length > 0 && (l2 = F(e3), this.$__.selected = e3, this.$__.exclude = l2);
        var h3 = false === l2 && e3 ? x(e3) : null;
        if (null == this._doc && (this.$__buildDoc(t4, e3, r3, l2, h3, false), o2 && P(this, e3, l2, h3, true, null)), t4 && (this.$__original_set ? this.$__original_set(t4, void 0, true, n2) : this.$set(t4, void 0, true, n2), t4 instanceof pt && (this.$isNew = t4.$isNew)), n2.willInit && o2 ? n2.skipDefaults && (this.$__.skipDefaults = n2.skipDefaults) : o2 && P(this, e3, l2, h3, false, n2.skipDefaults), !this.$__.strictMode && t4) {
          var d3 = this;
          Object.keys(this._doc).forEach(function(t5) {
            t5 in a2.tree || t5 in a2.methods || t5 in a2.virtuals || t5.startsWith("$") || B({ prop: t5, subprops: null, prototype: d3 });
          });
        }
        !function(t5) {
          var e4 = t5.$__schema && t5.$__schema.callQueue;
          if (e4.length) {
            var r4, n3 = f(e4);
            try {
              for (n3.s(); !(r4 = n3.n()).done; ) {
                var i4 = r4.value;
                "pre" !== i4[0] && "post" !== i4[0] && "on" !== i4[0] && t5[i4[0]].apply(t5, i4[1]);
              }
            } catch (t6) {
              n3.e(t6);
            } finally {
              n3.f();
            }
          }
        }(this);
      }
      for (var dt in pt.prototype.$isMongooseDocumentPrototype = true, Object.defineProperty(pt.prototype, "isNew", { get: function() {
        return this.$isNew;
      }, set: function(t4) {
        this.$isNew = t4;
      } }), Object.defineProperty(pt.prototype, "errors", { get: function() {
        return this.$errors;
      }, set: function(t4) {
        this.$errors = t4;
      } }), pt.prototype.$isNew = true, G.each(["on", "once", "emit", "listeners", "removeListener", "setMaxListeners", "removeAllListeners", "addListener"], function(t4) {
        pt.prototype[t4] = function() {
          if (!this.$__.emitter) {
            if ("emit" === t4)
              return;
            this.$__.emitter = new m2(), this.$__.emitter.setMaxListeners(0);
          }
          return this.$__.emitter[t4].apply(this.$__.emitter, arguments);
        }, pt.prototype["$".concat(t4)] = pt.prototype[t4];
      }), pt.prototype.constructor = pt, m2.prototype)
        pt[dt] = m2.prototype[dt];
      function yt(t4, e3, r3) {
        if (null != t4)
          for (var n2 = Object.keys(r3.$__schema.paths), i3 = n2.length, o2 = -1 === e3.indexOf(".") ? [e3] : e3.split("."), a2 = 0; a2 < i3; ++a2) {
            var s3 = "", c2 = n2[a2];
            if (c2.startsWith(e3 + ".")) {
              var u2 = r3.$__schema.paths[c2], f2 = u2.splitPath().slice(o2.length), l2 = f2.length;
              if (void 0 !== u2.defaultValue)
                for (var h3 = t4, p2 = 0; p2 < l2 && null != h3; ++p2) {
                  var d3 = f2[p2];
                  if (p2 === l2 - 1) {
                    if (void 0 !== h3[d3])
                      break;
                    try {
                      var y3 = u2.getDefault(r3, false);
                      void 0 !== y3 && (h3[d3] = y3);
                    } catch (t5) {
                      r3.invalidate(e3 + "." + s3, t5);
                      break;
                    }
                    break;
                  }
                  s3 += (s3.length ? "." : "") + d3, h3[d3] = h3[d3] || {}, h3 = h3[d3];
                }
            }
          }
      }
      function bt(t4, e3, r3, n2, i3) {
        i3 = i3 || "", null != e3.$__ && (e3 = e3._doc);
        for (var o2, a2, s3, c2 = Object.keys(e3), u2 = c2.length, f2 = 0, l2 = t4.$__.strictMode, h3 = t4.$__schema; f2 < u2; )
          p2(f2++);
        function p2(u3) {
          if ("__proto__" !== (s3 = c2[u3]) && "constructor" !== s3 && (a2 = i3 ? i3 + s3 : s3, o2 = h3.path(a2), !h3.$isRootDiscriminator || t4.$__isSelected(a2))) {
            var f3 = e3[s3];
            if (!o2 && G.isPOJO(f3))
              r3[s3] || (r3[s3] = {}, l2 || s3 in h3.tree || s3 in h3.methods || s3 in h3.virtuals || (t4[s3] = r3[s3])), bt(t4, f3, r3[s3], n2, a2 + ".");
            else if (o2) {
              if (r3.hasOwnProperty(s3) && void 0 !== f3 && !n2.hydratedPopulatedDocs && delete r3[s3], null === f3)
                r3[s3] = o2._castNullish(null);
              else if (void 0 !== f3) {
                var p3 = null == f3.$__ ? null : f3.$__.wasPopulated;
                if (!o2 || p3 || n2.hydratedPopulatedDocs)
                  r3[s3] = f3;
                else
                  try {
                    n2 && n2.setters ? r3[s3] = o2.applySetters(f3, t4, false) : r3[s3] = o2.cast(f3, t4, true);
                  } catch (e4) {
                    t4.invalidate(e4.path, new E({ path: e4.path, message: e4.message, type: "cast", value: e4.value, reason: e4 }));
                  }
              }
              t4.$isModified(a2) || t4.$__.activePaths.init(a2);
            } else
              r3[s3] = f3, l2 || i3 || (t4[s3] = f3);
          }
        }
      }
      function mt(t4) {
        if (null == t4)
          return true;
        if ("object" !== p(t4) || Array.isArray(t4))
          return false;
        for (var e3 = 0, r3 = Object.keys(t4); e3 < r3.length; e3++)
          if (!mt(t4[r3[e3]]))
            return false;
        return true;
      }
      function vt(t4, e3, r3) {
        var n2 = {};
        !function(t5) {
          var e4 = Object.keys(t5.$__.activePaths.getStatePaths("require")), r4 = 0, n3 = e4.length;
          for (r4 = 0; r4 < n3; ++r4) {
            var i4 = e4[r4], o3 = t5.$__schema.path(i4);
            if (null != o3 && "function" == typeof o3.originalRequiredValue) {
              t5.$__.cachedRequired = t5.$__.cachedRequired || {};
              try {
                t5.$__.cachedRequired[i4] = o3.originalRequiredValue.call(t5, t5);
              } catch (e5) {
                t5.invalidate(i4, e5);
              }
            }
          }
        }(t4);
        var i3 = new Set(Object.keys(t4.$__.activePaths.getStatePaths("require")).filter(function(e4) {
          return !(!t4.$__isSelected(e4) && !t4.$isModified(e4)) && (null == t4.$__.cachedRequired || !(e4 in t4.$__.cachedRequired) || t4.$__.cachedRequired[e4]);
        }));
        function o2(t5) {
          i3.add(t5);
        }
        Object.keys(t4.$__.activePaths.getStatePaths("init")).forEach(o2), Object.keys(t4.$__.activePaths.getStatePaths("modify")).forEach(o2), Object.keys(t4.$__.activePaths.getStatePaths("default")).forEach(o2);
        var a2, s3 = t4.$getAllSubdocs(), c2 = t4.modifiedPaths(), u2 = f(s3);
        try {
          for (u2.s(); !(a2 = u2.n()).done; ) {
            var l2 = a2.value;
            if (l2.$basePath) {
              var h3, p2 = l2.$isSingleNested ? l2.$__pathRelativeToParent() : l2.$__fullPathWithIndexes(), d3 = f(l2.modifiedPaths());
              try {
                for (d3.s(); !(h3 = d3.n()).done; ) {
                  var y3 = h3.value;
                  i3.delete(p2 + "." + y3);
                }
              } catch (t5) {
                d3.e(t5);
              } finally {
                d3.f();
              }
              !t4.$isModified(p2, null, c2) || t4.isDirectModified(p2) || t4.$isDefault(p2) || (i3.add(p2), null == t4.$__.pathsToScopes && (t4.$__.pathsToScopes = {}), t4.$__.pathsToScopes[p2] = l2.$isDocumentArrayElement ? l2.__parentArray : l2.$parent(), n2[p2] = { skipSchemaValidators: true }, l2.$isDocumentArrayElement && null != l2.__index && (n2[p2].index = l2.__index));
            }
          }
        } catch (t5) {
          u2.e(t5);
        } finally {
          u2.f();
        }
        var b2, m3 = f(i3);
        try {
          for (m3.s(); !(b2 = m3.n()).done; ) {
            var v2 = b2.value, g2 = t4.$__schema.path(v2);
            if (g2) {
              if (g2.$isMongooseDocumentArray) {
                var _2, w3 = f(i3);
                try {
                  for (w3.s(); !(_2 = w3.n()).done; ) {
                    var S2 = _2.value;
                    (null == S2 || S2.startsWith(g2.path + ".")) && i3.delete(S2);
                  }
                } catch (t5) {
                  w3.e(t5);
                } finally {
                  w3.f();
                }
              }
              (g2.caster || 0 !== g2.validators.length || g2.$parentSchemaDocArray) && (!g2.$isMongooseArray || g2.$isMongooseDocumentArray || g2.$embeddedSchemaType.$isMongooseArray || 0 !== g2.validators.length || 0 !== g2.$embeddedSchemaType.validators.length) || i3.delete(v2);
            }
          }
        } catch (t5) {
          m3.e(t5);
        } finally {
          m3.f();
        }
        var O2, j2 = f(i3);
        try {
          for (j2.s(); !(O2 = j2.n()).done; ) {
            var $2 = O2.value;
            t4.$__schema.singleNestedPaths.hasOwnProperty($2) && i3.delete($2);
          }
        } catch (t5) {
          j2.e(t5);
        } finally {
          j2.f();
        }
        Array.isArray(e3) ? i3 = function(t5, e4) {
          var r4, n3 = new Set(e4), i4 = /* @__PURE__ */ new Map([]), o3 = f(e4);
          try {
            for (o3.s(); !(r4 = o3.n()).done; ) {
              var a3 = r4.value;
              if (-1 !== a3.indexOf("."))
                for (var s4 = a3.split("."), c3 = s4[0], u3 = 1; u3 < s4.length; ++u3)
                  i4.set(c3, a3), c3 = c3 + "." + s4[u3];
            }
          } catch (t6) {
            o3.e(t6);
          } finally {
            o3.f();
          }
          var l3, h4 = /* @__PURE__ */ new Set(), p3 = f(t5);
          try {
            for (p3.s(); !(l3 = p3.n()).done; ) {
              var d4 = l3.value;
              n3.has(d4) ? h4.add(d4) : i4.has(d4) && h4.add(i4.get(d4));
            }
          } catch (t6) {
            p3.e(t6);
          } finally {
            p3.f();
          }
          return h4;
        }(i3, e3) : Array.isArray(r3) && (i3 = function(t5, e4) {
          return e4 = new Set(e4), t5 = Array.from(t5).filter(function(t6) {
            return !e4.has(t6);
          }), new Set(t5);
        }(i3, r3)), function(t5, e4) {
          var r4, n3 = f(e4);
          try {
            for (n3.s(); !(r4 = n3.n()).done; ) {
              var i4 = r4.value, o3 = t5.$__schema.path(i4);
              o3 && o3.$isMongooseArray && (Array.isArray(o3) || !o3.$isMongooseDocumentArray || o3 && o3.schemaOptions && o3.schemaOptions.required) && (!o3.$isMongooseArray || o3.$isMongooseDocumentArray || o3.$embeddedSchemaType.$isMongooseArray || 0 !== o3.$embeddedSchemaType.validators.length) && gt2(t5.$__getValue(i4), e4, i4);
            }
          } catch (t6) {
            n3.e(t6);
          } finally {
            n3.f();
          }
        }(t4, i3);
        var A2, E2 = { skipArrays: true }, x2 = f(i3);
        try {
          for (x2.s(); !(A2 = x2.n()).done; ) {
            var P2 = A2.value;
            if (t4.$__schema.nested[P2]) {
              var k2 = t4.$__getValue(P2);
              X(k2) && (k2 = k2.toObject({ transform: false }));
              var M2 = T(k2, P2, E2, t4.$__schema);
              Object.keys(M2).forEach(o2);
            }
          }
        } catch (t5) {
          x2.e(t5);
        } finally {
          x2.f();
        }
        var I2, B2 = f(i3);
        try {
          for (B2.s(); !(I2 = B2.n()).done; ) {
            var R2 = I2.value, N2 = t4.$__schema.path(R2);
            if (N2 && (N2.$parentSchemaDocArray && "string" == typeof N2.$parentSchemaDocArray.path && i3.add(N2.$parentSchemaDocArray.path), N2.$isSchemaMap)) {
              var D2 = t4.$__getValue(R2);
              if (null != D2) {
                var L2, U2 = f(D2.keys());
                try {
                  for (U2.s(); !(L2 = U2.n()).done; ) {
                    var C2 = L2.value;
                    i3.add(R2 + "." + C2);
                  }
                } catch (t5) {
                  U2.e(t5);
                } finally {
                  U2.f();
                }
              }
            }
          }
        } catch (t5) {
          B2.e(t5);
        } finally {
          B2.f();
        }
        return [i3 = Array.from(i3), n2];
      }
      function gt2(t4, e3, r3) {
        if (null != t4)
          for (var n2 = t4.length, i3 = 0; i3 < n2; ++i3)
            Array.isArray(t4[i3]) ? gt2(t4[i3], e3, r3 + "." + i3) : e3.add(r3 + "." + i3);
      }
      function _t(t4, e3, r3, n2) {
        var i3, o2, a2, s3 = t4.$__schema, c2 = Object.keys(s3.virtuals), u2 = c2.length, f2 = u2, l2 = t4._doc, h3 = "boolean" != typeof (n2 && n2.aliases) || n2.aliases;
        r3 = r3 || {};
        var p2 = null;
        if (Array.isArray(r3.virtuals))
          p2 = new Set(r3.virtuals);
        else if (r3.virtuals && r3.virtuals.pathsToSkip) {
          p2 = new Set(c2);
          for (var d3 = 0; d3 < r3.virtuals.pathsToSkip.length; d3++)
            p2.has(r3.virtuals.pathsToSkip[d3]) && p2.delete(r3.virtuals.pathsToSkip[d3]);
        }
        if (!l2)
          return e3;
        for (u2 = 0; u2 < f2; ++u2)
          if (i3 = c2[u2], (null == p2 || p2.has(i3)) && (h3 || !s3.aliases.hasOwnProperty(i3))) {
            if (o2 = i3, null != r3.path) {
              if (!i3.startsWith(r3.path + "."))
                continue;
              o2 = i3.substring(r3.path.length + 1);
            }
            var y3 = o2.split(".");
            if (void 0 !== (a2 = M(t4.get(i3), r3))) {
              var b2 = y3.length;
              l2 = e3;
              for (var m3 = 0; m3 < b2 - 1; ++m3)
                l2[y3[m3]] = l2[y3[m3]] || {}, l2 = l2[y3[m3]];
              l2[y3[b2 - 1]] = a2;
            }
          }
        return e3;
      }
      function wt(t4, e3) {
        if (Y(e3))
          throw new Error("`transform` function must be synchronous, but the transform on path `" + t4 + "` returned a promise.");
      }
      pt.prototype.$__schema, pt.prototype.schema, Object.defineProperty(pt.prototype, "$locals", { configurable: false, enumerable: false, get: function() {
        return null == this.$__.locals && (this.$__.locals = {}), this.$__.locals;
      }, set: function(t4) {
        this.$__.locals = t4;
      } }), pt.prototype.isNew, Object.defineProperty(pt.prototype, "$where", { configurable: false, enumerable: false, writable: true }), pt.prototype.id, pt.prototype.$errors, Object.defineProperty(pt.prototype, "$op", { get: function() {
        return this.$__.op || null;
      }, set: function(t4) {
        this.$__.op = t4;
      } }), pt.prototype.$__buildDoc = function(t4, e3, r3, n2, i3) {
        for (var o2 = {}, a2 = Object.keys(this.$__schema.paths).filter(function(t5) {
          return !t5.includes("$*");
        }), s3 = a2.length, c2 = 0; c2 < s3; ++c2) {
          var u2 = a2[c2];
          if ("_id" === u2) {
            if (r3)
              continue;
            if (t4 && "_id" in t4)
              continue;
          }
          for (var f2 = this.$__schema.paths[u2].splitPath(), l2 = f2.length, h3 = l2 - 1, p2 = "", d3 = o2, y3 = false, b2 = 0; b2 < l2; ++b2) {
            var m3 = f2[b2];
            if (p2.length ? p2 += "." + m3 : p2 = m3, true === n2) {
              if (p2 in e3)
                break;
            } else if (false === n2 && e3 && !y3) {
              if (p2 in e3)
                y3 = true;
              else if (!i3[p2])
                break;
            }
            b2 < h3 && (d3 = d3[m3] || (d3[m3] = {}));
          }
        }
        this._doc = o2;
      }, pt.prototype.toBSON = function() {
        return this.toObject(z);
      }, pt.prototype.init = function(t4, e3, r3) {
        return "function" == typeof e3 && (r3 = e3, e3 = null), this.$__init(t4, e3), r3 && r3(null, this), this;
      }, pt.prototype.$init = function() {
        return this.constructor.prototype.init.apply(this, arguments);
      }, pt.prototype.$__init = function(t4, e3) {
        if (this.$isNew = false, e3 = e3 || {}, null != t4._id && e3.populated && e3.populated.length) {
          var r3, n2 = String(t4._id), i3 = f(e3.populated);
          try {
            for (i3.s(); !(r3 = i3.n()).done; ) {
              var o2 = r3.value;
              if (o2.isVirtual ? this.$populated(o2.path, G.getValue(o2.path, t4), o2) : this.$populated(o2.path, o2._docs[n2], o2), null != o2._childDocs) {
                var a2, s3 = f(o2._childDocs);
                try {
                  for (s3.s(); !(a2 = s3.n()).done; ) {
                    var c2 = a2.value;
                    null != c2 && null != c2.$__ && (c2.$__.parent = this);
                  }
                } catch (t5) {
                  s3.e(t5);
                } finally {
                  s3.f();
                }
                o2._childDocs = [];
              }
            }
          } catch (t5) {
            i3.e(t5);
          } finally {
            i3.f();
          }
        }
        bt(this, t4, this._doc, e3), K(this, e3.populated), this.$emit("init", this), this.constructor.emit("init", this);
        var u2 = false === this.$__.exclude && this.$__.selected ? x(this.$__.selected) : null;
        return P(this, this.$__.selected, this.$__.exclude, u2, false, this.$__.skipDefaults), this;
      }, pt.prototype.updateOne = function(t4, e3, r3) {
        var n2 = this.constructor.updateOne({ _id: this._id }, t4, e3), i3 = this;
        return n2.pre(function(t5) {
          i3.constructor._middleware.execPre("updateOne", i3, [i3], t5);
        }), n2.post(function(t5) {
          i3.constructor._middleware.execPost("updateOne", i3, [i3], {}, t5);
        }), null != this.$session() && ("session" in n2.options || (n2.options.session = this.$session())), null != r3 ? n2.exec(r3) : n2;
      }, pt.prototype.replaceOne = function() {
        var t4 = Array.prototype.slice.call(arguments);
        return t4.unshift({ _id: this._id }), this.constructor.replaceOne.apply(this.constructor, t4);
      }, pt.prototype.$session = function(t4) {
        if (0 === arguments.length)
          return null != this.$__.session && this.$__.session.hasEnded ? (this.$__.session = null, null) : this.$__.session;
        if (null != t4 && t4.hasEnded)
          throw new g("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
        if (null != t4 || null != this.$__.session) {
          if (this.$__.session = t4, !this.$isSubdocument) {
            var e3, r3 = f(this.$getAllSubdocs());
            try {
              for (r3.s(); !(e3 = r3.n()).done; )
                e3.value.$session(t4);
            } catch (t5) {
              r3.e(t5);
            } finally {
              r3.f();
            }
          }
          return t4;
        }
      }, pt.prototype.$timestamps = function(t4) {
        return 0 === arguments.length ? null != this.$__.timestamps ? this.$__.timestamps : this.$__schema ? this.$__schema.options.timestamps : void 0 : (t4 !== this.$timestamps() && (this.$__.timestamps = t4), this);
      }, pt.prototype.overwrite = function(t4) {
        for (var e3 = 0, r3 = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(t4)))); e3 < r3.length; e3++) {
          var n2 = r3[e3];
          "_id" !== n2 && (this.$__schema.options.versionKey && n2 === this.$__schema.options.versionKey || this.$__schema.options.discriminatorKey && n2 === this.$__schema.options.discriminatorKey || this.$set(n2, t4[n2]));
        }
        return this;
      }, pt.prototype.$set = function(t4, e3, r3, n2) {
        var i3 = this;
        G.isPOJO(r3) && (n2 = r3, r3 = void 0);
        var o2, a2, s3, l2, h3 = n2 && n2.merge, d3 = r3 && true !== r3, y3 = true === r3, b2 = 0, m3 = n2 && "strict" in n2, v2 = m3 ? n2.strict : this.$__.strictMode;
        if (d3 && ((this.$__.adhocPaths || (this.$__.adhocPaths = {}))[t4] = this.$__schema.interpretAsType(t4, r3, this.$__schema.options)), null == t4) {
          var S2 = [e3, t4];
          t4 = S2[0], e3 = S2[1];
        } else if ("string" != typeof t4) {
          if (t4 instanceof pt && (t4 = t4.$__isNested ? t4.toObject() : t4.$__schema === this.$__schema ? _t(t4, c({}, t4._doc)) : t4._doc), null == t4) {
            var O2 = [e3, t4];
            t4 = O2[0], e3 = O2[1];
          }
          l2 = e3 ? e3 + "." : "";
          var j2 = (o2 = D(this.$__schema, t4)).length, A2 = n2 && n2._skipMinimizeTopLevel || false;
          if (0 === j2 && A2)
            return delete n2._skipMinimizeTopLevel, e3 && this.$set(e3, {}), this;
          n2 = Object.assign({}, n2, { _skipMinimizeTopLevel: false });
          for (var E2 = 0; E2 < j2; ++E2) {
            s3 = o2[E2];
            var x2 = l2 ? l2 + s3 : s3;
            a2 = this.$__schema.pathType(x2);
            var P2 = t4[s3];
            if (true !== r3 || l2 || null == P2 || "nested" !== a2 || null == this._doc[s3] || delete this._doc[s3], G.isNonBuiltinObject(P2) && "nested" === a2)
              this.$set(x2, P2, y3, Object.assign({}, n2, { _skipMarkModified: true })), yt(this.$get(x2), x2, this);
            else if (v2) {
              if (y3 && void 0 === P2 && void 0 !== this.$get(x2))
                continue;
              if ("adhocOrUndefined" === a2 && (a2 = N(this, x2, { typeOnly: true })), "real" === a2 || "virtual" === a2)
                this.$set(x2, P2, y3, n2);
              else if ("nested" === a2 && P2 instanceof pt)
                this.$set(x2, P2.toObject({ transform: false }), y3, n2);
              else {
                if ("throw" === v2)
                  throw "nested" === a2 ? new w2(s3, P2) : new $(s3);
                "nested" === a2 && null == P2 && this.$set(x2, P2, y3, n2);
              }
            } else
              void 0 !== P2 && this.$set(x2, P2, y3, n2);
          }
          for (var M2 = {}, I2 = Object.keys(this.$__schema.tree), B2 = 0, T2 = I2.length; B2 < T2; ++B2)
            (s3 = I2[B2]) && this._doc.hasOwnProperty(s3) && (M2[s3] = void 0);
          return this._doc = Object.assign(M2, this._doc), this;
        }
        var R2 = this.$__schema.pathType(t4), C2 = null;
        if ("adhocOrUndefined" === R2 && (C2 = -1 === t4.indexOf(".") ? [t4] : t4.split("."), R2 = N(this, C2, { typeOnly: true })), "adhocOrUndefined" === R2 && !m3) {
          null == C2 && (C2 = -1 === t4.indexOf(".") ? [t4] : t4.split("."));
          var q2 = L(this.$__schema, C2);
          void 0 !== q2 && (v2 = q2);
        }
        e3 = U(e3, true);
        var F2, V2 = null != i3.$__.priorDoc ? i3.$__.priorDoc.$__getValue(t4) : y3 ? void 0 : i3.$__getValue(t4);
        if ("nested" === R2 && e3) {
          if ("object" === p(e3) && null != e3) {
            if (null != e3.$__ && (e3 = e3.toObject(z)), null == e3)
              return this.invalidate(t4, new g.CastError("Object", e3, t4)), this;
            var K2 = this.$isModified(t4), H2 = null != this.$__.savedState && this.$__.savedState.hasOwnProperty(t4);
            if (null != this.$__.savedState && !this.$isNew && !this.$__.savedState.hasOwnProperty(t4)) {
              var J2 = this.$__getValue(t4);
              this.$__.savedState[t4] = J2;
              for (var Y2 = 0, Q2 = Object.keys(J2 || {}); Y2 < Q2.length; Y2++) {
                var X2 = Q2[Y2];
                this.$__.savedState[t4 + "." + X2] = J2[X2];
              }
            }
            if (h3)
              return this.$set(e3, t4, y3);
            this.$__setValue(t4, null), k(this, t4);
            var Z2 = D(this.$__schema, e3, t4);
            this.$__setValue(t4, {});
            var tt2, et2 = f(Z2);
            try {
              for (et2.s(); !(tt2 = et2.n()).done; ) {
                var rt2 = tt2.value;
                this.$set(t4 + "." + rt2, e3[rt2], y3, c(c({}, n2), {}, { _skipMarkModified: true }));
              }
            } catch (t5) {
              et2.e(t5);
            } finally {
              et2.f();
            }
            return null == V2 || K2 && !H2 || !G.deepEqual(H2 ? this.$__.savedState[t4] : V2, e3) ? this.markModified(t4) : this.unmarkModified(t4), this;
          }
          return this.invalidate(t4, new g.CastError("Object", e3, t4)), this;
        }
        if (null == C2 && (C2 = -1 === t4.indexOf(".") ? [t4] : t4.split(".")), "string" == typeof this.$__schema.aliases[C2[0]] && (C2[0] = this.$__schema.aliases[C2[0]]), "adhocOrUndefined" === R2 && v2) {
          var nt2;
          for (b2 = 0; b2 < C2.length; ++b2) {
            var it2 = C2.slice(0, b2 + 1).join(".");
            if (b2 + 1 < C2.length && "virtual" === this.$__schema.pathType(it2))
              return W.set(t4, e3, this), this;
            if (null != (F2 = this.$__schema.path(it2))) {
              if (F2 instanceof _) {
                nt2 = true;
                break;
              }
              if (F2.$isSchemaMap && F2.$__schemaType instanceof _ && b2 < C2.length - 1) {
                nt2 = true, F2 = F2.$__schemaType;
                break;
              }
            }
          }
          if (null == F2 && (F2 = N(this, t4)), !nt2 && !F2) {
            if ("throw" === v2)
              throw new $(t4);
            return this;
          }
        } else {
          if ("virtual" === R2)
            return (F2 = this.$__schema.virtualpath(t4)).applySetters(e3, this), this;
          F2 = this.$__path(t4);
        }
        var ot2, st2 = this._doc, ct2 = "";
        for (b2 = 0; b2 < C2.length - 1; ++b2)
          st2 = st2[C2[b2]], ct2 += (0 !== ct2.length ? "." : "") + C2[b2], st2 || (this.$set(ct2, {}), this.$__isSelected(ct2) || this.unmarkModified(ct2), st2 = this.$__getValue(ct2));
        if (C2.length <= 1)
          ot2 = t4;
        else {
          var ut2 = C2.length;
          for (b2 = 0; b2 < ut2; ++b2) {
            var ht2 = C2.slice(0, b2 + 1).join(".");
            if (null === this.$get(ht2, null, { getters: false })) {
              ot2 = ht2;
              break;
            }
          }
          ot2 || (ot2 = t4);
        }
        if (!F2)
          return this.$__set(ot2, t4, n2, y3, C2, F2, e3, V2), "nested" === R2 && null == e3 && k(this, t4), this;
        if ((F2.$isSingleNested || F2.$isMongooseArray) && function(t5, e4) {
          if (t5.$__.validationError) {
            for (var r4 = 0, n3 = Object.keys(t5.$__.validationError.errors); r4 < n3.length; r4++) {
              var i4 = n3[r4];
              i4.startsWith(e4 + ".") && delete t5.$__.validationError.errors[i4];
            }
            0 === Object.keys(t5.$__.validationError.errors).length && (t5.$__.validationError = null);
          }
        }(this, t4), null != e3 && h3 && F2.$isSingleNested) {
          e3 instanceof pt && (e3 = e3.toObject({ virtuals: false, transform: false }));
          for (var dt2 = 0, bt2 = Object.keys(e3); dt2 < bt2.length; dt2++) {
            var mt2 = bt2[dt2];
            this.$set(t4 + "." + mt2, e3[mt2], y3, n2);
          }
          return this;
        }
        var vt2 = true;
        try {
          var gt3, wt2 = function() {
            if (null == F2.options)
              return false;
            if (!(e3 instanceof pt))
              return false;
            var t5 = e3.constructor, r4 = F2.options.ref;
            if (null != r4 && (r4 === t5.modelName || r4 === t5.baseModelName))
              return true;
            var n3 = F2.options.refPath;
            if (null == n3)
              return false;
            var i4 = e3.get(n3);
            return i4 === t5.modelName || i4 === t5.baseModelName;
          }(), St = false;
          if (wt2 && e3 instanceof pt && (!e3.$__.wasPopulated || G.deepEqual(e3.$__.wasPopulated.value, e3._id))) {
            var Ot = F2 && F2.$isSingleNested ? F2.cast(e3, this) : e3._id;
            this.$populated(t4, Ot, u({}, at, e3.constructor)), e3.$__.wasPopulated = { value: Ot }, St = true;
          }
          var jt = this.$__schema.options.typeKey;
          if (F2.options && Array.isArray(F2.options[jt]) && F2.options[jt].length && F2.options[jt][0] && F2.options[jt][0].ref && function(t5, e4) {
            if (!Array.isArray(t5))
              return false;
            if (0 === t5.length)
              return false;
            var r4, n3 = f(t5);
            try {
              for (n3.s(); !(r4 = n3.n()).done; ) {
                var i4 = r4.value;
                if (!(i4 instanceof pt))
                  return false;
                if (null == i4.constructor.modelName)
                  return false;
                if (i4.constructor.modelName != e4 && i4.constructor.baseModelName != e4)
                  return false;
              }
            } catch (t6) {
              n3.e(t6);
            } finally {
              n3.f();
            }
            return true;
          }(e3, F2.options[jt][0].ref)) {
            gt3 = u({}, at, e3[0].constructor), this.$populated(t4, e3.map(function(t5) {
              return t5._id;
            }), gt3);
            var $t, At = f(e3);
            try {
              for (At.s(); !($t = At.n()).done; ) {
                var Et = $t.value;
                Et.$__.wasPopulated = { value: Et._id };
              }
            } catch (t5) {
              At.e(t5);
            } finally {
              At.f();
            }
            St = true;
          }
          if (!wt2 || !F2.$isSingleNested || !e3.$__) {
            var xt = this;
            null != this.$__schema.singleNestedPaths[t4] && C2.length > 1 && (xt = ft(this, C2, this.schema)), e3 = null != n2 && n2.overwriteImmutable ? F2.applySetters(e3, xt, false, V2, { overwriteImmutable: true }) : F2.applySetters(e3, xt, false, V2);
          }
          if (Array.isArray(e3) && !Array.isArray(F2) && F2.$isMongooseDocumentArray && 0 !== e3.length && null != e3[0] && null != e3[0].$__ && null != e3[0].$__.populated) {
            for (var Pt = Object.keys(e3[0].$__.populated), kt = function() {
              var r4 = It[Mt];
              i3.$populated(t4 + "." + r4, e3.map(function(t5) {
                return t5.$populated(r4);
              }), e3[0].$__.populated[r4].options);
            }, Mt = 0, It = Pt; Mt < It.length; Mt++)
              kt();
            St = true;
          }
          if (!St && this.$__.populated) {
            if (Array.isArray(e3) && this.$__.populated[t4])
              for (var Bt = 0; Bt < e3.length; ++Bt)
                e3[Bt] instanceof pt && e3.set(Bt, e3[Bt]._id, true);
            delete this.$__.populated[t4];
          }
          null != e3 && F2.$isSingleNested && function(t5, e4, r4) {
            var n3 = e4.schema;
            if (null != n3)
              for (var i4 = 0, o3 = Object.keys(n3.paths); i4 < o3.length; i4++) {
                var a3 = o3[i4], s4 = n3.paths[a3];
                if (null != s4.$immutableSetter) {
                  var c2 = null == r4 ? void 0 : r4.$__getValue(a3);
                  s4.$immutableSetter.call(t5, c2);
                }
              }
          }(e3, F2, V2), this.$markValid(t4);
        } catch (r4) {
          r4 instanceof g.StrictModeError && r4.isImmutableError ? this.invalidate(t4, r4) : r4 instanceof g.CastError ? (this.invalidate(r4.path, r4), r4.$originalErrorPath && this.invalidate(t4, new g.CastError(F2.instance, e3, t4, r4.$originalErrorPath))) : this.invalidate(t4, new g.CastError(F2.instance, e3, t4, r4)), vt2 = false;
        }
        if (vt2) {
          var Tt, Rt = null, Nt = null;
          if (!y3) {
            var Dt = this.$isSubdocument ? this.ownerDocument() : this;
            Rt = Dt.$__.savedState, Nt = this.$isSubdocument ? this.$__.fullPath + "." + t4 : t4, Dt.$__saveInitialState(Nt);
          }
          this.$__set(ot2, t4, n2, y3, C2, F2, e3, V2);
          var Lt = !(null === (Tt = this.$__.session) || void 0 === Tt || !Tt.transaction), Ut = this.$__.session && this.$__.session[lt2] && this.$__.session[lt2].has(this) && this.$__.session[lt2].get(this).modifiedPaths && !this.$__.session[lt2].get(this).modifiedPaths.has(Nt);
          null != Rt && Rt.hasOwnProperty(Nt) && (!Lt || Ut) && G.deepEqual(e3, Rt[Nt]) && this.unmarkModified(t4);
        }
        return F2.$isSingleNested && (this.isDirectModified(t4) || null == e3) && k(this, t4), this;
      }, pt.prototype.set = pt.prototype.$set, pt.prototype.$__shouldModify = function(t4, e3, r3, n2, i3, o2, a2, s3) {
        return !(r3 && r3._skipMarkModified || !this.$isNew && !(e3 in this.$__.activePaths.getStatePaths("modify")) && (void 0 !== a2 || this.$__isSelected(e3)) && (void 0 === a2 && e3 in this.$__.activePaths.getStatePaths("default") || this.$populated(e3) && a2 instanceof pt && Q(a2._id, s3) || Q(a2, void 0 !== s3 ? s3 : G.getValue(e3, this)) && (n2 || null == a2 || !(e3 in this.$__.activePaths.getStatePaths("default")) || !Q(a2, o2.getDefault(this, n2)))));
      }, pt.prototype.$__set = function(t4, e3, n2, i3, o2, a2, s3, c2) {
        b = b || r2(8578), this.$__shouldModify(t4, e3, n2, i3, o2, a2, s3, c2) ? (this.$__.primitiveAtomics && this.$__.primitiveAtomics[e3] && (delete this.$__.primitiveAtomics[e3], 0 === Object.keys(this.$__.primitiveAtomics).length && delete this.$__.primitiveAtomics), this.markModified(t4), y2 || (y2 = r2(2918)), s3 && G.isMongooseArray(s3) && (s3._registerAtomic("$set", s3), G.isMongooseDocumentArray(s3) && s3.forEach(function(t5) {
          t5 && t5.__parentArray && (t5.__parentArray = s3);
        }))) : Array.isArray(s3) && Array.isArray(c2) && G.isMongooseArray(s3) && G.isMongooseArray(c2) && (s3[tt] = c2[tt], s3[Z] = c2[Z], G.isMongooseDocumentArray(s3) && s3.forEach(function(t5) {
          null != t5 && (t5.$isNew = false);
        }));
        for (var u2 = this._doc, f2 = 0, l2 = o2.length, h3 = ""; f2 < l2; f2++) {
          var p2 = f2 + 1 === l2;
          if (h3 += h3 ? "." + o2[f2] : o2[f2], ht.has(o2[f2]))
            return;
          if (p2)
            u2 instanceof Map ? u2.set(o2[f2], s3) : u2.$isSingleNested ? (o2[f2] in u2 || (u2[o2[f2]] = s3), u2._doc[o2[f2]] = s3) : u2[o2[f2]] = s3;
          else {
            var d3 = u2 instanceof Map, m3 = d3 ? u2.get(o2[f2]) : u2[o2[f2]];
            G.isPOJO(m3) || m3 && m3 instanceof b || m3 && !Array.isArray(m3) && m3.$isSingleNested || m3 && Array.isArray(m3) ? u2 = m3 : null == m3 ? (m3 = {}, d3 ? u2.set(o2[f2], m3) : u2[o2[f2]] = m3, u2 = m3) : u2 = m3;
          }
        }
      }, pt.prototype.$__getValue = function(t4) {
        return G.getValue(t4, this._doc);
      }, pt.prototype.$inc = function(t4, e3) {
        var r3 = this;
        if (null == e3 && (e3 = 1), Array.isArray(t4))
          return t4.forEach(function(t5) {
            return r3.$inc(t5, e3);
          }), this;
        var n2 = this.$__path(t4);
        if (null == n2) {
          if ("throw" === this.$__.strictMode)
            throw new $(t4);
          if (true === this.$__.strictMode)
            return this;
        } else if ("Number" !== n2.instance)
          return this.invalidate(t4, new g.CastError(n2.instance, e3, t4)), this;
        var i3 = this.$__getValue(t4) || 0, o2 = false, a2 = null, s3 = e3;
        try {
          e3 = n2.cast(e3), s3 = (a2 = n2.applySetters(i3 + e3, this)) - i3, o2 = true;
        } catch (r4) {
          this.invalidate(t4, new g.CastError("number", e3, t4, r4));
        }
        return o2 && (this.$__.primitiveAtomics = this.$__.primitiveAtomics || {}, null == this.$__.primitiveAtomics[t4] ? this.$__.primitiveAtomics[t4] = { $inc: s3 } : this.$__.primitiveAtomics[t4].$inc += s3, this.markModified(t4), this.$__setValue(t4, a2)), this;
      }, pt.prototype.$__setValue = function(t4, e3) {
        return G.setValue(t4, e3, this._doc), this;
      }, pt.prototype.get = function(t4, e3, r3) {
        var n2;
        null == r3 && (r3 = {}), e3 && (n2 = this.$__schema.interpretAsType(t4, e3, this.$__schema.options));
        var i3 = r3.noDottedPath, o2 = i3 ? this.$__schema.paths[t4] : this.$__path(t4);
        if (null == o2 && null != (o2 = this.$__schema.virtualpath(t4)))
          return o2.applyGetters(void 0, this);
        if (i3) {
          var a2 = this._doc[t4];
          return n2 && (a2 = n2.cast(a2)), null != o2 && false !== r3.getters ? o2.applyGetters(a2, this) : a2;
        }
        if (null != o2 && "Mixed" === o2.instance) {
          var s3 = this.$__schema.virtualpath(t4);
          null != s3 && (o2 = s3);
        }
        var c2 = -1 !== t4.indexOf("."), u2 = this._doc, f2 = c2 ? t4.split(".") : [t4];
        "string" == typeof this.$__schema.aliases[f2[0]] && (f2[0] = this.$__schema.aliases[f2[0]]);
        for (var l2 = 0, h3 = f2.length; l2 < h3; l2++)
          u2 && u2._doc && (u2 = u2._doc), u2 = null == u2 ? void 0 : u2 instanceof Map ? u2.get(f2[l2], { getters: false }) : l2 === h3 - 1 ? G.getValue(f2[l2], u2) : u2[f2[l2]];
        if (n2 && (u2 = n2.cast(u2)), null != o2 && false !== r3.getters)
          u2 = o2.applyGetters(u2, this);
        else if (this.$__schema.nested[t4] && r3.virtuals)
          return _t(this, M(u2) || {}, { path: t4 });
        return u2;
      }, pt.prototype[ot] = pt.prototype.get, pt.prototype.$get = pt.prototype.get, pt.prototype.$__path = function(t4) {
        var e3 = this.$__.adhocPaths;
        return (e3 && e3.hasOwnProperty(t4) ? e3[t4] : null) || this.$__schema.path(t4);
      }, pt.prototype.markModified = function(t4, e3) {
        this.$__saveInitialState(t4), this.$__.activePaths.modify(t4), null == e3 || this.$isSubdocument || (this.$__.pathsToScopes = this.$__pathsToScopes || {}, this.$__.pathsToScopes[t4] = e3);
      }, pt.prototype.$__saveInitialState = function(t4) {
        var e3 = this.$__.savedState, r3 = t4;
        if (null != e3) {
          var n2 = r3.indexOf("."), i3 = -1 === n2 ? r3 : r3.slice(0, n2);
          e3.hasOwnProperty(i3) || (e3[i3] = M(this.$__getValue(i3)));
        }
      }, pt.prototype.unmarkModified = function(t4) {
        this.$__.activePaths.init(t4), null != this.$__.pathsToScopes && delete this.$__.pathsToScopes[t4];
      }, pt.prototype.$ignore = function(t4) {
        this.$__.activePaths.ignore(t4);
      }, pt.prototype.directModifiedPaths = function() {
        return Object.keys(this.$__.activePaths.getStatePaths("modify"));
      }, pt.prototype.$isEmpty = function(t4) {
        var e3 = { minimize: true, virtuals: false, getters: false, transform: false };
        if (0 !== arguments.length) {
          var r3 = this.$get(t4);
          return null == r3 || "object" === p(r3) && (G.isPOJO(r3) ? mt(r3) : 0 === Object.keys(r3.toObject(e3)).length);
        }
        return 0 === Object.keys(this.toObject(e3)).length;
      }, pt.prototype.modifiedPaths = function(t4) {
        t4 = t4 || {};
        var e3 = Object.keys(this.$__.activePaths.getStatePaths("modify")), r3 = /* @__PURE__ */ new Set(), n2 = 0, i3 = 0, o2 = e3.length;
        for (n2 = 0; n2 < o2; ++n2) {
          var a2 = e3[n2], s3 = ut(a2), c2 = s3.length;
          for (i3 = 0; i3 < c2; ++i3)
            r3.add(s3[i3]);
          if (t4.includeChildren) {
            var u2 = 0, f2 = this.$get(a2);
            if ("object" === p(f2) && null !== f2) {
              f2._doc && (f2 = f2._doc);
              var l2 = f2.length;
              if (Array.isArray(f2))
                for (u2 = 0; u2 < l2; ++u2) {
                  var h3 = a2 + "." + u2;
                  if (!r3.has(h3) && (r3.add(h3), null != f2[u2] && f2[u2].$__)) {
                    var d3 = f2[u2].modifiedPaths(), y3 = 0, b2 = d3.length;
                    for (y3 = 0; y3 < b2; ++y3)
                      r3.add(h3 + "." + d3[y3]);
                  }
                }
              else {
                var m3 = Object.keys(f2), v2 = 0, g2 = m3.length;
                for (v2 = 0; v2 < g2; ++v2)
                  r3.add(a2 + "." + m3[v2]);
              }
            }
          }
        }
        return Array.from(r3);
      }, pt.prototype[nt] = pt.prototype.modifiedPaths, pt.prototype.isModified = function(t4, e3, r3) {
        var n2 = this;
        if (t4) {
          var i3 = e3 && e3.ignoreAtomics, o2 = this.$__.activePaths.states.modify;
          if (null == o2)
            return false;
          "string" == typeof t4 && (t4 = -1 === t4.indexOf(" ") ? [t4] : t4.split(" "));
          var a2, s3 = f(t4);
          try {
            for (s3.s(); !(a2 = s3.n()).done; )
              if (null != o2[a2.value])
                return true;
          } catch (t5) {
            s3.e(t5);
          } finally {
            s3.f();
          }
          var c2 = r3 || this[nt](), u2 = t4.some(function(t5) {
            return !!~c2.indexOf(t5);
          }), l2 = Object.keys(o2);
          return i3 && (l2 = l2.filter(function(t5) {
            var e4 = n2.$__getValue(t5);
            return null == e4 || null == e4[tt] || void 0 !== e4[tt].$set;
          })), u2 || t4.some(function(t5) {
            return l2.some(function(e4) {
              return e4 === t5 || t5.startsWith(e4 + ".");
            });
          });
        }
        return this.$__.activePaths.some("modify");
      }, pt.prototype.$isModified = pt.prototype.isModified, pt.prototype[rt] = pt.prototype.isModified, pt.prototype.$isDefault = function(t4) {
        var e3 = this;
        if (null == t4)
          return this.$__.activePaths.some("default");
        if ("string" == typeof t4 && -1 === t4.indexOf(" "))
          return this.$__.activePaths.getStatePaths("default").hasOwnProperty(t4);
        var r3 = t4;
        return Array.isArray(r3) || (r3 = r3.split(" ")), r3.some(function(t5) {
          return e3.$__.activePaths.getStatePaths("default").hasOwnProperty(t5);
        });
      }, pt.prototype.$isDeleted = function(t4) {
        return 0 === arguments.length ? !!this.$__.isDeleted : (this.$__.isDeleted = !!t4, this);
      }, pt.prototype.isDirectModified = function(t4) {
        var e3 = this;
        if (null == t4)
          return this.$__.activePaths.some("modify");
        if ("string" == typeof t4 && -1 === t4.indexOf(" "))
          return this.$__.activePaths.getStatePaths("modify").hasOwnProperty(t4);
        var r3 = t4;
        return Array.isArray(r3) || (r3 = r3.split(" ")), r3.some(function(t5) {
          return e3.$__.activePaths.getStatePaths("modify").hasOwnProperty(t5);
        });
      }, pt.prototype.isInit = function(t4) {
        var e3 = this;
        if (null == t4)
          return this.$__.activePaths.some("init");
        if ("string" == typeof t4 && -1 === t4.indexOf(" "))
          return this.$__.activePaths.getStatePaths("init").hasOwnProperty(t4);
        var r3 = t4;
        return Array.isArray(r3) || (r3 = r3.split(" ")), r3.some(function(t5) {
          return e3.$__.activePaths.getStatePaths("init").hasOwnProperty(t5);
        });
      }, pt.prototype.isSelected = function(t4) {
        var e3 = this;
        if (null == this.$__.selected)
          return true;
        if (!t4)
          return false;
        if ("_id" === t4)
          return 0 !== this.$__.selected._id;
        if (-1 !== t4.indexOf(" ") && (t4 = t4.split(" ")), Array.isArray(t4))
          return t4.some(function(t5) {
            return e3.$__isSelected(t5);
          });
        var r3 = Object.keys(this.$__.selected), n2 = null;
        if (1 === r3.length && "_id" === r3[0])
          return 0 === this.$__.selected._id;
        for (var i3 = 0, o2 = r3; i3 < o2.length; i3++) {
          var a2 = o2[i3];
          if ("_id" !== a2 && q(this.$__.selected[a2])) {
            n2 = !!this.$__.selected[a2];
            break;
          }
        }
        if (null === n2)
          return true;
        if (t4 in this.$__.selected)
          return n2;
        for (var s3 = t4 + ".", c2 = 0, u2 = r3; c2 < u2.length; c2++) {
          var f2 = u2[c2];
          if ("_id" !== f2) {
            if (f2.startsWith(s3))
              return n2 || f2 !== s3;
            if (s3.startsWith(f2 + "."))
              return n2;
          }
        }
        return !n2;
      }, pt.prototype.$__isSelected = pt.prototype.isSelected, pt.prototype.isDirectSelected = function(t4) {
        var e3 = this;
        if (null == this.$__.selected)
          return true;
        if ("_id" === t4)
          return 0 !== this.$__.selected._id;
        if (-1 !== t4.indexOf(" ") && (t4 = t4.split(" ")), Array.isArray(t4))
          return t4.some(function(t5) {
            return e3.isDirectSelected(t5);
          });
        var r3 = Object.keys(this.$__.selected), n2 = null;
        if (1 === r3.length && "_id" === r3[0])
          return 0 === this.$__.selected._id;
        for (var i3 = 0, o2 = r3; i3 < o2.length; i3++) {
          var a2 = o2[i3];
          if ("_id" !== a2 && q(this.$__.selected[a2])) {
            n2 = !!this.$__.selected[a2];
            break;
          }
        }
        return null === n2 || (this.$__.selected.hasOwnProperty(t4) ? n2 : !n2);
      }, pt.prototype.validate = function() {
        var t4 = a(i2().mark(function t5(e3, r3) {
          var n2, o2, a2 = this, s3 = arguments;
          return i2().wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  if ("function" != typeof e3 && "function" != typeof r3 && "function" != typeof s3[2]) {
                    t6.next = 2;
                    break;
                  }
                  throw new g("Document.prototype.validate() no longer accepts a callback");
                case 2:
                  if (this.$op = "validate", null != this.$isSubdocument || (this.$__.validating ? n2 = new O(this, { parentStack: r3 && r3.parentStack, conflictStack: this.$__.validating.stack }) : this.$__.validating = new O(this, { parentStack: r3 && r3.parentStack })), 1 === s3.length && ("object" !== p(s3[0]) || Array.isArray(s3[0]) || (r3 = s3[0], e3 = null)), r3 && "string" == typeof r3.pathsToSkip && (o2 = -1 === r3.pathsToSkip.indexOf(" "), r3.pathsToSkip = o2 ? [r3.pathsToSkip] : r3.pathsToSkip.split(" ")), null == n2) {
                    t6.next = 8;
                    break;
                  }
                  throw n2;
                case 8:
                  return t6.abrupt("return", new Promise(function(t7, n3) {
                    a2.$__validate(e3, r3, function(e4) {
                      if (a2.$op = null, a2.$__.validating = null, null != e4)
                        return n3(e4);
                      t7();
                    });
                  }));
                case 9:
                case "end":
                  return t6.stop();
              }
          }, t5, this);
        }));
        return function(e3, r3) {
          return t4.apply(this, arguments);
        };
      }(), pt.prototype.$validate = pt.prototype.validate, pt.prototype.$__validate = function(t4, e3, r3) {
        var i3, o2 = this;
        this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !t4 ? t4 = n(this.$__.saveOptions.pathsToSave) : "function" == typeof t4 ? (r3 = t4, e3 = null, t4 = null) : "function" == typeof e3 && (r3 = e3, e3 = null);
        var a2, s3 = e3 && "object" === p(e3) && "validateModifiedOnly" in e3, u2 = e3 && e3.pathsToSkip || null;
        a2 = s3 ? !!e3.validateModifiedOnly : this.$__schema.options.validateModifiedOnly;
        var l2 = e3 && e3.validateAllPaths;
        if (l2) {
          if (u2)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
          if (t4)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
          if (s3 && a2)
            throw new TypeError("Cannot set both `validateAllPaths` and `validateModifiedOnly`");
        }
        var h3, d3, y3 = this, b2 = function() {
          var t5 = o2.$__.validationError;
          if (o2.$__.validationError = null, o2.$__.validating = null, a2 && null != t5) {
            for (var e4 = 0, r4 = Object.keys(t5.errors); e4 < r4.length; e4++) {
              var n2 = r4[e4];
              o2.$isModified(n2) || delete t5.errors[n2];
            }
            0 === Object.keys(t5.errors).length && (t5 = void 0);
          }
          if (o2.$__.cachedRequired = {}, o2.$emit("validate", y3), o2.constructor.emit("validate", y3), t5) {
            for (var i4 in t5.errors)
              !o2[et] && t5.errors[i4] instanceof g.CastError && o2.invalidate(i4, t5.errors[i4]);
            return t5;
          }
        };
        if (l2) {
          var m3, v2 = f(h3 = new Set(Object.keys(this.$__schema.paths)));
          try {
            for (v2.s(); !(m3 = v2.n()).done; ) {
              var _2 = m3.value, w3 = this.$__schema.path(_2);
              if (w3 && w3.$isMongooseArray) {
                var S2 = this.$__getValue(_2);
                S2 && gt2(S2, h3, _2);
              }
            }
          } catch (t5) {
            v2.e(t5);
          } finally {
            v2.f();
          }
          h3 = n(h3), d3 = {};
        } else {
          var O2 = vt(this, t4, u2);
          h3 = a2 ? O2[0].filter(function(t5) {
            return o2.$isModified(t5);
          }) : O2[0], d3 = O2[1];
        }
        if ("string" == typeof t4 && (t4 = t4.split(" ")), 0 === h3.length)
          return C(function() {
            var t5 = b2();
            if (t5)
              return y3.$__schema.s.hooks.execPost("validate:error", y3, [y3], { error: t5 }, function(t6) {
                r3(t6);
              });
            r3(null, y3);
          });
        var j2 = {}, $2 = 0, E2 = null === (i3 = this.$__.saveOptions) || void 0 === i3 ? void 0 : i3.pathsToSave;
        if (Array.isArray(E2)) {
          E2 = new Set(E2);
          var x2, P2 = f(h3);
          try {
            for (P2.s(); !(x2 = P2.n()).done; ) {
              var k2 = x2.value;
              E2.has(k2) && B2(k2);
            }
          } catch (t5) {
            P2.e(t5);
          } finally {
            P2.f();
          }
        } else {
          var M2, I2 = f(h3);
          try {
            for (I2.s(); !(M2 = I2.n()).done; )
              B2(M2.value);
          } catch (t5) {
            I2.e(t5);
          } finally {
            I2.f();
          }
        }
        function B2(t5) {
          null == t5 || j2[t5] || (j2[t5] = true, $2++, C(function() {
            var e4 = y3.$__schema.path(t5);
            if (!e4)
              return --$2 || T2();
            if (y3.$isValid(t5)) {
              if (null != e4[ct] && t5 !== e4.path)
                return --$2 || T2();
              var r4, n2 = y3.$__getValue(t5);
              (r4 = y3.$populated(t5)) ? n2 = r4 : null != n2 && null != n2.$__ && n2.$__.wasPopulated && (n2 = n2._id);
              var i4 = null != y3.$__.pathsToScopes && t5 in y3.$__.pathsToScopes ? y3.$__.pathsToScopes[t5] : y3, o3 = c(c({}, d3[t5]), {}, { path: t5, validateModifiedOnly: a2, validateAllPaths: l2 });
              e4.doValidate(n2, function(r5) {
                if (r5) {
                  if ((e4.$isSingleNested || e4.$isArraySubdocument || e4.$isMongooseDocumentArray) && r5 instanceof A)
                    return --$2 || T2();
                  y3.invalidate(t5, r5, void 0, true);
                }
                --$2 || T2();
              }, i4, o3);
            } else
              --$2 || T2();
          }));
        }
        function T2() {
          var t5 = b2();
          if (t5)
            return y3.$__schema.s.hooks.execPost("validate:error", y3, [y3], { error: t5 }, function(t6) {
              r3(t6);
            });
          r3(null, y3);
        }
      }, pt.prototype.validateSync = function(t4, e3) {
        var r3, i3 = this, o2 = this;
        1 !== arguments.length || "object" !== p(arguments[0]) || Array.isArray(arguments[0]) || (e3 = arguments[0], t4 = null), r3 = e3 && "object" === p(e3) && "validateModifiedOnly" in e3 ? !!e3.validateModifiedOnly : this.$__schema.options.validateModifiedOnly;
        var a2, s3, c2 = e3 && e3.pathsToSkip, u2 = e3 && e3.validateAllPaths;
        if (u2) {
          if (c2)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
          if (t4)
            throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
        }
        if ("string" == typeof t4) {
          var l2 = -1 === t4.indexOf(" ");
          t4 = l2 ? [t4] : t4.split(" ");
        } else
          "string" == typeof c2 && -1 !== c2.indexOf(" ") && (c2 = c2.split(" "));
        if (u2) {
          var h3, d3 = f(a2 = new Set(Object.keys(this.$__schema.paths)));
          try {
            for (d3.s(); !(h3 = d3.n()).done; ) {
              var y3 = h3.value, b2 = this.$__schema.path(y3);
              if (b2 && b2.$isMongooseArray) {
                var m3 = this.$__getValue(y3);
                m3 && gt2(m3, a2, y3);
              }
            }
          } catch (x3) {
            d3.e(x3);
          } finally {
            d3.f();
          }
          a2 = n(a2), s3 = {};
        } else {
          var v2 = vt(this, t4, c2);
          a2 = r3 ? v2[0].filter(function(t5) {
            return i3.$isModified(t5);
          }) : v2[0], s3 = v2[1];
        }
        for (var _2 = {}, w3 = 0, S2 = a2.length; w3 < S2; ++w3) {
          var O2 = a2[w3];
          if (!_2[O2]) {
            _2[O2] = true;
            var j2 = o2.$__schema.path(O2);
            if (j2 && o2.$isValid(O2)) {
              var $2 = o2.$__getValue(O2), E2 = j2.doValidateSync($2, o2, { skipSchemaValidators: s3[O2], path: O2, validateModifiedOnly: r3, validateAllPaths: u2 });
              if (E2) {
                if ((j2.$isSingleNested || j2.$isArraySubdocument || j2.$isMongooseDocumentArray) && E2 instanceof A)
                  continue;
                o2.invalidate(O2, E2, void 0, true);
              }
            }
          }
        }
        var x2 = o2.$__.validationError;
        if (o2.$__.validationError = void 0, o2.$emit("validate", o2), o2.constructor.emit("validate", o2), x2)
          for (var P2 in x2.errors)
            x2.errors[P2] instanceof g.CastError && o2.invalidate(P2, x2.errors[P2]);
        return x2;
      }, pt.prototype.invalidate = function(t4, e3, r3, n2) {
        if (this.$__.validationError || (this.$__.validationError = new A(this)), !this.$__.validationError.errors[t4])
          return e3 && "string" != typeof e3 || (e3 = new E({ path: t4, message: e3, type: n2 || "user defined", value: r3 })), this.$__.validationError === e3 || this.$__.validationError.addError(t4, e3), this.$__.validationError;
      }, pt.prototype.$markValid = function(t4) {
        this.$__.validationError && this.$__.validationError.errors[t4] && (delete this.$__.validationError.errors[t4], 0 === Object.keys(this.$__.validationError.errors).length && (this.$__.validationError = null));
      }, pt.prototype.$isValid = function(t4) {
        var e3 = this;
        return null == this.$__.validationError || 0 === Object.keys(this.$__.validationError.errors).length || null != t4 && (-1 !== t4.indexOf(" ") && (t4 = t4.split(" ")), Array.isArray(t4) ? t4.some(function(t5) {
          return null == e3.$__.validationError.errors[t5];
        }) : null == this.$__.validationError.errors[t4]);
      }, pt.prototype.$__reset = function() {
        var t4, e3 = this, r3 = this.$parent() === this ? this.$getAllSubdocs() : [], n2 = /* @__PURE__ */ new Set(), i3 = f(r3);
        try {
          for (i3.s(); !(t4 = i3.n()).done; ) {
            var o2 = t4.value, a2 = o2.$__fullPathWithIndexes();
            if (o2.$__reset(), this.isModified(a2) || h3(a2))
              if (o2.$isDocumentArrayElement)
                n2.add(o2.parentArray());
              else {
                var s3 = o2.$parent();
                s3 === this ? this.$__.activePaths.clearPath(o2.$basePath) : null != s3 && s3.$isSubdocument && s3.$__reset();
              }
          }
        } catch (t5) {
          i3.e(t5);
        } finally {
          i3.f();
        }
        var c2, u2 = f(n2);
        try {
          for (u2.s(); !(c2 = u2.n()).done; ) {
            var l2 = c2.value;
            this.$__.activePaths.clearPath(l2.$path()), l2[Z] = l2[tt], l2[tt] = {};
          }
        } catch (t5) {
          u2.e(t5);
        } finally {
          u2.f();
        }
        function h3(t5) {
          t5 = -1 === t5.indexOf(".") ? [t5] : t5.split(".");
          for (var r4 = "", n3 = 0; n3 < t5.length; ++n3)
            if (r4 += (r4.length ? "." : "") + t5[n3], "init" === e3.$__.activePaths[r4])
              return true;
          return false;
        }
        return this.$__dirty().forEach(function(t5) {
          var e4 = t5.value;
          e4 && e4[tt] && (e4[Z] = e4[tt], e4[tt] = {});
        }), this.$__.backup = {}, this.$__.backup.activePaths = { modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")), default: Object.assign({}, this.$__.activePaths.getStatePaths("default")) }, this.$__.backup.validationError = this.$__.validationError, this.$__.backup.errors = this.$errors, this.$__.activePaths.clear("modify"), this.$__.activePaths.clear("default"), this.$__.validationError = void 0, this.$errors = void 0, e3 = this, this.$__schema.requiredPaths().forEach(function(t5) {
          e3.$__.activePaths.require(t5);
        }), this;
      }, pt.prototype.$__undoReset = function() {
        if (null != this.$__.backup && null != this.$__.backup.activePaths) {
          this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify, this.$__.activePaths.states.default = this.$__.backup.activePaths.default, this.$__.validationError = this.$__.backup.validationError, this.$errors = this.$__.backup.errors;
          var t4, e3 = f(this.$__dirty());
          try {
            for (e3.s(); !(t4 = e3.n()).done; ) {
              var r3 = t4.value.value;
              r3 && r3[tt] && r3[Z] && (r3[tt] = r3[Z]);
            }
          } catch (t5) {
            e3.e(t5);
          } finally {
            e3.f();
          }
          var n2, i3 = f(this.$getAllSubdocs());
          try {
            for (i3.s(); !(n2 = i3.n()).done; )
              n2.value.$__undoReset();
          } catch (t5) {
            i3.e(t5);
          } finally {
            i3.f();
          }
        }
      }, pt.prototype.$__dirty = function() {
        var t4 = this, e3 = this.$__.activePaths.map("modify", function(e4) {
          return { path: e4, value: t4.$__getValue(e4), schema: t4.$__path(e4) };
        });
        e3 = e3.concat(this.$__.activePaths.map("default", function(e4) {
          if ("_id" !== e4 && null != t4.$__getValue(e4))
            return { path: e4, value: t4.$__getValue(e4), schema: t4.$__path(e4) };
        }));
        var r3 = new Map(e3.filter(function(t5) {
          return null != t5;
        }).map(function(t5) {
          return [t5.path, t5.value];
        })), n2 = [];
        return e3.forEach(function(t5) {
          if (t5) {
            for (var e4 = null, i3 = ut(t5.path), o2 = 0; o2 < i3.length - 1; o2++)
              if (r3.has(i3[o2])) {
                e4 = r3.get(i3[o2]);
                break;
              }
            null == e4 ? n2.push(t5) : null != e4 && null != e4[tt] && e4.hasAtomics() && (e4[tt] = {}, e4[tt].$set = e4);
          }
        }), n2;
      }, pt.prototype.$__setSchema = function(t4) {
        I(t4.tree, this, void 0, t4.options);
        for (var e3 = 0, r3 = Object.keys(t4.virtuals); e3 < r3.length; e3++) {
          var n2 = r3[e3];
          t4.virtuals[n2]._applyDefaultGetters();
        }
        null == t4.path("schema") && (this.schema = t4), this.$__schema = t4, this[it] = t4;
      }, pt.prototype.$__getArrayPathsToValidate = function() {
        return d2 || (d2 = r2(4941)), this.$__.activePaths.map("init", "modify", (function(t4) {
          return this.$__getValue(t4);
        }).bind(this)).filter(function(t4) {
          return t4 && Array.isArray(t4) && G.isMongooseDocumentArray(t4) && t4.length;
        }).reduce(function(t4, e3) {
          return t4.concat(e3);
        }, []).filter(function(t4) {
          return t4;
        });
      }, pt.prototype.$getAllSubdocs = function() {
        function t4(e4, r3, n3) {
          var i4 = e4, o2 = false;
          if (n3 && (e4 instanceof pt && e4[it].paths[n3] ? i4 = e4._doc[n3] : e4 instanceof pt && e4[it].nested[n3] ? (i4 = e4._doc[n3], o2 = true) : i4 = e4[n3]), i4 instanceof b)
            r3.push(i4);
          else if (i4 instanceof Map)
            r3 = Array.from(i4.keys()).reduce(function(e5, r4) {
              return t4(i4.get(r4), e5, null);
            }, r3);
          else if (i4 && !Array.isArray(i4) && i4.$isSingleNested)
            r3 = Object.keys(i4._doc).reduce(function(e5, r4) {
              return t4(i4, e5, r4);
            }, r3), r3.push(i4);
          else if (i4 && G.isMongooseDocumentArray(i4))
            i4.forEach(function(e5) {
              e5 && e5._doc && (r3 = Object.keys(e5._doc).reduce(function(r4, n4) {
                return t4(e5._doc, r4, n4);
              }, r3), e5 instanceof b && r3.push(e5));
            });
          else if (o2 && null != i4)
            for (var a2 = 0, s3 = Object.keys(i4); a2 < s3.length; a2++) {
              var c2 = s3[a2];
              t4(i4, r3, c2);
            }
          return r3;
        }
        d2 || (d2 = r2(4941)), b = b || r2(8578);
        for (var e3 = [], n2 = 0, i3 = Object.keys(this._doc); n2 < i3.length; n2++)
          t4(this, e3, i3[n2]);
        return e3;
      }, pt.prototype.$__handleReject = function(t4) {
        this.$listeners("error").length ? this.$emit("error", t4) : this.constructor.listeners && this.constructor.listeners("error").length && this.constructor.emit("error", t4);
      }, pt.prototype.$toObject = function(t4, e3) {
        var r3, n2, i3, o2 = { transform: true, flattenDecimals: true }, a2 = e3 ? "toJSON" : "toObject", s3 = this.constructor && this.constructor.base && this.constructor.base.options && R(this.constructor.base.options, a2) || {}, u2 = this.$__schema && this.$__schema.options || {};
        o2 = c(c(c({}, o2), s3), u2[a2]), (t4 = G.isPOJO(t4) ? c({}, t4) : {})._calledWithOptions = t4._calledWithOptions || c({}, t4), r3 = null != t4._calledWithOptions.minimize ? t4.minimize : null != o2.minimize ? o2.minimize : u2.minimize, n2 = null != t4._calledWithOptions.flattenMaps ? t4.flattenMaps : null != o2.flattenMaps ? o2.flattenMaps : u2.flattenMaps, i3 = null != t4._calledWithOptions.flattenObjectIds ? t4.flattenObjectIds : null != o2.flattenObjectIds ? o2.flattenObjectIds : u2.flattenObjectIds;
        var f2 = Object.assign({}, t4, { _isNested: true, json: e3, minimize: r3, flattenMaps: n2, flattenObjectIds: i3, _seen: t4 && t4._seen || /* @__PURE__ */ new Map() });
        if (G.hasUserDefinedProperty(t4, "getters") && (f2.getters = t4.getters), G.hasUserDefinedProperty(t4, "virtuals") && (f2.virtuals = t4.virtuals), (t4.depopulate || t4._parentOptions && t4._parentOptions.depopulate) && t4._isNested && this.$__.wasPopulated)
          return M(this.$__.wasPopulated.value || this._id, f2);
        (t4 = c(c({}, o2), t4))._isNested = true, t4.json = e3, t4.minimize = r3, f2._parentOptions = t4, f2._skipSingleNestedGetters = false;
        var l2 = Object.assign({}, f2);
        l2._skipSingleNestedGetters = true;
        var h3 = t4.transform, d3 = M(this._doc, f2) || {};
        t4.getters && (function(t5, e4, r4) {
          var n3, i4, o3 = t5.$__schema, a3 = Object.keys(o3.paths), s4 = a3.length, c2 = t5._doc;
          if (!c2)
            return e4;
          for (; s4--; ) {
            var u3 = (n3 = a3[s4]).split("."), f3 = u3.length, l3 = f3 - 1, h4 = e4, d4 = void 0;
            if (c2 = t5._doc, t5.$__isSelected(n3))
              for (var y4 = 0; y4 < f3 && (i4 = c2[d4 = u3[y4]], null == h4 || "object" === p(h4)); ++y4) {
                if (y4 === l3) {
                  var b3 = t5.$get(n3);
                  if (h4[d4] = M(b3, r4), Array.isArray(h4[d4]) && o3.paths[n3].$embeddedSchemaType)
                    for (var m4 = 0; m4 < h4[d4].length; ++m4)
                      h4[d4][m4] = o3.paths[n3].$embeddedSchemaType.applyGetters(h4[d4][m4], t5);
                } else {
                  if (null == i4) {
                    d4 in c2 && (h4[d4] = i4);
                    break;
                  }
                  h4 = h4[d4] || (h4[d4] = {});
                }
                c2 = i4;
              }
          }
        }(this, d3, l2), t4.minimize && (d3 = H(d3) || {})), (t4.virtuals || t4.getters && false !== t4.virtuals) && _t(this, d3, l2, t4), false === t4.versionKey && this.$__schema.options.versionKey && delete d3[this.$__schema.options.versionKey];
        var y3 = t4.transform;
        if (y3 && function(t5, e4) {
          var r4 = t5.$__schema, n3 = Object.keys(r4.paths || {});
          if (!t5._doc)
            return e4;
          for (var i4 = 0, o3 = n3; i4 < o3.length; i4++) {
            var a3 = o3[i4], s4 = r4.paths[a3];
            if ("function" == typeof s4.options.transform) {
              var c2 = t5.$get(a3);
              if (void 0 === c2)
                continue;
              var u3 = s4.options.transform.call(t5, c2);
              wt(a3, u3), G.setValue(a3, u3, e4);
            } else if (null != s4.$embeddedSchemaType && "function" == typeof s4.$embeddedSchemaType.options.transform) {
              var f3 = t5.$get(a3);
              if (void 0 === f3)
                continue;
              for (var l3 = [].concat(f3), h4 = s4.$embeddedSchemaType.options.transform, p2 = 0; p2 < l3.length; ++p2) {
                var d4 = h4.call(t5, l3[p2]);
                l3[p2] = d4, wt(a3, d4);
              }
              e4[a3] = l3;
            }
          }
        }(this, d3), t4.useProjection && function(t5, e4) {
          var r4 = t5.$__schema, n3 = Object.keys(r4.paths || {});
          if (!t5._doc)
            return e4;
          var i4 = t5.$__.selected;
          if (void 0 === i4 && (i4 = {}, J.applyPaths(i4, r4)), null == i4 || 0 === Object.keys(i4).length)
            return e4;
          for (var o3 = 0, a3 = n3; o3 < a3.length; o3++) {
            var s4 = a3[o3];
            null == i4[s4] || i4[s4] || delete e4[s4];
          }
        }(this, d3), true === y3 || u2.toObject && y3) {
          var b2 = t4.json ? u2.toJSON : u2.toObject;
          b2 && (y3 = "function" == typeof t4.transform ? t4.transform : b2.transform);
        } else
          t4.transform = h3;
        if ("function" == typeof y3) {
          var m3 = y3(this, d3, t4);
          void 0 !== m3 && (d3 = m3);
        }
        return d3;
      }, pt.prototype.toObject = function(t4) {
        return this.$toObject(t4);
      }, pt.prototype.toJSON = function(t4) {
        return this.$toObject(t4, true);
      }, pt.prototype.ownerDocument = function() {
        return this;
      }, pt.prototype.parent = function() {
        return this.$isSubdocument || this.$__.wasPopulated ? this.$__.parent : this;
      }, pt.prototype.$parent = pt.prototype.parent, pt.prototype.inspect = function(t4) {
        var e3;
        G.isPOJO(t4) && ((e3 = t4).minimize = false);
        var r3 = arguments.length > 0 ? this.toObject(e3) : this.toObject();
        return null == r3 ? "MongooseDocument { " + r3 + " }" : r3;
      }, V.custom && (pt.prototype[V.custom] = pt.prototype.inspect), pt.prototype.toString = function() {
        var t4 = this.inspect();
        return "string" == typeof t4 ? t4 : V(t4);
      }, pt.prototype.equals = function(t4) {
        if (!t4)
          return false;
        var e3 = this.$__getValue("_id"), r3 = null != t4.$__ ? t4.$__getValue("_id") : t4;
        return e3 || r3 ? e3 && e3.equals ? e3.equals(r3) : e3 === r3 : Q(this, t4);
      }, pt.prototype.populate = function() {
        var t4 = a(i2().mark(function t5() {
          var e3, r3, n2, o2, a2, s3, c2, u2, l2, h3, p2 = arguments;
          return i2().wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  if (e3 = {}, "function" != typeof (r3 = Array.prototype.slice.call(p2))[r3.length - 1]) {
                    t6.next = 4;
                    break;
                  }
                  throw new g("Document.prototype.populate() no longer accepts a callback");
                case 4:
                  if (0 !== r3.length) {
                    n2 = G.populate.apply(null, r3), o2 = f(n2);
                    try {
                      for (o2.s(); !(a2 = o2.n()).done; )
                        s3 = a2.value, e3[s3.path] = s3;
                    } catch (t7) {
                      o2.e(t7);
                    } finally {
                      o2.f();
                    }
                  }
                  return c2 = G.object.vals(e3), u2 = this.constructor, this.$__isNested && (u2 = this.$__[st].constructor, l2 = this.$__.nestedPath, c2.forEach(function(t7) {
                    t7.path = l2 + "." + t7.path;
                  })), null != this.$session() && (h3 = this.$session(), c2.forEach(function(t7) {
                    null != t7.options ? "session" in t7.options || (t7.options.session = h3) : t7.options = { session: h3 };
                  })), c2.forEach(function(t7) {
                    t7._localModel = u2;
                  }), t6.abrupt("return", u2.populate(this, c2));
                case 11:
                case "end":
                  return t6.stop();
              }
          }, t5, this);
        }));
        return function() {
          return t4.apply(this, arguments);
        };
      }(), pt.prototype.$getPopulatedDocs = function() {
        var t4 = [];
        null != this.$__.populated && (t4 = t4.concat(Object.keys(this.$__.populated)));
        var e3, r3 = [], n2 = f(t4);
        try {
          for (n2.s(); !(e3 = n2.n()).done; ) {
            var i3 = e3.value, o2 = this.$get(i3);
            Array.isArray(o2) ? r3 = r3.concat(o2) : o2 instanceof pt && r3.push(o2);
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        return r3;
      }, pt.prototype.populated = function(t4, e3, r3) {
        if (null == e3 || true === e3) {
          if (!this.$__.populated)
            return;
          if ("string" != typeof t4)
            return;
          var n2 = t4.endsWith(".$*") ? t4.replace(/\.\$\*$/, "") : t4, i3 = this.$__.populated[n2];
          return i3 ? true === e3 ? i3 : i3.value : void 0;
        }
        this.$__.populated || (this.$__.populated = {}), this.$__.populated[t4] = { value: e3, options: r3 };
        for (var o2 = t4.split("."), a2 = 0; a2 < o2.length - 1; ++a2) {
          var s3 = o2.slice(0, a2 + 1).join("."), c2 = this.$get(s3);
          if (null != c2 && null != c2.$__ && this.$populated(s3)) {
            var u2 = o2.slice(a2 + 1).join(".");
            c2.$populated(u2, e3, r3);
            break;
          }
        }
        return e3;
      }, pt.prototype.$populated = pt.prototype.populated, pt.prototype.$assertPopulated = function(t4, e3) {
        var r3 = this;
        if (Array.isArray(t4))
          return t4.forEach(function(t5) {
            return r3.$assertPopulated(t5, e3);
          }), this;
        if (arguments.length > 1 && this.$set(e3), !this.$populated(t4))
          throw new g('Expected path "'.concat(t4, '" to be populated'));
        return this;
      }, pt.prototype.depopulate = function(t4) {
        var e3;
        "string" == typeof t4 && (t4 = -1 === t4.indexOf(" ") ? [t4] : t4.split(" "));
        var r3 = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [], n2 = this.$__ && this.$__.populated || {};
        if (0 === arguments.length) {
          var i3, o2 = f(r3);
          try {
            for (o2.s(); !(i3 = o2.n()).done; ) {
              var a2 = i3.value;
              delete this.$$populatedVirtuals[a2], delete this._doc[a2], delete n2[a2];
            }
          } catch (t5) {
            o2.e(t5);
          } finally {
            o2.f();
          }
          for (var s3 = 0, c2 = Object.keys(n2); s3 < c2.length; s3++) {
            var u2 = c2[s3];
            (e3 = this.$populated(u2)) && (delete n2[u2], G.setValue(u2, e3, this._doc));
          }
          return this;
        }
        var l2, h3 = f(t4);
        try {
          for (h3.s(); !(l2 = h3.n()).done; ) {
            var p2 = l2.value;
            e3 = this.$populated(p2), delete n2[p2], -1 !== r3.indexOf(p2) ? (delete this.$$populatedVirtuals[p2], delete this._doc[p2]) : e3 && G.setValue(p2, e3, this._doc);
          }
        } catch (t5) {
          h3.e(t5);
        } finally {
          h3.f();
        }
        return this;
      }, pt.prototype.$__fullPath = function(t4) {
        return t4 || "";
      }, pt.prototype.getChanges = function() {
        var t4 = this.$__delta();
        return t4 ? t4[1] : {};
      }, pt.prototype.$clone = function() {
        var t4 = new this.constructor();
        if (t4.$isNew = this.$isNew, this._doc && (t4._doc = M(this._doc, { retainDocuments: true })), this.$__) {
          var e3, r3 = new this.$__.constructor(), n2 = f(Object.getOwnPropertyNames(this.$__));
          try {
            for (n2.s(); !(e3 = n2.n()).done; ) {
              var i3 = e3.value;
              "activePaths" !== i3 && (r3[i3] = M(this.$__[i3]));
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
          Object.assign(r3.activePaths, M(c({}, this.$__.activePaths))), t4.$__ = r3;
        }
        return t4;
      }, pt.ValidationError = A, t3.exports = pt;
    }, 3300: (t3, e2, r2) => {
      var n = r2(3293), i2 = r2(6024), o = false;
      t3.exports = function() {
        return o ? i2 : n;
      }, t3.exports.setBrowser = function(t4) {
        o = t4;
      };
    }, 8582: (t3) => {
      var e2 = null;
      t3.exports.get = function() {
        return e2;
      }, t3.exports.set = function(t4) {
        e2 = t4;
      };
    }, 5221: (t3, e2) => {
      e2.Collection = function() {
        throw new Error("Cannot create a collection from browser library");
      }, e2.Connection = function() {
        throw new Error("Cannot create a connection from browser library");
      };
    }, 6148: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, o(n2.key), n2);
        }
      }
      function o(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      function a(t4, e3, r3) {
        return e3 = u(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return s2(t5);
        }(t4, c() ? Reflect.construct(e3, r3 || [], u(t4).constructor) : e3.apply(t4, r3));
      }
      function s2(t4) {
        if (void 0 === t4)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      function c() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (c = function() {
          return !!t4;
        })();
      }
      function u(t4) {
        return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, u(t4);
      }
      function f(t4, e3) {
        return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, f(t4, e3);
      }
      var l = r2(7026), h2 = r2(7352), p = function(t4) {
        function e3(t5, r4, n3, i3, o2) {
          var c2;
          if (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), arguments.length > 0) {
            var u2 = y2(r4);
            (c2 = a(this, e3, [m2(null, t5, r4, n3, b(o2), u2, i3)])).init(t5, r4, n3, i3, o2);
          } else
            c2 = a(this, e3, [m2()]);
          return s2(c2);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && f(t5, e4);
        }(e3, t4), r3 = e3, (n2 = [{ key: "toJSON", value: function() {
          return { stringValue: this.stringValue, valueType: this.valueType, kind: this.kind, value: this.value, path: this.path, reason: this.reason, name: this.name, message: this.message };
        } }, { key: "init", value: function(t5, e4, r4, n3, i3) {
          this.stringValue = d2(e4), this.messageFormat = b(i3), this.kind = t5, this.value = e4, this.path = r4, this.reason = n3, this.valueType = y2(e4);
        } }, { key: "copy", value: function(t5) {
          this.messageFormat = t5.messageFormat, this.stringValue = t5.stringValue, this.kind = t5.kind, this.value = t5.value, this.path = t5.path, this.reason = t5.reason, this.message = t5.message, this.valueType = t5.valueType;
        } }, { key: "setModel", value: function(t5) {
          this.model = t5, this.message = m2(t5, this.kind, this.value, this.path, this.messageFormat, this.valueType);
        } }]) && i2(r3.prototype, n2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, n2;
      }(l);
      function d2(t4) {
        var e3 = h2.inspect(t4);
        return (e3 = e3.replace(/^'|'$/g, '"')).startsWith('"') || (e3 = '"' + e3 + '"'), e3;
      }
      function y2(t4) {
        if (null == t4)
          return "" + t4;
        var e3 = n(t4);
        return "object" !== e3 || "function" != typeof t4.constructor ? e3 : t4.constructor.name;
      }
      function b(t4) {
        var e3 = t4 && t4._castErrorMessage || null;
        if ("string" == typeof e3 || "function" == typeof e3)
          return e3;
      }
      function m2(t4, e3, r3, n2, i3, o2, a2) {
        if ("string" == typeof i3) {
          var s3 = d2(r3), c2 = i3.replace("{KIND}", e3).replace("{VALUE}", s3).replace("{PATH}", n2);
          return null != t4 && (c2 = c2.replace("{MODEL}", t4.modelName)), c2;
        }
        if ("function" == typeof i3)
          return i3(r3, n2, t4, e3);
        var u2 = "Cast to " + e3 + " failed for value " + d2(r3) + (o2 ? " (type " + o2 + ")" : "") + ' at path "' + n2 + '"';
        return null != t4 && (u2 += ' for model "' + t4.modelName + '"'), null != a2 && "function" == typeof a2.constructor && "AssertionError" !== a2.constructor.name && "Error" !== a2.constructor.name && (u2 += ' because of "' + a2.constructor.name + '"'), u2;
      }
      Object.defineProperty(p.prototype, "name", { value: "CastError" }), t3.exports = p;
    }, 6432: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, ["For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + t5.join("\n  ") + "\nUse Model.updateOne() to update these arrays instead."]);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "DivergentArrayError" }), t3.exports = c;
    }, 9507: (t3, e2, r2) => {
      var n = r2(7026);
      t3.exports = n, n.messages = r2(467), n.Messages = n.messages, n.DocumentNotFoundError = r2(8128), n.CastError = r2(6148), n.ValidationError = r2(5368), n.ValidatorError = r2(8393), n.VersionError = r2(587), n.ParallelSaveError = r2(5597), n.OverwriteModelError = r2(2597), n.MissingSchemaError = r2(8320), n.MongooseServerSelectionError = r2(6156), n.DivergentArrayError = r2(6432), n.StrictModeError = r2(6166), n.StrictPopulateError = r2(3232);
    }, 9662: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5, r4) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, ['Cannot create use schema for property "'.concat(t5, '" because the schema has the ').concat(r4, " option enabled.")]);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "InvalidSchemaOptionError" }), t3.exports = c;
    }, 467: (t3, e2) => {
      var r2 = t3.exports = {};
      r2.DocumentNotFoundError = null, r2.general = {}, r2.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`", r2.general.required = "Path `{PATH}` is required.", r2.Number = {}, r2.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).", r2.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).", r2.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", r2.Date = {}, r2.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).", r2.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).", r2.String = {}, r2.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", r2.String.match = "Path `{PATH}` is invalid ({VALUE}).", r2.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).", r2.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
    }, 8320: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, [`Schema hasn't been registered for model "` + t5 + '".\nUse mongoose.model(name, schema)']);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "MissingSchemaError" }), t3.exports = c;
    }, 7026: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      function r2(t4) {
        var e3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return r2 = function(t5) {
          if (null === t5 || !function(t6) {
            try {
              return -1 !== Function.toString.call(t6).indexOf("[native code]");
            } catch (e4) {
              return "function" == typeof t6;
            }
          }(t5))
            return t5;
          if ("function" != typeof t5)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e3) {
            if (e3.has(t5))
              return e3.get(t5);
            e3.set(t5, r3);
          }
          function r3() {
            return function(t6, e4, r4) {
              if (n())
                return Reflect.construct.apply(null, arguments);
              var o2 = [null];
              o2.push.apply(o2, e4);
              var a2 = new (t6.bind.apply(t6, o2))();
              return r4 && i2(a2, r4.prototype), a2;
            }(t5, arguments, o(this).constructor);
          }
          return r3.prototype = Object.create(t5.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), i2(r3, t5);
        }, r2(t4);
      }
      function n() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (n = function() {
          return !!t4;
        })();
      }
      function i2(t4, e3) {
        return i2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, i2(t4, e3);
      }
      function o(t4) {
        return o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, o(t4);
      }
      var a = function(t4) {
        function r3() {
          return function(t6, e3) {
            if (!(t6 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, r3), t5 = this, a3 = arguments, i3 = o(i3 = r3), function(t6, r4) {
            if (r4 && ("object" === e2(r4) || "function" == typeof r4))
              return r4;
            if (void 0 !== r4)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t7) {
              if (void 0 === t7)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t7;
            }(t6);
          }(t5, n() ? Reflect.construct(i3, a3 || [], o(t5).constructor) : i3.apply(t5, a3));
          var t5, i3, a3;
        }
        return function(t5, e3) {
          if ("function" != typeof e3 && null !== e3)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e3 && i2(t5, e3);
        }(r3, t4), a2 = r3, Object.defineProperty(a2, "prototype", { writable: false }), a2;
        var a2;
      }(r2(Error));
      Object.defineProperty(a.prototype, "name", { value: "MongooseError" }), t3.exports = a;
    }, 8128: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = r2(9507), u = r2(7352), f = function(t4) {
        function e3(t5, r4, n2, o2) {
          var a2;
          !function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3);
          var s3 = c.messages;
          return (a2 = i2(this, e3, [null != s3.DocumentNotFoundError ? "function" == typeof s3.DocumentNotFoundError ? s3.DocumentNotFoundError(t5, r4) : s3.DocumentNotFoundError : 'No document found for query "' + u.inspect(t5) + '" on model "' + r4 + '"'])).result = o2, a2.numAffected = n2, a2.filter = t5, a2.query = t5, a2;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(c);
      Object.defineProperty(f.prototype, "name", { value: "DocumentNotFoundError" }), t3.exports = f;
    }, 2260: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5, r4) {
          var n2;
          !function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3);
          var o2 = Array.isArray(r4) ? "array" : "primitive value";
          return (n2 = i2(this, e3, ["Tried to set nested object field `" + t5 + "` to ".concat(o2, " `") + r4 + "`"])).path = t5, n2;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "ObjectExpectedError" }), t3.exports = c;
    }, 1857: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5, r4, o2) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, ['Parameter "' + r4 + '" to ' + o2 + '() must be an object, got "' + t5.toString() + '" (type ' + n(t5) + ")"]);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "ObjectParameterError" }), t3.exports = c;
    }, 2597: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, ["Cannot overwrite `" + t5 + "` model once compiled."]);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "OverwriteModelError" }), t3.exports = c;
    }, 5597: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, ["Can't save() the same doc multiple times in parallel. Document: " + t5._id]);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "ParallelSaveError" }), t3.exports = c;
    }, 3810: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5) {
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, ["Can't validate() the same doc multiple times in parallel. Document: " + t5._id]);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(7026));
      Object.defineProperty(c.prototype, "name", { value: "ParallelValidateError" }), t3.exports = c;
    }, 6156: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, o(n2.key), n2);
        }
      }
      function o(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      function a(t4, e3, r3) {
        return e3 = c(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, s2() ? Reflect.construct(e3, r3 || [], c(t4).constructor) : e3.apply(t4, r3));
      }
      function s2() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (s2 = function() {
          return !!t4;
        })();
      }
      function c(t4) {
        return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, c(t4);
      }
      function u(t4, e3) {
        return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, u(t4, e3);
      }
      var f = r2(7026), l = r2(8437), h2 = r2(3343), p = r2(2078), d2 = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), a(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && u(t5, e4);
        }(e3, t4), r3 = e3, (n2 = [{ key: "assimilateError", value: function(t5) {
          var e4 = t5.reason, r4 = h2(e4) && l(e4) && -1 === t5.message.indexOf("bad auth") && -1 === t5.message.indexOf("Authentication failed");
          for (var n3 in r4 ? this.message = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/" : p(e4) ? this.message = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html" : this.message = t5.message, t5)
            "name" !== n3 && (this[n3] = t5[n3]);
          return this;
        } }]) && i2(r3.prototype, n2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, n2;
      }(f);
      Object.defineProperty(d2.prototype, "name", { value: "MongooseServerSelectionError" }), t3.exports = d2;
    }, 6166: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5, r4, n2) {
          var o2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (o2 = i2(this, e3, [r4 = r4 || "Field `" + t5 + "` is not in schema and strict mode is set to throw."])).isImmutableError = !!n2, o2.path = t5, o2;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "StrictModeError" }), t3.exports = c;
    }, 3232: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5, r4) {
          var n2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (n2 = i2(this, e3, [r4 = r4 || "Cannot populate path `" + t5 + "` because it is not in your schema. Set the `strictPopulate` option to false to override."])).path = t5, n2;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "StrictPopulateError" }), t3.exports = c;
    }, 5368: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, o(n2.key), n2);
        }
      }
      function o(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      function a(t4, e3, r3) {
        return e3 = c(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, s2() ? Reflect.construct(e3, r3 || [], c(t4).constructor) : e3.apply(t4, r3));
      }
      function s2() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (s2 = function() {
          return !!t4;
        })();
      }
      function c(t4) {
        return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, c(t4);
      }
      function u(t4, e3) {
        return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, u(t4, e3);
      }
      var f = r2(7026), l = r2(5857), h2 = r2(7352), p = r2(1892), d2 = function(t4) {
        function e3(t5) {
          var r4, n3;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (r4 = a(this, e3, [n3 = "model" === l(t5) ? t5.constructor.modelName + " validation failed" : "Validation failed"])).errors = {}, r4._message = n3, t5 && (t5.$errors = r4.errors), r4;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && u(t5, e4);
        }(e3, t4), r3 = e3, (n2 = [{ key: "toString", value: function() {
          return this.name + ": " + p(this);
        } }, { key: "inspect", value: function() {
          return Object.assign(new Error(this.message), this);
        } }, { key: "addError", value: function(t5, r4) {
          if (r4 instanceof e3)
            for (var n3 = r4.errors, i3 = 0, o2 = Object.keys(n3); i3 < o2.length; i3++) {
              var a2 = o2[i3];
              this.addError("".concat(t5, ".").concat(a2), n3[a2]);
            }
          else
            this.errors[t5] = r4, this.message = this._message + ": " + p(this);
        } }]) && i2(r3.prototype, n2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, n2;
      }(f);
      h2.inspect.custom && (d2.prototype[h2.inspect.custom] = d2.prototype.inspect), Object.defineProperty(d2.prototype, "toJSON", { enumerable: false, writable: false, configurable: true, value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      } }), Object.defineProperty(d2.prototype, "name", { value: "ValidationError" }), t3.exports = d2;
    }, 8393: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, o(n2.key), n2);
        }
      }
      function o(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      function a(t4, e3, r3) {
        return e3 = c(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, s2() ? Reflect.construct(e3, r3 || [], c(t4).constructor) : e3.apply(t4, r3));
      }
      function s2() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (s2 = function() {
          return !!t4;
        })();
      }
      function c(t4) {
        return c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, c(t4);
      }
      function u(t4, e3) {
        return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, u(t4, e3);
      }
      var f = r2(9507), l = function(t4) {
        function e3(t5, r4) {
          var n3;
          !function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3);
          var i3 = t5.message;
          i3 || (i3 = f.messages.general.default);
          var o2 = h2(i3, t5, r4);
          return n3 = a(this, e3, [o2]), t5 = Object.assign({}, t5, { message: o2 }), n3.properties = t5, n3.kind = t5.type, n3.path = t5.path, n3.value = t5.value, n3.reason = t5.reason, n3;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && u(t5, e4);
        }(e3, t4), r3 = e3, (n2 = [{ key: "toString", value: function() {
          return this.message;
        } }, { key: "toJSON", value: function() {
          return Object.assign({ name: this.name, message: this.message }, this);
        } }]) && i2(r3.prototype, n2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, n2;
      }(f);
      function h2(t4, e3, r3) {
        if ("function" == typeof t4)
          return t4(e3, r3);
        for (var n2 = 0, i3 = Object.keys(e3); n2 < i3.length; n2++) {
          var o2 = i3[n2];
          "message" !== o2 && (t4 = t4.replace("{" + o2.toUpperCase() + "}", e3[o2]));
        }
        return t4;
      }
      Object.defineProperty(l.prototype, "name", { value: "ValidatorError" }), Object.defineProperty(l.prototype, "properties", { enumerable: false, writable: true, value: null }), l.prototype.formatMessage = h2, t3.exports = l;
    }, 587: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3(t5, r4, n2) {
          var o2;
          !function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3);
          var a2 = n2.join(", ");
          return (o2 = i2(this, e3, ['No matching document found for id "' + t5._id + '" version ' + r4 + ' modifiedPaths "' + a2 + '"'])).version = r4, o2.modifiedPaths = n2, o2;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(9507));
      Object.defineProperty(c.prototype, "name", { value: "VersionError" }), t3.exports = c;
    }, 3164: (t3) => {
      t3.exports = function t4(e2) {
        if (!Array.isArray(e2))
          return { min: 0, max: 0, containsNonArrayItem: true };
        if (0 === e2.length)
          return { min: 1, max: 1, containsNonArrayItem: false };
        if (1 === e2.length && !Array.isArray(e2[0]))
          return { min: 1, max: 1, containsNonArrayItem: false };
        for (var r2 = t4(e2[0]), n = 1; n < e2.length; ++n) {
          var i2 = t4(e2[n]);
          i2.min < r2.min && (r2.min = i2.min), i2.max > r2.max && (r2.max = i2.max), r2.containsNonArrayItem = r2.containsNonArrayItem || i2.containsNonArrayItem;
        }
        return r2.min = r2.min + 1, r2.max = r2.max + 1, r2;
      };
    }, 1829: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(9394), o = r2(6704), a = r2(8150), s2 = r2(6504), c = r2(5515), u = r2(2128), f = r2(9240).isMongooseArray, l = r2(4797), h2 = r2(6288), p = r2(5625), d2 = r2(3692).trustedSymbol;
      function y2(t4, e3, r3) {
        if (null == t4)
          return t4;
        if (Array.isArray(t4))
          return function(t5, e4) {
            var r4 = 0, n2 = t5.length, i3 = new Array(n2);
            for (r4 = 0; r4 < n2; ++r4)
              i3[r4] = y2(t5[r4], e4, true);
            return i3;
          }(f(t4) ? t4.__array : t4, e3);
        if (s2(t4)) {
          if (e3 && (e3._skipSingleNestedGetters && t4.$isSingleNested && (e3 = Object.assign({}, e3, { getters: false })), e3.retainDocuments && null != t4.$__)) {
            var a2 = t4.$clone();
            return null != t4.__index && (a2.__index = t4.__index), null != t4.__parentArray && (a2.__parentArray = t4.__parentArray), a2.$__parent = t4.$__parent, a2;
          }
          var d3, m2 = t4.$isSingleNested;
          if (h2(t4) && null != t4.$__ && null != t4._doc)
            return t4._doc;
          if (d3 = e3 && e3.json && "function" == typeof t4.toJSON ? t4.toJSON(e3) : t4.toObject(e3), e3 && e3.minimize && !t4.constructor.$__required && m2 && 0 === Object.keys(d3).length)
            return;
          return d3;
        }
        var v = t4.constructor;
        if (v)
          switch (c(v)) {
            case "Object":
              return b(t4, e3, r3);
            case "Date":
              return new v(+t4);
            case "RegExp":
              return function(t5) {
                var e4 = new RegExp(t5.source, t5.flags);
                return e4.lastIndex !== t5.lastIndex && (e4.lastIndex = t5.lastIndex), e4;
              }(t4);
          }
        return u(t4, "ObjectId") ? e3 && e3.flattenObjectIds ? t4.toJSON() : new o(t4.id) : u(t4, "Decimal128") ? e3 && e3.flattenDecimals ? t4.toJSON() : i2.fromString(t4.toString()) : !v && l(t4) ? b(t4, e3, r3) : "object" === n(t4) && t4[p.schemaTypeSymbol] ? t4.clone() : e3 && e3.bson && "function" == typeof t4.toBSON ? t4 : "function" == typeof t4.valueOf ? t4.valueOf() : b(t4, e3, r3);
      }
      function b(t4, e3, r3) {
        var n2, i3 = e3 && e3.minimize, o2 = e3 && e3.omitUndefined, s3 = e3 && e3._seen, c2 = {};
        if (s3 && s3.has(t4))
          return s3.get(t4);
        s3 && s3.set(t4, c2), d2 in t4 && (c2[d2] = t4[d2]);
        var u2 = 0, f2 = "", l2 = Object.keys(t4), h3 = l2.length;
        for (u2 = 0; u2 < h3; ++u2)
          if (!a.has(f2 = l2[u2])) {
            var p2 = y2(t4[f2], e3, false);
            false !== i3 && !o2 || void 0 !== p2 ? true === i3 && void 0 === p2 || (n2 || (n2 = true), c2[f2] = p2) : delete c2[f2];
          }
        return i3 && !r3 ? n2 && c2 : c2;
      }
      t3.exports = y2;
    }, 9563: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      var o = r2(3633).Binary, a = r2(2128), s2 = r2(6504);
      r2(9507), r2(7352);
      function c(t4) {
        return t4 && "object" === i2(t4) && !(t4 instanceof Date) && !a(t4, "ObjectId") && (!Array.isArray(t4) || 0 !== t4.length) && !(t4 instanceof n) && !a(t4, "Decimal128") && !(t4 instanceof o);
      }
      e2.B = function t4(e3, r3, i3, o2) {
        var a2, u = (a2 = e3 && s2(e3) && !n.isBuffer(e3) ? Object.keys(e3.toObject({ transform: false, virtuals: false }) || {}) : Object.keys(e3 || {})).length, f = {};
        r3 = r3 ? r3 + "." : "";
        for (var l = 0; l < u; ++l) {
          var h2 = a2[l], p = e3[h2];
          f[r3 + h2] = p;
          var d2 = o2 && o2.path && o2.path(r3 + h2), y2 = o2 && o2.nested && o2.nested[r3 + h2];
          if (!d2 || "Mixed" !== d2.instance) {
            if (c(p)) {
              if (i3 && i3.skipArrays && Array.isArray(p))
                continue;
              var b = t4(p, r3 + h2, i3, o2);
              for (var m2 in b)
                f[m2] = b[m2];
              Array.isArray(p) && (f[r3 + h2] = p);
            }
            if (y2)
              for (var v = 0, g = Object.keys(o2.paths); v < g.length; v++) {
                var _ = g[v];
                _.startsWith(r3 + h2 + ".") && !f.hasOwnProperty(_) && (f[_] = void 0);
              }
          }
        }
        return f;
      };
    }, 7603: (t3, e2, r2) => {
      var n = r2(2128);
      t3.exports = function(t4, e3) {
        return "string" == typeof t4 && "string" == typeof e3 || "number" == typeof t4 && "number" == typeof e3 ? t4 === e3 : !(!n(t4, "ObjectId") || !n(e3, "ObjectId")) && t4.toString() === e3.toString();
      };
    }, 967: (t3) => {
      t3.exports = function(t4, e2, r2, n, i2) {
        var o = Object.keys(t4).reduce(function(t5, r3) {
          return t5 || r3.startsWith(e2 + ".");
        }, false), a = e2 + "." + r2.options.discriminatorKey;
        o || 1 !== i2.length || i2[0] !== a || n.splice(n.indexOf(a), 1);
      };
    }, 371: (t3, e2, r2) => {
      var n = r2(7785);
      t3.exports = function(t4, e3, r3) {
        var i2 = t4.schema.options.discriminatorKey, o = null != e3 && e3[i2];
        if (null == o && (o = r3), t4.discriminators && null != o)
          if (t4.discriminators[o])
            t4 = t4.discriminators[o];
          else {
            var a = n(t4.discriminators, o);
            a && (t4 = a);
          }
        return t4;
      };
    }, 7785: (t3, e2, r2) => {
      var n = r2(7603);
      t3.exports = function(t4, e3) {
        if (null == t4)
          return null;
        for (var r3 = 0, i2 = Object.keys(t4); r3 < i2.length; r3++) {
          var o = t4[i2[r3]];
          if (o.schema && o.schema.discriminatorMapping && n(o.schema.discriminatorMapping.value, e3))
            return o;
        }
        return null;
      };
    }, 1654: (t3, e2, r2) => {
      var n = r2(7603);
      t3.exports = function(t4, e3) {
        if (null == t4 || null == t4.discriminators)
          return null;
        for (var r3 = 0, i2 = Object.keys(t4.discriminators); r3 < i2.length; r3++) {
          var o = i2[r3], a = t4.discriminators[o];
          if (null != a.discriminatorMapping && n(a.discriminatorMapping.value, e3))
            return a;
        }
        return null;
      };
    }, 8836: (t3, e2, r2) => {
      var n = r2(5682), i2 = r2(8150), o = r2(2128), a = r2(6704), s2 = r2(4797);
      t3.exports = function t4(e3, r3, c, u) {
        var f, l = Object.keys(r3), h2 = 0, p = l.length;
        if (c = c || "", !(u = u || /* @__PURE__ */ new WeakSet()).has(r3)) {
          for (u.add(r3); h2 < p; )
            if (f = l[h2++], (c || "discriminators" !== f && "base" !== f && "_applyDiscriminators" !== f && "_userProvidedOptions" !== f && "options" !== f && "tree" !== f) && !("tree" === c && null != r3 && r3.instanceOfSchema || i2.has(f))) {
              if (null == e3[f])
                e3[f] = r3[f];
              else if (s2(r3[f])) {
                if (s2(e3[f]) || (e3[f] = {}), null != r3[f]) {
                  if (r3[f].$isSingleNested && e3[f].$isMongooseDocumentArray || r3[f].$isMongooseDocumentArray && e3[f].$isSingleNested || r3[f].$isMongooseDocumentArrayElement && e3[f].$isMongooseDocumentArrayElement)
                    continue;
                  if (r3[f].instanceOfSchema) {
                    e3[f].instanceOfSchema ? n(e3[f], r3[f].clone(), true) : e3[f] = r3[f].clone();
                    continue;
                  }
                  if (o(r3[f], "ObjectId")) {
                    e3[f] = new a(r3[f]);
                    continue;
                  }
                }
                t4(e3[f], r3[f], c ? c + "." + f : f, u);
              }
            }
          null != r3 && r3.instanceOfSchema && (e3.tree = Object.assign({}, r3.tree, e3.tree));
        }
      };
    }, 6690: (t3, e2, r2) => {
      var n = r2(180);
      function i2(t4, e3) {
        t4.$__.activePaths.default(e3), t4.$isSubdocument && t4.$isSingleNested && null != t4.$parent() && t4.$parent().$__.activePaths.default(t4.$__pathRelativeToParent(e3));
      }
      t3.exports = function(t4, e3, r3, o, a, s2) {
        for (var c = Object.keys(t4.$__schema.paths), u = c.length, f = 0; f < u; ++f) {
          var l = void 0, h2 = "", p = c[f];
          if ("_id" !== p || !t4.$__.skipId)
            for (var d2 = t4.$__schema.paths[p], y2 = d2.splitPath(), b = y2.length, m2 = false, v = t4._doc, g = 0; g < b && null != v; ++g) {
              var _ = y2[g];
              if (h2 += (h2.length ? "." : "") + _, true === r3) {
                if (h2 in e3)
                  break;
              } else if (false === r3 && e3 && !m2) {
                var w2 = d2.$isSingleNested || d2.$isMongooseDocumentArray;
                if (h2 in e3 && !n(e3[h2]) || g === b - 1 && w2 && null != o && o[h2])
                  m2 = true;
                else if (null != o && !o[h2])
                  break;
              }
              if (g === b - 1) {
                if (void 0 !== v[_])
                  break;
                if (null != a) {
                  if ("function" == typeof d2.defaultValue) {
                    if (!d2.defaultValue.$runBeforeSetters && a)
                      break;
                    if (d2.defaultValue.$runBeforeSetters && !a)
                      break;
                  } else if (!a)
                    continue;
                }
                if (s2 && s2[h2])
                  break;
                if (e3 && null !== r3) {
                  if (true === r3) {
                    if (p in e3)
                      continue;
                    try {
                      l = d2.getDefault(t4, false);
                    } catch (e4) {
                      t4.invalidate(p, e4);
                      break;
                    }
                    void 0 !== l && (v[_] = l, i2(t4, p));
                  } else if (m2) {
                    try {
                      l = d2.getDefault(t4, false);
                    } catch (e4) {
                      t4.invalidate(p, e4);
                      break;
                    }
                    void 0 !== l && (v[_] = l, i2(t4, p));
                  }
                } else {
                  try {
                    l = d2.getDefault(t4, false);
                  } catch (e4) {
                    t4.invalidate(p, e4);
                    break;
                  }
                  void 0 !== l && (v[_] = l, i2(t4, p));
                }
              } else
                v = v[_];
            }
        }
      };
    }, 8208: (t3) => {
      t3.exports = function(t4, e2, r2) {
        var n = (r2 = r2 || {}).skipDocArrays, i2 = 0;
        if (!t4)
          return i2;
        for (var o = 0, a = Object.keys(t4.$__.activePaths.getStatePaths("modify")); o < a.length; o++) {
          var s2 = a[o];
          if (n) {
            var c = t4.$__schema.path(s2);
            if (c && c.$isMongooseDocumentArray)
              continue;
          }
          if (s2.startsWith(e2 + ".") && (t4.$__.activePaths.clearPath(s2), ++i2, t4.$isSubdocument)) {
            var u = t4.ownerDocument(), f = t4.$__fullPath(s2);
            u.$__.activePaths.clearPath(f);
          }
        }
        return i2;
      };
    }, 9725: (t3, e2, r2) => {
      var n, i2 = r2(1829), o = r2(5625).documentSchemaSymbol, a = r2(3920)._, s2 = r2(335), c = r2(5625).getSymbol, u = r2(5625).scopeSymbol, f = s2.isPOJO;
      e2.w = p, e2.X = d2;
      var l = Object.freeze({ minimize: true, virtuals: false, getters: false, transform: false }), h2 = Object.freeze({ noDottedPath: true });
      function p(t4, e3, i3, o2) {
        n = n || r2(3293);
        for (var a2 = o2.typeKey, s3 = 0, c2 = Object.keys(t4); s3 < c2.length; s3++) {
          var u2 = c2[s3], l2 = t4[u2];
          d2({ prop: u2, subprops: f(l2) && Object.keys(l2).length > 0 && (!l2[a2] || "type" === a2 && f(l2.type) && l2.type.type) ? l2 : null, prototype: e3, prefix: i3, options: o2 });
        }
      }
      function d2(t4) {
        var e3 = t4.prop, s3 = t4.subprops, f2 = t4.prototype, d3 = t4.prefix, y2 = t4.options;
        n = n || r2(3293);
        var b = (d3 ? d3 + "." : "") + e3, m2 = (d3 = d3 || "") ? Object.freeze({}) : h2;
        s3 ? Object.defineProperty(f2, e3, { enumerable: true, configurable: true, get: function() {
          var t5, e4, r3 = this;
          if (this.$__.getters || (this.$__.getters = {}), !this.$__.getters[b]) {
            var a2 = Object.create(n.prototype, (t5 = this, e4 = {}, Object.getOwnPropertyNames(t5).forEach(function(r4) {
              -1 === ["isNew", "$__", "$errors", "errors", "_doc", "$locals", "$op", "__parentArray", "__index", "$isDocumentArrayElement"].indexOf(r4) || (e4[r4] = Object.getOwnPropertyDescriptor(t5, r4), e4[r4].enumerable = false);
            }), e4));
            d3 || (a2.$__[u] = this), a2.$__.nestedPath = b, Object.defineProperty(a2, "schema", { enumerable: false, configurable: true, writable: false, value: f2.schema }), Object.defineProperty(a2, "$__schema", { enumerable: false, configurable: true, writable: false, value: f2.schema }), Object.defineProperty(a2, o, { enumerable: false, configurable: true, writable: false, value: f2.schema }), Object.defineProperty(a2, "toObject", { enumerable: false, configurable: true, writable: false, value: function() {
              return i2(r3.get(b, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null }));
            } }), Object.defineProperty(a2, "$__get", { enumerable: false, configurable: true, writable: false, value: function() {
              return r3.get(b, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null });
            } }), Object.defineProperty(a2, "toJSON", { enumerable: false, configurable: true, writable: false, value: function() {
              return r3.get(b, null, { virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null });
            } }), Object.defineProperty(a2, "$__isNested", { enumerable: false, configurable: true, writable: false, value: true }), Object.defineProperty(a2, "$isEmpty", { enumerable: false, configurable: true, writable: false, value: function() {
              return 0 === Object.keys(this.get(b, null, l) || {}).length;
            } }), Object.defineProperty(a2, "$__parent", { enumerable: false, configurable: true, writable: false, value: this }), p(s3, a2, b, y2), this.$__.getters[b] = a2;
          }
          return this.$__.getters[b];
        }, set: function(t5) {
          null != t5 && t5.$__isNested ? t5 = t5.$__get() : t5 instanceof n && !t5.$__isNested && (t5 = t5.$toObject(a)), (this.$__[u] || this).$set(b, t5);
        } }) : Object.defineProperty(f2, e3, { enumerable: true, configurable: true, get: function() {
          return this[c].call(this.$__[u] || this, b, null, m2);
        }, set: function(t5) {
          this.$set.call(this.$__[u] || this, b, t5);
        } });
      }
    }, 2609: (t3) => {
      t3.exports = function(t4, e2, r2) {
        for (var n = e2[0], i2 = r2, o = t4, a = 0; a < e2.length - 1; ++a) {
          var s2 = i2.path(n);
          if (s2 && s2.schema) {
            var c = o.get(n);
            if (i2 = s2.schema, n = e2[a + 1], Array.isArray(c) && !isNaN(n) && (c = c[n], n = ""), null == c)
              break;
            o = c;
          } else
            n += n.length ? "." + e2[a + 1] : e2[a + 1];
        }
        return o;
      };
    }, 8239: (t3, e2, r2) => {
      var n = r2(5132), i2 = r2(1654);
      t3.exports = function t4(e3, r3, o) {
        for (var a = (o = o || {}).typeOnly, s2 = Array.isArray(r3) ? r3 : -1 === r3.indexOf(".") ? [r3] : r3.split("."), c = null, u = "adhocOrUndefined", f = i2(e3.schema, e3.get(e3.schema.options.discriminatorKey)) || e3.schema, l = 0; l < s2.length; ++l) {
          var h2 = s2.slice(0, l + 1).join(".");
          if (null != (c = f.path(h2))) {
            if ("Mixed" === c.instance)
              return a ? "real" : c;
            if (u = f.pathType(h2), (c.$isSingleNested || c.$isMongooseDocumentArrayElement) && null != c.schema.discriminators) {
              var p = c.schema.discriminators, d2 = e3.get(h2 + "." + n(c, "schema.options.discriminatorKey"));
              if (null == d2 || null == p[d2])
                continue;
              var y2 = s2.slice(l + 1).join(".");
              return t4(e3.get(h2), y2, o);
            }
          } else
            u = "adhocOrUndefined";
        }
        return a ? u : c;
      };
    }, 8145: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i2(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            var n2, i3, a2, s3;
            n2 = t4, i3 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != o(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != o(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(i3), (i3 = "symbol" == o(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, i3, { value: a2, enumerable: true, configurable: true, writable: true }) : n2[i3] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a = r2(335), s2 = /* @__PURE__ */ new Set(["__index", "__parentArray", "_doc"]);
      t3.exports = function(t4, e3) {
        if (a.isPOJO(t4) && null != t4.$__ && null != t4._doc) {
          if (e3) {
            for (var r3 = {}, n2 = 0, c = Object.keys(t4); n2 < c.length; n2++) {
              var u = c[n2];
              "symbol" !== o(u) && "$" !== u[0] && (s2.has(u) || (r3[u] = t4[u]));
            }
            return i2(i2({}, t4._doc), r3);
          }
          return t4._doc;
        }
        return t4;
      };
    }, 6343: (t3) => {
      function e2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r2 = 0, n = new Array(e3); r2 < e3; r2++)
          n[r2] = t4[r2];
        return n;
      }
      t3.exports = function(t4, r2, n) {
        if (0 === t4.length)
          return n();
        var i2, o = t4.length, a = null, s2 = function(t5, r3) {
          var n2 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (!n2) {
            if (Array.isArray(t5) || (n2 = function(t6, r4) {
              if (t6) {
                if ("string" == typeof t6)
                  return e2(t6, r4);
                var n3 = Object.prototype.toString.call(t6).slice(8, -1);
                return "Object" === n3 && t6.constructor && (n3 = t6.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t6) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? e2(t6, r4) : void 0;
              }
            }(t5)) || r3 && t5 && "number" == typeof t5.length) {
              n2 && (t5 = n2);
              var i3 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return i3 >= t5.length ? { done: true } : { done: false, value: t5[i3++] };
              }, e: function(t6) {
                throw t6;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var a2, s3 = true, c = false;
          return { s: function() {
            n2 = n2.call(t5);
          }, n: function() {
            var t6 = n2.next();
            return s3 = t6.done, t6;
          }, e: function(t6) {
            c = true, a2 = t6;
          }, f: function() {
            try {
              s3 || null == n2.return || n2.return();
            } finally {
              if (c)
                throw a2;
            }
          } };
        }(t4);
        try {
          for (s2.s(); !(i2 = s2.n()).done; )
            r2(i2.value, function(t5) {
              if (null == a)
                return null != t5 ? n(a = t5) : --o <= 0 ? n() : void 0;
            });
        } catch (a2) {
          s2.e(a2);
        } finally {
          s2.f();
        }
      };
    }, 1892: (t3) => {
      t3.exports = function(t4) {
        for (var e2, r2 = Object.keys(t4.errors || {}), n = r2.length, i2 = [], o = 0; o < n; ++o)
          e2 = r2[o], t4 !== t4.errors[e2] && i2.push(e2 + ": " + t4.errors[e2].message);
        return i2.join(", ");
      };
    }, 5132: (t3) => {
      function e2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n = new Array(e3); r3 < e3; r3++)
          n[r3] = t4[r3];
        return n;
      }
      function r2(t4, e3) {
        return null == t4 ? t4 : t4 instanceof Map ? t4.get(e3) : t4[e3];
      }
      t3.exports = function(t4, n, i2) {
        var o, a = false;
        if ("string" == typeof n) {
          if (-1 === n.indexOf(".")) {
            var s2 = r2(t4, n);
            return null == s2 ? i2 : s2;
          }
          o = n.split(".");
        } else if (a = true, 1 === (o = n).length) {
          var c = r2(t4, o[0]);
          return null == c ? i2 : c;
        }
        var u, f = n, l = t4, h2 = function(t5, r3) {
          var n2 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (!n2) {
            if (Array.isArray(t5) || (n2 = function(t6, r4) {
              if (t6) {
                if ("string" == typeof t6)
                  return e2(t6, r4);
                var n3 = Object.prototype.toString.call(t6).slice(8, -1);
                return "Object" === n3 && t6.constructor && (n3 = t6.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t6) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? e2(t6, r4) : void 0;
              }
            }(t5)) || r3 && t5 && "number" == typeof t5.length) {
              n2 && (t5 = n2);
              var i3 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return i3 >= t5.length ? { done: true } : { done: false, value: t5[i3++] };
              }, e: function(t6) {
                throw t6;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var a2, s3 = true, c2 = false;
          return { s: function() {
            n2 = n2.call(t5);
          }, n: function() {
            var t6 = n2.next();
            return s3 = t6.done, t6;
          }, e: function(t6) {
            c2 = true, a2 = t6;
          }, f: function() {
            try {
              s3 || null == n2.return || n2.return();
            } finally {
              if (c2)
                throw a2;
            }
          } };
        }(o);
        try {
          for (h2.s(); !(u = h2.n()).done; ) {
            var p = u.value;
            if (null == l)
              return i2;
            if (!a && null != l[f])
              return l[f];
            l = r2(l, p), a || (f = f.substr(p.length + 1));
          }
        } catch (t5) {
          h2.e(t5);
        } finally {
          h2.f();
        }
        return null == l ? i2 : l;
      };
    }, 5857: (t3) => {
      t3.exports = function(t4) {
        if (null != t4 && "function" == typeof t4.constructor)
          return t4.constructor.name;
      };
    }, 5515: (t3) => {
      var e2 = /^function\s*([^\s(]+)/;
      t3.exports = function(t4) {
        return t4.name || (t4.toString().trim().match(e2) || [])[1];
      };
    }, 3933: (t3) => {
      var e2 = void 0 !== { env: {} } && "function" == typeof { env: {} }.nextTick ? { env: {} }.nextTick.bind({ env: {} }) : function(t4) {
        return setTimeout(t4, 0);
      };
      t3.exports = function(t4) {
        return e2(t4);
      };
    }, 9996: (t3) => {
      t3.exports = function(t4, e2) {
        var r2 = t4.discriminatorMapping && t4.discriminatorMapping.value;
        if (r2 && !("sparse" in e2)) {
          var n = t4.options.discriminatorKey;
          e2.partialFilterExpression = e2.partialFilterExpression || {}, e2.partialFilterExpression[n] = r2;
        }
        return e2;
      };
    }, 6564: (t3) => {
      t3.exports = function(t4) {
        return "function" == typeof t4 && t4.constructor && "AsyncFunction" === t4.constructor.name;
      };
    }, 2128: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4, r2) {
        return "object" === e2(t4) && null !== t4 && t4._bsontype === r2;
      };
    }, 6504: (t3, e2, r2) => {
      var n = r2(9240).isMongooseArray;
      t3.exports = function(t4) {
        return null != t4 && (n(t4) || null != t4.$__ || t4.isMongooseBuffer || t4.$isMongooseMap);
      };
    }, 4797: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      t3.exports = function(t4) {
        return n.isBuffer(t4) || "[object Object]" === Object.prototype.toString.call(t4);
      };
    }, 6288: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        if (null == t4 || "object" !== e2(t4))
          return false;
        var r2 = Object.getPrototypeOf(t4);
        return !r2 || "Object" === r2.constructor.name;
      };
    }, 3165: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return !!t4 && ("object" === e2(t4) || "function" == typeof t4) && "function" == typeof t4.then;
      };
    }, 4664: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        for (var r2 = Object.keys(t4), n = true, i2 = 0, o = r2.length; i2 < o; ++i2)
          if ("object" === e2(t4[r2[i2]]) && null !== t4[r2[i2]]) {
            n = false;
            break;
          }
        return n;
      };
    }, 6470: (t3, e2, r2) => {
      var n = r2(335).isPOJO;
      t3.exports = function t4(e3) {
        for (var r3, i2, o, a = Object.keys(e3), s2 = a.length; s2--; )
          o = e3[i2 = a[s2]], n(o) && (e3[i2] = t4(o)), void 0 !== e3[i2] ? r3 = true : delete e3[i2];
        return r3 ? e3 : void 0;
      };
    }, 8892: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            var i3, o2, a2, s3;
            i3 = t4, o2 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != n(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var i4 = r4.call(t5, "string");
                if ("object" != n(i4))
                  return i4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(o2), (o2 = "symbol" == n(s3) ? s3 : s3 + "") in i3 ? Object.defineProperty(i3, o2, { value: a2, enumerable: true, configurable: true, writable: true }) : i3[o2] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      var a = r2(3089), s2 = r2(8183);
      t3.exports = u, u.middlewareFunctions = ["deleteOne", "save", "validate", "remove", "updateOne", "init"];
      var c = new Set(u.middlewareFunctions.flatMap(function(t4) {
        return [t4, "$__".concat(t4)];
      }));
      function u(t4, e3, r3) {
        var n2 = { useErrorHandlers: true, numCallbackParams: 1, nullResultByDefault: true, contextParameter: true }, i3 = (r3 = r3 || {}).decorateDoc ? t4 : t4.prototype;
        t4.$appliedHooks = true;
        for (var f = 0, l = Object.keys(e3.paths); f < l.length; f++) {
          var h2 = l[f], p = e3.paths[h2], d2 = null;
          if (p.$isSingleNested)
            d2 = p.caster;
          else {
            if (!p.$isMongooseDocumentArray)
              continue;
            d2 = p.Constructor;
          }
          if (!d2.$appliedHooks && (u(d2, p.schema, o(o({}, r3), {}, { isChildSchema: true })), null != d2.discriminators))
            for (var y2 = 0, b = Object.keys(d2.discriminators); y2 < b.length; y2++) {
              var m2 = b[y2];
              u(d2.discriminators[m2], d2.discriminators[m2].schema, r3);
            }
        }
        var v = e3.s.hooks.filter(function(t5) {
          return "updateOne" === t5.name || "deleteOne" === t5.name ? !!t5.document : "remove" === t5.name || "init" === t5.name ? null == t5.document || !!t5.document : null == t5.query && null == t5.document || false !== t5.document;
        }).filter(function(t5) {
          return !e3.methods[t5.name] || !t5.fn[a.builtInMiddleware];
        });
        t4._middleware = v, i3.$__originalValidate = i3.$__originalValidate || i3.$__validate;
        for (var g = 0, _ = r3 && r3.isChildSchema ? ["save", "validate", "deleteOne"] : ["save", "validate"]; g < _.length; g++) {
          var w2 = _[g], S = "validate" === w2 ? "$__originalValidate" : "$__".concat(w2), O = v.createWrapper(w2, i3[S], null, n2);
          i3["$__".concat(w2)] = O;
        }
        i3.$__init = v.createWrapperSync("init", i3.$__init, null, n2);
        for (var j = Object.keys(e3.methods), $ = Object.assign({}, n2, { checkForPromise: true }), A = function() {
          var e4 = x[E];
          if (c.has(e4))
            return 0;
          if (!v.hasHooks(e4))
            return 0;
          var r4 = i3[e4];
          i3[e4] = function() {
            var r5 = this, n3 = Array.prototype.slice.call(arguments), i4 = n3.slice(-1).pop(), o2 = "function" == typeof i4 ? n3.slice(0, n3.length - 1) : n3;
            return s2(i4, function(t5) {
              return r5["$__".concat(e4)].apply(r5, o2.concat([t5]));
            }, t4.events);
          }, i3["$__".concat(e4)] = v.createWrapper(e4, r4, null, $);
        }, E = 0, x = j; E < x.length; E++)
          A();
      }
    }, 8650: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return i2(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i2(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var o = r2(1895), a = r2(7807), s2 = r2(1829), c = r2(9725).X, u = r2(5132), f = r2(335), l = r2(8836), h2 = { toJSON: true, toObject: true, _id: true, id: true, virtuals: true, methods: true };
      t3.exports = function(t4, e3, r3, i3, p, d2, y2) {
        if (!r3 || !r3.instanceOfSchema)
          throw new Error("You must pass a valid discriminator Schema");
        if (d2 = null == d2 || d2, t4.schema.discriminatorMapping && !t4.schema.discriminatorMapping.isRoot)
          throw new Error('Discriminator "' + e3 + '" can only be a discriminator of the root model');
        if (p) {
          var b = u(t4.base, "options.applyPluginsToDiscriminators", false) || !d2;
          t4.base._applyPlugins(r3, { skipTopLevel: !b });
        } else
          d2 || a(r3);
        var m2 = t4.schema.options.discriminatorKey, v = t4.schema.path(m2);
        if (null != v)
          f.hasUserDefinedProperty(v.options, "select") || (v.options.select = true), v.options.$skipDiscriminatorCheck = true;
        else {
          var g = {};
          g[m2] = { default: void 0, select: true, $skipDiscriminatorCheck: true }, g[m2][t4.schema.options.typeKey] = String, t4.schema.add(g), c({ prop: m2, prototype: t4.prototype, options: t4.schema.options });
        }
        if (r3.path(m2) && true !== r3.path(m2).options.$skipDiscriminatorCheck)
          throw new Error('Discriminator "' + e3 + '" cannot have field with name "' + m2 + '"');
        var _ = e3;
        if (("string" == typeof i3 && i3.length || null != i3) && (_ = i3), function(e4, r4) {
          e4._baseSchema = r4, r4.paths._id && r4.paths._id.options && !r4.paths._id.options.auto && e4.remove("_id");
          for (var i4 = [], a2 = 0, c2 = Object.keys(r4.paths); a2 < c2.length; a2++) {
            var u2 = c2[a2];
            if (e4.nested[u2])
              i4.push(u2);
            else if (-1 !== u2.indexOf(".")) {
              var y3, b2 = "", g2 = n(u2.split(".").slice(0, -1));
              try {
                for (g2.s(); !(y3 = g2.n()).done; ) {
                  var w2 = y3.value;
                  b2 += (b2.length ? "." : "") + w2, (e4.paths[b2] instanceof o || e4.singleNestedPaths[b2] instanceof o) && i4.push(u2);
                }
              } catch (t5) {
                g2.e(t5);
              } finally {
                g2.f();
              }
            }
          }
          l(e4, r4);
          for (var S = 0, O = i4; S < O.length; S++) {
            var j = O[S];
            delete e4.paths[j];
          }
          e4.childSchemas.forEach(function(t5) {
            t5.model.prototype.$__setSchema(t5.schema);
          });
          var $ = {};
          $[m2] = { default: _, select: true, set: function(t5) {
            if (t5 === _ || Array.isArray(_) && f.deepEqual(t5, _))
              return _;
            throw new Error(`Can't set discriminator key "` + m2 + '"');
          }, $skipDiscriminatorCheck: true }, $[m2][e4.options.typeKey] = v ? v.options[e4.options.typeKey] : String, e4.add($), e4.discriminatorMapping = { key: m2, value: _, isRoot: false }, r4.options.collection && (e4.options.collection = r4.options.collection);
          var A = e4.options.toJSON, E = e4.options.toObject, x = e4.options._id, P = e4.options.id, k = Object.keys(e4.options);
          e4.options.discriminatorKey = r4.options.discriminatorKey;
          for (var M = e4._userProvidedOptions, I = 0, B = k; I < B.length; I++) {
            var T = B[I];
            if (!h2[T] && T in M && !f.deepEqual(e4.options[T], r4.options[T]))
              throw new Error("Can't customize discriminator option " + T + " (can only modify " + Object.keys(h2).join(", ") + ")");
          }
          e4.options = s2(r4.options);
          for (var R = 0, N = Object.keys(M); R < N.length; R++) {
            var D = N[R];
            e4.options[D] = M[D];
          }
          A && (e4.options.toJSON = A), E && (e4.options.toObject = E), void 0 !== x && (e4.options._id = x), e4.options.id = P, d2 && (e4.s.hooks = t4.schema.s.hooks.merge(e4.s.hooks)), p && (e4.plugins = Array.prototype.slice.call(r4.plugins)), e4.callQueue = r4.callQueue.concat(e4.callQueue), delete e4._requiredpaths;
        }(r3, t4.schema), t4.discriminators || (t4.discriminators = {}), t4.schema.discriminatorMapping || (t4.schema.discriminatorMapping = { key: m2, value: null, isRoot: true }), t4.schema.discriminators || (t4.schema.discriminators = {}), t4.schema.discriminators[e3] = r3, t4.discriminators[e3] && !r3.options.overwriteModels && !y2)
          throw new Error('Discriminator with name "' + e3 + '" already exists');
        return r3;
      };
    }, 4094: (t3) => {
      var e2 = /\./g;
      t3.exports = function(t4) {
        if (-1 === t4.indexOf("."))
          return [t4];
        for (var r2 = t4.split(e2), n = r2.length, i2 = new Array(n), o = "", a = 0; a < n; ++a)
          o += 0 !== o.length ? "." + r2[a] : r2[a], i2[a] = o;
        return i2;
      };
    }, 1096: (t3, e2, r2) => {
      function n(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var i2 = r2(335);
      t3.exports = function(t4, e3) {
        if (null != t4._id && null != e3 && 0 !== e3.length) {
          var r3, o = String(t4._id), a = function(t5, e4) {
            var r4 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
            if (!r4) {
              if (Array.isArray(t5) || (r4 = function(t6, e5) {
                if (t6) {
                  if ("string" == typeof t6)
                    return n(t6, e5);
                  var r5 = Object.prototype.toString.call(t6).slice(8, -1);
                  return "Object" === r5 && t6.constructor && (r5 = t6.constructor.name), "Map" === r5 || "Set" === r5 ? Array.from(t6) : "Arguments" === r5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? n(t6, e5) : void 0;
                }
              }(t5)) || e4 && t5 && "number" == typeof t5.length) {
                r4 && (t5 = r4);
                var i3 = 0, o2 = function() {
                };
                return { s: o2, n: function() {
                  return i3 >= t5.length ? { done: true } : { done: false, value: t5[i3++] };
                }, e: function(t6) {
                  throw t6;
                }, f: o2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a2, s3 = true, c2 = false;
            return { s: function() {
              r4 = r4.call(t5);
            }, n: function() {
              var t6 = r4.next();
              return s3 = t6.done, t6;
            }, e: function(t6) {
              c2 = true, a2 = t6;
            }, f: function() {
              try {
                s3 || null == r4.return || r4.return();
              } finally {
                if (c2)
                  throw a2;
              }
            } };
          }(e3);
          try {
            for (a.s(); !(r3 = a.n()).done; ) {
              var s2 = r3.value;
              if (!s2.isVirtual)
                for (var c = s2.path.split("."), u = 0; u < c.length - 1; ++u) {
                  var f = c.slice(0, u + 1).join("."), l = c.slice(u + 1).join("."), h2 = t4.get(f);
                  if (null != h2 && i2.isMongooseDocumentArray(h2)) {
                    for (var p = 0; p < h2.length; ++p)
                      h2[p] && h2[p].populated(l, null == s2._docs[o] ? void 0 : s2._docs[o][p], s2);
                    break;
                  }
                }
            }
          } catch (t5) {
            a.e(t5);
          } finally {
            a.f();
          }
        }
      };
    }, 5877: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4, r2, n, i2) {
        return i2.justOne || i2.count ? (t4[r2] = Array.isArray(n) ? n[0] : n, "object" !== e2(t4[r2]) && (t4[r2] = i2.count ? n : null)) : (t4[r2] = Array.isArray(n) ? n : null == n ? [] : [n], t4[r2] = t4[r2].filter(function(t5) {
          return t5 && "object" === e2(t5);
        })), t4[r2];
      };
    }, 6560: (t3, e2, r2) => {
      var n = r2(7026), i2 = r2(7352);
      t3.exports = function(t4, e3) {
        if ("string" != typeof t4 && "function" != typeof t4)
          throw new n('Invalid ref at path "' + e3 + '". Got ' + i2.inspect(t4, { depth: 0 }));
      };
    }, 8279: (t3) => {
      t3.exports = function(t4) {
        for (var e2 = {}, r2 = 0, n = Object.keys(t4); r2 < n.length; r2++) {
          var i2 = n[r2];
          if (-1 !== i2.indexOf("."))
            for (var o = i2.split("."), a = o[0], s2 = 0; s2 < o.length; ++s2)
              e2[a] = 1, s2 + 1 < o.length && (a = a + "." + o[s2 + 1]);
          else
            e2[i2] = 1;
        }
        return e2;
      };
    }, 6239: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return null == t4 || "object" !== e2(t4) || !("$meta" in t4) && !("$slice" in t4);
      };
    }, 1384: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(6239);
      t3.exports = function t4(e3) {
        if (null == e3)
          return null;
        var r3 = Object.keys(e3), o = null;
        if (1 === r3.length && "_id" === r3[0])
          o = !e3._id;
        else
          for (var a = 0; a < r3.length; ++a) {
            var s2 = r3[a];
            if ("_id" !== s2 && i2(e3[s2])) {
              o = null != e3[s2] && "object" === n(e3[s2]) ? t4(e3[s2]) : !e3[s2];
              break;
            }
          }
        return o;
      };
    }, 180: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return null != t4 && "object" === e2(t4) && null == t4.$slice && null == t4.$elemMatch && null == t4.$meta && null == t4.$;
      };
    }, 5772: (t3) => {
      t3.exports = function(t4, e2) {
        for (var r2, n, i2, o = e2.split("."), a = "", s2 = 0; s2 < o.length; ++s2)
          if (t4[a += a.length ? "." : "" + o[s2]]) {
            for (i2 = (n = Object.keys(t4)).length, r2 = 0; r2 < i2; ++r2)
              0 !== n[s2].indexOf(a + ".") || n[s2].indexOf(e2);
            return true;
          }
        return false;
      };
    }, 8183: (t3, e2, r2) => {
      var n = r2(3933), i2 = Symbol("mongoose#emitted");
      t3.exports = function(t4, e3, o, a) {
        if ("function" == typeof t4)
          try {
            return e3(function(e4) {
              if (null == e4)
                t4.apply(this, arguments);
              else {
                null != o && null != o.listeners && o.listeners("error").length > 0 && !e4[i2] && (e4[i2] = true, o.emit("error", e4));
                try {
                  t4(e4);
                } catch (e5) {
                  return n(function() {
                    throw e5;
                  });
                }
              }
            });
          } catch (e4) {
            return null != o && null != o.listeners && o.listeners("error").length > 0 && !e4[i2] && (e4[i2] = true, o.emit("error", e4)), t4(e4);
          }
        return new (a = a || r2.g.Promise)(function(t5, r3) {
          e3(function(e4, n2) {
            return null != e4 ? (null != o && null != o.listeners && o.listeners("error").length > 0 && !e4[i2] && (e4[i2] = true, o.emit("error", e4)), r3(e4)) : arguments.length > 2 ? t5(Array.prototype.slice.call(arguments, 1)) : void t5(n2);
          });
        });
      };
    }, 8385: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(6148), o = r2(6166), a = r2(247), s2 = /* @__PURE__ */ new Set(["$and", "$or"]), c = /* @__PURE__ */ new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]), u = /* @__PURE__ */ new Set(["$multiply", "$divide", "$log", "$mod", "$trunc", "$avg", "$max", "$min", "$stdDevPop", "$stdDevSamp", "$sum"]), f = /* @__PURE__ */ new Set(["$abs", "$exp", "$ceil", "$floor", "$ln", "$log10", "$sqrt", "$sin", "$cos", "$tan", "$asin", "$acos", "$atan", "$atan2", "$asinh", "$acosh", "$atanh", "$sinh", "$cosh", "$tanh", "$degreesToRadians", "$radiansToDegrees"]), l = /* @__PURE__ */ new Set(["$arrayElemAt", "$first", "$last"]), h2 = /* @__PURE__ */ new Set(["$year", "$month", "$week", "$dayOfMonth", "$dayOfYear", "$hour", "$minute", "$second", "$isoDayOfWeek", "$isoWeekYear", "$isoWeek", "$millisecond"]), p = /* @__PURE__ */ new Set(["$not"]);
      function d2(t4, e3, r3) {
        if (v(t4) || null === t4)
          return t4;
        null != t4.$cond ? Array.isArray(t4.$cond) ? t4.$cond = t4.$cond.map(function(t5) {
          return d2(t5, e3, r3);
        }) : (t4.$cond.if = d2(t4.$cond.if, e3, r3), t4.$cond.then = d2(t4.$cond.then, e3, r3), t4.$cond.else = d2(t4.$cond.else, e3, r3)) : null != t4.$ifNull ? t4.$ifNull.map(function(t5) {
          return d2(t5, e3, r3);
        }) : null != t4.$switch && (t4.branches.map(function(t5) {
          return d2(t5, e3, r3);
        }), t4.default = d2(t4.default, e3, r3));
        for (var n2 = 0, a2 = Object.keys(t4); n2 < a2.length; n2++) {
          var l2 = a2[n2];
          s2.has(l2) ? t4[l2] = t4[l2].map(function(t5) {
            return d2(t5, e3, r3);
          }) : c.has(l2) ? t4[l2] = m2(t4[l2], e3, r3) : u.has(l2) ? t4[l2] = b(t4[l2]) : f.has(l2) ? t4[l2] = y2(t4[l2]) : p.has(l2) && (t4[l2] = d2(t4[l2], e3, r3));
        }
        if (t4.$in && (t4.$in = function(t5, e4, r4) {
          var n3 = t5[1];
          if (!v(n3))
            return t5;
          var i3 = t5[0], a3 = e4.path(n3.slice(1));
          if (null !== a3) {
            if (!a3.$isMongooseArray)
              throw new Error("Path must be an array for $in");
            return [a3.$isMongooseDocumentArray ? a3.$embeddedSchemaType.cast(i3) : a3.caster.cast(i3), n3];
          }
          if (false === r4)
            return t5;
          if ("throw" === r4)
            throw new o("$in");
        }(t4.$in, e3, r3)), t4.$size && (t4.$size = y2(t4.$size)), t4.$round) {
          var h3 = t4.$round;
          if (!Array.isArray(h3) || h3.length < 1 || h3.length > 2)
            throw new i2("Array", h3, "$round");
          t4.$round = h3.map(function(t5) {
            return y2(t5);
          });
        }
        return function(t5) {
          for (var e4 = Object.keys(t5), r4 = 0, n3 = e4.length; r4 < n3; ++r4)
            void 0 === t5[e4[r4]] && delete t5[e4[r4]];
        }(t4), t4;
      }
      function y2(t4) {
        if (!g(t4))
          return t4;
        try {
          return a(t4);
        } catch (e3) {
          throw new i2("Number", t4);
        }
      }
      function b(t4) {
        if (!Array.isArray(t4)) {
          if (!g(t4))
            return t4;
          try {
            return a(t4);
          } catch (e3) {
            throw new i2("Number", t4);
          }
        }
        return t4.map(function(t5) {
          if (!g(t5))
            return t5;
          try {
            return a(t5);
          } catch (e3) {
            throw new i2("Number", t5);
          }
        });
      }
      function m2(t4, e3, r3) {
        if (!Array.isArray(t4) || 2 !== t4.length)
          throw new Error("Comparison operator must be an array of length 2");
        t4[0] = d2(t4[0], e3, r3);
        var s3 = t4[0];
        if (g(t4[1])) {
          var c2 = null, u2 = null, f2 = null;
          if (v(s3))
            c2 = s3.slice(1), u2 = e3.path(c2);
          else if ("object" === n(s3) && null != s3)
            for (var p2 = 0, y3 = Object.keys(s3); p2 < y3.length; p2++) {
              var b2 = y3[p2];
              h2.has(b2) && v(s3[b2]) ? (c2 = s3[b2].slice(1) + "." + b2, f2 = a) : l.has(b2) && v(s3[b2]) && (c2 = s3[b2].slice(1) + "." + b2, null != (u2 = e3.path(s3[b2].slice(1))) && (u2.$isMongooseDocumentArray ? u2 = u2.$embeddedSchemaType : u2.$isMongooseArray && (u2 = u2.caster)));
            }
          var m3 = "object" === n(t4[1]) && null != t4[1] && null != t4[1].$literal;
          if (null != u2)
            t4[1] = m3 ? { $literal: u2.cast(t4[1].$literal) } : u2.cast(t4[1]);
          else if (null != f2)
            if (m3)
              try {
                t4[1] = { $literal: f2(t4[1].$literal) };
              } catch (e4) {
                throw new i2(f2.name.replace(/^cast/, ""), t4[1], c2 + ".$literal");
              }
            else
              try {
                t4[1] = f2(t4[1]);
              } catch (e4) {
                throw new i2(f2.name.replace(/^cast/, ""), t4[1], c2);
              }
          else {
            if (null != c2 && true === r3)
              return;
            if (null != c2 && "throw" === r3)
              throw new o(c2);
          }
        } else
          t4[1] = d2(t4[1]);
        return t4;
      }
      function v(t4) {
        return "string" == typeof t4 && "$" === t4[0];
      }
      function g(t4) {
        return !("string" == typeof t4 && "$" === t4[0] || "object" === n(t4) && null !== t4 && Object.keys(t4).find(function(t5) {
          return "$" === t5[0];
        }) && null == t4.$literal);
      }
      t3.exports = function(t4, e3, r3) {
        if ("object" !== n(t4) || null === t4)
          throw new Error("`$expr` must be an object");
        return d2(t4, e3, r3);
      };
    }, 6482: (t3) => {
      t3.exports = function(t4) {
        switch (t4) {
          case "p":
            t4 = "primary";
            break;
          case "pp":
            t4 = "primaryPreferred";
            break;
          case "s":
            t4 = "secondary";
            break;
          case "sp":
            t4 = "secondaryPreferred";
            break;
          case "n":
            t4 = "nearest";
        }
        return t4;
      };
    }, 499: (t3) => {
      var e2 = /* @__PURE__ */ new Set(["$ref", "$id", "$db"]);
      t3.exports = function(t4) {
        return "$" === t4[0] && !e2.has(t4);
      };
    }, 3692: (t3, e2) => {
      function r2(t4) {
        return r2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, r2(t4);
      }
      var n = Symbol("mongoose#trustedSymbol");
      e2.trustedSymbol = n, e2.trusted = function(t4) {
        return null == t4 || "object" !== r2(t4) || (t4[n] = true), t4;
      };
    }, 8331: (t3) => {
      t3.exports = function(t4) {
        var e2 = { _id: { auto: true } };
        e2._id[t4.options.typeKey] = "ObjectId", t4.add(e2);
      };
    }, 7807: (t3, e2, r2) => {
      var n = r2(7509);
      t3.exports = function(t4) {
        for (var e3 = 0, r3 = Object.values(n); e3 < r3.length; e3++)
          (0, r3[e3])(t4, { deduplicate: true });
        t4.plugins = Object.values(n).map(function(t5) {
          return { fn: t5, opts: { deduplicate: true } };
        }).concat(t4.plugins);
      };
    }, 8796: (t3) => {
      t3.exports = function(t4) {
        return t4.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
      };
    }, 5792: (t3, e2, r2) => {
      var n = r2(5132), i2 = r2(4797), o = r2(9996);
      t3.exports = function(t4) {
        var e3 = [], r3 = /* @__PURE__ */ new WeakMap(), a = t4.constructor.indexTypes, s2 = /* @__PURE__ */ new Map();
        return function t5(c, u, f) {
          if (!r3.has(c)) {
            r3.set(c, true), u = u || "";
            for (var l = 0, h2 = Object.keys(c.paths); l < h2.length; l++) {
              var p = h2[l], d2 = c.paths[p];
              if (null == f || !f.paths[p]) {
                if (d2.$isMongooseDocumentArray || d2.$isSingleNested) {
                  if (true !== n(d2, "options.excludeIndexes") && true !== n(d2, "schemaOptions.excludeIndexes") && true !== n(d2, "schema.options.excludeIndexes") && t5(d2.schema, u + p + "."), null != d2.schema.discriminators)
                    for (var y2 = d2.schema.discriminators, b = 0, m2 = Object.keys(y2); b < m2.length; b++) {
                      t5(y2[m2[b]], u + p + ".", d2.schema);
                    }
                  if (d2.$isMongooseDocumentArray)
                    continue;
                }
                var v = d2._index || d2.caster && d2.caster._index;
                if (false !== v && null != v) {
                  var g = {}, _ = i2(v), w2 = _ ? v : {}, S = "string" == typeof v ? v : !!_ && v.type;
                  if (S && -1 !== a.indexOf(S))
                    g[u + p] = S;
                  else if (w2.text)
                    g[u + p] = "text", delete w2.text;
                  else {
                    var O;
                    O = "descending" === v || "desc" === v || "ascending" !== v && "asc" !== v && -1 === Number(v), g[u + p] = O ? -1 : 1;
                  }
                  delete w2.type, "background" in w2 || (w2.background = true), null != c.options.autoIndex && (w2._autoIndex = c.options.autoIndex);
                  var j = w2 && w2.name;
                  "string" == typeof j && s2.has(j) ? Object.assign(s2.get(j), g) : (e3.push([g, w2]), s2.set(j, g));
                }
              }
            }
            r3.delete(c), u ? function(t6, r4) {
              for (var n2 = t6._indexes, i3 = n2.length, o2 = 0; o2 < i3; ++o2) {
                for (var a2 = n2[o2][0], s3 = n2[o2][1], c2 = Object.keys(a2), u2 = c2.length, f2 = {}, l2 = 0; l2 < u2; ++l2) {
                  var h3 = c2[l2];
                  f2[r4 + h3] = a2[h3];
                }
                var p2 = Object.assign({}, s3);
                if (null != s3 && null != s3.partialFilterExpression) {
                  p2.partialFilterExpression = {};
                  for (var d3 = s3.partialFilterExpression, y3 = 0, b2 = Object.keys(d3); y3 < b2.length; y3++) {
                    var m3 = b2[y3];
                    p2.partialFilterExpression[r4 + m3] = d3[m3];
                  }
                }
                e3.push([f2, p2]);
              }
            }(c, u) : (c._indexes.forEach(function(t6) {
              var e4 = t6[1];
              "background" in e4 || (e4.background = true), o(c, e4);
            }), e3 = e3.concat(c._indexes));
          }
        }(t4), e3;
      };
    }, 4051: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return i2(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i2(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a, s2 = true, c = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          c = true, a = t5;
        }, f: function() {
          try {
            s2 || null == r3.return || r3.return();
          } finally {
            if (c)
              throw a;
          }
        } };
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var o = r2(5132);
      t3.exports = function(t4, e3, r3) {
        var i3, a = null != r3 ? Object.keys(o(t4.tree, r3, {})) : Object.keys(t4.tree), s2 = new Set(Object.keys(e3));
        if (s2.size > 1) {
          i3 = /* @__PURE__ */ new Set();
          var c, u = n(a);
          try {
            for (u.s(); !(c = u.n()).done; ) {
              var f = c.value;
              s2.has(f) && i3.add(f);
            }
          } catch (t5) {
            u.e(t5);
          } finally {
            u.f();
          }
          var l, h2 = n(s2);
          try {
            for (h2.s(); !(l = h2.n()).done; ) {
              var p = l.value;
              i3.has(p) || i3.add(p);
            }
          } catch (t5) {
            h2.e(t5);
          } finally {
            h2.f();
          }
          i3 = Array.from(i3);
        } else
          i3 = Array.from(s2);
        return i3;
      };
    }, 8825: (t3) => {
      t3.exports = function(t4, e2) {
        if (1 !== e2.length) {
          for (var r2 = e2[0], n = void 0, i2 = 0; i2 < e2.length - 1; ++i2) {
            var o = t4.path(r2);
            o && o.schema ? (n = o.schema.options.strict, t4 = o.schema, r2 = o.$isMongooseDocumentArray && !isNaN(e2[i2 + 1]) ? "" : e2[i2 + 1]) : r2 += r2.length ? "." + e2[i2 + 1] : e2[i2 + 1];
          }
          return n;
        }
      };
    }, 5962: (t3, e2, r2) => {
      var n = r2(8331);
      t3.exports = function(t4, e3) {
        return null == e3 || null == e3._id || (t4 = t4.clone(), e3._id ? t4.paths._id || (n(t4), t4.options._id = true) : (t4.remove("_id"), t4.options._id = false)), t4;
      };
    }, 2169: (t3) => {
      t3.exports = function(t4, e2) {
        return null == t4 ? null : "boolean" == typeof t4 ? e2 : "boolean" == typeof t4[e2] ? t4[e2] ? e2 : null : e2 in t4 ? t4[e2] : e2;
      };
    }, 8638: (t3) => {
      function e2() {
        return null != this._id ? String(this._id) : null;
      }
      t3.exports = function(t4) {
        return !t4.paths.id && t4.paths._id && t4.options.id ? (t4.aliases && t4.aliases.id || t4.virtual("id").get(e2), t4) : t4;
      };
    }, 5682: (t3) => {
      function e2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r2 = 0, n = new Array(e3); r2 < e3; r2++)
          n[r2] = t4[r2];
        return n;
      }
      t3.exports = function(t4, r2, n) {
        for (var i2 = {}, o = 0, a = Object.keys(r2.tree); o < a.length; o++) {
          var s2 = a[o];
          n && (t4.paths[s2] || t4.nested[s2] || t4.singleNestedPaths[s2]) || (i2[s2] = r2.tree[s2]);
        }
        t4.options._isMerging = true, t4.add(i2, null), delete t4.options._isMerging, t4.callQueue = t4.callQueue.concat(r2.callQueue), t4.method(r2.methods), t4.static(r2.statics);
        for (var c = 0, u = Object.entries(r2._userProvidedOptions); c < u.length; c++) {
          var f = (p = u[c], d2 = 2, function(t5) {
            if (Array.isArray(t5))
              return t5;
          }(p) || function(t5, e3) {
            var r3 = null == t5 ? null : "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
            if (null != r3) {
              var n2, i3, o2, a2, s3 = [], c2 = true, u2 = false;
              try {
                if (o2 = (r3 = r3.call(t5)).next, 0 === e3) {
                  if (Object(r3) !== r3)
                    return;
                  c2 = false;
                } else
                  for (; !(c2 = (n2 = o2.call(r3)).done) && (s3.push(n2.value), s3.length !== e3); c2 = true)
                    ;
              } catch (t6) {
                u2 = true, i3 = t6;
              } finally {
                try {
                  if (!c2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2))
                    return;
                } finally {
                  if (u2)
                    throw i3;
                }
              }
              return s3;
            }
          }(p, d2) || function(t5, r3) {
            if (t5) {
              if ("string" == typeof t5)
                return e2(t5, r3);
              var n2 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === n2 && t5.constructor && (n2 = t5.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(t5) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? e2(t5, r3) : void 0;
            }
          }(p, d2) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }()), l = f[0], h2 = f[1];
          l in t4._userProvidedOptions || t4.set(l, h2);
        }
        var p, d2;
        for (var y2 in r2.query)
          t4.query[y2] = r2.query[y2];
        for (var b in r2.virtuals)
          t4.virtuals[b] = r2.virtuals[b].clone();
        t4._indexes = t4._indexes.concat(r2._indexes || []), t4.s.hooks.merge(r2.s.hooks, false);
      };
    }, 9012: (t3, e2, r2) => {
      var n = r2(6166);
      t3.exports = function(t4) {
        var e3, r3;
        t4.$immutable ? (t4.$immutableSetter = (e3 = t4.path, r3 = t4.options.immutable, function(t5, i2, o, a) {
          if (null == this || null == this.$__)
            return t5;
          if (this.isNew)
            return t5;
          if (a && a.overwriteImmutable)
            return t5;
          if (!("function" == typeof r3 ? r3.call(this, this) : r3))
            return t5;
          var s2 = null != this.$__.priorDoc ? this.$__.priorDoc.$__getValue(e3) : this.$__getValue(e3);
          if ("throw" === this.$__.strictMode && t5 !== s2)
            throw new n(e3, "Path `" + e3 + "` is immutable and strict mode is set to throw.", true);
          return s2;
        }), t4.set(t4.$immutableSetter)) : t4.$immutableSetter && (t4.setters = t4.setters.filter(function(e4) {
          return e4 !== t4.$immutableSetter;
        }), delete t4.$immutableSetter);
      };
    }, 8150: (t3) => {
      t3.exports = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
    }, 5625: (t3, e2) => {
      e2.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup"), e2.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics"), e2.arrayParentSymbol = Symbol("mongoose#Array#_parent"), e2.arrayPathSymbol = Symbol("mongoose#Array#_path"), e2.arraySchemaSymbol = Symbol("mongoose#Array#_schema"), e2.documentArrayParent = Symbol("mongoose#documentArrayParent"), e2.documentIsSelected = Symbol("mongoose#Document#isSelected"), e2.documentIsModified = Symbol("mongoose#Document#isModified"), e2.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths"), e2.documentSchemaSymbol = Symbol("mongoose#Document#schema"), e2.getSymbol = Symbol("mongoose#Document#get"), e2.modelSymbol = Symbol("mongoose#Model"), e2.objectIdSymbol = Symbol("mongoose#ObjectId"), e2.populateModelSymbol = Symbol("mongoose#PopulateOptions#Model"), e2.schemaTypeSymbol = Symbol("mongoose#schemaType"), e2.sessionNewDocuments = Symbol("mongoose#ClientSession#newDocuments"), e2.scopeSymbol = Symbol("mongoose#Document#scope"), e2.validatorErrorSymbol = Symbol("mongoose#validatorError");
    }, 7796: (t3) => {
      t3.exports = function(t4, e2, r2, n, i2) {
        var o = null != e2 && false === e2.updatedAt, a = null != e2 && false === e2.createdAt, s2 = null != r2 ? r2() : t4.ownerDocument().constructor.base.now();
        if (!a && (t4.isNew || t4.$isSubdocument) && n && !t4.$__getValue(n) && t4.$__isSelected(n) && t4.$set(n, s2, void 0, { overwriteImmutable: true }), !o && i2 && (t4.isNew || t4.$isModified())) {
          var c = s2;
          t4.isNew && null != n && (c = t4.$__getValue(n)), t4.$set(i2, c);
        }
      };
    }, 8644: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function o(t4, e3, r3) {
        var i3;
        return i3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (void 0 !== r4) {
            var i4 = r4.call(t5, "string");
            if ("object" != n(i4))
              return i4;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(e3), (e3 = "symbol" == n(i3) ? i3 : i3 + "") in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(4287), s2 = r2(7457), c = r2(5132), u = r2(2169), f = r2(7796), l = r2(3089), h2 = /* @__PURE__ */ new Set(["replaceOne", "findOneAndReplace"]);
      t3.exports = function(t4, e3) {
        var r3 = t4.childSchemas.find(function(t5) {
          return !!t5.schema.options.timestamps;
        });
        if (e3 || r3) {
          var n2 = u(e3, "createdAt"), p = u(e3, "updatedAt"), d2 = null != e3 && e3.hasOwnProperty("currentTime") ? e3.currentTime : null, y2 = {};
          if (t4.$timestamps = { createdAt: n2, updatedAt: p }, n2 && !t4.paths[n2]) {
            var b = null != t4.base ? t4.base.get("timestamps.createdAt.immutable") : null, m2 = null == b || b;
            y2[n2] = o(o({}, t4.options.typeKey || "type", Date), "immutable", m2);
          }
          p && !t4.paths[p] && (y2[p] = Date), t4.add(y2), t4.pre("save", function(t5) {
            var e4 = c(this, "$__.saveOptions.timestamps");
            if (false === e4)
              return t5();
            f(this, e4, d2, n2, p), t5();
          }), t4.methods.initializeTimestamps = function() {
            var t5 = null != d2 ? d2() : this.constructor.base.now();
            if (n2 && !this.get(n2) && this.$set(n2, t5), p && !this.get(p) && this.$set(p, t5), this.$isSubdocument)
              return this;
            var e4, r4 = function(t6, e5) {
              var r5 = "undefined" != typeof Symbol && t6[Symbol.iterator] || t6["@@iterator"];
              if (!r5) {
                if (Array.isArray(t6) || (r5 = function(t7, e6) {
                  if (t7) {
                    if ("string" == typeof t7)
                      return i2(t7, e6);
                    var r6 = Object.prototype.toString.call(t7).slice(8, -1);
                    return "Object" === r6 && t7.constructor && (r6 = t7.constructor.name), "Map" === r6 || "Set" === r6 ? Array.from(t7) : "Arguments" === r6 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r6) ? i2(t7, e6) : void 0;
                  }
                }(t6)) || e5 && t6 && "number" == typeof t6.length) {
                  r5 && (t6 = r5);
                  var n3 = 0, o3 = function() {
                  };
                  return { s: o3, n: function() {
                    return n3 >= t6.length ? { done: true } : { done: false, value: t6[n3++] };
                  }, e: function(t7) {
                    throw t7;
                  }, f: o3 };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var a2, s3 = true, c2 = false;
              return { s: function() {
                r5 = r5.call(t6);
              }, n: function() {
                var t7 = r5.next();
                return s3 = t7.done, t7;
              }, e: function(t7) {
                c2 = true, a2 = t7;
              }, f: function() {
                try {
                  s3 || null == r5.return || r5.return();
                } finally {
                  if (c2)
                    throw a2;
                }
              } };
            }(this.$getAllSubdocs());
            try {
              for (r4.s(); !(e4 = r4.n()).done; ) {
                var o2 = e4.value;
                o2.initializeTimestamps && o2.initializeTimestamps();
              }
            } catch (t6) {
              r4.e(t6);
            } finally {
              r4.f();
            }
            return this;
          }, g[l.builtInMiddleware] = true;
          var v = { query: true, model: false };
          t4.pre("findOneAndReplace", v, g), t4.pre("findOneAndUpdate", v, g), t4.pre("replaceOne", v, g), t4.pre("update", v, g), t4.pre("updateOne", v, g), t4.pre("updateMany", v, g);
        }
        function g(t5) {
          var e4 = null != d2 ? d2() : this.model.base.now();
          h2.has(this.op) && null == this.getUpdate() && this.setUpdate({}), s2(e4, n2, p, this.getUpdate(), this._mongooseOptions, h2.has(this.op)), a(e4, this.getUpdate(), this.model.schema), t5();
        }
      };
    }, 8437: (t3, e2, r2) => {
      var n = r2(5857);
      t3.exports = function(t4) {
        if ("TopologyDescription" !== n(t4))
          return false;
        var e3 = Array.from(t4.servers.values());
        return e3.length > 0 && e3.every(function(t5) {
          return "Unknown" === t5.type;
        });
      };
    }, 3343: (t3, e2, r2) => {
      function n(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var i2 = r2(5857);
      t3.exports = function(t4) {
        if ("TopologyDescription" !== i2(t4))
          return false;
        if (0 === t4.servers.size)
          return false;
        var e3, r3 = function(t5, e4) {
          var r4 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (!r4) {
            if (Array.isArray(t5) || (r4 = function(t6, e5) {
              if (t6) {
                if ("string" == typeof t6)
                  return n(t6, e5);
                var r5 = Object.prototype.toString.call(t6).slice(8, -1);
                return "Object" === r5 && t6.constructor && (r5 = t6.constructor.name), "Map" === r5 || "Set" === r5 ? Array.from(t6) : "Arguments" === r5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? n(t6, e5) : void 0;
              }
            }(t5)) || e4 && t5 && "number" == typeof t5.length) {
              r4 && (t5 = r4);
              var i3 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return i3 >= t5.length ? { done: true } : { done: false, value: t5[i3++] };
              }, e: function(t6) {
                throw t6;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var a, s2 = true, c = false;
          return { s: function() {
            r4 = r4.call(t5);
          }, n: function() {
            var t6 = r4.next();
            return s2 = t6.done, t6;
          }, e: function(t6) {
            c = true, a = t6;
          }, f: function() {
            try {
              s2 || null == r4.return || r4.return();
            } finally {
              if (c)
                throw a;
            }
          } };
        }(t4.servers.values());
        try {
          for (r3.s(); !(e3 = r3.n()).done; ) {
            var o = e3.value;
            if (false === o.host.endsWith(".mongodb.net") || 27017 !== o.port)
              return false;
          }
        } catch (t5) {
          r3.e(t5);
        } finally {
          r3.f();
        }
        return true;
      };
    }, 2078: (t3, e2, r2) => {
      var n = r2(5857);
      t3.exports = function(t4) {
        if ("TopologyDescription" !== n(t4))
          return false;
        var e3 = Array.from(t4.servers.values());
        return e3.length > 0 && e3.every(function(t5) {
          return t5.error && -1 !== t5.error.message.indexOf("Client network socket disconnected before secure TLS connection was established");
        });
      };
    }, 4287: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return i2(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i2(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var o = r2(8796), a = r2(2169);
      function s2(t4, e3, r3) {
        if (null != e3) {
          var i3 = Object.keys(e3).some(function(t5) {
            return "$" === t5[0];
          });
          if (i3) {
            if (e3.$push && v(e3.$push), e3.$addToSet && v(e3.$addToSet), null != e3.$set)
              for (var o2 = 0, u = Object.keys(e3.$set); o2 < u.length; o2++) {
                var f = u[o2];
                c(r3, f, e3.$set, t4);
              }
            if (null != e3.$setOnInsert)
              for (var l = 0, h2 = Object.keys(e3.$setOnInsert); l < h2.length; l++) {
                var p = h2[l];
                c(r3, p, e3.$setOnInsert, t4);
              }
          }
          var d2, y2 = Object.keys(e3).filter(function(t5) {
            return "$" !== t5[0];
          }), b = n(y2);
          try {
            for (b.s(); !(d2 = b.n()).done; ) {
              var m2 = d2.value;
              c(r3, m2, e3, t4);
            }
          } catch (t5) {
            b.e(t5);
          } finally {
            b.f();
          }
        }
        function v(e4) {
          for (var n2 = function() {
            var n3 = o3[i4], c2 = r3.path(n3.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
            if (e4[n3] && c2 && c2.$isMongooseDocumentArray && c2.schema.options.timestamps) {
              var u2 = c2.schema.options.timestamps, f2 = a(u2, "createdAt"), l2 = a(u2, "updatedAt");
              e4[n3].$each ? e4[n3].$each.forEach(function(e5) {
                null != l2 && (e5[l2] = t4), null != f2 && (e5[f2] = t4), s2(t4, e5, c2.schema);
              }) : (null != l2 && (e4[n3][l2] = t4), null != f2 && (e4[n3][f2] = t4), s2(t4, e4[n3], c2.schema));
            }
          }, i4 = 0, o3 = Object.keys(e4); i4 < o3.length; i4++)
            n2();
        }
      }
      function c(t4, e3, r3, i3) {
        var c2 = o(e3), u = t4.path(c2);
        if (u) {
          for (var f = [], l = c2.split("."), h2 = l.length - 1; h2 > 0; --h2) {
            var p = t4.path(l.slice(0, h2).join("."));
            null != p && (p.$isMongooseDocumentArray || p.$isSingleNested) && f.push({ parentPath: e3.split(".").slice(0, h2).join("."), parentSchemaType: p });
          }
          if (Array.isArray(r3[e3]) && u.$isMongooseDocumentArray)
            !function(t5, e4, r4) {
              var n2 = e4.schema.options.timestamps, i4 = t5.length;
              if (n2)
                for (var o2 = a(n2, "createdAt"), c3 = a(n2, "updatedAt"), u2 = 0; u2 < i4; ++u2)
                  null != c3 && (t5[u2][c3] = r4), null != o2 && (t5[u2][o2] = r4), s2(r4, t5[u2], e4.schema);
              else
                for (var f2 = 0; f2 < i4; ++f2)
                  s2(r4, t5[f2], e4.schema);
            }(r3[e3], u, i3);
          else if (r3[e3] && u.$isSingleNested)
            !function(t5, e4, r4) {
              var n2 = e4.schema.options.timestamps;
              if (n2) {
                var i4 = a(n2, "createdAt"), o2 = a(n2, "updatedAt");
                null != o2 && (t5[o2] = r4), null != i4 && (t5[i4] = r4), s2(r4, t5, e4.schema);
              } else
                s2(r4, t5, e4.schema);
            }(r3[e3], u, i3);
          else if (f.length > 0) {
            var d2, y2 = n(f);
            try {
              for (y2.s(); !(d2 = y2.n()).done; ) {
                var b = d2.value, m2 = b.parentPath, v = b.parentSchemaType, g = v.schema.options.timestamps, _ = a(g, "updatedAt");
                if (g && null != _) {
                  if (v.$isSingleNested)
                    r3[m2 + "." + _] = i3;
                  else if (v.$isMongooseDocumentArray) {
                    var w2 = e3.substring(m2.length + 1);
                    if (/^\d+$/.test(w2)) {
                      r3[m2 + "." + w2][_] = i3;
                      continue;
                    }
                    var S = w2.indexOf(".");
                    r3[m2 + "." + (w2 = -1 !== S ? w2.substring(0, S) : w2) + "." + _] = i3;
                  }
                }
              }
            } catch (t5) {
              y2.e(t5);
            } finally {
              y2.f();
            }
          } else if (null != u.schema && u.schema != t4 && r3[e3]) {
            var O = u.schema.options.timestamps, j = a(O, "createdAt"), $ = a(O, "updatedAt");
            if (!O)
              return;
            null != $ && (r3[e3][$] = i3), null != j && (r3[e3][j] = i3);
          }
        }
      }
      t3.exports = s2;
    }, 7457: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        var i3;
        return i3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (void 0 !== r4) {
            var i4 = r4.call(t5, "string");
            if ("object" != n(i4))
              return i4;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(e3), (e3 = "symbol" == n(i3) ? i3 : i3 + "") in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var o = r2(5132);
      t3.exports = function(t4, e3, r3, n2, a, s2) {
        var c = n2, u = c, f = o(a, "timestamps", true);
        if (!f || null == c)
          return n2;
        var l = null != f && false === f.createdAt, h2 = null != f && false === f.updatedAt;
        if (s2)
          return n2 && n2.$set && (n2 = n2.$set, c.$set = {}, u = c.$set), h2 || !r3 || n2[r3] || (u[r3] = t4), l || !e3 || n2[e3] || (u[e3] = t4), c;
        if (n2 = n2 || {}, Array.isArray(c))
          return null == r3 || c.push({ $set: i2({}, r3, t4) }), c;
        if (c.$set = c.$set || {}, !h2 && r3 && (!n2.$currentDate || !n2.$currentDate[r3])) {
          var p = false;
          if (-1 !== r3.indexOf("."))
            for (var d2 = r3.split("."), y2 = 1; y2 < d2.length; ++y2) {
              var b = d2.slice(-y2).join("."), m2 = d2.slice(0, -y2).join(".");
              if (null != n2[m2]) {
                n2[m2][b] = t4, p = true;
                break;
              }
              if (n2.$set && n2.$set[m2]) {
                n2.$set[m2][b] = t4, p = true;
                break;
              }
            }
          p || (c.$set[r3] = t4), c.hasOwnProperty(r3) && delete c[r3];
        }
        if (!l && e3) {
          n2[e3] && delete n2[e3], n2.$set && n2.$set[e3] && delete n2.$set[e3];
          var v = false;
          if (-1 !== e3.indexOf("."))
            for (var g = e3.split("."), _ = 1; _ < g.length; ++_) {
              var w2 = g.slice(-_).join("."), S = g.slice(0, -_).join(".");
              if (null != n2[S]) {
                n2[S][w2] = t4, v = true;
                break;
              }
              if (n2.$set && n2.$set[S]) {
                n2.$set[S][w2] = t4, v = true;
                break;
              }
            }
          v || (c.$setOnInsert = c.$setOnInsert || {}, c.$setOnInsert[e3] = t4);
        }
        return 0 === Object.keys(c.$set).length && delete c.$set, c;
      };
    }, 641: (t3, e2, r2) => {
      var n = r2(4494).ctor("require", "modify", "init", "default", "ignore");
      function i2() {
        this.activePaths = new n();
      }
      t3.exports = i2, i2.prototype.strictMode = true, i2.prototype.fullPath = void 0, i2.prototype.selected = void 0, i2.prototype.shardval = void 0, i2.prototype.saveError = void 0, i2.prototype.validationError = void 0, i2.prototype.adhocPaths = void 0, i2.prototype.removing = void 0, i2.prototype.inserting = void 0, i2.prototype.saving = void 0, i2.prototype.version = void 0, i2.prototype._id = void 0, i2.prototype.ownerDocument = void 0, i2.prototype.populate = void 0, i2.prototype.populated = void 0, i2.prototype.primitiveAtomics = void 0, i2.prototype.wasPopulated = false, i2.prototype.scope = void 0, i2.prototype.session = null, i2.prototype.pathsToScopes = null, i2.prototype.cachedRequired = null;
    }, 3920: (t3, e2) => {
      e2._ = { transform: false, virtuals: false, getters: false, _skipDepopulateTopLevel: true, depopulate: true, flattenDecimals: false, useProjection: false, versionKey: true };
    }, 6591: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, a(n2.key), n2);
        }
      }
      function o(t4, e3, r3) {
        return e3 && i2(t4.prototype, e3), r3 && i2(t4, r3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function a(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      var s2 = r2(1829), c = o(function t4(e3) {
        if (function(t5, e4) {
          if (!(t5 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t4), this._docs = {}, this._childDocs = [], null != e3 && (e3 = s2(e3), Object.assign(this, e3), "object" === n(e3.subPopulate) && (this.populate = e3.subPopulate), null != e3.perDocumentLimit && null != e3.limit))
          throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + e3.path + "`.");
      });
      t3.exports = c;
    }, 1918: (t3) => {
      t3.exports = Object.freeze({ enumerable: true, configurable: true, writable: true, value: void 0 });
    }, 2685: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "enum", u), Object.defineProperty(c.prototype, "of", u), Object.defineProperty(c.prototype, "castNonArrays", u), t3.exports = c;
    }, 3958: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "subtype", u), t3.exports = c;
    }, 7236: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "min", u), Object.defineProperty(c.prototype, "max", u), Object.defineProperty(c.prototype, "expires", u), t3.exports = c;
    }, 4172: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "excludeIndexes", u), Object.defineProperty(c.prototype, "_id", u), t3.exports = c;
    }, 7488: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "of", u), t3.exports = c;
    }, 3823: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "min", u), Object.defineProperty(c.prototype, "max", u), Object.defineProperty(c.prototype, "enum", u), Object.defineProperty(c.prototype, "populate", u), t3.exports = c;
    }, 210: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "auto", u), Object.defineProperty(c.prototype, "populate", u), t3.exports = c;
    }, 8035: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "enum", u), Object.defineProperty(c.prototype, "match", u), Object.defineProperty(c.prototype, "lowercase", u), Object.defineProperty(c.prototype, "trim", u), Object.defineProperty(c.prototype, "uppercase", u), Object.defineProperty(c.prototype, "minLength", u), Object.defineProperty(c.prototype, "minlength", u), Object.defineProperty(c.prototype, "maxLength", u), Object.defineProperty(c.prototype, "maxlength", u), Object.defineProperty(c.prototype, "populate", u), t3.exports = c;
    }, 6271: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 = a(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, o() ? Reflect.construct(e3, r3 || [], a(t4).constructor) : e3.apply(t4, r3));
      }
      function o() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (o = function() {
          return !!t4;
        })();
      }
      function a(t4) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, a(t4);
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      var c = function(t4) {
        function e3() {
          return function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), i2(this, e3, arguments);
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && s2(t5, e4);
        }(e3, t4), r3 = e3, Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3;
      }(r2(1e3)), u = r2(1918);
      Object.defineProperty(c.prototype, "_id", u), t3.exports = c;
    }, 1e3: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, a(n2.key), n2);
        }
      }
      function o(t4, e3, r3) {
        return e3 && i2(t4.prototype, e3), r3 && i2(t4, r3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function a(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      var s2 = r2(1829), c = o(function t4(e3) {
        if (function(t5, e4) {
          if (!(t5 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t4), null == e3)
          return this;
        Object.assign(this, s2(e3));
      }), u = r2(1918);
      Object.defineProperty(c.prototype, "type", u), Object.defineProperty(c.prototype, "validate", u), Object.defineProperty(c.prototype, "cast", u), Object.defineProperty(c.prototype, "required", u), Object.defineProperty(c.prototype, "default", u), Object.defineProperty(c.prototype, "ref", u), Object.defineProperty(c.prototype, "refPath", u), Object.defineProperty(c.prototype, "select", u), Object.defineProperty(c.prototype, "index", u), Object.defineProperty(c.prototype, "unique", u), Object.defineProperty(c.prototype, "immutable", u), Object.defineProperty(c.prototype, "sparse", u), Object.defineProperty(c.prototype, "text", u), Object.defineProperty(c.prototype, "transform", u), t3.exports = c;
    }, 384: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, a(n2.key), n2);
        }
      }
      function o(t4, e3, r3) {
        return e3 && i2(t4.prototype, e3), r3 && i2(t4, r3), Object.defineProperty(t4, "prototype", { writable: false }), t4;
      }
      function a(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      var s2 = r2(1918), c = o(function t4(e3) {
        !function(t5, e4) {
          if (!(t5 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t4), Object.assign(this, e3), null != e3 && null != e3.options && (this.options = Object.assign({}, e3.options));
      });
      Object.defineProperty(c.prototype, "ref", s2), Object.defineProperty(c.prototype, "refPath", s2), Object.defineProperty(c.prototype, "localField", s2), Object.defineProperty(c.prototype, "foreignField", s2), Object.defineProperty(c.prototype, "justOne", s2), Object.defineProperty(c.prototype, "count", s2), Object.defineProperty(c.prototype, "match", s2), Object.defineProperty(c.prototype, "options", s2), Object.defineProperty(c.prototype, "skip", s2), Object.defineProperty(c.prototype, "limit", s2), Object.defineProperty(c.prototype, "perDocumentLimit", s2), t3.exports = c;
    }, 7509: (t3, e2, r2) => {
      e2.saveSubdocs = r2(4679), e2.sharding = r2(7201), e2.trackTransaction = r2(2016), e2.validateBeforeSave = r2(377);
    }, 4679: (t3, e2, r2) => {
      var n = r2(6343);
      t3.exports = function(t4) {
        var e3 = true;
        t4.s.hooks.pre("save", false, function(t5) {
          if (this.$isSubdocument)
            t5();
          else {
            var e4 = this, r3 = this.$getAllSubdocs();
            r3.length ? n(r3, function(t6, e5) {
              t6.$__schema.s.hooks.execPre("save", t6, function(t7) {
                e5(t7);
              });
            }, function(r4) {
              if (r4)
                return e4.$__schema.s.hooks.execPost("save:error", e4, [e4], { error: r4 }, function(e5) {
                  t5(e5);
                });
              t5();
            }) : t5();
          }
        }, null, e3), t4.s.hooks.post("save", function(t5, e4) {
          if (this.$isSubdocument)
            e4();
          else {
            var r3 = this, i2 = this.$getAllSubdocs();
            i2.length ? n(i2, function(t6, e5) {
              t6.$__schema.s.hooks.execPost("save", t6, [t6], function(t7) {
                e5(t7);
              });
            }, function(t6) {
              if (t6)
                return r3.$__schema.s.hooks.execPost("save:error", r3, [r3], { error: t6 }, function(t7) {
                  e4(t7);
                });
              e4();
            }) : e4();
          }
        }, null, e3);
      };
    }, 7201: (t3, e2, r2) => {
      var n = r2(5625).objectIdSymbol, i2 = r2(335);
      function o() {
        var t4, e3;
        if (this.$__.shardval) {
          e3 = (t4 = Object.keys(this.$__.shardval)).length, this.$where = this.$where || {};
          for (var r3 = 0; r3 < e3; ++r3)
            this.$where[t4[r3]] = this.$__.shardval[t4[r3]];
        }
      }
      function a() {
        var t4 = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
        if (i2.isPOJO(t4))
          for (var e3, r3 = this.$__.shardval = {}, o2 = Object.keys(t4), a2 = o2.length, s2 = 0; s2 < a2; ++s2)
            null == (e3 = this.$__getValue(o2[s2])) ? r3[o2[s2]] = e3 : i2.isMongooseObject(e3) ? r3[o2[s2]] = e3.toObject({ depopulate: true, _isNested: true }) : e3 instanceof Date || e3[n] ? r3[o2[s2]] = e3 : "function" == typeof e3.valueOf ? r3[o2[s2]] = e3.valueOf() : r3[o2[s2]] = e3;
      }
      t3.exports = function(t4) {
        t4.post("init", function() {
          return a.call(this), this;
        }), t4.pre("save", function(t5) {
          o.call(this), t5();
        }), t4.pre("remove", function(t5) {
          o.call(this), t5();
        }), t4.post("save", function() {
          a.call(this);
        });
      }, t3.exports.storeShard = a;
    }, 2016: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = i2(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function i2(t4, e3) {
        if (t4) {
          if ("string" == typeof t4)
            return o(t4, e3);
          var r3 = Object.prototype.toString.call(t4).slice(8, -1);
          return "Object" === r3 && t4.constructor && (r3 = t4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? o(t4, e3) : void 0;
        }
      }
      function o(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var a = r2(5625).arrayAtomicsSymbol, s2 = r2(5625).sessionNewDocuments, c = r2(335);
      function u(t4, e3) {
        var r3 = /* @__PURE__ */ new Map();
        e3 = e3 || /* @__PURE__ */ new Map();
        var i3, o2 = n(Object.keys(t4.$__.activePaths.init).concat(Object.keys(t4.$__.activePaths.modify)));
        try {
          for (o2.s(); !(i3 = o2.n()).done; ) {
            var s3 = i3.value, u2 = t4.$__getValue(s3);
            if (null != u2 && Array.isArray(u2) && c.isMongooseDocumentArray(u2) && u2.length && null != u2[a] && 0 !== Object.keys(u2[a]).length) {
              var l = e3.get(s3) || {};
              r3.set(s3, f(l, u2[a]));
            }
          }
        } catch (t5) {
          o2.e(t5);
        } finally {
          o2.f();
        }
        var h2, p = n(t4.$__dirty());
        try {
          for (p.s(); !(h2 = p.n()).done; ) {
            var d2 = h2.value, y2 = d2.path, b = d2.value;
            if (null != b && null != b[a] && 0 !== Object.keys(b[a]).length) {
              var m2 = e3.get(y2) || {};
              r3.set(y2, f(m2, b[a]));
            }
          }
        } catch (t5) {
          p.e(t5);
        } finally {
          p.f();
        }
        return r3;
      }
      function f(t4, e3) {
        return t4 = t4 || {}, null != e3.$pullAll && (t4.$pullAll = (t4.$pullAll || []).concat(e3.$pullAll)), null != e3.$push && (t4.$push = t4.$push || {}, t4.$push.$each = (t4.$push.$each || []).concat(e3.$push.$each)), null != e3.$addToSet && (t4.$addToSet = (t4.$addToSet || []).concat(e3.$addToSet)), null != e3.$set && (t4.$set = Array.isArray(e3.$set) ? function(t5) {
          if (Array.isArray(t5))
            return o(t5);
        }(r3 = e3.$set) || function(t5) {
          if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
            return Array.from(t5);
        }(r3) || i2(r3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }() : Object.assign({}, e3.$set)), t4;
        var r3;
      }
      t3.exports = function(t4) {
        t4.pre("save", function() {
          var t5 = this.$session();
          if (null != t5 && null != t5.transaction && null != t5[s2])
            if (t5[s2].has(this)) {
              for (var e3 = t5[s2].get(this), r3 = 0, n2 = Object.keys(this.$__.activePaths.getStatePaths("modify")); r3 < n2.length; r3++) {
                var i3 = n2[r3];
                e3.modifiedPaths.add(i3);
              }
              e3.atomics = u(this, e3.atomics);
            } else {
              var o2 = {};
              this.isNew && (o2.isNew = true), this.$__schema.options.versionKey && (o2.versionKey = this.get(this.$__schema.options.versionKey)), o2.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify"))), o2.atomics = u(this), t5[s2].set(this, o2);
            }
        });
      };
    }, 377: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        t4.pre("save", false, function(t5, r2) {
          var n = this, i2 = this;
          if (this.$isSubdocument)
            return t5();
          if (r2 && "object" === e2(r2) && "validateBeforeSave" in r2 ? r2.validateBeforeSave : this.$__schema.options.validateBeforeSave) {
            var o = r2 && "object" === e2(r2) && "validateModifiedOnly" in r2 ? { validateModifiedOnly: r2.validateModifiedOnly } : null;
            this.$validate(o).then(function() {
              n.$op = "save", t5();
            }, function(e3) {
              i2.$__schema.s.hooks.execPost("save:error", i2, [i2], { error: e3 }, function(e4) {
                i2.$op = "save", t5(e4);
              });
            });
          } else
            t5();
        }, null, true);
      };
    }, 2205: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return o(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function o(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var a = r2(967), s2 = r2(5132), c = r2(7785), u = r2(6239), f = r2(1829), l = r2(5772);
      function h2(t4) {
        return function(e3) {
          e3.options || (e3.options = {}), null != t4 && Array.isArray(t4.virtuals) && ((t4 = Object.assign({}, t4)).virtuals = t4.virtuals.filter(function(t5) {
            return "string" == typeof t5 && t5.startsWith(e3.path + ".");
          }).map(function(t5) {
            return t5.slice(e3.path.length + 1);
          })), e3.options.lean = t4;
        };
      }
      e2.preparePopulationOptions = function(t4, e3) {
        var r3 = t4.options.populate, n2 = Object.keys(r3).reduce(function(t5, e4) {
          return t5.concat([r3[e4]]);
        }, []);
        return null != e3.lean && n2.filter(function(t5) {
          return null == (t5 && t5.options && t5.options.lean);
        }).forEach(h2(e3.lean)), n2.forEach(function(e4) {
          e4._localModel = t4.model;
        }), n2;
      }, e2.preparePopulationOptionsMQ = function(t4, e3) {
        var r3 = t4._mongooseOptions.populate, n2 = Object.keys(r3).reduce(function(t5, e4) {
          return t5.concat([r3[e4]]);
        }, []);
        null != e3.lean && n2.filter(function(t5) {
          return null == (t5 && t5.options && t5.options.lean);
        }).forEach(h2(e3.lean));
        var i3 = t4 && t4.options && t4.options.session || null;
        null != i3 && n2.forEach(function(t5) {
          null != t5.options ? "session" in t5.options || (t5.options.session = i3) : t5.options = { session: i3 };
        });
        var o2 = t4._fieldsForExec();
        return n2.forEach(function(t5) {
          t5._queryProjection = o2;
        }), n2.forEach(function(e4) {
          e4._localModel = t4.model;
        }), n2;
      }, e2.createModel = function(t4, r3, n2, i3, o2) {
        t4.hooks.execPreSync("createModel", r3);
        var a2 = t4.schema ? t4.schema.discriminatorMapping : null, s3 = a2 && a2.isRoot ? a2.key : null, u2 = r3[s3];
        if (s3 && u2 && t4.discriminators) {
          var l2 = t4.discriminators[u2] || c(t4.discriminators, u2);
          if (l2) {
            var h3 = f(i3);
            return e2.applyPaths(h3, l2.schema), new l2(void 0, h3, true);
          }
        }
        var p = { skipId: true, isNew: false, willInit: true };
        return null != o2 && "defaults" in o2 && (p.defaults = o2.defaults), new t4(void 0, n2, p);
      }, e2.createModelAndInit = function(t4, r3, n2, i3, o2, a2, s3) {
        var c2 = a2 ? { populated: a2 } : void 0, u2 = e2.createModel(t4, r3, n2, i3, o2);
        try {
          u2.$init(r3, c2, s3);
        } catch (t5) {
          s3(t5, u2);
        }
      }, e2.applyPaths = function(t4, e3) {
        var r3, o2, c2 = /* @__PURE__ */ new Set();
        if (t4) {
          o2 = Object.keys(t4);
          for (var f2 = [], h3 = 0; h3 < o2.length; ++h3) {
            var p = o2[h3];
            "-" === o2[h3][0] && (delete t4[p], "-_id" === p ? t4._id = 0 : f2.push(p.slice(1)));
          }
          o2 = Object.keys(t4);
          for (var d2 = 0; d2 < o2.length; ++d2)
            if ("+" !== o2[d2][0]) {
              var y2 = t4[o2[d2]];
              if (u(y2) && !("_id" === o2[d2] && o2.length > 1) && (!(o2[d2] === e3.options.discriminatorKey && o2.length > 1 && null != y2) || y2)) {
                r3 = !y2;
                break;
              }
            }
          for (var b = 0, m2 = f2; b < m2.length; b++) {
            var v = m2[b], g = e3.path(v);
            g && g.selected && false === r3 ? g && g.selected && false === r3 && c2.add(v) : (t4[v] = 0, r3 = true);
          }
        }
        var _ = [], w2 = [], S = [];
        switch (function e4(n2, i3) {
          if (i3 || (i3 = ""), -1 !== S.indexOf(n2))
            return [];
          S.push(n2);
          var o3 = [];
          return n2.eachPath(function(n3, s3) {
            if (i3 && (n3 = i3 + "." + n3), s3.$isSchemaMap || n3.endsWith(".$*")) {
              var c3 = t4 && "+" + n3 in t4;
              s3.options && false === s3.options.select && !c3 && w2.push(n3);
            } else {
              var u2 = R(n3, s3);
              if (null != u2 || Array.isArray(s3) || !s3.$isMongooseArray || s3.$isMongooseDocumentArray || (u2 = R(n3, s3.caster)), null != u2 && o3.push(u2), s3.schema) {
                var f3 = e4(s3.schema, n3);
                false === r3 && a(t4, n3, s3.schema, _, f3);
              }
            }
          }), S.pop(), o3;
        }(e3), r3) {
          case true:
            var O, j = i2(w2);
            try {
              for (j.s(); !(O = j.n()).done; ) {
                var $ = O.value;
                t4[$] = 0;
              }
            } catch (t5) {
              j.e(t5);
            } finally {
              j.f();
            }
            break;
          case false:
            e3 && e3.paths._id && e3.paths._id.options && false === e3.paths._id.options.select && (t4._id = 0);
            var A, E = i2(_);
            try {
              for (E.s(); !(A = E.n()).done; ) {
                var x = A.value;
                c2.has(x) || l(t4, x) || (t4[x] = t4[x] || 1);
              }
            } catch (t5) {
              E.e(t5);
            } finally {
              E.f();
            }
            break;
          case void 0:
            if (null == t4)
              break;
            for (var P = 0, k = Object.keys(t4 || {}); P < k.length; P++) {
              var M = k[P];
              M.startsWith("+") && delete t4[M];
            }
            var I, B = i2(w2);
            try {
              for (B.s(); !(I = B.n()).done; ) {
                var T = I.value;
                null == t4[T] && (t4[T] = 0);
              }
            } catch (t5) {
              B.e(t5);
            } finally {
              B.f();
            }
        }
        function R(i3, a2) {
          if (null != t4 && "boolean" == typeof a2.selected && (false !== a2.selected || !t4[i3]))
            if (r3 || !a2.selected || i3 !== e3.options.discriminatorKey || null == t4[i3] || t4[i3]) {
              if (false !== r3 || !a2.selected || null == t4[i3] || t4[i3]) {
                var c3 = "+" + i3;
                if (t4 && c3 in t4)
                  return delete t4[c3], void (false === r3 && o2.length > 1 && !~o2.indexOf(i3) && (t4[i3] = 1));
                for (var u2 = i3.split("."), f3 = "", l2 = 0; l2 < u2.length; ++l2)
                  if (f3 += f3.length ? "." + u2[l2] : u2[l2], -1 !== w2.indexOf(f3))
                    return;
                if (!r3 && a2 && a2.options && a2.options.$skipDiscriminatorCheck)
                  for (var h4 = "", p2 = 0; p2 < u2.length; ++p2) {
                    h4 += (0 === h4.length ? "" : ".") + u2[p2];
                    var d3 = s2(t4, h4, false) || s2(t4, h4 + ".$", false);
                    if (d3 && "object" !== n(d3))
                      return;
                  }
                return (a2.selected ? _ : w2).push(i3), i3;
              }
              delete t4[i3];
            } else
              delete t4[i3];
        }
      };
    }, 9703: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            a(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function a(t4, e3, r3) {
        var n2;
        return n2 = function(t5, e4) {
          if ("object" != s2(t5) || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (void 0 !== r4) {
            var n3 = r4.call(t5, "string");
            if ("object" != s2(n3))
              return n3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(e3), (e3 = "symbol" == s2(n2) ? n2 : n2 + "") in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s2(t4) {
        return s2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, s2(t4);
      }
      function c(t4, e3) {
        return function(t5) {
          if (Array.isArray(t5))
            return t5;
        }(t4) || function(t5, e4) {
          var r3 = null == t5 ? null : "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (null != r3) {
            var n2, i3, o2, a2, s3 = [], c2 = true, u2 = false;
            try {
              if (o2 = (r3 = r3.call(t5)).next, 0 === e4) {
                if (Object(r3) !== r3)
                  return;
                c2 = false;
              } else
                for (; !(c2 = (n2 = o2.call(r3)).done) && (s3.push(n2.value), s3.length !== e4); c2 = true)
                  ;
            } catch (t6) {
              u2 = true, i3 = t6;
            } finally {
              try {
                if (!c2 && null != r3.return && (a2 = r3.return(), Object(a2) !== a2))
                  return;
              } finally {
                if (u2)
                  throw i3;
              }
            }
            return s3;
          }
        }(t4, e3) || f(t4, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function u(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = f(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o2, a2 = true, s3 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return a2 = t5.done, t5;
        }, e: function(t5) {
          s3 = true, o2 = t5;
        }, f: function() {
          try {
            a2 || null == r3.return || r3.return();
          } finally {
            if (s3)
              throw o2;
          }
        } };
      }
      function f(t4, e3) {
        if (t4) {
          if ("string" == typeof t4)
            return l(t4, e3);
          var r3 = Object.prototype.toString.call(t4).slice(8, -1);
          return "Object" === r3 && t4.constructor && (r3 = t4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? l(t4, e3) : void 0;
        }
      }
      function l(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var h2, p = r2(3550).EventEmitter, d2 = r2(8297), y2 = r2(7026), b = r2(2319), m2 = r2(1e3), v = r2(384), g = r2(5165), _ = r2(8331), w2 = r2(1829), S = r2(5132), O = r2(5857), j = r2(5792), $ = r2(6482), A = r2(8638), E = r2(5682), x = r2(5678), P = r2(5877), k = r2(8644), M = r2(335), I = r2(6560), B = r2(7352), T = /\.\d+(\.|$)/, R = r2(991).U, N = r2(8892).middlewareFunctions, D = R.concat(N).reduce(function(t4, e3) {
        return t4.add(e3);
      }, /* @__PURE__ */ new Set()), L = M.isPOJO, U = 0, C = /^\d+$/;
      function q(t4, e3) {
        if (!(this instanceof q))
          return new q(t4, e3);
        if (this.obj = t4, this.paths = {}, this.aliases = {}, this.subpaths = {}, this.virtuals = {}, this.singleNestedPaths = {}, this.nested = {}, this.inherits = {}, this.callQueue = [], this._indexes = [], this._searchIndexes = [], this.methods = e3 && e3.methods || {}, this.methodOptions = {}, this.statics = e3 && e3.statics || {}, this.tree = {}, this.query = e3 && e3.query || {}, this.childSchemas = [], this.plugins = [], this.$id = ++U, this.mapPaths = [], this.s = { hooks: new d2() }, this.options = this.defaultOptions(e3), Array.isArray(t4)) {
          var r3, n2 = u(t4);
          try {
            for (n2.s(); !(r3 = n2.n()).done; ) {
              var i3 = r3.value;
              this.add(i3);
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        } else
          t4 && this.add(t4);
        if (e3 && e3.virtuals)
          for (var o2 = e3.virtuals, a2 = 0, s3 = Object.keys(o2); a2 < s3.length; a2++) {
            var c2 = s3[a2], f2 = o2[c2].options ? o2[c2].options : void 0, l2 = this.virtual(c2, f2);
            o2[c2].get && l2.get(o2[c2].get), o2[c2].set && l2.set(o2[c2].set);
          }
        var h3 = t4 && t4._id && M.isObject(t4._id);
        !this.paths._id && this.options._id && !h3 && _(this), this.setupTimestamp(this.options.timestamps);
      }
      function F(t4, e3) {
        for (var r3 = 0, n2 = Object.keys(e3); r3 < n2.length; r3++) {
          var i3 = n2[r3], o2 = null;
          if (null != e3[i3])
            o2 = e3[i3];
          else {
            var a2 = S(t4.paths[i3], "options");
            if (null == a2)
              continue;
            o2 = a2.alias;
          }
          if (o2) {
            var s3 = t4.paths[i3].path;
            if (Array.isArray(o2)) {
              var c2, f2 = u(o2);
              try {
                for (f2.s(); !(c2 = f2.n()).done; ) {
                  var l2 = c2.value;
                  if ("string" != typeof l2)
                    throw new Error("Invalid value for alias option on " + s3 + ", got " + l2);
                  t4.aliases[l2] = s3, t4.virtual(l2).get(/* @__PURE__ */ function(t5) {
                    return function() {
                      return "function" == typeof this.get ? this.get(t5) : this[t5];
                    };
                  }(s3)).set(/* @__PURE__ */ function(t5) {
                    return function(e4) {
                      return this.$set(t5, e4);
                    };
                  }(s3));
                }
              } catch (t5) {
                f2.e(t5);
              } finally {
                f2.f();
              }
            } else {
              if ("string" != typeof o2)
                throw new Error("Invalid value for alias option on " + s3 + ", got " + o2);
              t4.aliases[o2] = s3, t4.virtual(o2).get(/* @__PURE__ */ function(t5) {
                return function() {
                  return "function" == typeof this.get ? this.get(t5) : this[t5];
                };
              }(s3)).set(/* @__PURE__ */ function(t5) {
                return function(e4) {
                  return this.$set(t5, e4);
                };
              }(s3));
            }
          }
        }
      }
      q.prototype = Object.create(p.prototype), q.prototype.constructor = q, q.prototype.instanceOfSchema = true, Object.defineProperty(q.prototype, "$schemaType", { configurable: false, enumerable: false, writable: true }), Object.defineProperty(q.prototype, "childSchemas", { configurable: false, enumerable: true, writable: true }), Object.defineProperty(q.prototype, "virtuals", { configurable: false, enumerable: true, writable: true }), q.prototype.obj, q.prototype.paths, q.prototype.tree, q.prototype.clone = function() {
        var t4 = this, e3 = this._clone();
        return e3.on("init", function(e4) {
          return t4.emit("init", e4);
        }), e3;
      }, q.prototype._clone = function(t4) {
        var e3 = new (t4 = t4 || (null == this.base ? q : this.base.Schema))({}, this._userProvidedOptions);
        e3.base = this.base, e3.obj = this.obj, e3.options = w2(this.options), e3.callQueue = this.callQueue.map(function(t5) {
          return t5;
        }), e3.methods = w2(this.methods), e3.methodOptions = w2(this.methodOptions), e3.statics = w2(this.statics), e3.query = w2(this.query), e3.plugins = Array.prototype.slice.call(this.plugins), e3._indexes = w2(this._indexes), e3._searchIndexes = w2(this._searchIndexes), e3.s.hooks = this.s.hooks.clone(), e3.tree = w2(this.tree), e3.paths = Object.fromEntries(Object.entries(this.paths).map(function(t5) {
          var e4 = c(t5, 2);
          return [e4[0], e4[1].clone()];
        })), e3.nested = w2(this.nested), e3.subpaths = w2(this.subpaths);
        for (var r3 = 0, n2 = Object.values(e3.paths); r3 < n2.length; r3++) {
          var i3 = n2[r3];
          if (i3.$isSingleNested) {
            for (var o2 = i3.path, a2 = 0, s3 = Object.keys(i3.schema.paths); a2 < s3.length; a2++) {
              var u2 = s3[a2];
              e3.singleNestedPaths[o2 + "." + u2] = i3.schema.paths[u2];
            }
            for (var f2 = 0, l2 = Object.keys(i3.schema.singleNestedPaths); f2 < l2.length; f2++) {
              var h3 = l2[f2];
              e3.singleNestedPaths[o2 + "." + h3] = i3.schema.singleNestedPaths[h3];
            }
            for (var p2 = 0, d3 = Object.keys(i3.schema.subpaths); p2 < d3.length; p2++) {
              var y3 = d3[p2];
              e3.singleNestedPaths[o2 + "." + y3] = i3.schema.subpaths[y3];
            }
            for (var b2 = 0, m3 = Object.keys(i3.schema.nested); b2 < m3.length; b2++) {
              var v2 = m3[b2];
              e3.singleNestedPaths[o2 + "." + v2] = "nested";
            }
          }
        }
        return e3.childSchemas = function(t5) {
          for (var e4 = [], r4 = 0, n3 = Object.keys(t5.paths); r4 < n3.length; r4++) {
            var i4 = n3[r4], o3 = t5.paths[i4];
            (o3.$isMongooseDocumentArray || o3.$isSingleNested) && e4.push({ schema: o3.schema, model: o3.caster });
          }
          return e4;
        }(e3), e3.virtuals = w2(this.virtuals), e3.$globalPluginsApplied = this.$globalPluginsApplied, e3.$isRootDiscriminator = this.$isRootDiscriminator, e3.$implicitlyCreated = this.$implicitlyCreated, e3.$id = ++U, e3.$originalSchemaId = this.$id, e3.mapPaths = [].concat(this.mapPaths), null != this.discriminatorMapping && (e3.discriminatorMapping = Object.assign({}, this.discriminatorMapping)), null != this.discriminators && (e3.discriminators = Object.assign({}, this.discriminators)), null != this._applyDiscriminators && (e3._applyDiscriminators = new Map(this._applyDiscriminators)), e3.aliases = Object.assign({}, this.aliases), e3;
      }, q.prototype.pick = function(t4, e3) {
        var r3 = new q({}, e3 || this.options);
        if (!Array.isArray(t4))
          throw new y2('Schema#pick() only accepts an array argument, got "' + s2(t4) + '"');
        var n2, i3 = u(t4);
        try {
          for (i3.s(); !(n2 = i3.n()).done; ) {
            var o2 = n2.value;
            if (this.nested[o2])
              r3.add(a({}, o2, S(this.tree, o2)));
            else {
              var c2 = this.path(o2);
              if (null == c2)
                throw new y2("Path `" + o2 + "` is not in the schema");
              r3.add(a({}, o2, c2));
            }
          }
        } catch (t5) {
          i3.e(t5);
        } finally {
          i3.f();
        }
        return r3;
      }, q.prototype.omit = function(t4, e3) {
        var r3 = new q(this, e3 || this.options);
        if (!Array.isArray(t4))
          throw new y2('Schema#omit() only accepts an array argument, got "' + s2(t4) + '"');
        for (var n2 in r3.remove(t4), r3.singleNestedPaths)
          t4.includes(n2) && delete r3.singleNestedPaths[n2];
        return r3;
      }, q.prototype.defaultOptions = function(t4) {
        this._userProvidedOptions = null == t4 ? {} : w2(t4);
        var e3 = this.base && this.base.options || {};
        if ((t4 = o({ strict: !("strict" in e3) || e3.strict, strictQuery: "strictQuery" in e3 && e3.strictQuery, bufferCommands: true, capped: false, versionKey: "__v", optimisticConcurrency: false, minimize: true, autoIndex: null, discriminatorKey: "__t", shardKey: null, read: null, validateBeforeSave: true, validateModifiedOnly: false, _id: true, id: !("id" in e3) || e3.id, typeKey: "type" }, t4)).versionKey && "string" != typeof t4.versionKey)
          throw new y2("`versionKey` must be falsy or string, got `" + s2(t4.versionKey) + "`");
        if ("string" == typeof t4.read ? t4.read = $(t4.read) : Array.isArray(t4.read) && "string" == typeof t4.read[0] && (t4.read = { mode: $(t4.read[0]), tags: t4.read[1] }), t4.optimisticConcurrency && !t4.versionKey)
          throw new y2("Must set `versionKey` if using `optimisticConcurrency`");
        return t4;
      }, q.prototype.discriminator = function(t4, e3, r3) {
        return this._applyDiscriminators = this._applyDiscriminators || /* @__PURE__ */ new Map(), this._applyDiscriminators.set(t4, { schema: e3, options: r3 }), this;
      }, q.prototype.add = function(t4, e3) {
        if (t4 instanceof q || null != t4 && t4.instanceOfSchema)
          return E(this, t4), this;
        if (false === t4._id && null == e3 && (this.options._id = false), "__proto__." === (e3 = e3 || "") || "constructor." === e3 || "prototype." === e3)
          return this;
        for (var r3 = Object.keys(t4), n2 = this.options.typeKey, i3 = 0, o2 = r3; i3 < o2.length; i3++) {
          var u2 = o2[i3];
          if (!M.specialProperties.has(u2)) {
            var f2 = e3 + u2, l2 = t4[u2];
            if (null == l2)
              throw new TypeError("Invalid value for schema path `" + f2 + '`, got value "' + l2 + '"');
            if ("_id" !== u2 || false !== l2) {
              var h3 = false;
              if ("string" == typeof l2 && (h3 = null != (null != this.base ? this.base.Schema.Types : q.Types)[l2.charAt(0).toUpperCase() + l2.substring(1)]), "_id" !== u2 && ("object" !== s2(l2) && "function" != typeof l2 && !h3 || null == l2))
                throw new TypeError("Invalid schema configuration: `".concat(l2, "` is not ") + "a valid type at path `".concat(u2, "`. See ") + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
              if (l2 instanceof g || "VirtualType" === (l2.constructor && l2.constructor.name || null))
                this.virtual(l2);
              else {
                if (Array.isArray(l2) && 1 === l2.length && null == l2[0])
                  throw new TypeError("Invalid value for schema Array path `" + f2 + '`, got value "' + l2[0] + '"');
                if (L(l2) || l2 instanceof m2)
                  if (Object.keys(l2).length < 1)
                    e3 && (this.nested[e3.substring(0, e3.length - 1)] = true), this.path(f2, l2);
                  else if (!l2[n2] || "type" === n2 && L(l2.type) && l2.type.type)
                    this.nested[f2] = true, this.add(l2, f2 + ".");
                  else {
                    var p2 = l2[n2];
                    if (L(p2) && Object.keys(p2).length > 0) {
                      e3 && (this.nested[e3.substring(0, e3.length - 1)] = true);
                      var d3 = {};
                      this._userProvidedOptions.typeKey && (d3.typeKey = this._userProvidedOptions.typeKey), null != this._userProvidedOptions.strict && (d3.strict = this._userProvidedOptions.strict), null != this._userProvidedOptions.toObject && (d3.toObject = M.omit(this._userProvidedOptions.toObject, ["transform"])), null != this._userProvidedOptions.toJSON && (d3.toJSON = M.omit(this._userProvidedOptions.toJSON, ["transform"]));
                      var y3 = new q(p2, d3);
                      y3.$implicitlyCreated = true;
                      var b2 = Object.assign({}, l2, a({}, n2, y3));
                      this.path(e3 + u2, b2);
                    } else if (e3 && (this.nested[e3.substring(0, e3.length - 1)] = true), this.path(e3 + u2, l2), null != l2 && !l2.instanceOfSchema && M.isPOJO(l2.discriminators)) {
                      var v2 = this.path(e3 + u2);
                      for (var _2 in l2.discriminators)
                        v2.discriminator(_2, l2.discriminators[_2]);
                    }
                  }
                else if (e3 && (this.nested[e3.substring(0, e3.length - 1)] = true), this.path(e3 + u2, l2), null != l2[0] && !l2[0].instanceOfSchema && M.isPOJO(l2[0].discriminators)) {
                  var w3 = this.path(e3 + u2);
                  for (var S2 in l2[0].discriminators)
                    w3.discriminator(S2, l2[0].discriminators[S2]);
                }
              }
            }
          }
        }
        var O2 = Object.fromEntries(Object.entries(t4).map(function(t5) {
          var r4 = c(t5, 1)[0];
          return [e3 + r4, null];
        }));
        return F(this, O2), this;
      }, q.prototype.alias = function(t4, e3) {
        return F(this, a({}, t4, e3)), this;
      }, q.prototype.removeIndex = function(t4) {
        if (arguments.length > 1)
          throw new Error("removeIndex() takes only 1 argument");
        if ("object" !== s2(t4) && "string" != typeof t4)
          throw new Error("removeIndex() may only take either an object or a string as an argument");
        if ("object" === s2(t4))
          for (var e3 = this._indexes.length - 1; e3 >= 0; --e3)
            B.isDeepStrictEqual(this._indexes[e3][0], t4) && this._indexes.splice(e3, 1);
        else
          for (var r3 = this._indexes.length - 1; r3 >= 0; --r3)
            null != this._indexes[r3][1] && this._indexes[r3][1].name === t4 && this._indexes.splice(r3, 1);
        return this;
      }, q.prototype.clearIndexes = function() {
        return this._indexes.length = 0, this;
      }, q.prototype.searchIndex = function(t4) {
        return this._searchIndexes.push(t4), this;
      }, q.reserved = /* @__PURE__ */ Object.create(null), q.prototype.reserved = q.reserved;
      var V = q.reserved;
      function z(t4) {
        return /\.\d+/.test(t4) ? t4.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$") : t4;
      }
      function K(t4, e3) {
        if (0 === t4.mapPaths.length)
          return null;
        var r3, n2 = u(t4.mapPaths);
        try {
          for (n2.s(); !(r3 = n2.n()).done; ) {
            var i3 = r3.value.path;
            if (new RegExp("^" + i3.replace(/\.\$\*/g, "\\.[^.]+") + "$").test(e3))
              return t4.paths[i3];
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        return null;
      }
      function H(t4, e3, r3) {
        var n2 = e3.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
        if (n2.length < 2)
          return t4.paths.hasOwnProperty(n2[0]) ? t4.paths[n2[0]] : "adhocOrUndefined";
        var i3 = t4.path(n2[0]), o2 = false;
        if (!i3)
          return "adhocOrUndefined";
        for (var a2 = n2.length - 1, s3 = 1; s3 < n2.length; ++s3) {
          o2 = false;
          var c2 = n2[s3];
          if (s3 === a2 && i3 && !/\D/.test(c2)) {
            i3 = i3.$isMongooseDocumentArray ? i3.$embeddedSchemaType : i3 instanceof h2.Array ? i3.caster : void 0;
            break;
          }
          if (/\D/.test(c2)) {
            if (!i3 || !i3.schema) {
              i3 = void 0;
              break;
            }
            o2 = "nested" === i3.schema.pathType(c2), i3 = i3.schema.path(c2);
          } else
            i3 instanceof h2.Array && s3 !== a2 && (i3 = i3.caster);
        }
        return t4.subpaths[r3] = i3, i3 ? "real" : o2 ? "nested" : "adhocOrUndefined";
      }
      function W(t4, e3) {
        var r3, n2 = u(t4.childSchemas);
        try {
          for (n2.s(); !(r3 = n2.n()).done; ) {
            var i3 = r3.value.schema;
            i3.$implicitlyCreated && (Object.assign(i3.options, e3), W(i3, e3));
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
      }
      V.prototype = V.emit = V.listeners = V.removeListener = V.collection = V.errors = V.get = V.init = V.isModified = V.isNew = V.populated = V.remove = V.save = V.toObject = V.validate = 1, V.collection = 1, q.prototype.path = function(t4, e3) {
        if (void 0 === e3) {
          if (null != this.paths[t4])
            return this.paths[t4];
          var r3 = z(t4), n2 = function(t5, e4, r4) {
            if (t5.paths.hasOwnProperty(e4))
              return t5.paths[e4];
            if (t5.subpaths.hasOwnProperty(r4)) {
              var n3 = t5.subpaths[r4];
              if ("nested" === n3)
                return;
              return n3;
            }
            if (t5.singleNestedPaths.hasOwnProperty(r4) && "object" === s2(t5.singleNestedPaths[r4])) {
              var i4 = t5.singleNestedPaths[r4];
              if ("nested" === i4)
                return;
              return i4;
            }
            return null;
          }(this, t4, r3);
          if (null != n2)
            return n2;
          var i3 = K(this, t4);
          return null != i3 ? i3 : null != (n2 = this.hasMixedParent(r3)) ? n2 : T.test(t4) ? function(t5, e4, r4) {
            return H(t5, e4, r4), t5.subpaths[r4];
          }(this, t4, r3) : void 0;
        }
        var o2 = t4.split(".")[0];
        if (V[o2] && !this.options.suppressReservedKeysWarning) {
          var a2 = "`".concat(o2, "` is a reserved schema pathname and may break some functionality. ") + "You are allowed to use it, but use at your own risk. To disable this warning pass `suppressReservedKeysWarning` as a schema option.";
          M.warn(a2);
        }
        "object" === s2(e3) && M.hasUserDefinedProperty(e3, "ref") && I(e3.ref, t4);
        var c2, f2 = t4.split(/\./), l2 = f2.pop(), h3 = this.tree, p2 = "", d3 = u(f2);
        try {
          for (d3.s(); !(c2 = d3.n()).done; ) {
            var y3 = c2.value;
            if (M.specialProperties.has(y3))
              throw new Error("Cannot set special property `" + y3 + "` on a schema");
            if (p2 = p2 += (p2.length > 0 ? "." : "") + y3, h3[y3] || (this.nested[p2] = true, h3[y3] = {}), "object" !== s2(h3[y3])) {
              var m3 = "Cannot set nested path `" + t4 + "`. Parent path `" + p2 + "` already set to type " + h3[y3].name + ".";
              throw new Error(m3);
            }
            h3 = h3[y3];
          }
        } catch (t5) {
          d3.e(t5);
        } finally {
          d3.f();
        }
        h3[l2] = w2(e3), this.paths[t4] = this.interpretAsType(t4, e3, this.options);
        var v2 = this.paths[t4];
        if (v2.$isSchemaMap) {
          var g2 = t4 + ".$*";
          this.paths[g2] = v2.$__schemaType, this.mapPaths.push(this.paths[g2]);
        }
        if (v2.$isSingleNested) {
          for (var _2 = 0, S2 = Object.keys(v2.schema.paths); _2 < S2.length; _2++) {
            var O2 = S2[_2];
            this.singleNestedPaths[t4 + "." + O2] = v2.schema.paths[O2];
          }
          for (var j2 = 0, $2 = Object.keys(v2.schema.singleNestedPaths); j2 < $2.length; j2++) {
            var A2 = $2[j2];
            this.singleNestedPaths[t4 + "." + A2] = v2.schema.singleNestedPaths[A2];
          }
          for (var E2 = 0, x2 = Object.keys(v2.schema.subpaths); E2 < x2.length; E2++) {
            var P2 = x2[E2];
            this.singleNestedPaths[t4 + "." + P2] = v2.schema.subpaths[P2];
          }
          for (var k2 = 0, B2 = Object.keys(v2.schema.nested); k2 < B2.length; k2++) {
            var R2 = B2[k2];
            this.singleNestedPaths[t4 + "." + R2] = "nested";
          }
          Object.defineProperty(v2.schema, "base", { configurable: true, enumerable: false, writable: false, value: this.base }), v2.caster.base = this.base, this.childSchemas.push({ schema: v2.schema, model: v2.caster });
        } else
          v2.$isMongooseDocumentArray && (Object.defineProperty(v2.schema, "base", { configurable: true, enumerable: false, writable: false, value: this.base }), v2.casterConstructor.base = this.base, this.childSchemas.push({ schema: v2.schema, model: v2.casterConstructor }));
        if (v2.$isMongooseArray && v2.caster instanceof b) {
          for (var N2 = t4, D2 = v2; D2.$isMongooseArray; )
            N2 += ".$", D2.$isMongooseDocumentArray ? (D2.$embeddedSchemaType._arrayPath = N2, D2.$embeddedSchemaType._arrayParentPath = t4, D2 = D2.$embeddedSchemaType) : (D2.caster._arrayPath = N2, D2.caster._arrayParentPath = t4, D2 = D2.caster), this.subpaths[N2] = D2;
          for (var L2 = 0, U2 = []; L2 < U2.length; L2++) {
            var C2 = U2[L2];
            this.subpaths[C2.path] = C2;
          }
        }
        if (v2.$isMongooseDocumentArray) {
          for (var q2 = 0, F2 = Object.keys(v2.schema.paths); q2 < F2.length; q2++) {
            var W2 = F2[q2], J2 = v2.schema.paths[W2];
            this.subpaths[t4 + "." + W2] = J2, "object" === s2(J2) && null != J2 && null == J2.$parentSchemaDocArray && (J2.$parentSchemaDocArray = v2);
          }
          for (var G2 = 0, Y2 = Object.keys(v2.schema.subpaths); G2 < Y2.length; G2++) {
            var Q = Y2[G2], X = v2.schema.subpaths[Q];
            this.subpaths[t4 + "." + Q] = X, "object" === s2(X) && null != X && null == X.$parentSchemaDocArray && (X.$parentSchemaDocArray = v2);
          }
          for (var Z = 0, tt = Object.keys(v2.schema.singleNestedPaths); Z < tt.length; Z++) {
            var et = tt[Z], rt = v2.schema.singleNestedPaths[et];
            this.subpaths[t4 + "." + et] = rt, "object" === s2(rt) && null != rt && null == rt.$parentSchemaDocArray && (rt.$parentSchemaDocArray = v2);
          }
        }
        return this;
      }, Object.defineProperty(q.prototype, "base", { configurable: true, enumerable: false, writable: true, value: null }), q.prototype.interpretAsType = function(t4, e3, i3) {
        if (e3 instanceof b) {
          if (e3.path === t4)
            return e3;
          var o2 = e3.clone();
          return o2.path = t4, o2;
        }
        var c2 = null != this.base ? this.base.Schema.Types : q.Types, u2 = null != this.base ? this.base.Types : r2(1148);
        if (!(M.isPOJO(e3) || e3 instanceof m2) && "Object" !== M.getFunctionName(e3.constructor)) {
          var f2 = e3;
          (e3 = {})[i3.typeKey] = f2;
        }
        var l2, h3 = e3[i3.typeKey] && (e3[i3.typeKey] instanceof Function || "type" !== i3.typeKey || !e3.type.type) ? e3[i3.typeKey] : {};
        if (M.isPOJO(h3) || "mixed" === h3)
          return new c2.Mixed(t4, e3);
        if (Array.isArray(h3) || h3 === Array || "array" === h3 || h3 === c2.Array) {
          var p2 = h3 === Array || "array" === h3 ? e3.cast || e3.of : h3[0];
          if (p2 && p2.instanceOfSchema) {
            if (!(p2 instanceof q)) {
              if (!this.options._isMerging)
                throw new TypeError("Schema for array path `" + t4 + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + "".concat(t4, ": new Schema(...)"));
              p2 = new q(p2);
            }
            return new c2.DocumentArray(t4, p2, e3);
          }
          if (p2 && p2[i3.typeKey] && p2[i3.typeKey].instanceOfSchema) {
            if (!(p2[i3.typeKey] instanceof q)) {
              if (!this.options._isMerging)
                throw new TypeError("Schema for array path `" + t4 + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + "".concat(t4, ": new Schema(...)"));
              p2[i3.typeKey] = new q(p2[i3.typeKey]);
            }
            return new c2.DocumentArray(t4, p2[i3.typeKey], e3, p2);
          }
          if (void 0 !== p2 && (Array.isArray(p2) || p2.type === Array || "Array" == p2.type))
            return p2 && "Array" == p2.type && (p2.type = Array), new c2.Array(t4, this.interpretAsType(t4, p2, i3), e3);
          var d3 = null == p2 || !p2[i3.typeKey] || "type" === i3.typeKey && p2.type.type ? p2 : p2[i3.typeKey];
          if ("string" == typeof p2)
            p2 = c2[p2.charAt(0).toUpperCase() + p2.substring(1)];
          else if (M.isPOJO(d3)) {
            if (Object.keys(d3).length) {
              var v2 = { minimize: i3.minimize };
              i3.typeKey && (v2.typeKey = i3.typeKey), i3.hasOwnProperty("strict") && (v2.strict = i3.strict), i3.hasOwnProperty("strictQuery") && (v2.strictQuery = i3.strictQuery), i3.hasOwnProperty("toObject") && (v2.toObject = M.omit(i3.toObject, ["transform"])), i3.hasOwnProperty("toJSON") && (v2.toJSON = M.omit(i3.toJSON, ["transform"])), this._userProvidedOptions.hasOwnProperty("_id") ? v2._id = this._userProvidedOptions._id : null != q.Types.DocumentArray.defaultOptions._id && (v2._id = q.Types.DocumentArray.defaultOptions._id);
              var g2 = new q(d3, v2);
              return g2.$implicitlyCreated = true, new c2.DocumentArray(t4, g2, e3);
            }
            return new c2.Array(t4, c2.Mixed, e3);
          }
          if (p2) {
            if (h3 = !p2[i3.typeKey] || "type" === i3.typeKey && p2.type.type ? p2 : p2[i3.typeKey], Array.isArray(h3))
              return new c2.Array(t4, this.interpretAsType(t4, h3, i3), e3);
            if ("ClockDate" === (l2 = "string" == typeof h3 ? h3 : h3.schemaName || M.getFunctionName(h3)) && (l2 = "Date"), void 0 === l2)
              throw new TypeError("Invalid schema configuration: " + "Could not determine the embedded type for array `".concat(t4, "`. ") + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
            if (!c2.hasOwnProperty(l2))
              throw new TypeError("Invalid schema configuration: " + "`".concat(l2, "` is not a valid type within the array `").concat(t4, "`.") + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
          }
          return new c2.Array(t4, p2 || c2.Mixed, e3, i3);
        }
        if (h3 && h3.instanceOfSchema)
          return new c2.Subdocument(h3, t4, e3);
        if ((l2 = n.isBuffer(h3) ? "Buffer" : "function" == typeof h3 || "object" === s2(h3) ? h3.schemaName || M.getFunctionName(h3) : h3 === u2.ObjectId ? "ObjectId" : h3 === u2.Decimal128 ? "Decimal128" : null == h3 ? "" + h3 : h3.toString()) && (l2 = l2.charAt(0).toUpperCase() + l2.substring(1)), "ObjectID" === l2 && (l2 = "ObjectId"), "ClockDate" === l2 && (l2 = "Date"), void 0 === l2)
          throw new TypeError("Invalid schema configuration: `".concat(t4, "` schematype definition is ") + "invalid. See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
        if (null == c2[l2])
          throw new TypeError("Invalid schema configuration: `".concat(l2, "` is not ") + "a valid type at path `".concat(t4, "`. See ") + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
        var _2 = new c2[l2](t4, e3);
        return _2.$isSchemaMap && function(t5, e4, r3, n2, i4) {
          var o3 = r3 + ".$*", s3 = { type: {} };
          M.hasUserDefinedProperty(n2, "of") && ((s3 = M.isPOJO(n2.of) && Object.keys(n2.of).length > 0 && !M.hasUserDefinedProperty(n2.of, t5.options.typeKey) ? a({}, t5.options.typeKey, new q(n2.of)) : M.isPOJO(n2.of) ? Object.assign({}, n2.of) : a({}, t5.options.typeKey, n2.of))[t5.options.typeKey] && s3[t5.options.typeKey].instanceOfSchema && s3[t5.options.typeKey].eachPath(function(t6, e5) {
            if (true === e5.options.select || false === e5.options.select)
              throw new y2('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + r3 + "." + t6 + '"');
          }), M.hasUserDefinedProperty(n2, "ref") && (s3.ref = n2.ref)), e4.$__schemaType = t5.interpretAsType(o3, s3, i4);
        }(this, _2, t4, e3, i3), _2;
      }, q.prototype.eachPath = function(t4) {
        for (var e3 = Object.keys(this.paths), r3 = e3.length, n2 = 0; n2 < r3; ++n2)
          t4(e3[n2], this.paths[e3[n2]]);
        return this;
      }, q.prototype.requiredPaths = function(t4) {
        if (this._requiredpaths && !t4)
          return this._requiredpaths;
        for (var e3 = Object.keys(this.paths), r3 = e3.length, n2 = []; r3--; ) {
          var i3 = e3[r3];
          this.paths[i3].isRequired && n2.push(i3);
        }
        return this._requiredpaths = n2, this._requiredpaths;
      }, q.prototype.indexedPaths = function() {
        return this._indexedpaths || (this._indexedpaths = this.indexes()), this._indexedpaths;
      }, q.prototype.pathType = function(t4) {
        if (this.paths.hasOwnProperty(t4))
          return "real";
        if (this.virtuals.hasOwnProperty(t4))
          return "virtual";
        if (this.nested.hasOwnProperty(t4))
          return "nested";
        var e3 = z(t4);
        if (this.subpaths.hasOwnProperty(e3) || this.subpaths.hasOwnProperty(t4))
          return "real";
        var r3 = this.singleNestedPaths.hasOwnProperty(e3) || this.singleNestedPaths.hasOwnProperty(t4);
        return r3 ? "nested" === r3 ? "nested" : "real" : null != K(this, t4) ? "real" : /\.\d+\.|\.\d+$/.test(t4) ? H(this, t4, e3) : "adhocOrUndefined";
      }, q.prototype.hasMixedParent = function(t4) {
        var e3 = t4.split(/\./g);
        t4 = "";
        for (var r3 = 0; r3 < e3.length; ++r3)
          if (t4 = r3 > 0 ? t4 + "." + e3[r3] : e3[r3], this.paths.hasOwnProperty(t4) && this.paths[t4] instanceof h2.Mixed)
            return this.paths[t4];
        return null;
      }, q.prototype.setupTimestamp = function(t4) {
        return k(this, t4);
      }, q.prototype.queue = function(t4, e3) {
        return this.callQueue.push([t4, e3]), this;
      }, q.prototype.pre = function(t4) {
        if (t4 instanceof RegExp) {
          var e3, r3 = Array.prototype.slice.call(arguments, 1), n2 = u(D);
          try {
            for (n2.s(); !(e3 = n2.n()).done; ) {
              var i3 = e3.value;
              t4.test(i3) && this.pre.apply(this, [i3].concat(r3));
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
          return this;
        }
        if (Array.isArray(t4)) {
          var o2, a2 = Array.prototype.slice.call(arguments, 1), s3 = u(t4);
          try {
            for (s3.s(); !(o2 = s3.n()).done; ) {
              var c2 = o2.value;
              this.pre.apply(this, [c2].concat(a2));
            }
          } catch (t5) {
            s3.e(t5);
          } finally {
            s3.f();
          }
          return this;
        }
        return this.s.hooks.pre.apply(this.s.hooks, arguments), this;
      }, q.prototype.post = function(t4) {
        if (t4 instanceof RegExp) {
          var e3, r3 = Array.prototype.slice.call(arguments, 1), n2 = u(D);
          try {
            for (n2.s(); !(e3 = n2.n()).done; ) {
              var i3 = e3.value;
              t4.test(i3) && this.post.apply(this, [i3].concat(r3));
            }
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
          return this;
        }
        if (Array.isArray(t4)) {
          var o2, a2 = Array.prototype.slice.call(arguments, 1), s3 = u(t4);
          try {
            for (s3.s(); !(o2 = s3.n()).done; ) {
              var c2 = o2.value;
              this.post.apply(this, [c2].concat(a2));
            }
          } catch (t5) {
            s3.e(t5);
          } finally {
            s3.f();
          }
          return this;
        }
        return this.s.hooks.post.apply(this.s.hooks, arguments), this;
      }, q.prototype.plugin = function(t4, e3) {
        if ("function" != typeof t4)
          throw new Error('First param to `schema.plugin()` must be a function, got "' + s2(t4) + '"');
        if (e3 && e3.deduplicate) {
          var r3, n2 = u(this.plugins);
          try {
            for (n2.s(); !(r3 = n2.n()).done; )
              if (r3.value.fn === t4)
                return this;
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        }
        return this.plugins.push({ fn: t4, opts: e3 }), t4(this, e3), this;
      }, q.prototype.method = function(t4, e3, r3) {
        if ("string" != typeof t4)
          for (var n2 in t4)
            this.methods[n2] = t4[n2], this.methodOptions[n2] = w2(r3);
        else
          this.methods[t4] = e3, this.methodOptions[t4] = w2(r3);
        return this;
      }, q.prototype.static = function(t4, e3) {
        if ("string" != typeof t4)
          for (var r3 in t4)
            this.statics[r3] = t4[r3];
        else
          this.statics[t4] = e3;
        return this;
      }, q.prototype.index = function(t4, e3) {
        for (var r3 in t4 || (t4 = {}), e3 || (e3 = {}), e3.expires && M.expires(e3), t4)
          this.aliases[r3] && (t4 = M.renameObjKey(t4, r3, this.aliases[r3]));
        for (var n2 = 0, i3 = Object.keys(t4); n2 < i3.length; n2++) {
          var o2 = i3[n2];
          "ascending" === t4[o2] || "asc" === t4[o2] ? t4[o2] = 1 : "descending" !== t4[o2] && "desc" !== t4[o2] || (t4[o2] = -1);
        }
        return this._indexes.push([t4, e3]), this;
      }, q.prototype.set = function(t4, e3, r3) {
        if (1 === arguments.length)
          return this.options[t4];
        switch (t4) {
          case "read":
            "string" == typeof e3 ? this.options[t4] = { mode: $(e3), tags: r3 } : Array.isArray(e3) && "string" == typeof e3[0] ? this.options[t4] = { mode: $(e3[0]), tags: e3[1] } : this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4];
            break;
          case "timestamps":
            this.setupTimestamp(e3), this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4];
            break;
          case "_id":
            this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4], e3 && !this.paths._id ? _(this) : !e3 && null != this.paths._id && this.paths._id.auto && this.remove("_id");
            break;
          default:
            this.options[t4] = e3, this._userProvidedOptions[t4] = this.options[t4];
        }
        return "strict" === t4 && W(this, { strict: e3 }), "strictQuery" === t4 && W(this, { strictQuery: e3 }), "toObject" === t4 && (delete (e3 = o({}, e3)).transform, W(this, { toObject: e3 })), "toJSON" === t4 && (delete (e3 = o({}, e3)).transform, W(this, { toJSON: e3 })), this;
      }, q.prototype.get = function(t4) {
        return this.options[t4];
      };
      var J = "2d 2dsphere hashed text".split(" ");
      function G(t4, e3) {
        var r3, n2 = e3.split("."), i3 = n2.pop(), o2 = t4.tree, a2 = u(n2);
        try {
          for (a2.s(); !(r3 = a2.n()).done; )
            o2 = o2[r3.value];
        } catch (t5) {
          a2.e(t5);
        } finally {
          a2.f();
        }
        delete o2[i3];
      }
      function Y(t4) {
        return t4.startsWith("$[") && t4.endsWith("]");
      }
      Object.defineProperty(q, "indexTypes", { get: function() {
        return J;
      }, set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
      } }), q.prototype.indexes = function() {
        return j(this);
      }, q.prototype.virtual = function(t4, e3) {
        if (t4 instanceof g || "VirtualType" === O(t4))
          return this.virtual(t4.path, t4.options);
        if (e3 = new v(e3), M.hasUserDefinedProperty(e3, ["ref", "refPath"])) {
          if (null == e3.localField)
            throw new Error("Reference virtuals require `localField` option");
          if (null == e3.foreignField)
            throw new Error("Reference virtuals require `foreignField` option");
          this.pre("init", function(r4) {
            if (x.has(t4, r4)) {
              var n3 = x.get(t4, r4);
              this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), e3.justOne || e3.count ? this.$$populatedVirtuals[t4] = Array.isArray(n3) ? n3[0] : n3 : this.$$populatedVirtuals[t4] = Array.isArray(n3) ? n3 : null == n3 ? [] : [n3], x.unset(t4, r4);
            }
          });
          var r3 = this.virtual(t4);
          r3.options = e3, r3.set(function(r4) {
            return this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), P(this.$$populatedVirtuals, t4, r4, e3);
          }), "function" == typeof e3.get && r3.get(e3.get);
          for (var n2 = t4.split("."), i3 = n2[0], o2 = 0; o2 < n2.length - 1; ++o2)
            if (null != this.paths[i3]) {
              if (this.paths[i3].$isMongooseDocumentArray || this.paths[i3].$isSingleNested) {
                var a2 = n2.slice(o2 + 1).join(".");
                this.paths[i3].schema.virtual(a2, e3);
                break;
              }
              i3 += "." + n2[o2 + 1];
            }
          return r3;
        }
        var s3 = this.virtuals, c2 = t4.split(".");
        if ("real" === this.pathType(t4))
          throw new Error('Virtual path "' + t4 + '" conflicts with a real path in the schema');
        return s3[t4] = c2.reduce(function(r4, n3, i4) {
          return r4[n3] || (r4[n3] = i4 === c2.length - 1 ? new g(e3, t4) : {}), r4[n3];
        }, this.tree), s3[t4];
      }, q.prototype.virtualpath = function(t4) {
        return this.virtuals.hasOwnProperty(t4) ? this.virtuals[t4] : null;
      }, q.prototype.remove = function(t4) {
        return "string" == typeof t4 && (t4 = [t4]), Array.isArray(t4) && t4.forEach(function(t5) {
          if (null != this.path(t5) || this.nested[t5]) {
            if (this.nested[t5]) {
              var e3, r3 = u(Object.keys(this.paths).concat(Object.keys(this.nested)));
              try {
                for (r3.s(); !(e3 = r3.n()).done; ) {
                  var n2 = e3.value;
                  n2.startsWith(t5 + ".") && (delete this.paths[n2], delete this.nested[n2], G(this, n2));
                }
              } catch (t6) {
                r3.e(t6);
              } finally {
                r3.f();
              }
              return delete this.nested[t5], void G(this, t5);
            }
            delete this.paths[t5], G(this, t5);
          }
        }, this), this;
      }, q.prototype.removeVirtual = function(t4) {
        if ("string" == typeof t4 && (t4 = [t4]), Array.isArray(t4)) {
          var e3, r3 = u(t4);
          try {
            for (r3.s(); !(e3 = r3.n()).done; ) {
              var n2 = e3.value;
              if (null == this.virtuals[n2])
                throw new y2('Attempting to remove virtual "'.concat(n2, '" that does not exist.'));
            }
          } catch (t5) {
            r3.e(t5);
          } finally {
            r3.f();
          }
          var i3, o2 = u(t4);
          try {
            for (o2.s(); !(i3 = o2.n()).done; ) {
              var a2 = i3.value;
              delete this.paths[a2], delete this.virtuals[a2], -1 !== a2.indexOf(".") ? x.unset(a2, this.tree) : delete this.tree[a2];
            }
          } catch (t5) {
            o2.e(t5);
          } finally {
            o2.f();
          }
        }
        return this;
      }, q.prototype.loadClass = function(t4, e3) {
        return t4 === Object.prototype || t4 === Function.prototype || t4.prototype.hasOwnProperty("$isMongooseModelPrototype") || t4.prototype.hasOwnProperty("$isMongooseDocumentPrototype") || (this.loadClass(Object.getPrototypeOf(t4), e3), e3 || Object.getOwnPropertyNames(t4).forEach(function(e4) {
          if (!e4.match(/^(length|name|prototype|constructor|__proto__)$/)) {
            var r3 = Object.getOwnPropertyDescriptor(t4, e4);
            r3.hasOwnProperty("value") && this.static(e4, r3.value);
          }
        }, this), Object.getOwnPropertyNames(t4.prototype).forEach(function(r3) {
          if (!r3.match(/^(constructor)$/)) {
            var n2 = Object.getOwnPropertyDescriptor(t4.prototype, r3);
            e3 || "function" == typeof n2.value && this.method(r3, n2.value), "function" == typeof n2.get && (this.virtuals[r3] && (this.virtuals[r3].getters = []), this.virtual(r3).get(n2.get)), "function" == typeof n2.set && (this.virtuals[r3] && (this.virtuals[r3].setters = []), this.virtual(r3).set(n2.set));
          }
        }, this)), this;
      }, q.prototype._getSchema = function(t4) {
        var e3 = this.path(t4), r3 = [];
        if (e3)
          return e3.$fullPath = t4, e3;
        for (var n2 = t4.split("."), i3 = 0; i3 < n2.length; ++i3)
          ("$" === n2[i3] || Y(n2[i3])) && (n2[i3] = "0"), C.test(n2[i3]) && (n2[i3] = "$");
        return function t5(e4, n3) {
          for (var i4, o2, a2 = e4.length + 1; a2--; )
            if (o2 = e4.slice(0, a2).join("."), i4 = n3.path(o2)) {
              if (r3.push(o2), i4.caster) {
                if (i4.caster instanceof h2.Mixed)
                  return i4.caster.$fullPath = r3.join("."), i4.caster;
                if (a2 !== e4.length && i4.schema) {
                  var s3 = void 0;
                  return "$" === e4[a2] || Y(e4[a2]) ? a2 + 1 === e4.length ? i4.$embeddedSchemaType : ((s3 = t5(e4.slice(a2 + 1), i4.schema)) && (s3.$parentSchemaDocArray = s3.$parentSchemaDocArray || (i4.schema.$isSingleNested ? null : i4)), s3) : ((s3 = t5(e4.slice(a2), i4.schema)) && (s3.$parentSchemaDocArray = s3.$parentSchemaDocArray || (i4.schema.$isSingleNested ? null : i4)), s3);
                }
              } else if (i4.$isSchemaMap) {
                if (a2 >= e4.length)
                  return i4;
                if (a2 + 1 >= e4.length)
                  return i4.$__schemaType;
                if (i4.$__schemaType instanceof h2.Mixed)
                  return i4.$__schemaType;
                if (null != i4.$__schemaType.schema)
                  return t5(e4.slice(a2 + 1), i4.$__schemaType.schema);
              }
              return i4.$fullPath = r3.join("."), i4;
            }
        }(n2, this);
      }, q.prototype._getPathType = function(t4) {
        return this.path(t4) ? "real" : function t5(e3, r3) {
          for (var n2, i3, o2 = e3.length + 1; o2--; ) {
            if (i3 = e3.slice(0, o2).join("."), n2 = r3.path(i3))
              return n2.caster ? n2.caster instanceof h2.Mixed ? { schema: n2, pathType: "mixed" } : o2 !== e3.length && n2.schema ? "$" === e3[o2] || Y(e3[o2]) ? o2 === e3.length - 1 ? { schema: n2, pathType: "nested" } : t5(e3.slice(o2 + 1), n2.schema) : t5(e3.slice(o2), n2.schema) : { schema: n2, pathType: n2.$isSingleNested ? "nested" : "array" } : { schema: n2, pathType: "real" };
            if (o2 === e3.length && r3.nested[i3])
              return { schema: r3, pathType: "nested" };
          }
          return { schema: n2 || r3, pathType: "undefined" };
        }(t4.split("."), this);
      }, q.prototype._preCompile = function() {
        this.plugin(A, { deduplicate: true });
      }, t3.exports = e2 = q, q.Types = h2 = r2(2176), e2.ObjectId = h2.ObjectId;
    }, 9225: (t3, e2, r2) => {
      function n(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      var o, a, s2 = r2(1188), c = r2(3180), u = r2(7026), f = r2(2685), l = r2(2319), h2 = l.CastError, p = r2(1895), d2 = r2(3164), y2 = r2(8447), b = r2(1829), m2 = r2(499), v = r2(7352), g = r2(335), _ = r2(4111).G, w2 = r2(6951), S = r2(7785), O = Symbol("mongoose#isNestedArray"), j = Object.freeze({});
      function $(t4, e3, n2, i3) {
        a || (a = r2(1148).Embedded);
        var o2, s3, c2 = "type";
        if (i3 && i3.typeKey && (c2 = i3.typeKey), this.schemaOptions = i3, e3) {
          var u2 = {};
          g.isPOJO(e3) && (e3[c2] ? (delete (u2 = b(e3))[c2], e3 = e3[c2]) : e3 = p), null != n2 && null != n2.ref && null == u2.ref && (u2.ref = n2.ref), e3 === Object && (e3 = p);
          var f2 = "string" == typeof e3 ? e3 : g.getFunctionName(e3), h3 = r2(2176), d3 = h3.hasOwnProperty(f2) ? h3[f2] : e3;
          if (this.casterConstructor = d3, this.casterConstructor instanceof $ && (this.casterConstructor[O] = true), "function" != typeof d3 || d3.$isArraySubdocument || d3.$isSchemaMap)
            this.caster = d3, this.caster instanceof a || (this.caster.path = t4);
          else {
            var y3 = this.caster instanceof a ? null : t4;
            this.caster = new d3(y3, u2);
          }
          this.$embeddedSchemaType = this.caster;
        }
        if (this.$isMongooseArray = true, l.call(this, t4, n2, "Array"), null != this.defaultValue && (o2 = this.defaultValue, s3 = "function" == typeof o2), !("defaultValue" in this) || void 0 !== this.defaultValue) {
          var m3 = function() {
            return s3 ? o2.call(this) : null != o2 ? [].concat(o2) : [];
          };
          m3.$runBeforeSetters = !s3, this.default(m3);
        }
      }
      $.schemaName = "Array", $.options = { castNonArrays: true }, $.defaultOptions = {}, $.set = l.set, $.setters = [], $.get = l.get, $.prototype = Object.create(l.prototype), $.prototype.constructor = $, $.prototype.OptionsConstructor = f, $._checkRequired = l.prototype.checkRequired, $.checkRequired = l.checkRequired, $.prototype.checkRequired = function(t4, e3) {
        return "object" === i2(t4) && l._isRef(this, t4, e3, true) ? !!t4 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : $.checkRequired())(t4);
      }, $.prototype.enum = function() {
        for (var t4 = this; ; ) {
          var e3 = t4 && t4.caster && t4.caster.instance;
          if ("Array" !== e3) {
            if ("String" !== e3 && "Number" !== e3)
              throw new Error("`enum` can only be set on an array of strings or numbers , not " + e3);
            break;
          }
          t4 = t4.caster;
        }
        var r3 = arguments;
        return !Array.isArray(arguments) && g.isObject(arguments) && (r3 = g.object.vals(r3)), t4.caster.enum.apply(t4.caster, r3), this;
      }, $.prototype.applyGetters = function(t4, e3) {
        return null != e3 && null != e3.$__ && e3.$populated(this.path) ? t4 : l.prototype.applyGetters.call(this, t4, e3);
      }, $.prototype._applySetters = function(t4, e3, r3, n2) {
        if (this.casterConstructor.$isMongooseArray && $.options.castNonArrays && !this[O]) {
          for (var i3 = 0, o2 = this; null != o2 && o2.$isMongooseArray && !o2.$isMongooseDocumentArray; )
            ++i3, o2 = o2.casterConstructor;
          if (null != t4 && 0 !== t4.length) {
            var a2 = d2(t4);
            if (a2.min === a2.max && a2.max < i3 && a2.containsNonArrayItem)
              for (var s3 = a2.max; s3 < i3; ++s3)
                t4 = [t4];
          }
        }
        return l.prototype._applySetters.call(this, t4, e3, r3, n2);
      }, $.prototype.cast = function(t4, e3, n2, i3, a2) {
        var s3, c2;
        if (o || (o = r2(1148).Array), Array.isArray(t4)) {
          if (!t4.length && e3) {
            var u2 = e3.schema.indexedPaths(), f2 = this.path;
            for (s3 = 0, c2 = u2.length; s3 < c2; ++s3) {
              var l2 = u2[s3][0][f2];
              if ("2dsphere" === l2 || "2d" === l2)
                return;
            }
            var d3 = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
            if (null != d3) {
              for (s3 = 0, c2 = u2.length; s3 < c2; ++s3)
                if ("2dsphere" === u2[s3][0][d3])
                  return;
            }
          }
          a2 = a2 || j;
          var y3 = g.isMongooseArray(t4) ? t4.__array : t4, b2 = a2.path || this.path;
          if (null != a2.arrayPathIndex && (b2 += "." + a2.arrayPathIndex), y3 = (t4 = o(y3, b2, e3, this)).__array, n2 && null != e3 && null != e3.$__ && e3.$populated(this.path))
            return t4;
          var m3 = this.caster, _2 = m3.$isMongooseArray;
          if (m3 && this.casterConstructor !== p)
            try {
              var w3 = y3.length;
              for (s3 = 0; s3 < w3; s3++) {
                var S2 = {};
                _2 && (null != a2.arrayPath || null != m3._arrayParentPath) && (S2.arrayPathIndex = s3), y3[s3] = m3.applySetters(y3[s3], e3, n2, void 0, S2);
              }
            } catch (e4) {
              throw new h2("[" + e4.kind + "]", v.inspect(t4), this.path + "." + s3, e4, this);
            }
          return t4;
        }
        var O2 = null != this.options.castNonArrays ? this.options.castNonArrays : $.options.castNonArrays;
        if (n2 || O2)
          return e3 && n2 && e3.markModified(this.path), this.cast([t4], e3, n2);
        throw new h2("Array", v.inspect(t4), this.path, null, this);
      }, $.prototype._castForPopulate = function(t4, e3) {
        if (o || (o = r2(1148).Array), Array.isArray(t4)) {
          var n2, i3 = t4.__array ? t4.__array : t4, a2 = i3.length, s3 = this.caster;
          if (s3 && this.casterConstructor !== p)
            try {
              for (n2 = 0; n2 < a2; n2++) {
                var c2 = {};
                s3.$isMongooseArray && null != s3._arrayParentPath && (c2.arrayPathIndex = n2), i3[n2] = s3.cast(i3[n2], e3, false, void 0, c2);
              }
            } catch (e4) {
              throw new h2("[" + e4.kind + "]", v.inspect(t4), this.path + "." + n2, e4, this);
            }
          return t4;
        }
        throw new h2("Array", v.inspect(t4), this.path, null, this);
      }, $.prototype.$toObject = $.prototype.toObject, $.prototype.discriminator = function() {
        for (var t4, e3 = this; e3.$isMongooseArray && !e3.$isMongooseDocumentArray; )
          if (null == (e3 = e3.casterConstructor) || "function" == typeof e3)
            throw new u("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
        return (t4 = e3).discriminator.apply(t4, arguments);
      }, $.prototype.clone = function() {
        var t4 = Object.assign({}, this.options), e3 = new this.constructor(this.path, this.caster, t4, this.schemaOptions);
        return e3.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e3.requiredValidator = this.requiredValidator), e3;
      }, $.prototype._castForQuery = function(t4, e3) {
        var r3 = this, n2 = this.casterConstructor;
        if (t4 && n2.discriminators && n2.schema && n2.schema.options && n2.schema.options.discriminatorKey)
          if ("string" == typeof t4[n2.schema.options.discriminatorKey] && n2.discriminators[t4[n2.schema.options.discriminatorKey]])
            n2 = n2.discriminators[t4[n2.schema.options.discriminatorKey]];
          else {
            var i3 = S(n2.discriminators, t4[n2.schema.options.discriminatorKey]);
            i3 && (n2 = i3);
          }
        var o2 = this.casterConstructor.prototype, a2 = o2 && o2.castForQuery, s3 = o2 && o2.cast, c2 = n2.castForQuery, u2 = this.caster;
        return Array.isArray(t4) ? (this.setters.reverse().forEach(function(e4) {
          t4 = e4.call(r3, t4, r3);
        }), t4 = t4.map(function(t5) {
          return g.isObject(t5) && t5.$elemMatch ? t5 : a2 ? t5 = a2.call(u2, null, t5, e3) : s3 ? t5 = s3.call(u2, t5) : c2 ? t5 = c2.call(u2, null, t5, e3) : null != t5 ? t5 = new n2(t5) : t5;
        })) : a2 ? t4 = a2.call(u2, null, t4, e3) : s3 ? t4 = s3.call(u2, t4) : c2 ? t4 = c2.call(u2, null, t4, e3) : null != t4 && (t4 = new n2(t4)), t4;
      }, $.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with Array.");
          return n2.call(this, e3, r3);
        }
        return this._castForQuery(e3, r3);
      };
      var A = $.prototype.$conditionalHandlers = {};
      function E(t4) {
        return function(e3, r3) {
          if (!Array.isArray(e3))
            throw new TypeError("conditional " + t4 + " requires an array");
          var i3, o2 = [], a2 = function(t5, e4) {
            var r4 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
            if (!r4) {
              if (Array.isArray(t5) || (r4 = function(t6, e5) {
                if (t6) {
                  if ("string" == typeof t6)
                    return n(t6, e5);
                  var r5 = Object.prototype.toString.call(t6).slice(8, -1);
                  return "Object" === r5 && t6.constructor && (r5 = t6.constructor.name), "Map" === r5 || "Set" === r5 ? Array.from(t6) : "Arguments" === r5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? n(t6, e5) : void 0;
                }
              }(t5)) || e4 && t5 && "number" == typeof t5.length) {
                r4 && (t5 = r4);
                var i4 = 0, o3 = function() {
                };
                return { s: o3, n: function() {
                  return i4 >= t5.length ? { done: true } : { done: false, value: t5[i4++] };
                }, e: function(t6) {
                  throw t6;
                }, f: o3 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a3, s4 = true, c3 = false;
            return { s: function() {
              r4 = r4.call(t5);
            }, n: function() {
              var t6 = r4.next();
              return s4 = t6.done, t6;
            }, e: function(t6) {
              c3 = true, a3 = t6;
            }, f: function() {
              try {
                s4 || null == r4.return || r4.return();
              } finally {
                if (c3)
                  throw a3;
              }
            } };
          }(e3);
          try {
            for (a2.s(); !(i3 = a2.n()).done; ) {
              var s3, c2 = i3.value;
              o2.push(y2(null !== (s3 = this.casterConstructor.schema) && void 0 !== s3 ? s3 : r3.schema, c2, null, this && this.$$context));
            }
          } catch (t5) {
            a2.e(t5);
          } finally {
            a2.f();
          }
          return o2;
        };
      }
      A.$all = function(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) || (t4 = [t4]), t4 = t4.map(function(t5) {
          if (!g.isObject(t5))
            return t5;
          if (null != t5.$elemMatch)
            return { $elemMatch: y2(r3.casterConstructor.schema, t5.$elemMatch, null, r3 && r3.$$context) };
          var e4 = {};
          return e4[r3.path] = t5, y2(r3.casterConstructor.schema, e4, null, r3 && r3.$$context)[r3.path];
        }, this), this.castForQuery(null, t4, e3);
      }, A.$options = String, A.$elemMatch = function(t4, e3) {
        for (var r3, n2 = Object.keys(t4), i3 = n2.length, o2 = 0; o2 < i3; ++o2) {
          var a2 = n2[o2], s3 = t4[a2];
          m2(a2) && null != s3 && (t4[a2] = this.castForQuery(a2, s3, e3));
        }
        var c2 = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey, u2 = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
        if (null != c2 && null != t4[c2] && null != u2[t4[c2]])
          return y2(u2[t4[c2]], t4, null, this && this.$$context);
        var f2 = null !== (r3 = this.casterConstructor.schema) && void 0 !== r3 ? r3 : e3.schema;
        return y2(f2, t4, null, this && this.$$context);
      }, A.$geoIntersects = w2.cast$geoIntersects, A.$or = E("$or"), A.$and = E("$and"), A.$nor = E("$nor"), A.$near = A.$nearSphere = w2.cast$near, A.$within = A.$geoWithin = w2.cast$within, A.$size = A.$minDistance = A.$maxDistance = _, A.$exists = s2, A.$type = c, A.$eq = A.$gt = A.$gte = A.$lt = A.$lte = A.$not = A.$regex = A.$ne = $.prototype._castForQuery, A.$nin = l.prototype.$conditionalHandlers.$nin, A.$in = l.prototype.$conditionalHandlers.$in, t3.exports = $;
    }, 4725: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            var i3, o2, a2, s3;
            i3 = t4, o2 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != n(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var i4 = r4.call(t5, "string");
                if ("object" != n(i4))
                  return i4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(o2), (o2 = "symbol" == n(s3) ? s3 : s3 + "") in i3 ? Object.defineProperty(i3, o2, { value: a2, enumerable: true, configurable: true, writable: true }) : i3[o2] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      var a = r2(6148), s2 = r2(2319), c = r2(6237);
      function u(t4, e3) {
        s2.call(this, t4, e3, "BigInt");
      }
      function f(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      u.schemaName = "BigInt", u.defaultOptions = {}, u.prototype = Object.create(s2.prototype), u.prototype.constructor = u, u._cast = c, u.set = s2.set, u.setters = [], u.get = s2.get, u.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, u._checkRequired = function(t4) {
        return null != t4;
      }, u.checkRequired = s2.checkRequired, u.prototype.checkRequired = function(t4) {
        return this.constructor._checkRequired(t4);
      }, u.prototype.cast = function(t4) {
        var e3;
        e3 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : u.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new a("BigInt", t4, this.path, e4, this);
        }
      }, u.$conditionalHandlers = o(o({}, s2.prototype.$conditionalHandlers), {}, { $gt: f, $gte: f, $lt: f, $lte: f }), u.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4)
          return (n2 = u.$conditionalHandlers[t4]) ? n2.call(this, e3) : this.applySetters(null, e3, r3);
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof a && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
      }, u.prototype._castNullish = function(t4) {
        return void 0 === t4 || ("function" == typeof this.constructor.cast ? this.constructor.cast() : u.cast()), t4;
      }, t3.exports = u;
    }, 7116: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      var o = r2(6148), a = r2(2319), s2 = r2(7092);
      function c(t4, e3) {
        a.call(this, t4, e3, "Boolean");
      }
      c.schemaName = "Boolean", c.defaultOptions = {}, c.prototype = Object.create(a.prototype), c.prototype.constructor = c, c._cast = s2, c.set = a.set, c.setters = [], c.get = a.get, c.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, c._defaultCaster = function(t4) {
        if (null != t4 && "boolean" != typeof t4)
          throw new Error();
        return t4;
      }, c._checkRequired = function(t4) {
        return true === t4 || false === t4;
      }, c.checkRequired = a.checkRequired, c.prototype.checkRequired = function(t4) {
        return this.constructor._checkRequired(t4);
      }, Object.defineProperty(c, "convertToTrue", { get: function() {
        return s2.convertToTrue;
      }, set: function(t4) {
        s2.convertToTrue = t4;
      } }), Object.defineProperty(c, "convertToFalse", { get: function() {
        return s2.convertToFalse;
      }, set: function(t4) {
        s2.convertToFalse = t4;
      } }), c.prototype.cast = function(t4) {
        var e3;
        e3 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : c.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new o("Boolean", t4, this.path, e4, this);
        }
      }, c.$conditionalHandlers = function(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            var i3, o2, a2, s3;
            i3 = t4, o2 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != n(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var i4 = r4.call(t5, "string");
                if ("object" != n(i4))
                  return i4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(o2), (o2 = "symbol" == n(s3) ? s3 : s3 + "") in i3 ? Object.defineProperty(i3, o2, { value: a2, enumerable: true, configurable: true, writable: true }) : i3[o2] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }({}, a.prototype.$conditionalHandlers), c.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4)
          return (n2 = c.$conditionalHandlers[t4]) ? n2.call(this, e3) : this.applySetters(null, e3, r3);
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof o && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
      }, c.prototype._castNullish = function(t4) {
        if (void 0 === t4)
          return t4;
        var e3 = "function" == typeof this.constructor.cast ? this.constructor.cast() : c.cast();
        return null == e3 ? t4 : !(e3.convertToFalse instanceof Set && e3.convertToFalse.has(t4)) && (!!(e3.convertToTrue instanceof Set && e3.convertToTrue.has(t4)) || t4);
      }, t3.exports = c;
    }, 1792: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            var n2, i3, o2, s3;
            n2 = t4, i3 = e4, o2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != a(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != a(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(i3), (i3 = "symbol" == a(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, i3, { value: o2, enumerable: true, configurable: true, writable: true }) : n2[i3] = o2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function a(t4) {
        return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, a(t4);
      }
      var s2 = r2(9820), c = r2(3958), u = r2(2319), f = r2(133), l = r2(335), h2 = s2.Binary, p = u.CastError;
      function d2(t4, e3) {
        u.call(this, t4, e3, "Buffer");
      }
      function y2(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      d2.schemaName = "Buffer", d2.defaultOptions = {}, d2.prototype = Object.create(u.prototype), d2.prototype.constructor = d2, d2.prototype.OptionsConstructor = c, d2._checkRequired = function(t4) {
        return !(!t4 || !t4.length);
      }, d2.set = u.set, d2.setters = [], d2.get = u.get, d2.checkRequired = u.checkRequired, d2.prototype.checkRequired = function(t4, e3) {
        return u._isRef(this, t4, e3, true) ? !!t4 : this.constructor._checkRequired(t4);
      }, d2.prototype.cast = function(t4, e3, r3) {
        var i3;
        if (u._isRef(this, t4, e3, r3)) {
          if (t4 && t4.isMongooseBuffer)
            return t4;
          if (n.isBuffer(t4))
            return t4 && t4.isMongooseBuffer || (t4 = new s2(t4, [this.path, e3]), null != this.options.subtype && (t4._subtype = this.options.subtype)), t4;
          if (t4 instanceof h2) {
            if (i3 = new s2(t4.value(true), [this.path, e3]), "number" != typeof t4.sub_type)
              throw new p("Buffer", t4, this.path, null, this);
            return i3._subtype = t4.sub_type, i3;
          }
          if (null == t4 || l.isNonBuiltinObject(t4))
            return this._castRef(t4, e3, r3);
        }
        if (t4 && t4._id && (t4 = t4._id), t4 && t4.isMongooseBuffer)
          return t4;
        if (n.isBuffer(t4))
          return t4 && t4.isMongooseBuffer || (t4 = new s2(t4, [this.path, e3]), null != this.options.subtype && (t4._subtype = this.options.subtype)), t4;
        if (t4 instanceof h2) {
          if (i3 = new s2(t4.value(true), [this.path, e3]), "number" != typeof t4.sub_type)
            throw new p("Buffer", t4, this.path, null, this);
          return i3._subtype = t4.sub_type, i3;
        }
        if (null === t4)
          return t4;
        var o2 = a(t4);
        if ("string" === o2 || "number" === o2 || Array.isArray(t4) || "object" === o2 && "Buffer" === t4.type && Array.isArray(t4.data))
          return "number" === o2 && (t4 = [t4]), i3 = new s2(t4, [this.path, e3]), null != this.options.subtype && (i3._subtype = this.options.subtype), i3;
        throw new p("Buffer", t4, this.path, null, this);
      }, d2.prototype.subtype = function(t4) {
        return this.options.subtype = t4, this;
      }, d2.prototype.$conditionalHandlers = o(o({}, u.prototype.$conditionalHandlers), {}, { $bitsAllClear: f, $bitsAnyClear: f, $bitsAllSet: f, $bitsAnySet: f, $gt: y2, $gte: y2, $lt: y2, $lte: y2 }), d2.prototype.castForQuery = function(t4, e3, r3) {
        var n2, i3;
        if (null != t4) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with Buffer.");
          return n2.call(this, e3);
        }
        try {
          i3 = this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof p && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
        return i3 ? i3.toObject({ transform: false, virtuals: false }) : i3;
      }, t3.exports = d2;
    }, 7386: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i2(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            var n2, i3, a2, s3;
            n2 = t4, i3 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != o(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != o(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(i3), (i3 = "symbol" == o(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, i3, { value: a2, enumerable: true, configurable: true, writable: true }) : n2[i3] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a = r2(9507), s2 = r2(7236), c = r2(2319), u = r2(9973), f = r2(5857), l = r2(335), h2 = c.CastError;
      function p(t4, e3) {
        c.call(this, t4, e3, "Date");
      }
      function d2(t4) {
        return this.cast(t4);
      }
      p.schemaName = "Date", p.defaultOptions = {}, p.prototype = Object.create(c.prototype), p.prototype.constructor = p, p.prototype.OptionsConstructor = s2, p._cast = u, p.set = c.set, p.setters = [], p.get = c.get, p.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, p._defaultCaster = function(t4) {
        if (null != t4 && !(t4 instanceof Date))
          throw new Error();
        return t4;
      }, p.prototype.expires = function(t4) {
        return "Object" !== f(this._index) && (this._index = {}), this._index.expires = t4, l.expires(this._index), this;
      }, p._checkRequired = function(t4) {
        return t4 instanceof Date;
      }, p.checkRequired = c.checkRequired, p.prototype.checkRequired = function(t4, e3) {
        return "object" === o(t4) && c._isRef(this, t4, e3, true) ? null != t4 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : p.checkRequired())(t4);
      }, p.prototype.min = function(t4, e3) {
        if (this.minValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.minValidator;
        }, this)), t4) {
          var r3 = e3 || a.messages.Date.min;
          "string" == typeof r3 && (r3 = r3.replace(/{MIN}/, t4 === Date.now ? "Date.now()" : t4.toString()));
          var n2 = this;
          this.validators.push({ validator: this.minValidator = function(e4) {
            var r4 = t4;
            "function" == typeof t4 && t4 !== Date.now && (r4 = r4.call(this));
            var i3 = r4 === Date.now ? r4() : n2.cast(r4);
            return null === e4 || e4.valueOf() >= i3.valueOf();
          }, message: r3, type: "min", min: t4 });
        }
        return this;
      }, p.prototype.max = function(t4, e3) {
        if (this.maxValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.maxValidator;
        }, this)), t4) {
          var r3 = e3 || a.messages.Date.max;
          "string" == typeof r3 && (r3 = r3.replace(/{MAX}/, t4 === Date.now ? "Date.now()" : t4.toString()));
          var n2 = this;
          this.validators.push({ validator: this.maxValidator = function(e4) {
            var r4 = t4;
            "function" == typeof r4 && r4 !== Date.now && (r4 = r4.call(this));
            var i3 = r4 === Date.now ? r4() : n2.cast(r4);
            return null === e4 || e4.valueOf() <= i3.valueOf();
          }, message: r3, type: "max", max: t4 });
        }
        return this;
      }, p.prototype.cast = function(t4) {
        var e3;
        e3 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : p.cast();
        try {
          return e3(t4);
        } catch (e4) {
          throw new h2("date", t4, this.path, e4, this);
        }
      }, p.prototype.$conditionalHandlers = i2(i2({}, c.prototype.$conditionalHandlers), {}, { $gt: d2, $gte: d2, $lt: d2, $lte: d2 }), p.prototype.castForQuery = function(t4, e3, r3) {
        if (null == t4)
          try {
            return this.applySetters(e3, r3);
          } catch (t5) {
            throw t5 instanceof h2 && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
          }
        var n2 = this.$conditionalHandlers[t4];
        if (!n2)
          throw new Error("Can't use " + t4 + " with Date.");
        return n2.call(this, e3);
      }, t3.exports = p;
    }, 8598: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            var i3, o2, a2, s3;
            i3 = t4, o2 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != n(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var i4 = r4.call(t5, "string");
                if ("object" != n(i4))
                  return i4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(o2), (o2 = "symbol" == n(s3) ? s3 : s3 + "") in i3 ? Object.defineProperty(i3, o2, { value: a2, enumerable: true, configurable: true, writable: true }) : i3[o2] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      var a = r2(2319), s2 = a.CastError, c = r2(3854), u = r2(2128);
      function f(t4, e3) {
        a.call(this, t4, e3, "Decimal128");
      }
      function l(t4) {
        return this.cast(t4);
      }
      f.schemaName = "Decimal128", f.defaultOptions = {}, f.prototype = Object.create(a.prototype), f.prototype.constructor = f, f._cast = c, f.set = a.set, f.setters = [], f.get = a.get, f.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, f._defaultCaster = function(t4) {
        if (null != t4 && !u(t4, "Decimal128"))
          throw new Error();
        return t4;
      }, f._checkRequired = function(t4) {
        return u(t4, "Decimal128");
      }, f.checkRequired = a.checkRequired, f.prototype.checkRequired = function(t4, e3) {
        return a._isRef(this, t4, e3, true) ? !!t4 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : f.checkRequired())(t4);
      }, f.prototype.cast = function(t4, e3, r3) {
        if (a._isRef(this, t4, e3, r3))
          return u(t4, "Decimal128") ? t4 : this._castRef(t4, e3, r3);
        var n2;
        n2 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : f.cast();
        try {
          return n2(t4);
        } catch (e4) {
          throw new s2("Decimal128", t4, this.path, e4, this);
        }
      }, f.prototype.$conditionalHandlers = o(o({}, a.prototype.$conditionalHandlers), {}, { $gt: l, $gte: l, $lt: l, $lte: l }), t3.exports = f;
    }, 9970: (t3, e2, r2) => {
      var n, i2, o = r2(6148), a = r2(2512), s2 = r2(3550).EventEmitter, c = r2(9225), u = r2(4172), f = r2(2319), l = r2(8650), h2 = r2(5962), p = r2(8145), d2 = r2(335), y2 = r2(371), b = r2(9662), m2 = r2(5625).arrayAtomicsSymbol, v = r2(5625).arrayPathSymbol, g = r2(5625).documentArrayParent;
      function _(t4, e3, r3, n2) {
        if (e3.options && e3.options.timeseries)
          throw new b(t4, "timeseries");
        var i3 = _.defaultOptions && _.defaultOptions._id;
        null != i3 && ((n2 = n2 || {})._id = i3), null != n2 && null != n2._id ? e3 = h2(e3, n2) : null != r3 && null != r3._id && (e3 = h2(e3, r3));
        var o2 = w2(e3, r3);
        o2.prototype.$basePath = t4, c.call(this, t4, o2, r3), this.schema = e3, this.schemaOptions = n2 || {}, this.$isMongooseDocumentArray = true, this.Constructor = o2, o2.base = e3.base;
        var s3 = this.defaultValue;
        "defaultValue" in this && void 0 === s3 || this.default(function() {
          var t5 = s3.call(this);
          return null == t5 || Array.isArray(t5) || (t5 = [t5]), t5;
        }), this.$embeddedSchemaType = new a(t4 + ".$", { required: this && this.schemaOptions && this.schemaOptions.required || false, $parentSchemaType: this }), this.$embeddedSchemaType.caster = this.Constructor, this.$embeddedSchemaType.schema = this.schema;
      }
      function w2(t4, e3, n2) {
        function o2() {
          i2.apply(this, arguments), null != this.__parentArray && null != this.__parentArray.getArrayParent() && this.$session(this.__parentArray.getArrayParent().$session());
        }
        i2 || (i2 = r2(8578)), t4._preCompile();
        var a2 = null != n2 ? n2.prototype : i2.prototype;
        for (var c2 in o2.prototype = Object.create(a2), o2.prototype.$__setSchema(t4), o2.schema = t4, o2.prototype.constructor = o2, o2.$isArraySubdocument = true, o2.events = new s2(), o2.base = t4.base, t4.methods)
          o2.prototype[c2] = t4.methods[c2];
        for (var u2 in t4.statics)
          o2[u2] = t4.statics[u2];
        for (var f2 in s2.prototype)
          o2[f2] = s2.prototype[f2];
        return o2.options = e3, o2;
      }
      _.schemaName = "DocumentArray", _.options = { castNonArrays: true }, _.prototype = Object.create(c.prototype), _.prototype.constructor = _, _.prototype.OptionsConstructor = u, _.prototype.discriminator = function(t4, e3, r3) {
        "function" == typeof t4 && (t4 = d2.getFunctionName(t4)), r3 = r3 || {};
        var n2 = d2.isPOJO(r3) ? r3.value : r3, i3 = "boolean" != typeof r3.clone || r3.clone;
        e3.instanceOfSchema && i3 && (e3 = e3.clone());
        var o2 = w2(e3 = l(this.casterConstructor, t4, e3, n2), null, this.casterConstructor);
        o2.baseCasterConstructor = this.casterConstructor;
        try {
          Object.defineProperty(o2, "name", { value: t4 });
        } catch (t5) {
        }
        return this.casterConstructor.discriminators[t4] = o2, this.casterConstructor.discriminators[t4];
      }, _.prototype.doValidate = function(t4, e3, o2, a2) {
        n || (n = r2(4941));
        var s3 = this;
        try {
          f.prototype.doValidate.call(this, t4, function(r3) {
            if (r3)
              return e3(r3);
            var c2, u2 = t4 && t4.length;
            if (!u2)
              return e3();
            if (a2 && a2.updateValidator)
              return e3();
            function f2(t5) {
              null != t5 && (c2 = t5), --u2 || e3(c2);
            }
            d2.isMongooseDocumentArray(t4) || (t4 = new n(t4, s3.path, o2));
            for (var l2 = 0, h3 = u2; l2 < h3; ++l2) {
              var p2 = t4[l2];
              if (null != p2) {
                if (!(p2 instanceof i2)) {
                  var b2 = y2(s3.casterConstructor, t4[l2]);
                  p2 = t4[l2] = new b2(p2, t4, void 0, void 0, l2);
                }
                null == a2 || !a2.validateModifiedOnly || p2.$isModified() ? p2.$__validate(null, a2, f2) : --u2 || e3(c2);
              } else
                --u2 || e3(c2);
            }
          }, o2);
        } catch (t5) {
          return e3(t5);
        }
      }, _.prototype.doValidateSync = function(t4, e3, r3) {
        var n2 = f.prototype.doValidateSync.call(this, t4, e3);
        if (null != n2)
          return n2;
        var o2 = t4 && t4.length, a2 = null;
        if (o2) {
          for (var s3 = 0, c2 = o2; s3 < c2; ++s3) {
            var u2 = t4[s3];
            if (u2) {
              if (!(u2 instanceof i2)) {
                var l2 = y2(this.casterConstructor, t4[s3]);
                u2 = t4[s3] = new l2(u2, t4, void 0, void 0, s3);
              }
              if (null == r3 || !r3.validateModifiedOnly || u2.$isModified()) {
                var h3 = u2.validateSync(r3);
                h3 && null == a2 && (a2 = h3);
              }
            }
          }
          return a2;
        }
      }, _.prototype.getDefault = function(t4, e3, i3) {
        var o2 = "function" == typeof this.defaultValue ? this.defaultValue.call(t4) : this.defaultValue;
        if (null == o2)
          return o2;
        if (i3 && i3.skipCast)
          return o2;
        n || (n = r2(4941)), Array.isArray(o2) || (o2 = [o2]), o2 = new n(o2, this.path, t4);
        for (var a2 = 0; a2 < o2.length; ++a2) {
          var s3 = new (y2(this.casterConstructor, o2[a2]))({}, o2, void 0, void 0, a2);
          s3.$init(o2[a2]), s3.isNew = true, Object.assign(s3.$__.activePaths.default, s3.$__.activePaths.init), s3.$__.activePaths.init = {}, o2[a2] = s3;
        }
        return o2;
      };
      var S = Object.freeze({ transform: false, virtuals: false }), O = Object.freeze({ skipId: false, willInit: true });
      function j(t4, e3, r3) {
        if (r3 && e3) {
          for (var n2, i3, o2, a2 = t4.path + ".", s3 = Object.keys(e3), c2 = s3.length, u2 = {}; c2--; )
            if ((i3 = s3[c2]).startsWith(a2)) {
              if ("$" === (o2 = i3.substring(a2.length)))
                continue;
              o2.startsWith("$.") && (o2 = o2.substring(2)), n2 || (n2 = true), u2[o2] = e3[i3];
            }
          return n2 && u2 || void 0;
        }
      }
      _.prototype.cast = function(t4, e3, a2, s3, c2) {
        if (n || (n = r2(4941)), null != t4 && null != t4[v] && t4 === s3)
          return t4;
        var u2, f2, l2 = (c2 = c2 || {}).path || this.path;
        if (!Array.isArray(t4)) {
          if (!a2 && !_.options.castNonArrays)
            throw new o("DocumentArray", t4, this.path, null, this);
          return e3 && a2 && e3.markModified(l2), this.cast([t4], e3, a2, s3, c2);
        }
        c2.skipDocumentArrayCast && !d2.isMongooseDocumentArray(t4) || (t4 = new n(t4, l2, e3)), null != s3 && (t4[m2] = s3[m2] || {}), null != c2.arrayPathIndex && (t4[v] = l2 + "." + c2.arrayPathIndex);
        for (var h3 = d2.isMongooseDocumentArray(t4) ? t4.__array : t4, b2 = h3.length, w3 = 0; w3 < b2; ++w3)
          if (h3[w3]) {
            var $ = y2(this.casterConstructor, h3[w3]), A = p(h3[w3], true);
            if (h3[w3] !== A && (h3[w3] = A), h3[w3] instanceof i2) {
              if (h3[w3][g] !== e3)
                if (a2) {
                  var E = new $(null, t4, O, u2, w3);
                  h3[w3] = E.$init(h3[w3]);
                } else {
                  var x = new $(h3[w3], t4, void 0, void 0, w3);
                  h3[w3] = x;
                }
              null == h3[w3].__index && h3[w3].$setIndex(w3);
            } else if (null != h3[w3])
              if (a2)
                e3 ? u2 || (u2 = j(this, e3.$__.selected, a2)) : u2 = true, f2 = new $(null, t4, O, u2, w3), h3[w3] = f2.$init(h3[w3]);
              else if (s3 && "function" == typeof s3.id && (f2 = s3.id(h3[w3]._id)), s3 && f2 && d2.deepEqual(f2.toObject(S), h3[w3]))
                f2.set(h3[w3]), h3[w3] = f2;
              else
                try {
                  f2 = new $(h3[w3], t4, void 0, void 0, w3), h3[w3] = f2;
                } catch (e4) {
                  throw new o("embedded", h3[w3], t4[v], e4, this);
                }
          }
        return t4;
      }, _.prototype.clone = function() {
        var t4 = Object.assign({}, this.options), e3 = new this.constructor(this.path, this.schema, t4, this.schemaOptions);
        return e3.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e3.requiredValidator = this.requiredValidator), e3.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators), e3;
      }, _.prototype.applyGetters = function(t4, e3) {
        return f.prototype.applyGetters.call(this, t4, e3);
      }, _.defaultOptions = {}, _.set = f.set, _.setters = [], _.get = f.get, t3.exports = _;
    }, 2512: (t3, e2, r2) => {
      var n = r2(7026), i2 = r2(2319), o = r2(963), a = r2(371);
      function s2(t4, e3) {
        if (this.$parentSchemaType = e3 && e3.$parentSchemaType, !this.$parentSchemaType)
          throw new n("Cannot create DocumentArrayElement schematype without a parent");
        delete e3.$parentSchemaType, i2.call(this, t4, e3, "DocumentArrayElement"), this.$isMongooseDocumentArrayElement = true;
      }
      s2.schemaName = "DocumentArrayElement", s2.defaultOptions = {}, s2.prototype = Object.create(i2.prototype), s2.prototype.constructor = s2, s2.prototype.cast = function() {
        var t4;
        return (t4 = this.$parentSchemaType).cast.apply(t4, arguments)[0];
      }, s2.prototype.doValidate = function(t4, e3, r3, n2) {
        var i3 = a(this.caster, t4);
        return !t4 || t4 instanceof i3 || (t4 = new i3(t4, r3, null, null, n2 && null != n2.index ? n2.index : null)), o.prototype.doValidate.call(this, t4, e3, r3, n2);
      }, s2.prototype.clone = function() {
        this.options.$parentSchemaType = this.$parentSchemaType;
        var t4 = i2.prototype.clone.apply(this, arguments);
        return delete this.options.$parentSchemaType, t4.caster = this.caster, t4.schema = this.schema, t4;
      }, t3.exports = s2;
    }, 2176: (t3, e2, r2) => {
      e2.Array = r2(9225), e2.BigInt = r2(4725), e2.Boolean = r2(7116), e2.Buffer = r2(1792), e2.Date = r2(7386), e2.Decimal128 = e2.Decimal = r2(8598), e2.DocumentArray = r2(9970), e2.Map = r2(5690), e2.Mixed = r2(1895), e2.Number = r2(8191), e2.ObjectId = r2(9476), e2.String = r2(9391), e2.Subdocument = r2(963), e2.UUID = r2(7245), e2.Oid = e2.ObjectId, e2.Object = e2.Mixed, e2.Bool = e2.Boolean, e2.ObjectID = e2.ObjectId;
    }, 5690: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function o(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, a(n2.key), n2);
        }
      }
      function a(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      function s2(t4, e3, r3) {
        return e3 = f(e3), function(t5, e4) {
          if (e4 && ("object" === n(e4) || "function" == typeof e4))
            return e4;
          if (void 0 !== e4)
            throw new TypeError("Derived constructors may only return object or undefined");
          return function(t6) {
            if (void 0 === t6)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t6;
          }(t5);
        }(t4, c() ? Reflect.construct(e3, r3 || [], f(t4).constructor) : e3.apply(t4, r3));
      }
      function c() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (c = function() {
          return !!t4;
        })();
      }
      function u() {
        return u = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t4, e3, r3) {
          var n2 = function(t5, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t5, e4) && null !== (t5 = f(t5)); )
              ;
            return t5;
          }(t4, e3);
          if (n2) {
            var i3 = Object.getOwnPropertyDescriptor(n2, e3);
            return i3.get ? i3.get.call(arguments.length < 3 ? t4 : r3) : i3.value;
          }
        }, u.apply(this, arguments);
      }
      function f(t4) {
        return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, f(t4);
      }
      function l(t4, e3) {
        return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, l(t4, e3);
      }
      var h2 = r2(4902), p = r2(7488), d2 = r2(2319), y2 = function(t4) {
        function e3(t5, r3) {
          var n3;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), (n3 = s2(this, e3, [t5, r3, "Map"])).$isSchemaMap = true, n3;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && l(t5, e4);
        }(e3, t4), n2 = e3, (a2 = [{ key: "set", value: function(t5, e4) {
          return d2.set(t5, e4);
        } }, { key: "cast", value: function(t5, e4, n3) {
          if (t5 instanceof h2)
            return t5;
          var o2 = this.path;
          if (n3) {
            var a3 = new h2({}, o2, e4, this.$__schemaType);
            if (t5 instanceof r2.g.Map) {
              var s3, c2 = function(t6, e5) {
                var r3 = "undefined" != typeof Symbol && t6[Symbol.iterator] || t6["@@iterator"];
                if (!r3) {
                  if (Array.isArray(t6) || (r3 = function(t7, e6) {
                    if (t7) {
                      if ("string" == typeof t7)
                        return i2(t7, e6);
                      var r4 = Object.prototype.toString.call(t7).slice(8, -1);
                      return "Object" === r4 && t7.constructor && (r4 = t7.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t7) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i2(t7, e6) : void 0;
                    }
                  }(t6)) || e5 && t6 && "number" == typeof t6.length) {
                    r3 && (t6 = r3);
                    var n4 = 0, o3 = function() {
                    };
                    return { s: o3, n: function() {
                      return n4 >= t6.length ? { done: true } : { done: false, value: t6[n4++] };
                    }, e: function(t7) {
                      throw t7;
                    }, f: o3 };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var a4, s4 = true, c3 = false;
                return { s: function() {
                  r3 = r3.call(t6);
                }, n: function() {
                  var t7 = r3.next();
                  return s4 = t7.done, t7;
                }, e: function(t7) {
                  c3 = true, a4 = t7;
                }, f: function() {
                  try {
                    s4 || null == r3.return || r3.return();
                  } finally {
                    if (c3)
                      throw a4;
                  }
                } };
              }(t5.keys());
              try {
                for (c2.s(); !(s3 = c2.n()).done; ) {
                  var u2 = s3.value, f2 = t5.get(u2);
                  f2 = null == f2 ? a3.$__schemaType._castNullish(f2) : a3.$__schemaType.cast(f2, e4, true, null, { path: o2 + "." + u2 }), a3.$init(u2, f2);
                }
              } catch (t6) {
                c2.e(t6);
              } finally {
                c2.f();
              }
            } else
              for (var l2 = 0, p2 = Object.keys(t5); l2 < p2.length; l2++) {
                var d3 = p2[l2], y3 = t5[d3];
                y3 = null == y3 ? a3.$__schemaType._castNullish(y3) : a3.$__schemaType.cast(y3, e4, true, null, { path: o2 + "." + d3 }), a3.$init(d3, y3);
              }
            return a3;
          }
          return new h2(t5, o2, e4, this.$__schemaType);
        } }, { key: "clone", value: function() {
          var t5 = u(f(e3.prototype), "clone", this).call(this);
          return null != this.$__schemaType && (t5.$__schemaType = this.$__schemaType.clone()), t5;
        } }]) && o(n2.prototype, a2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
        var n2, a2;
      }(d2);
      y2.schemaName = "Map", y2.prototype.OptionsConstructor = p, y2.defaultOptions = {}, t3.exports = y2;
    }, 1895: (t3, e2, r2) => {
      var n = r2(2319), i2 = r2(3089), o = r2(4797), a = r2(335);
      function s2(t4, e3) {
        if (e3 && e3.default) {
          var r3 = e3.default;
          Array.isArray(r3) && 0 === r3.length ? e3.default = Array : !e3.shared && o(r3) && 0 === Object.keys(r3).length && (e3.default = function() {
            return {};
          });
        }
        n.call(this, t4, e3, "Mixed"), this[i2.schemaMixedSymbol] = true;
      }
      s2.schemaName = "Mixed", s2.defaultOptions = {}, s2.prototype = Object.create(n.prototype), s2.prototype.constructor = s2, s2.get = n.get, s2.set = n.set, s2.setters = [], s2.prototype.cast = function(t4) {
        return t4 instanceof Error ? a.errorToPOJO(t4) : t4;
      }, s2.prototype.castForQuery = function(t4, e3) {
        return e3;
      }, t3.exports = s2;
    }, 8191: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i2(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            var n2, i3, a2, s3;
            n2 = t4, i3 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != o(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != o(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(i3), (i3 = "symbol" == o(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, i3, { value: a2, enumerable: true, configurable: true, writable: true }) : n2[i3] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a = r2(9507), s2 = r2(3823), c = r2(2319), u = r2(247), f = r2(133), l = r2(335), h2 = c.CastError;
      function p(t4, e3) {
        c.call(this, t4, e3, "Number");
      }
      function d2(t4) {
        return this.cast(t4);
      }
      p.get = c.get, p.set = c.set, p.setters = [], p._cast = u, p.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, p._defaultCaster = function(t4) {
        if ("number" != typeof t4)
          throw new Error();
        return t4;
      }, p.schemaName = "Number", p.defaultOptions = {}, p.prototype = Object.create(c.prototype), p.prototype.constructor = p, p.prototype.OptionsConstructor = s2, p._checkRequired = function(t4) {
        return "number" == typeof t4 || t4 instanceof Number;
      }, p.checkRequired = c.checkRequired, p.prototype.checkRequired = function(t4, e3) {
        return "object" === o(t4) && c._isRef(this, t4, e3, true) ? null != t4 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : p.checkRequired())(t4);
      }, p.prototype.min = function(t4, e3) {
        if (this.minValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.minValidator;
        }, this)), null != t4) {
          var r3 = e3 || a.messages.Number.min;
          r3 = r3.replace(/{MIN}/, t4), this.validators.push({ validator: this.minValidator = function(e4) {
            return null == e4 || e4 >= t4;
          }, message: r3, type: "min", min: t4 });
        }
        return this;
      }, p.prototype.max = function(t4, e3) {
        if (this.maxValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.maxValidator;
        }, this)), null != t4) {
          var r3 = e3 || a.messages.Number.max;
          r3 = r3.replace(/{MAX}/, t4), this.validators.push({ validator: this.maxValidator = function(e4) {
            return null == e4 || e4 <= t4;
          }, message: r3, type: "max", max: t4 });
        }
        return this;
      }, p.prototype.enum = function(t4, e3) {
        return this.enumValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.enumValidator;
        }, this)), Array.isArray(t4) || (l.isPOJO(t4) && null != t4.values ? (e3 = t4.message, t4 = t4.values) : "number" == typeof t4 && (t4 = Array.prototype.slice.call(arguments), e3 = null), l.isPOJO(t4) && (t4 = Object.values(t4)), e3 = e3 || a.messages.Number.enum), e3 = null == e3 ? a.messages.Number.enum : e3, this.enumValidator = function(e4) {
          return null == e4 || -1 !== t4.indexOf(e4);
        }, this.validators.push({ validator: this.enumValidator, message: e3, type: "enum", enumValues: t4 }), this;
      }, p.prototype.cast = function(t4, e3, r3) {
        if ("number" != typeof t4 && c._isRef(this, t4, e3, r3) && (null == t4 || l.isNonBuiltinObject(t4)))
          return this._castRef(t4, e3, r3);
        var n2, i3 = t4 && void 0 !== t4._id ? t4._id : t4;
        n2 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : p.cast();
        try {
          return n2(i3);
        } catch (t5) {
          throw new h2("Number", i3, this.path, t5, this);
        }
      }, p.prototype.$conditionalHandlers = i2(i2({}, c.prototype.$conditionalHandlers), {}, { $bitsAllClear: f, $bitsAnyClear: f, $bitsAllSet: f, $bitsAnySet: f, $gt: d2, $gte: d2, $lt: d2, $lte: d2, $mod: function(t4) {
        var e3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return e3.cast(t5);
        }) : [this.cast(t4)];
      } }), p.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new h2("number", e3, this.path, null, this);
          return n2.call(this, e3, r3);
        }
        try {
          e3 = this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof h2 && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
        return e3;
      }, t3.exports = p;
    }, 9476: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            var i3, o2, a2, s3;
            i3 = t4, o2 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != n(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var i4 = r4.call(t5, "string");
                if ("object" != n(i4))
                  return i4;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(o2), (o2 = "symbol" == n(s3) ? s3 : s3 + "") in i3 ? Object.defineProperty(i3, o2, { value: a2, enumerable: true, configurable: true, writable: true }) : i3[o2] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      var a, s2 = r2(210), c = r2(2319), u = r2(8092), f = r2(5857), l = r2(6704), h2 = r2(2128), p = r2(335), d2 = c.CastError;
      function y2(t4, e3) {
        var r3 = "string" == typeof t4 && 24 === t4.length && /^[a-f0-9]+$/i.test(t4), n2 = e3 && e3.suppressWarning;
        !r3 && void 0 !== t4 || n2 || p.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema."), c.call(this, t4, e3, "ObjectId");
      }
      function b(t4) {
        return this.cast(t4);
      }
      function m2() {
        return new l();
      }
      function v(t4) {
        return a || (a = r2(3293)), this instanceof a && void 0 === t4 ? new l() : t4;
      }
      y2.schemaName = "ObjectId", y2.defaultOptions = {}, y2.prototype = Object.create(c.prototype), y2.prototype.constructor = y2, y2.prototype.OptionsConstructor = s2, y2.get = c.get, y2.set = c.set, y2.setters = [], y2.prototype.auto = function(t4) {
        return t4 && (this.default(m2), this.set(v)), this;
      }, y2._checkRequired = function(t4) {
        return h2(t4, "ObjectId");
      }, y2._cast = u, y2.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, y2._defaultCaster = function(t4) {
        if (!h2(t4, "ObjectId"))
          throw new Error(t4 + " is not an instance of ObjectId");
        return t4;
      }, y2.checkRequired = c.checkRequired, y2.prototype.checkRequired = function(t4, e3) {
        return c._isRef(this, t4, e3, true) ? !!t4 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : y2.checkRequired())(t4);
      }, y2.prototype.cast = function(t4, e3, r3) {
        if (!h2(t4, "ObjectId") && c._isRef(this, t4, e3, r3)) {
          if ("objectid" === (f(t4) || "").toLowerCase())
            return new l(t4.toHexString());
          if (null == t4 || p.isNonBuiltinObject(t4))
            return this._castRef(t4, e3, r3);
        }
        var n2;
        n2 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : y2.cast();
        try {
          return n2(t4);
        } catch (e4) {
          throw new d2("ObjectId", t4, this.path, e4, this);
        }
      }, y2.prototype.$conditionalHandlers = o(o({}, c.prototype.$conditionalHandlers), {}, { $gt: b, $gte: b, $lt: b, $lte: b }), m2.$runBeforeSetters = true, t3.exports = y2;
    }, 133: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(6148);
      function o(t4, e3) {
        var r3 = Number(e3);
        if (isNaN(r3))
          throw new i2("number", e3, t4);
        return r3;
      }
      t3.exports = function(t4) {
        var e3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return o(e3.path, t5);
        }) : n.isBuffer(t4) ? t4 : o(e3.path, t4);
      };
    }, 1188: (t3, e2, r2) => {
      var n = r2(7092);
      t3.exports = function(t4) {
        var e3 = null != this ? this.path : null;
        return n(t4, e3);
      };
    }, 6951: (t3, e2, r2) => {
      var n = r2(4111).p, i2 = r2(4111).G;
      function o(t4, e3) {
        switch (t4.$geometry.type) {
          case "Polygon":
          case "LineString":
          case "Point":
            n(t4.$geometry.coordinates, e3);
        }
        return a(e3, t4), t4;
      }
      function a(t4, e3) {
        e3.$maxDistance && (e3.$maxDistance = i2.call(t4, e3.$maxDistance)), e3.$minDistance && (e3.$minDistance = i2.call(t4, e3.$minDistance));
      }
      e2.cast$geoIntersects = function(t4) {
        if (t4.$geometry)
          return o(t4, this), t4;
      }, e2.cast$near = function(t4) {
        var e3 = r2(9225);
        if (Array.isArray(t4))
          return n(t4, this), t4;
        if (a(this, t4), t4 && t4.$geometry)
          return o(t4, this);
        if (!Array.isArray(t4))
          throw new TypeError("$near must be either an array or an object with a $geometry property");
        return e3.prototype.castForQuery.call(this, null, t4);
      }, e2.cast$within = function(t4) {
        var e3 = this;
        if (a(this, t4), t4.$box || t4.$polygon) {
          var r3 = t4.$box ? "$box" : "$polygon";
          t4[r3].forEach(function(t5) {
            if (!Array.isArray(t5))
              throw new TypeError("Invalid $within $box argument. Expected an array, received " + t5);
            t5.forEach(function(r4, n3) {
              t5[n3] = i2.call(e3, r4);
            });
          });
        } else if (t4.$center || t4.$centerSphere) {
          var n2 = t4.$center ? "$center" : "$centerSphere";
          t4[n2].forEach(function(r4, o2) {
            Array.isArray(r4) ? r4.forEach(function(t5, n3) {
              r4[n3] = i2.call(e3, t5);
            }) : t4[n2][o2] = i2.call(e3, r4);
          });
        } else
          t4.$geometry && o(t4, this);
        return t4;
      };
    }, 4111: (t3, e2, r2) => {
      var n = r2(8191);
      function i2(t4) {
        return n.cast()(t4);
      }
      e2.G = i2, e2.p = function t4(e3, r3) {
        e3.forEach(function(n2, o) {
          Array.isArray(n2) ? t4(n2, r3) : e3[o] = i2.call(r3, n2);
        });
      };
    }, 2503: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(6148), o = r2(7092), a = r2(8471);
      t3.exports = function(t4, e3) {
        if (null == t4 || "object" !== n(t4))
          throw new i2("$text", t4, e3);
        return null != t4.$search && (t4.$search = a(t4.$search, e3 + ".$search")), null != t4.$language && (t4.$language = a(t4.$language, e3 + ".$language")), null != t4.$caseSensitive && (t4.$caseSensitive = o(t4.$caseSensitive, e3 + ".$castSensitive")), null != t4.$diacriticSensitive && (t4.$diacriticSensitive = o(t4.$diacriticSensitive, e3 + ".$diacriticSensitive")), t4;
      };
    }, 3180: (t3) => {
      t3.exports = function(t4) {
        if (Array.isArray(t4)) {
          if (!t4.every(function(t5) {
            return "number" == typeof t5 || "string" == typeof t5;
          }))
            throw new Error("$type array values must be strings or numbers");
          return t4;
        }
        if ("number" != typeof t4 && "string" != typeof t4)
          throw new Error("$type parameter must be number, string, or array of numbers and strings");
        return t4;
      };
    }, 9391: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i2(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            var n2, i3, a2, s3;
            n2 = t4, i3 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != o(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != o(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(i3), (i3 = "symbol" == o(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, i3, { value: a2, enumerable: true, configurable: true, writable: true }) : n2[i3] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      function a(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var s2 = r2(2319), c = r2(9507), u = r2(8035), f = r2(8471), l = r2(335), h2 = r2(2128), p = s2.CastError;
      function d2(t4, e3) {
        this.enumValues = [], this.regExp = null, s2.call(this, t4, e3, "String");
      }
      function y2(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      function b(t4) {
        return null == t4 ? this._castNullish(t4) : this.cast(t4, this);
      }
      d2.schemaName = "String", d2.defaultOptions = {}, d2.prototype = Object.create(s2.prototype), d2.prototype.constructor = d2, Object.defineProperty(d2.prototype, "OptionsConstructor", { configurable: false, enumerable: false, writable: false, value: u }), d2._cast = f, d2.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, d2._defaultCaster = function(t4) {
        if (null != t4 && "string" != typeof t4)
          throw new Error();
        return t4;
      }, d2.get = s2.get, d2.set = s2.set, d2.setters = [], d2._checkRequired = function(t4) {
        return (t4 instanceof String || "string" == typeof t4) && t4.length;
      }, d2.checkRequired = s2.checkRequired, d2.prototype.enum = function() {
        if (this.enumValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.enumValidator;
        }, this), this.enumValidator = false), void 0 === arguments[0] || false === arguments[0])
          return this;
        var t4, e3;
        l.isObject(arguments[0]) ? Array.isArray(arguments[0].values) ? (t4 = arguments[0].values, e3 = arguments[0].message) : (t4 = l.object.vals(arguments[0]), e3 = c.messages.String.enum) : (t4 = arguments, e3 = c.messages.String.enum);
        var r3, n2 = function(t5, e4) {
          var r4 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (!r4) {
            if (Array.isArray(t5) || (r4 = function(t6, e5) {
              if (t6) {
                if ("string" == typeof t6)
                  return a(t6, e5);
                var r5 = Object.prototype.toString.call(t6).slice(8, -1);
                return "Object" === r5 && t6.constructor && (r5 = t6.constructor.name), "Map" === r5 || "Set" === r5 ? Array.from(t6) : "Arguments" === r5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? a(t6, e5) : void 0;
              }
            }(t5)) || e4 && t5 && "number" == typeof t5.length) {
              r4 && (t5 = r4);
              var n3 = 0, i4 = function() {
              };
              return { s: i4, n: function() {
                return n3 >= t5.length ? { done: true } : { done: false, value: t5[n3++] };
              }, e: function(t6) {
                throw t6;
              }, f: i4 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var o3, s3 = true, c2 = false;
          return { s: function() {
            r4 = r4.call(t5);
          }, n: function() {
            var t6 = r4.next();
            return s3 = t6.done, t6;
          }, e: function(t6) {
            c2 = true, o3 = t6;
          }, f: function() {
            try {
              s3 || null == r4.return || r4.return();
            } finally {
              if (c2)
                throw o3;
            }
          } };
        }(t4);
        try {
          for (n2.s(); !(r3 = n2.n()).done; ) {
            var i3 = r3.value;
            void 0 !== i3 && this.enumValues.push(this.cast(i3));
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        var o2 = this.enumValues;
        return this.enumValidator = function(t5) {
          return null == t5 || ~o2.indexOf(t5);
        }, this.validators.push({ validator: this.enumValidator, message: e3, type: "enum", enumValues: o2 }), this;
      }, d2.prototype.lowercase = function(t4) {
        var e3 = this;
        return arguments.length > 0 && !t4 ? this : this.set(function(t5) {
          return "string" != typeof t5 && (t5 = e3.cast(t5)), t5 ? t5.toLowerCase() : t5;
        });
      }, d2.prototype.uppercase = function(t4) {
        var e3 = this;
        return arguments.length > 0 && !t4 ? this : this.set(function(t5) {
          return "string" != typeof t5 && (t5 = e3.cast(t5)), t5 ? t5.toUpperCase() : t5;
        });
      }, d2.prototype.trim = function(t4) {
        var e3 = this;
        return arguments.length > 0 && !t4 ? this : this.set(function(t5) {
          return "string" != typeof t5 && (t5 = e3.cast(t5)), t5 ? t5.trim() : t5;
        });
      }, d2.prototype.minlength = function(t4, e3) {
        if (this.minlengthValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.minlengthValidator;
        }, this)), null != t4) {
          var r3 = e3 || c.messages.String.minlength;
          r3 = r3.replace(/{MINLENGTH}/, t4), this.validators.push({ validator: this.minlengthValidator = function(e4) {
            return null === e4 || e4.length >= t4;
          }, message: r3, type: "minlength", minlength: t4 });
        }
        return this;
      }, d2.prototype.minLength = d2.prototype.minlength, d2.prototype.maxlength = function(t4, e3) {
        if (this.maxlengthValidator && (this.validators = this.validators.filter(function(t5) {
          return t5.validator !== this.maxlengthValidator;
        }, this)), null != t4) {
          var r3 = e3 || c.messages.String.maxlength;
          r3 = r3.replace(/{MAXLENGTH}/, t4), this.validators.push({ validator: this.maxlengthValidator = function(e4) {
            return null === e4 || e4.length <= t4;
          }, message: r3, type: "maxlength", maxlength: t4 });
        }
        return this;
      }, d2.prototype.maxLength = d2.prototype.maxlength, d2.prototype.match = function(t4, e3) {
        var r3 = e3 || c.messages.String.match;
        return this.validators.push({ validator: function(e4) {
          return !!t4 && (t4.lastIndex = 0, null == e4 || "" === e4 || t4.test(e4));
        }, message: r3, type: "regexp", regexp: t4 }), this;
      }, d2.prototype.checkRequired = function(t4, e3) {
        return "object" === o(t4) && s2._isRef(this, t4, e3, true) ? null != t4 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : d2.checkRequired())(t4);
      }, d2.prototype.cast = function(t4, e3, r3) {
        if ("string" != typeof t4 && s2._isRef(this, t4, e3, r3))
          return this._castRef(t4, e3, r3);
        var n2;
        n2 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : d2.cast();
        try {
          return n2(t4);
        } catch (e4) {
          throw new p("string", t4, this.path, null, this);
        }
      };
      var m2 = i2(i2({}, s2.prototype.$conditionalHandlers), {}, { $all: function(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return r3.castForQuery(null, t5, e3);
        }) : [this.castForQuery(null, t4, e3)];
      }, $gt: y2, $gte: y2, $lt: y2, $lte: y2, $options: b, $regex: function(t4) {
        return "[object RegExp]" === Object.prototype.toString.call(t4) ? t4 : b.call(this, t4);
      }, $not: y2 });
      Object.defineProperty(d2.prototype, "$conditionalHandlers", { configurable: false, enumerable: false, writable: false, value: Object.freeze(m2) }), d2.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with String.");
          return n2.call(this, e3, r3);
        }
        if ("[object RegExp]" === Object.prototype.toString.call(e3) || h2(e3, "BSONRegExp"))
          return e3;
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof p && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
      }, t3.exports = d2;
    }, 963: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i2(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? n(Object(r3), true).forEach(function(e4) {
            var n2, i3, a2, s3;
            n2 = t4, i3 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != o(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != o(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(i3), (i3 = "symbol" == o(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, i3, { value: a2, enumerable: true, configurable: true, writable: true }) : n2[i3] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : n(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a, s2 = r2(6148), c = r2(3550).EventEmitter, u = r2(2260), f = r2(6271), l = r2(2319), h2 = r2(6690), p = r2(1188), d2 = r2(4111).G, y2 = r2(8650), b = r2(6951), m2 = r2(371), v = r2(5962), g = r2(3920)._, _ = r2(1384), w2 = r2(335), S = r2(9662);
      function O(t4, e3, r3) {
        if (t4.options.timeseries)
          throw new S(e3, "timeseries");
        var n2 = O.defaultOptions && O.defaultOptions._id;
        null != n2 && ((r3 = r3 || {})._id = n2), t4 = v(t4, r3), this.caster = j(t4, null, r3), this.caster.path = e3, this.caster.prototype.$basePath = e3, this.schema = t4, this.$isSingleNested = true, this.base = t4.base, l.call(this, e3, r3, "Embedded");
      }
      function j(t4, e3, n2) {
        a || (a = r2(292));
        var i3 = function(t5, e4, r3) {
          this.$__parent = r3, a.apply(this, arguments), null != r3 && this.$session(r3.$session());
        };
        t4._preCompile();
        var o2 = null != e3 ? e3.prototype : a.prototype;
        for (var s3 in (i3.prototype = Object.create(o2)).$__setSchema(t4), i3.prototype.constructor = i3, i3.$__required = null == n2 ? void 0 : n2.required, i3.base = t4.base, i3.schema = t4, i3.$isSingleNested = true, i3.events = new c(), i3.prototype.toBSON = function() {
          return this.toObject(g);
        }, t4.methods)
          i3.prototype[s3] = t4.methods[s3];
        for (var u2 in t4.statics)
          i3[u2] = t4.statics[u2];
        for (var f2 in c.prototype)
          i3[f2] = c.prototype[f2];
        return i3;
      }
      t3.exports = O, O.prototype = Object.create(l.prototype), O.prototype.constructor = O, O.prototype.OptionsConstructor = f, O.prototype.$conditionalHandlers.$geoWithin = function(t4, e3) {
        return { $geometry: this.castForQuery(null, t4.$geometry, e3) };
      }, O.prototype.$conditionalHandlers.$near = O.prototype.$conditionalHandlers.$nearSphere = b.cast$near, O.prototype.$conditionalHandlers.$within = O.prototype.$conditionalHandlers.$geoWithin = b.cast$within, O.prototype.$conditionalHandlers.$geoIntersects = b.cast$geoIntersects, O.prototype.$conditionalHandlers.$minDistance = d2, O.prototype.$conditionalHandlers.$maxDistance = d2, O.prototype.$conditionalHandlers.$exists = p, O.prototype.cast = function(t4, e3, r3, n2, i3) {
        if (t4 && t4.$isSingleNested && t4.parent === e3)
          return t4;
        if (null != t4 && ("object" !== o(t4) || Array.isArray(t4)))
          throw new u(this.path, t4);
        var a2, s3 = this.schema.path(this.schema.options.discriminatorKey), c2 = null == s3 ? null : s3.getDefault(e3), f2 = m2(this.caster, t4, c2), l2 = e3 && e3.$__ && e3.$__.selected, p2 = this.path, d3 = null == l2 ? null : Object.keys(l2).reduce(function(t5, e4) {
          return e4.startsWith(p2 + ".") && ((t5 = t5 || {})[e4.substring(p2.length + 1)] = l2[e4]), t5;
        }, null);
        if (!r3)
          return i3 = Object.assign({}, i3, { priorDoc: n2 }), 0 === Object.keys(t4).length ? new f2({}, d3, e3, void 0, i3) : new f2(t4, d3, e3, void 0, i3);
        delete (a2 = new f2(void 0, d3, e3, false, { defaults: false })).$__.defaults, a2.$init(t4);
        var y3 = _(d3);
        return h2(a2, d3, y3), a2;
      }, O.prototype.castForQuery = function(t4, e3, r3, n2) {
        var i3;
        if (null != t4) {
          if (!(i3 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4);
          return i3.call(this, e3);
        }
        if (null == e3)
          return e3;
        var o2 = m2(this.caster, e3);
        if (e3 instanceof o2)
          return e3;
        this.options.runSetters && (e3 = this._applySetters(e3, r3));
        var a2 = null != n2 && null != n2.strict ? n2.strict : void 0;
        try {
          e3 = new o2(e3, a2);
        } catch (t5) {
          if (!(t5 instanceof s2))
            throw new s2("Embedded", e3, this.path, t5, this);
          throw t5;
        }
        return e3;
      }, O.prototype.doValidate = function(t4, e3, r3, n2) {
        var i3 = m2(this.caster, t4);
        if (!t4 || t4 instanceof i3 || (t4 = new i3(t4, null, null != r3 && null != r3.$__ ? r3 : null)), n2 && n2.skipSchemaValidators)
          return t4 ? t4.validate().then(function() {
            return e3(null);
          }, function(t5) {
            return e3(t5);
          }) : e3(null);
        l.prototype.doValidate.call(this, t4, function(r4) {
          return r4 ? e3(r4) : t4 ? void t4.validate().then(function() {
            return e3(null);
          }, function(t5) {
            return e3(t5);
          }) : e3(null);
        }, r3, n2);
      }, O.prototype.doValidateSync = function(t4, e3, r3) {
        if (!r3 || !r3.skipSchemaValidators) {
          var n2 = l.prototype.doValidateSync.call(this, t4, e3);
          if (n2)
            return n2;
        }
        if (t4)
          return t4.validateSync();
      }, O.prototype.discriminator = function(t4, e3, r3) {
        r3 = r3 || {};
        var n2 = w2.isPOJO(r3) ? r3.value : r3, i3 = "boolean" != typeof r3.clone || r3.clone;
        return e3.instanceOfSchema && i3 && (e3 = e3.clone()), e3 = y2(this.caster, t4, e3, n2, null, null, r3.overwriteExisting), this.caster.discriminators[t4] = j(e3, this.caster), this.caster.discriminators[t4];
      }, O.defaultOptions = {}, O.set = l.set, O.setters = [], O.get = l.get, O.prototype.toJSON = function() {
        return { path: this.path, options: this.options };
      }, O.prototype.clone = function() {
        var t4 = new this.constructor(this.schema, this.path, i2(i2({}, this.options), {}, { _skipApplyDiscriminators: true }));
        return t4.validators = this.validators.slice(), void 0 !== this.requiredValidator && (t4.requiredValidator = this.requiredValidator), t4.caster.discriminators = Object.assign({}, this.caster.discriminators), t4;
      };
    }, 3089: (t3, e2) => {
      e2.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed"), e2.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
    }, 7245: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      function o(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function a(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? o(Object(r3), true).forEach(function(e4) {
            var n2, o2, a2, s3;
            n2 = t4, o2 = e4, a2 = r3[e4], s3 = function(t5, e5) {
              if ("object" != i2(t5) || !t5)
                return t5;
              var r4 = t5[Symbol.toPrimitive];
              if (void 0 !== r4) {
                var n3 = r4.call(t5, "string");
                if ("object" != i2(n3))
                  return n3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(t5);
            }(o2), (o2 = "symbol" == i2(s3) ? s3 : s3 + "") in n2 ? Object.defineProperty(n2, o2, { value: a2, enumerable: true, configurable: true, writable: true }) : n2[o2] = a2;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : o(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      var s2 = r2(9820), c = r2(2319), u = c.CastError, f = r2(335), l = r2(133), h2 = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i, p = s2.Binary;
      function d2(t4) {
        "string" != typeof t4 && (t4 = "");
        var e3, r3 = null != (e3 = t4.replace(/[{}-]/g, "")) && n.from(e3, "hex"), i3 = new s2(r3);
        return i3._subtype = 4, i3;
      }
      function y2(t4) {
        var e3, r3;
        return "string" != typeof t4 && null != t4 ? (e3 = null != (r3 = t4) && r3.toString("hex")).substring(0, 8) + "-" + e3.substring(8, 12) + "-" + e3.substring(12, 16) + "-" + e3.substring(16, 20) + "-" + e3.substring(20, 32) : t4;
      }
      function b(t4, e3) {
        c.call(this, t4, e3, "UUID"), this.getters.push(function(t5) {
          return null != t5 && null != t5.$__ ? t5 : y2(t5);
        });
      }
      function m2(t4) {
        return this.cast(t4);
      }
      function v(t4) {
        var e3 = this;
        return t4.map(function(t5) {
          return e3.cast(t5);
        });
      }
      b.schemaName = "UUID", b.defaultOptions = {}, b.prototype = Object.create(c.prototype), b.prototype.constructor = b, b._cast = function(t4) {
        if (null == t4)
          return t4;
        function e3(t5) {
          var e4 = new s2(t5);
          return e4._subtype = 4, e4;
        }
        if ("string" == typeof t4) {
          if (h2.test(t4))
            return d2(t4);
          throw new u(b.schemaName, t4, this.path);
        }
        if (n.isBuffer(t4))
          return e3(t4);
        if (t4 instanceof p)
          return e3(t4.value(true));
        if (t4.toString && t4.toString !== Object.prototype.toString && h2.test(t4.toString()))
          return d2(t4.toString());
        throw new u(b.schemaName, t4, this.path);
      }, b.get = c.get, b.set = c.set, b.setters = [], b.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = this._defaultCaster), this._cast = t4), this._cast;
      }, b._checkRequired = function(t4) {
        return null != t4;
      }, b.checkRequired = c.checkRequired, b.prototype.checkRequired = function(t4) {
        return n.isBuffer(t4) && (t4 = y2(t4)), null != t4 && h2.test(t4);
      }, b.prototype.cast = function(t4, e3, r3) {
        if (f.isNonBuiltinObject(t4) && c._isRef(this, t4, e3, r3))
          return this._castRef(t4, e3, r3);
        var n2;
        n2 = "function" == typeof this._castFunction ? this._castFunction : "function" == typeof this.constructor.cast ? this.constructor.cast() : b.cast();
        try {
          return n2(t4);
        } catch (e4) {
          throw new u(b.schemaName, t4, this.path, e4, this);
        }
      }, b.prototype.$conditionalHandlers = a(a({}, c.prototype.$conditionalHandlers), {}, { $bitsAllClear: l, $bitsAnyClear: l, $bitsAllSet: l, $bitsAnySet: l, $all: v, $gt: m2, $gte: m2, $in: v, $lt: m2, $lte: m2, $ne: m2, $nin: v }), b.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4 + " with UUID.");
          return n2.call(this, e3, r3);
        }
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof u && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
      }, t3.exports = b;
    }, 2319: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      var o = r2(9507), a = r2(1e3), s2 = r2(1188), c = r2(3180), u = r2(1829), f = r2(9012), l = r2(6564), h2 = r2(4664), p = r2(3933), d2 = r2(5625).schemaTypeSymbol, y2 = r2(335), b = r2(5625).validatorErrorSymbol, m2 = r2(5625).documentIsModified, v = r2(5625).populateModelSymbol, g = o.CastError, _ = o.ValidatorError, w2 = { _skipMarkModified: true };
      function S(t4, e3, r3) {
        this[d2] = true, this.path = t4, this.instance = r3, this.validators = [], this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [], this.setters = this.constructor.hasOwnProperty("setters") ? this.constructor.setters.slice() : [], this.splitPath(), e3 = e3 || {};
        for (var n2 = this.constructor.defaultOptions || {}, o2 = 0, s3 = Object.keys(n2); o2 < s3.length; o2++) {
          var c2 = s3[o2];
          "validate" === c2 ? this.validate(n2.validate) : n2.hasOwnProperty(c2) && !Object.prototype.hasOwnProperty.call(e3, c2) && (e3[c2] = n2[c2]);
        }
        null == e3.select && delete e3.select;
        var u2 = this.OptionsConstructor || a;
        this.options = new u2(e3), this._index = null, y2.hasUserDefinedProperty(this.options, "immutable") && (this.$immutable = this.options.immutable, f(this));
        for (var l2 = 0, h3 = Object.keys(this.options); l2 < h3.length; l2++) {
          var p2 = h3[l2];
          if ("cast" !== p2) {
            if (y2.hasUserDefinedProperty(this.options, p2) && "function" == typeof this[p2]) {
              if ("index" === p2 && this._index) {
                if (false === e3.index) {
                  var b2 = this._index;
                  if ("object" === i2(b2) && null != b2) {
                    if (b2.unique)
                      throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                    if (b2.sparse)
                      throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                  }
                  this._index = false;
                }
                continue;
              }
              var m3 = e3[p2];
              if ("default" === p2) {
                this.default(m3);
                continue;
              }
              var v2 = Array.isArray(m3) ? m3 : [m3];
              this[p2].apply(this, v2);
            }
          } else
            Array.isArray(this.options[p2]) ? this.castFunction.apply(this, this.options[p2]) : this.castFunction(this.options[p2]);
        }
        Object.defineProperty(this, "$$context", { enumerable: false, configurable: false, writable: true, value: null });
      }
      function O(t4, e3) {
        if (void 0 !== t4 && !t4) {
          var r3 = new (e3.ErrorConstructor || _)(e3);
          return r3[b] = true, r3;
        }
      }
      function j(t4, e3) {
        return this.castForQuery(null, t4, e3);
      }
      function $(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return Array.isArray(t5) && 0 === t5.length ? t5 : r3.castForQuery(null, t5, e3);
        }) : [this.castForQuery(null, t4, e3)];
      }
      S.prototype.OptionsConstructor = a, S.prototype.path, S.prototype.validators, S.prototype.isRequired, S.prototype.splitPath = function() {
        return null != this._presplitPath ? this._presplitPath : null != this.path ? (this._presplitPath = -1 === this.path.indexOf(".") ? [this.path] : this.path.split("."), this._presplitPath) : void 0;
      }, S.cast = function(t4) {
        return 0 === arguments.length || (false === t4 && (t4 = function(t5) {
          return t5;
        }), this._cast = t4), this._cast;
      }, S.prototype.castFunction = function(t4, e3) {
        return 0 === arguments.length ? this._castFunction : (false === t4 && (t4 = this.constructor._defaultCaster || function(t5) {
          return t5;
        }), "string" == typeof t4 ? (this._castErrorMessage = t4, this._castFunction) : (null != t4 && (this._castFunction = t4), null != e3 && (this._castErrorMessage = e3), this._castFunction));
      }, S.prototype.cast = function() {
        throw new Error("Base SchemaType class does not implement a `cast()` function");
      }, S.set = function(t4, e3) {
        this.hasOwnProperty("defaultOptions") || (this.defaultOptions = Object.assign({}, this.defaultOptions)), this.defaultOptions[t4] = e3;
      }, S.get = function(t4) {
        this.getters = this.hasOwnProperty("getters") ? this.getters : [], this.getters.push(t4);
      }, S.prototype.default = function(t4) {
        if (1 === arguments.length) {
          if (void 0 === t4)
            return void (this.defaultValue = void 0);
          if (null != t4 && t4.instanceOfSchema)
            throw new o("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
          return this.defaultValue = t4, this.defaultValue;
        }
        return arguments.length > 1 && (this.defaultValue = Array.prototype.slice.call(arguments)), this.defaultValue;
      }, S.prototype.index = function(t4) {
        return this._index = t4, y2.expires(this._index), this;
      }, S.prototype.unique = function(t4) {
        if (false === this._index) {
          if (!t4)
            return;
          throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
        }
        return this.options.hasOwnProperty("index") || false !== t4 ? (null == this._index || true === this._index ? this._index = {} : "string" == typeof this._index && (this._index = { type: this._index }), this._index.unique = t4, this) : this;
      }, S.prototype.text = function(t4) {
        if (false === this._index) {
          if (!t4)
            return this;
          throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
        }
        return this.options.hasOwnProperty("index") || false !== t4 ? (null === this._index || void 0 === this._index || "boolean" == typeof this._index ? this._index = {} : "string" == typeof this._index && (this._index = { type: this._index }), this._index.text = t4, this) : this;
      }, S.prototype.sparse = function(t4) {
        if (false === this._index) {
          if (!t4)
            return this;
          throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
        }
        return this.options.hasOwnProperty("index") || false !== t4 ? (null == this._index || "boolean" == typeof this._index ? this._index = {} : "string" == typeof this._index && (this._index = { type: this._index }), this._index.sparse = t4, this) : this;
      }, S.prototype.immutable = function(t4) {
        return this.$immutable = t4, f(this), this;
      }, S.prototype.transform = function(t4) {
        return this.options.transform = t4, this;
      }, S.prototype.set = function(t4) {
        if ("function" != typeof t4)
          throw new TypeError("A setter must be a function.");
        return this.setters.push(t4), this;
      }, S.prototype.get = function(t4) {
        if ("function" != typeof t4)
          throw new TypeError("A getter must be a function.");
        return this.getters.push(t4), this;
      }, S.prototype.validateAll = function(t4) {
        for (var e3 = 0; e3 < t4.length; e3++)
          this.validate(t4[e3]);
        return this;
      }, S.prototype.validate = function(t4, e3, r3) {
        var n2, a2, s3, c2;
        if ("function" == typeof t4 || t4 && "RegExp" === y2.getFunctionName(t4.constructor))
          return "function" == typeof e3 ? (n2 = { validator: t4, message: e3 }).type = r3 || "user defined" : e3 instanceof Object && !r3 ? ((n2 = h2(e3) ? Object.assign({}, e3) : u(e3)).message || (n2.message = n2.msg), n2.validator = t4, n2.type = n2.type || "user defined") : (null == e3 && (e3 = o.messages.general.default), r3 || (r3 = "user defined"), n2 = { message: e3, type: r3, validator: t4 }), this.validators.push(n2), this;
        for (a2 = 0, s3 = arguments.length; a2 < s3; a2++) {
          if (c2 = arguments[a2], !y2.isPOJO(c2)) {
            var f2 = "Invalid validator. Received (" + i2(c2) + ") " + c2 + ". See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()";
            throw new Error(f2);
          }
          this.validate(c2.validator, c2);
        }
        return this;
      }, S.prototype.required = function(t4, e3) {
        var r3 = {};
        if (arguments.length > 0 && null == t4)
          return this.validators = this.validators.filter(function(t5) {
            return t5.validator !== this.requiredValidator;
          }, this), this.isRequired = false, delete this.originalRequiredValue, this;
        if ("object" === i2(t4) && (e3 = (r3 = t4).message || e3, t4 = t4.isRequired), false === t4)
          return this.validators = this.validators.filter(function(t5) {
            return t5.validator !== this.requiredValidator;
          }, this), this.isRequired = false, delete this.originalRequiredValue, this;
        var n2 = this;
        this.isRequired = true, this.requiredValidator = function(e4) {
          var r4 = this && this.$__ && this.$__.cachedRequired;
          if (null != r4 && !this.$__isSelected(n2.path) && !this[m2](n2.path))
            return true;
          if (null != r4 && n2.path in r4) {
            var i3 = !r4[n2.path] || n2.checkRequired(e4, this);
            return delete r4[n2.path], i3;
          }
          return "function" == typeof t4 && !t4.apply(this) || n2.checkRequired(e4, this);
        }, this.originalRequiredValue = t4, "string" == typeof t4 && (e3 = t4, t4 = void 0);
        var a2 = e3 || o.messages.general.required;
        return this.validators.unshift(Object.assign({}, r3, { validator: this.requiredValidator, message: a2, type: "required" })), this;
      }, S.prototype.ref = function(t4) {
        return this.options.ref = t4, this;
      }, S.prototype.getDefault = function(t4, e3, r3) {
        var n2;
        if (null != (n2 = "function" == typeof this.defaultValue ? this.defaultValue === Date.now || this.defaultValue === Array || "objectid" === this.defaultValue.name.toLowerCase() ? this.defaultValue.call(t4) : this.defaultValue.call(t4, t4) : this.defaultValue)) {
          if ("object" !== i2(n2) || this.options && this.options.shared || (n2 = u(n2)), r3 && r3.skipCast)
            return this._applySetters(n2, t4);
          var o2 = this.applySetters(n2, t4, e3, void 0, w2);
          return o2 && !Array.isArray(o2) && o2.$isSingleNested && (o2.$__parent = t4), o2;
        }
        return n2;
      }, S.prototype._applySetters = function(t4, e3, r3, n2, i3) {
        var o2 = t4;
        if (r3)
          return o2;
        for (var a2 = this.setters, s3 = a2.length - 1; s3 >= 0; s3--)
          o2 = a2[s3].call(e3, o2, n2, this, i3);
        return o2;
      }, S.prototype._castNullish = function(t4) {
        return t4;
      }, S.prototype.applySetters = function(t4, e3, r3, n2, i3) {
        var o2 = this._applySetters(t4, e3, r3, n2, i3);
        return null == o2 ? this._castNullish(o2) : o2 = this.cast(o2, e3, r3, n2, i3);
      }, S.prototype.applyGetters = function(t4, e3) {
        var r3 = t4, n2 = this.getters, i3 = n2.length;
        if (0 === i3)
          return r3;
        for (var o2 = 0; o2 < i3; ++o2)
          r3 = n2[o2].call(e3, r3, this);
        return r3;
      }, S.prototype.select = function(t4) {
        return this.selected = !!t4, this;
      }, S.prototype.doValidate = function(t4, e3, r3, n2) {
        var o2 = this, a2 = false, s3 = this.path;
        if ("function" != typeof e3)
          throw new TypeError("Must pass callback function to doValidate(), got ".concat(i2(e3)));
        var c2 = this.validators.filter(function(t5) {
          return "object" === i2(t5) && null !== t5;
        }), f2 = c2.length;
        if (!f2)
          return e3(null);
        for (var l2 = function() {
          if (a2)
            return 0;
          var e4, i3 = c2[d3], f3 = i3.validator, l3 = h2(i3) ? Object.assign({}, i3) : u(i3);
          if (l3.path = n2 && n2.path ? n2.path : s3, l3.fullPath = o2.$fullPath, l3.value = t4, f3 instanceof RegExp)
            return m3(f3.test(t4), l3, r3), 1;
          if ("function" != typeof f3)
            return 1;
          if (void 0 === t4 && f3 !== o2.requiredValidator)
            return m3(true, l3, r3), 1;
          try {
            e4 = l3.propsParameter ? f3.call(r3, t4, l3) : f3.call(r3, t4);
          } catch (t5) {
            e4 = false, l3.reason = t5, t5.message && (l3.message = t5.message);
          }
          null != e4 && "function" == typeof e4.then ? e4.then(function(t5) {
            m3(t5, l3, r3);
          }, function(t5) {
            l3.reason = t5, l3.message = t5.message, m3(e4 = false, l3, r3);
          }) : m3(e4, l3, r3);
        }, d3 = 0, y3 = c2.length; d3 < y3 && 0 !== l2(); ++d3)
          ;
        function m3(t5, r4, n3) {
          if (!a2)
            if (void 0 === t5 || t5)
              --f2 <= 0 && p(function() {
                e3(null);
              });
            else {
              var i3 = r4.ErrorConstructor || _;
              (a2 = new i3(r4, n3))[b] = true, p(function() {
                e3(a2);
              });
            }
        }
      }, S.prototype.doValidateSync = function(t4, e3, r3) {
        var n2 = this.path;
        if (!this.validators.length)
          return null;
        var o2 = this.validators;
        if (void 0 === t4) {
          if (0 === this.validators.length || "required" !== this.validators[0].type)
            return null;
          o2 = [this.validators[0]];
        }
        var a2 = null, s3 = 0, c2 = o2.length;
        for (s3 = 0; s3 < c2; ++s3) {
          var f2 = o2[s3];
          if (null !== f2 && "object" === i2(f2)) {
            var p2 = f2.validator, d3 = h2(f2) ? Object.assign({}, f2) : u(f2);
            d3.path = r3 && r3.path ? r3.path : n2, d3.fullPath = this.$fullPath, d3.value = t4;
            var y3 = false;
            if (!l(p2)) {
              if (p2 instanceof RegExp)
                a2 = O(p2.test(t4), d3);
              else if ("function" == typeof p2) {
                try {
                  y3 = d3.propsParameter ? p2.call(e3, t4, d3) : p2.call(e3, t4);
                } catch (t5) {
                  y3 = false, d3.reason = t5;
                }
                if ((null == y3 || "function" != typeof y3.then) && (a2 = O(y3, d3)))
                  break;
              }
            }
          }
        }
        return a2;
      }, S._isRef = function(t4, e3, r3, i3) {
        var o2 = i3 && t4.options && (t4.options.ref || t4.options.refPath);
        if (!o2 && r3 && null != r3.$__) {
          var a2 = r3.$__fullPath(t4.path, true), s3 = r3.ownerDocument();
          o2 = null != a2 && s3.$populated(a2) || r3.$populated(t4.path);
        }
        return !!o2 && (null == e3 || !(n.isBuffer(e3) || "Binary" === e3._bsontype || !y2.isObject(e3)) || i3);
      }, S.prototype._castRef = function(t4, e3, r3) {
        if (null == t4)
          return t4;
        if (null != t4.$__)
          return t4.$__.wasPopulated = t4.$__.wasPopulated || { value: t4._id }, t4;
        if (n.isBuffer(t4) || !y2.isObject(t4)) {
          if (r3)
            return t4;
          throw new g(this.instance, t4, this.path, null, this);
        }
        var i3 = e3.$__fullPath(this.path, true), o2 = e3.ownerDocument().$populated(i3, true), a2 = t4;
        return e3.$__.populated && e3.$__.populated[i3] && e3.$__.populated[i3].options && e3.$__.populated[i3].options.options && e3.$__.populated[i3].options.options.lean || ((a2 = new o2.options[v](t4)).$__.wasPopulated = { value: a2._id }), a2;
      }, S.prototype.$conditionalHandlers = { $all: function(t4, e3) {
        var r3 = this;
        return Array.isArray(t4) ? t4.map(function(t5) {
          return r3.castForQuery(null, t5, e3);
        }) : [this.castForQuery(null, t4, e3)];
      }, $eq: j, $in: $, $ne: j, $nin: $, $exists: s2, $type: c }, S.prototype.castForQuery = function(t4, e3, r3) {
        var n2;
        if (null != t4) {
          if (!(n2 = this.$conditionalHandlers[t4]))
            throw new Error("Can't use " + t4);
          return n2.call(this, e3, r3);
        }
        try {
          return this.applySetters(e3, r3);
        } catch (t5) {
          throw t5 instanceof g && t5.path === this.path && null != this.$fullPath && (t5.path = this.$fullPath), t5;
        }
      }, S.checkRequired = function(t4) {
        return 0 !== arguments.length && (this._checkRequired = t4), this._checkRequired;
      }, S.prototype.checkRequired = function(t4) {
        return null != t4;
      }, S.prototype.clone = function() {
        var t4 = Object.assign({}, this.options), e3 = new this.constructor(this.path, t4, this.instance);
        return e3.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e3.requiredValidator = this.requiredValidator), void 0 !== this.defaultValue && (e3.defaultValue = this.defaultValue), void 0 !== this.$immutable && void 0 === this.options.immutable && (e3.$immutable = this.$immutable, f(e3)), void 0 !== this._index && (e3._index = this._index), void 0 !== this.selected && (e3.selected = this.selected), void 0 !== this.isRequired && (e3.isRequired = this.isRequired), void 0 !== this.originalRequiredValue && (e3.originalRequiredValue = this.originalRequiredValue), e3.getters = this.getters.slice(), e3.setters = this.setters.slice(), e3;
      }, t3.exports = e2 = S, e2.CastError = g, e2.ValidatorError = _;
    }, 4494: (t3, e2, r2) => {
      r2(335);
      var n = t3.exports = function() {
      };
      n.ctor = function() {
        var t4 = Array.prototype.slice.call(arguments), e3 = function() {
          n.apply(this, arguments), this.paths = {}, this.states = {};
        };
        return (e3.prototype = new n()).stateNames = t4, t4.forEach(function(t5) {
          e3.prototype[t5] = function(e4) {
            this._changeState(e4, t5);
          };
        }), e3;
      }, n.prototype._changeState = function(t4, e3) {
        var r3 = this.paths[t4];
        if (r3 !== e3) {
          var n2 = this.states[r3];
          n2 && delete n2[t4], this.paths[t4] = e3, this.states[e3] = this.states[e3] || {}, this.states[e3][t4] = true;
        }
      }, n.prototype.clear = function(t4) {
        if (null != this.states[t4])
          for (var e3, r3 = Object.keys(this.states[t4]), n2 = r3.length; n2--; )
            e3 = r3[n2], delete this.states[t4][e3], delete this.paths[e3];
      }, n.prototype.clearPath = function(t4) {
        var e3 = this.paths[t4];
        e3 && (delete this.paths[t4], delete this.states[e3][t4]);
      }, n.prototype.getStatePaths = function(t4) {
        return null != this.states[t4] ? this.states[t4] : {};
      }, n.prototype.some = function() {
        var t4 = this, e3 = arguments.length ? arguments : this.stateNames;
        return Array.prototype.some.call(e3, function(e4) {
          return null != t4.states[e4] && Object.keys(t4.states[e4]).length;
        });
      }, n.prototype._iter = function(t4) {
        return function() {
          var e3 = Array.prototype.slice.call(arguments), r3 = e3.pop();
          e3.length || (e3 = this.stateNames);
          var n2 = this;
          return e3.reduce(function(t5, e4) {
            return null == n2.states[e4] ? t5 : t5.concat(Object.keys(n2.states[e4]));
          }, [])[t4](function(t5, e4, n3) {
            return r3(t5, e4, n3);
          });
        };
      }, n.prototype.forEach = function() {
        return this.forEach = this._iter("forEach"), this.forEach.apply(this, arguments);
      }, n.prototype.map = function() {
        return this.map = this._iter("map"), this.map.apply(this, arguments);
      };
    }, 2918: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        var i3;
        return i3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (void 0 !== r4) {
            var i4 = r4.call(t5, "string");
            if ("object" != n(i4))
              return i4;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(e3), (e3 = "symbol" == n(i3) ? i3 : i3 + "") in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var o = r2(3293), a = r2(9987), s2 = r2(5625).arrayAtomicsSymbol, c = r2(5625).arrayAtomicsBackupSymbol, u = r2(5625).arrayParentSymbol, f = r2(5625).arrayPathSymbol, l = r2(5625).arraySchemaSymbol, h2 = Array.prototype.push, p = /^\d+$/;
      t3.exports = function(t4, e3, r3, n2) {
        var d2;
        if (Array.isArray(t4)) {
          var y2 = t4.length;
          if (0 === y2)
            d2 = new Array();
          else if (1 === y2)
            (d2 = new Array(1))[0] = t4[0];
          else if (y2 < 1e4)
            d2 = new Array(), h2.apply(d2, t4);
          else {
            d2 = new Array();
            for (var b = 0; b < y2; ++b)
              h2.call(d2, t4[b]);
          }
        } else
          d2 = [];
        var m2 = i2(i2(i2(i2(i2(i2(i2(i2({}, s2, {}), c, void 0), f, e3), l, n2), u, void 0), "isMongooseArray", true), "isMongooseArrayProxy", true), "__array", d2);
        t4 && null != t4[s2] && (m2[s2] = t4[s2]), null != r3 && r3 instanceof o && (m2[u] = r3, m2[l] = n2 || r3.schema.path(e3));
        var v = new Proxy(d2, { get: function(t5, e4) {
          return m2.hasOwnProperty(e4) ? m2[e4] : a.hasOwnProperty(e4) ? a[e4] : "string" == typeof e4 && p.test(e4) && null != (null == n2 ? void 0 : n2.$embeddedSchemaType) ? n2.$embeddedSchemaType.applyGetters(d2[e4], r3) : d2[e4];
        }, set: function(t5, e4, r4) {
          return "string" == typeof e4 && p.test(e4) ? a.set.call(v, e4, r4, false) : m2.hasOwnProperty(e4) ? m2[e4] = r4 : d2[e4] = r4, true;
        } });
        return v;
      };
    }, 9240: (t3, e2) => {
      e2.isMongooseArray = function(t4) {
        return Array.isArray(t4) && t4.isMongooseArray;
      };
    }, 9987: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, i2(t4);
      }
      function o(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = a(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, o2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw o2;
          }
        } };
      }
      function a(t4, e3) {
        if (t4) {
          if ("string" == typeof t4)
            return s2(t4, e3);
          var r3 = Object.prototype.toString.call(t4).slice(8, -1);
          return "Object" === r3 && t4.constructor && (r3 = t4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? s2(t4, e3) : void 0;
        }
      }
      function s2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var c = r2(3293), u = r2(8578), f = r2(7026), l = r2(8208), h2 = r2(1829), p = r2(3920)._, d2 = r2(5678), y2 = r2(335), b = r2(2128), m2 = r2(5625).arrayAtomicsSymbol, v = r2(5625).arrayParentSymbol, g = r2(5625).arrayPathSymbol, _ = r2(5625).arraySchemaSymbol, w2 = r2(5625).populateModelSymbol, S = Symbol("mongoose#Array#sliced"), O = Array.prototype.push, j = { $__getAtomics: function() {
        var t4 = [], e3 = Object.keys(this[m2] || {}), r3 = e3.length, n2 = Object.assign({}, p, { _isNested: true });
        if (0 === r3)
          return t4[0] = ["$set", this.toObject(n2)], t4;
        for (; r3--; ) {
          var i3 = e3[r3], o2 = this[m2][i3];
          y2.isMongooseObject(o2) ? o2 = o2.toObject(n2) : Array.isArray(o2) ? o2 = this.toObject.call(o2, n2) : null != o2 && Array.isArray(o2.$each) ? o2.$each = this.toObject.call(o2.$each, n2) : null != o2 && "function" == typeof o2.valueOf && (o2 = o2.valueOf()), "$addToSet" === i3 && (o2 = { $each: o2 }), t4.push([i3, o2]);
        }
        return t4;
      }, $atomics: function() {
        return this[m2];
      }, $parent: function() {
        return this[v];
      }, $path: function() {
        return this[g];
      }, $shift: function() {
        this._registerAtomic("$pop", -1), this._markModified();
        var t4 = this.__array;
        if (!t4._shifted)
          return t4._shifted = true, [].shift.call(t4);
      }, $pop: function() {
        if (this._registerAtomic("$pop", 1), this._markModified(), !this._popped)
          return this._popped = true, [].pop.call(this);
      }, $schema: function() {
        return this[_];
      }, _cast: function(t4) {
        var e3, r3 = false, i3 = this[v];
        if (i3 && (r3 = i3.$populated(this[g], true)), r3 && null != t4) {
          if (null == (e3 = r3.options[w2]))
            throw new f("No populated model found for path `" + this[g] + "`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.");
          return (n.isBuffer(t4) || b(t4, "ObjectId") || !y2.isObject(t4)) && (t4 = { _id: t4 }), t4.schema && t4.schema.discriminatorMapping && void 0 !== t4.schema.discriminatorMapping.key || (t4 = new e3(t4)), this[_].caster.applySetters(t4, i3, true);
        }
        return this[_].caster.applySetters(t4, i3, false);
      }, _mapCast: function(t4, e3) {
        return this._cast(t4, this.length + e3);
      }, _markModified: function(t4) {
        var e3, r3 = this[v];
        if (r3) {
          if (e3 = this[g], arguments.length && (e3 = e3 + "." + t4), null != e3 && e3.endsWith(".$"))
            return this;
          r3.markModified(e3, 0 !== arguments.length ? t4 : r3);
        }
        return this;
      }, _registerAtomic: function(t4, e3) {
        if (!this[S]) {
          if ("$set" === t4)
            return this[m2] = { $set: e3 }, l(this[v], this[g]), this._markModified(), this;
          var r3, n2 = this[m2];
          if ("$pop" === t4 && !("$pop" in n2)) {
            var i3 = this;
            this[v].once("save", function() {
              i3._popped = i3._shifted = null;
            });
          }
          if (n2.$set || Object.keys(n2).length && !(t4 in n2))
            return this[m2] = { $set: this }, this;
          if ("$pullAll" === t4 || "$addToSet" === t4)
            n2[t4] || (n2[t4] = []), n2[t4] = n2[t4].concat(e3);
          else if ("$pullDocs" === t4) {
            var c2 = n2.$pull || (n2.$pull = {});
            e3[0] instanceof u ? (r3 = c2.$or || (c2.$or = []), Array.prototype.push.apply(r3, e3.map(function(t5) {
              return t5.toObject({ transform: function(e4, r4) {
                return null == t5 || null == t5.$__ || Object.keys(t5.$__.activePaths.getStatePaths("default")).forEach(function(t6) {
                  d2.unset(t6, r4), $(r4, t6);
                }), r4;
              }, virtuals: false });
            }))) : (r3 = c2._id || (c2._id = { $in: [] })).$in = r3.$in.concat(e3);
          } else if ("$push" === t4)
            if (n2.$push = n2.$push || { $each: [] }, null != e3 && y2.hasUserDefinedProperty(e3, "$each"))
              n2.$push = e3;
            else if (1 === e3.length)
              n2.$push.$each.push(e3[0]);
            else if (e3.length < 1e4) {
              var f2;
              (f2 = n2.$push.$each).push.apply(f2, function(t5) {
                if (Array.isArray(t5))
                  return s2(t5);
              }(_2 = e3) || function(t5) {
                if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
                  return Array.from(t5);
              }(_2) || a(_2) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }());
            } else {
              var h3, p2 = o(e3);
              try {
                for (p2.s(); !(h3 = p2.n()).done; ) {
                  var b2 = h3.value;
                  n2.$push.$each.push(b2);
                }
              } catch (t5) {
                p2.e(t5);
              } finally {
                p2.f();
              }
            }
          else
            n2[t4] = e3;
          return this;
        }
        var _2;
      }, addToSet: function() {
        A(this, arguments);
        var t4 = [].map.call(arguments, this._mapCast, this), e3 = [], r3 = "";
        t4[0] instanceof u ? r3 = "doc" : t4[0] instanceof Date ? r3 = "date" : b(t4[0], "ObjectId") && (r3 = "ObjectId");
        var n2 = y2.isMongooseArray(t4) ? t4.__array : t4, i3 = y2.isMongooseArray(this) ? this.__array : this;
        return n2.forEach(function(t5) {
          var n3, o2 = +t5;
          switch (r3) {
            case "doc":
              n3 = this.some(function(e4) {
                return e4.equals(t5);
              });
              break;
            case "date":
              n3 = this.some(function(t6) {
                return +t6 === o2;
              });
              break;
            case "ObjectId":
              n3 = this.find(function(e4) {
                return e4.toString() === t5.toString();
              });
              break;
            default:
              n3 = ~this.indexOf(t5);
          }
          n3 || (this._markModified(), i3.push(t5), this._registerAtomic("$addToSet", t5), [].push.call(e3, t5));
        }, this), e3;
      }, hasAtomics: function() {
        return y2.isPOJO(this[m2]) ? Object.keys(this[m2]).length : 0;
      }, includes: function(t4, e3) {
        return -1 !== this.indexOf(t4, e3);
      }, indexOf: function(t4, e3) {
        b(t4, "ObjectId") && (t4 = t4.toString()), e3 = null == e3 ? 0 : e3;
        for (var r3 = this.length, n2 = e3; n2 < r3; ++n2)
          if (t4 == this[n2])
            return n2;
        return -1;
      }, inspect: function() {
        return JSON.stringify(this);
      }, nonAtomicPush: function() {
        var t4 = [].map.call(arguments, this._mapCast, this);
        this._markModified();
        var e3 = [].push.apply(this, t4);
        return this._registerAtomic("$set", this), e3;
      }, pop: function() {
        this._markModified();
        var t4 = [].pop.call(this);
        return this._registerAtomic("$set", this), t4;
      }, pull: function() {
        var t4, e3 = this, r3 = [].map.call(arguments, function(t5, r4) {
          return e3._cast(t5, r4, { defaults: false });
        }, this), n2 = this[v].get(this[g]), i3 = n2.length;
        for (this._markModified(); i3--; )
          (t4 = n2[i3]) instanceof c ? r3.some(function(e4) {
            return t4.equals(e4);
          }) && [].splice.call(n2, i3, 1) : ~n2.indexOf.call(r3, t4) && [].splice.call(n2, i3, 1);
        return r3[0] instanceof u ? this._registerAtomic("$pullDocs", r3.map(function(t5) {
          var e4 = t5.$__getValue("_id");
          return void 0 === e4 || t5.$isDefault("_id") ? t5 : e4;
        })) : this._registerAtomic("$pullAll", r3), l(this[v], this[g]) > 0 && this._registerAtomic("$set", this), this;
      }, push: function() {
        var t4, e3 = arguments, r3 = e3, n2 = null != e3[0] && y2.hasUserDefinedProperty(e3[0], "$each"), i3 = y2.isMongooseArray(this) ? this.__array : this;
        if (n2 && (r3 = e3[0], e3 = e3[0].$each), null == this[_])
          return O.apply(this, e3);
        A(this, e3), e3 = [].map.call(e3, this._mapCast, this);
        var o2 = this[m2];
        return this._markModified(), n2 ? (r3.$each = e3, 0 !== (o2.$push && o2.$push.$each && o2.$push.$each.length || 0) && o2.$push.$position != r3.$position ? (null != r3.$position ? ([].splice.apply(i3, [r3.$position, 0].concat(e3)), t4 = i3.length) : t4 = [].push.apply(i3, e3), this._registerAtomic("$set", this)) : null != r3.$position ? ([].splice.apply(i3, [r3.$position, 0].concat(e3)), t4 = this.length) : t4 = [].push.apply(i3, e3)) : (r3 = e3, t4 = O.apply(i3, e3)), this._registerAtomic("$push", r3), t4;
      }, remove: function() {
        return this.pull.apply(this, arguments);
      }, set: function(t4, e3, r3) {
        var n2 = this.__array;
        if (r3)
          return n2[t4] = e3, this;
        var i3 = j._cast.call(this, e3, t4);
        return j._markModified.call(this, t4), n2[t4] = i3, this;
      }, shift: function() {
        var t4 = y2.isMongooseArray(this) ? this.__array : this;
        this._markModified();
        var e3 = [].shift.call(t4);
        return this._registerAtomic("$set", this), e3;
      }, sort: function() {
        var t4 = y2.isMongooseArray(this) ? this.__array : this, e3 = [].sort.apply(t4, arguments);
        return this._registerAtomic("$set", this), e3;
      }, splice: function() {
        var t4, e3 = y2.isMongooseArray(this) ? this.__array : this;
        if (this._markModified(), A(this, Array.prototype.slice.call(arguments, 2)), arguments.length) {
          var r3;
          if (null == this[_])
            r3 = arguments;
          else {
            r3 = [];
            for (var n2 = 0; n2 < arguments.length; ++n2)
              r3[n2] = n2 < 2 ? arguments[n2] : this._cast(arguments[n2], arguments[0] + (n2 - 2));
          }
          t4 = [].splice.apply(e3, r3), this._registerAtomic("$set", this);
        }
        return t4;
      }, toBSON: function() {
        return this.toObject(p);
      }, toObject: function(t4) {
        var e3 = y2.isMongooseArray(this) ? this.__array : this;
        return t4 && t4.depopulate ? ((t4 = h2(t4))._isNested = true, [].concat(e3).map(function(e4) {
          return e4 instanceof c ? e4.toObject(t4) : e4;
        })) : [].concat(e3);
      }, $toObject: function() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      }, unshift: function() {
        var t4;
        A(this, arguments), t4 = null == this[_] ? arguments : [].map.call(arguments, this._cast, this);
        var e3 = y2.isMongooseArray(this) ? this.__array : this;
        return this._markModified(), [].unshift.apply(e3, t4), this._registerAtomic("$set", this), this.length;
      } };
      function $(t4, e3, r3) {
        if ("string" == typeof e3) {
          if (-1 === e3.indexOf("."))
            return;
          e3 = d2.stringToParts(e3);
        }
        (r3 = r3 || 0) >= e3.length || null != t4 && "object" === i2(t4) && ($(t4[e3[0]], e3, r3 + 1), null != t4[e3[0]] && "object" === i2(t4[e3[0]]) && 0 === Object.keys(t4[e3[0]]).length && delete t4[e3[0]]);
      }
      function A(t4, e3) {
        var r3, n2, a2, s3, u2 = null == t4 ? null : t4[_] && t4[_].caster && t4[_].caster.options && t4[_].caster.options.ref || null;
        0 === t4.length && 0 !== e3.length && function(t5, e4) {
          if (!e4)
            return false;
          var r4, n3 = o(t5);
          try {
            for (n3.s(); !(r4 = n3.n()).done; ) {
              var i3 = r4.value;
              if (null == i3)
                return false;
              var a3 = i3.constructor;
              if (!(i3 instanceof c) || a3.modelName !== e4 && a3.baseModelName !== e4)
                return false;
            }
          } catch (t6) {
            n3.e(t6);
          } finally {
            n3.f();
          }
          return true;
        }(e3, u2) && t4[v].$populated(t4[g], [], (r3 = {}, n2 = w2, a2 = e3[0].constructor, s3 = function(t5, e4) {
          if ("object" != i2(t5) || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (void 0 !== r4) {
            var n3 = r4.call(t5, "string");
            if ("object" != i2(n3))
              return n3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(n2), (n2 = "symbol" == i2(s3) ? s3 : s3 + "") in r3 ? Object.defineProperty(r3, n2, { value: a2, enumerable: true, configurable: true, writable: true }) : r3[n2] = a2, r3));
      }
      for (var E = function() {
        var t4 = P[x];
        if (null == Array.prototype[t4])
          return 1;
        j[t4] = function() {
          var e3 = y2.isMongooseArray(this) ? this.__array : this, r3 = [].concat(e3);
          return r3[t4].apply(r3, arguments);
        };
      }, x = 0, P = ["filter", "flat", "flatMap", "map", "slice"]; x < P.length; x++)
        E();
      t3.exports = j;
    }, 8578: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function i2(t4, e3, r3) {
        return e3 = function(t5) {
          var e4 = function(t6, e5) {
            if ("object" != o(t6) || !t6)
              return t6;
            var r4 = t6[Symbol.toPrimitive];
            if (void 0 !== r4) {
              var n2 = r4.call(t6, "string");
              if ("object" != o(n2))
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return "symbol" == o(e4) ? e4 : e4 + "";
        }(e3), e3 in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a = r2(3550).EventEmitter, s2 = r2(292), c = r2(335), u = r2(5625).documentArrayParent;
      function f(t4, e3, r3, a2, f2) {
        var l2;
        c.isMongooseDocumentArray(e3) ? (this.__parentArray = e3, this[u] = e3.$parent()) : (this.__parentArray = void 0, this[u] = void 0), this.$setIndex(f2), this.$__parent = this[u], "object" === o(r3) && null != r3 ? (l2 = function(t5) {
          for (var e4 = 1; e4 < arguments.length; e4++) {
            var r4 = null != arguments[e4] ? arguments[e4] : {};
            e4 % 2 ? n(Object(r4), true).forEach(function(e5) {
              i2(t5, e5, r4[e5]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t5, Object.getOwnPropertyDescriptors(r4)) : n(Object(r4)).forEach(function(e5) {
              Object.defineProperty(t5, e5, Object.getOwnPropertyDescriptor(r4, e5));
            });
          }
          return t5;
        }({ isNew: true }, r3), r3 = void 0) : l2 = { isNew: true }, s2.call(this, t4, a2, this[u], r3, l2);
      }
      for (var l in f.prototype = Object.create(s2.prototype), f.prototype.constructor = f, Object.defineProperty(f.prototype, "$isSingleNested", { configurable: false, writable: false, value: false }), Object.defineProperty(f.prototype, "$isDocumentArrayElement", { configurable: false, writable: false, value: true }), a.prototype)
        f[l] = a.prototype[l];
      f.prototype.$setIndex = function(t4) {
        if (this.__index = t4, null != this.$__ && null != this.$__.validationError)
          for (var e3 = 0, r3 = Object.keys(this.$__.validationError.errors); e3 < r3.length; e3++) {
            var n2 = r3[e3];
            this.invalidate(n2, this.$__.validationError.errors[n2]);
          }
      }, f.prototype.populate = function() {
        throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
      }, f.prototype.$__removeFromParent = function() {
        var t4 = this._doc._id;
        if (!t4)
          throw new Error("For your own good, Mongoose does not know how to remove an ArraySubdocument that has no _id");
        this.__parentArray.pull({ _id: t4 });
      }, f.prototype.$__fullPath = function(t4, e3) {
        return null == this.__index ? null : (this.$__.fullPath || this.ownerDocument(), e3 ? t4 ? this.$__.fullPath + "." + t4 : this.$__.fullPath : t4 ? this.$__.fullPath + "." + this.__index + "." + t4 : this.$__.fullPath + "." + this.__index);
      }, f.prototype.$__pathRelativeToParent = function(t4, e3) {
        return null != this.__index && this.__parentArray && this.__parentArray.$path ? e3 ? null == t4 ? this.__parentArray.$path() : this.__parentArray.$path() + "." + t4 : null == t4 ? this.__parentArray.$path() + "." + this.__index : this.__parentArray.$path() + "." + this.__index + "." + t4 : null;
      }, f.prototype.$parent = function() {
        return this[u];
      }, f.prototype.parentArray = function() {
        return this.__parentArray;
      }, t3.exports = f;
    }, 9820: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(3633).Binary, o = r2(335);
      function a(t4, e3, r3) {
        var i3, s3, u, f, l = t4;
        return null == t4 && (l = 0), Array.isArray(e3) ? (s3 = e3[0], u = e3[1]) : i3 = e3, f = "number" == typeof l || l instanceof Number ? n.alloc(l) : n.from(l, i3, r3), o.decorate(f, a.mixin), f.isMongooseBuffer = true, f[a.pathSymbol] = s3, f[c] = u, f._subtype = 0, f;
      }
      var s2 = Symbol.for("mongoose#Buffer#_path"), c = Symbol.for("mongoose#Buffer#_parent");
      a.pathSymbol = s2, a.mixin = { _subtype: void 0, _markModified: function() {
        var t4 = this[c];
        return t4 && t4.markModified(this[a.pathSymbol]), this;
      }, write: function() {
        var t4 = n.prototype.write.apply(this, arguments);
        return t4 > 0 && this._markModified(), t4;
      }, copy: function(t4) {
        var e3 = n.prototype.copy.apply(this, arguments);
        return t4 && t4.isMongooseBuffer && t4._markModified(), e3;
      } }, o.each(["writeUInt8", "writeUInt16", "writeUInt32", "writeInt8", "writeInt16", "writeInt32", "writeFloat", "writeDouble", "fill", "utf8Write", "binaryWrite", "asciiWrite", "set", "writeUInt16LE", "writeUInt16BE", "writeUInt32LE", "writeUInt32BE", "writeInt16LE", "writeInt16BE", "writeInt32LE", "writeInt32BE", "writeFloatLE", "writeFloatBE", "writeDoubleLE", "writeDoubleBE"], function(t4) {
        n.prototype[t4] && (a.mixin[t4] = function() {
          var e3 = n.prototype[t4].apply(this, arguments);
          return this._markModified(), e3;
        });
      }), a.mixin.toObject = function(t4) {
        var e3 = "number" == typeof t4 ? t4 : this._subtype || 0;
        return new i2(n.from(this), e3);
      }, a.mixin.$toObject = a.mixin.toObject, a.mixin.toBSON = function() {
        return new i2(this, this._subtype || 0);
      }, a.mixin.equals = function(t4) {
        if (!n.isBuffer(t4))
          return false;
        if (this.length !== t4.length)
          return false;
        for (var e3 = 0; e3 < this.length; ++e3)
          if (this[e3] !== t4[e3])
            return false;
        return true;
      }, a.mixin.subtype = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Invalid subtype. Expected a number");
        this._subtype !== t4 && this._markModified(), this._subtype = t4;
      }, a.Binary = i2, t3.exports = a;
    }, 9394: (t3, e2, r2) => {
      t3.exports = r2(3633).Decimal128;
    }, 4941: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        var i3;
        return i3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r4 = t5[Symbol.toPrimitive];
          if (void 0 !== r4) {
            var i4 = r4.call(t5, "string");
            if ("object" != n(i4))
              return i4;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(e3), (e3 = "symbol" == n(i3) ? i3 : i3 + "") in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var o = r2(9987), a = r2(1520), s2 = r2(3293), c = r2(5625).arrayAtomicsSymbol, u = r2(5625).arrayAtomicsBackupSymbol, f = r2(5625).arrayParentSymbol, l = r2(5625).arrayPathSymbol, h2 = r2(5625).arraySchemaSymbol, p = Array.prototype.push, d2 = /^\d+$/;
      t3.exports = function(t4, e3, r3) {
        var n2 = [], y2 = i2(i2(i2(i2(i2({}, c, {}), u, void 0), l, e3), h2, void 0), f, void 0);
        if (Array.isArray(t4) && (t4[l] === e3 && t4[f] === r3 && (y2[c] = Object.assign({}, t4[c])), t4.forEach(function(t5) {
          p.call(n2, t5);
        })), y2[l] = e3, y2.__array = n2, r3 && r3 instanceof s2)
          for (y2[f] = r3, y2[h2] = r3.$__schema.path(e3); null != y2[h2] && y2[h2].$isMongooseArray && !y2[h2].$isMongooseDocumentArray; )
            y2[h2] = y2[h2].casterConstructor;
        var b = new Proxy(n2, { get: function(t5, e4) {
          return "isMongooseArray" === e4 || "isMongooseArrayProxy" === e4 || "isMongooseDocumentArray" === e4 || "isMongooseDocumentArrayProxy" === e4 || (y2.hasOwnProperty(e4) ? y2[e4] : a.hasOwnProperty(e4) ? a[e4] : o.hasOwnProperty(e4) ? o[e4] : n2[e4]);
        }, set: function(t5, e4, r4) {
          return "string" == typeof e4 && d2.test(e4) ? a.set.call(b, e4, r4, false) : y2.hasOwnProperty(e4) ? y2[e4] = r4 : n2[e4] = r4, true;
        } });
        return b;
      };
    }, 3640: (t3, e2) => {
      e2.isMongooseDocumentArray = function(t4) {
        return Array.isArray(t4) && t4.isMongooseDocumentArray;
      };
    }, 1520: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return o(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function o(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var a = r2(9987), s2 = r2(3293), c = r2(8092), u = r2(7785), f = r2(3920)._, l = r2(335), h2 = r2(2128), p = r2(5625).arrayParentSymbol, d2 = r2(5625).arrayPathSymbol, y2 = r2(5625).arraySchemaSymbol, b = r2(5625).documentArrayParent, m2 = Array.prototype.toString, v = { toBSON: function() {
        return this.toObject(f);
      }, toString: function() {
        return m2.call(this.__array.map(function(t4) {
          return null != t4 && null != t4.$__ ? t4.toString() : t4;
        }));
      }, getArrayParent: function() {
        return this[p];
      }, _cast: function(t4, e3, r3) {
        if (null == this[y2])
          return t4;
        var i3 = this[y2].casterConstructor;
        if ((i3.$isMongooseDocumentArray ? l.isMongooseDocumentArray(t4) : t4 instanceof i3) || t4 && t4.constructor && t4.constructor.baseCasterConstructor === i3)
          return t4[b] && t4.__parentArray || (t4[b] = this[p], t4.__parentArray = this), t4.$setIndex(e3), t4;
        if (null == t4)
          return null;
        if ((n.isBuffer(t4) || h2(t4, "ObjectId") || !l.isObject(t4)) && (t4 = { _id: t4 }), t4 && i3.discriminators && i3.schema && i3.schema.options && i3.schema.options.discriminatorKey)
          if ("string" == typeof t4[i3.schema.options.discriminatorKey] && i3.discriminators[t4[i3.schema.options.discriminatorKey]])
            i3 = i3.discriminators[t4[i3.schema.options.discriminatorKey]];
          else {
            var o2 = u(i3.discriminators, t4[i3.schema.options.discriminatorKey]);
            o2 && (i3 = o2);
          }
        if (i3.$isMongooseDocumentArray)
          return i3.cast(t4, this, void 0, void 0, e3);
        var a2 = new i3(t4, this, r3, void 0, e3);
        return a2.isNew = true, a2;
      }, id: function(t4) {
        var e3, r3, n2;
        try {
          e3 = c(t4).toString();
        } catch (t5) {
          e3 = null;
        }
        var o2, a2 = i2(this);
        try {
          for (a2.s(); !(o2 = a2.n()).done; ) {
            var u2 = o2.value;
            if (u2 && null != (n2 = u2.get("_id"))) {
              if (n2 instanceof s2) {
                if (r3 || (r3 = String(t4)), r3 == n2._id)
                  return u2;
              } else if (h2(t4, "ObjectId") || h2(n2, "ObjectId")) {
                if (e3 == n2)
                  return u2;
              } else if (t4 == n2 || l.deepEqual(t4, n2))
                return u2;
            }
          }
        } catch (t5) {
          a2.e(t5);
        } finally {
          a2.f();
        }
        return null;
      }, toObject: function(t4) {
        return [].concat(this.map(function(e3) {
          return null == e3 ? null : "function" != typeof e3.toObject ? e3 : e3.toObject(t4);
        }));
      }, $toObject: function() {
        return this.constructor.prototype.toObject.apply(this, arguments);
      }, push: function() {
        var t4 = a.push.apply(this, arguments);
        return g(this), t4;
      }, pull: function() {
        var t4 = a.pull.apply(this, arguments);
        return g(this), t4;
      }, shift: function() {
        var t4 = a.shift.apply(this, arguments);
        return g(this), t4;
      }, splice: function() {
        var t4 = a.splice.apply(this, arguments);
        return g(this), t4;
      }, inspect: function() {
        return this.toObject();
      }, create: function(t4) {
        var e3 = this[y2].casterConstructor;
        if (t4 && e3.discriminators && e3.schema && e3.schema.options && e3.schema.options.discriminatorKey)
          if ("string" == typeof t4[e3.schema.options.discriminatorKey] && e3.discriminators[t4[e3.schema.options.discriminatorKey]])
            e3 = e3.discriminators[t4[e3.schema.options.discriminatorKey]];
          else {
            var r3 = u(e3.discriminators, t4[e3.schema.options.discriminatorKey]);
            r3 && (e3 = r3);
          }
        return new e3(t4, this);
      }, notify: function(t4) {
        var e3 = this;
        return function r3(n2, i3) {
          for (var o2 = (i3 = i3 || e3).length; o2--; )
            null != i3[o2] && ("save" === t4 && (n2 = e3[o2]), l.isMongooseArray(i3[o2]) ? r3(n2, i3[o2]) : i3[o2] && i3[o2].emit(t4, n2));
        };
      }, set: function(t4, e3, r3) {
        var n2 = this.__array;
        if (r3)
          return n2[t4] = e3, this;
        var i3 = v._cast.call(this, e3, t4);
        return v._markModified.call(this, t4), n2[t4] = i3, this;
      }, _markModified: function(t4, e3) {
        var r3, n2 = this[p];
        if (n2) {
          if (r3 = this[d2], arguments.length && (r3 = null != e3 ? r3 + "." + t4.__index + "." + e3 : r3 + "." + t4), null != r3 && r3.endsWith(".$"))
            return this;
          n2.markModified(r3, 0 !== arguments.length ? t4 : n2);
        }
        return this;
      } };
      function g(t4) {
        var e3 = t4[p];
        if (e3 && null != e3.$__.populated) {
          var r3, n2 = i2(Object.keys(e3.$__.populated).filter(function(e4) {
            return e4.startsWith(t4[d2] + ".");
          }));
          try {
            var o2 = function() {
              var n3 = r3.value, i3 = n3.slice((t4[d2] + ".").length);
              if (!Array.isArray(e3.$__.populated[n3].value))
                return 1;
              e3.$__.populated[n3].value = t4.map(function(t5) {
                return t5.$populated(i3);
              });
            };
            for (n2.s(); !(r3 = n2.n()).done; )
              o2();
          } catch (t5) {
            n2.e(t5);
          } finally {
            n2.f();
          }
        }
      }
      t3.exports = v;
    }, 1148: (t3, e2, r2) => {
      e2.Array = r2(2918), e2.Buffer = r2(9820), e2.Document = e2.Embedded = r2(8578), e2.DocumentArray = r2(4941), e2.Decimal128 = r2(9394), e2.ObjectId = r2(6704), e2.Map = r2(4902), e2.Subdocument = r2(292), e2.UUID = r2(2417);
    }, 4902: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return o(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function o(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function a(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, s2(n2.key), n2);
        }
      }
      function s2(t4) {
        var e3 = function(t5, e4) {
          if ("object" != n(t5) || !t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" != n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" == n(e3) ? e3 : e3 + "";
      }
      function c() {
        return c = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t4, e3, r3) {
          var n2 = function(t5, e4) {
            for (; !Object.prototype.hasOwnProperty.call(t5, e4) && null !== (t5 = h2(t5)); )
              ;
            return t5;
          }(t4, e3);
          if (n2) {
            var i3 = Object.getOwnPropertyDescriptor(n2, e3);
            return i3.get ? i3.get.call(arguments.length < 3 ? t4 : r3) : i3.value;
          }
        }, c.apply(this, arguments);
      }
      function u(t4) {
        var e3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return u = function(t5) {
          if (null === t5 || !function(t6) {
            try {
              return -1 !== Function.toString.call(t6).indexOf("[native code]");
            } catch (e4) {
              return "function" == typeof t6;
            }
          }(t5))
            return t5;
          if ("function" != typeof t5)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e3) {
            if (e3.has(t5))
              return e3.get(t5);
            e3.set(t5, r3);
          }
          function r3() {
            return function(t6, e4, r4) {
              if (f())
                return Reflect.construct.apply(null, arguments);
              var n2 = [null];
              n2.push.apply(n2, e4);
              var i3 = new (t6.bind.apply(t6, n2))();
              return r4 && l(i3, r4.prototype), i3;
            }(t5, arguments, h2(this).constructor);
          }
          return r3.prototype = Object.create(t5.prototype, { constructor: { value: r3, enumerable: false, writable: true, configurable: true } }), l(r3, t5);
        }, u(t4);
      }
      function f() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (f = function() {
          return !!t4;
        })();
      }
      function l(t4, e3) {
        return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, l(t4, e3);
      }
      function h2(t4) {
        return h2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, h2(t4);
      }
      var p = r2(1895), d2 = r2(7026), y2 = r2(1829), b = r2(335).deepEqual, m2 = r2(5857), v = r2(8145), g = r2(7352), _ = r2(8150), w2 = r2(2128), S = r2(5625).populateModelSymbol, O = function(t4) {
        function e3(t5, r4, i3, o3) {
          var a2, s3, c2, u2;
          return function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), "Object" === m2(t5) && (t5 = Object.keys(t5).reduce(function(e4, r5) {
            return e4.concat([[r5, t5[r5]]]);
          }, [])), (s3 = this, c2 = e3, u2 = [t5], c2 = h2(c2), a2 = function(t6, e4) {
            if (e4 && ("object" === n(e4) || "function" == typeof e4))
              return e4;
            if (void 0 !== e4)
              throw new TypeError("Derived constructors may only return object or undefined");
            return function(t7) {
              if (void 0 === t7)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t7;
            }(t6);
          }(s3, f() ? Reflect.construct(c2, u2 || [], h2(s3).constructor) : c2.apply(s3, u2))).$__parent = null != i3 && null != i3.$__ ? i3 : null, a2.$__path = r4, a2.$__schemaType = null == o3 ? new p(r4) : o3, a2.$__runDeferred(), a2;
        }
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e4 && l(t5, e4);
        }(e3, t4), r3 = e3, o2 = [{ key: "$init", value: function(t5, r4) {
          j(t5), c(h2(e3.prototype), "set", this).call(this, t5, r4), null != r4 && r4.$isSingleNested && (r4.$basePath = this.$__path + "." + t5);
        } }, { key: "$__set", value: function(t5, r4) {
          c(h2(e3.prototype), "set", this).call(this, t5, r4);
        } }, { key: "get", value: function(t5, r4) {
          return w2(t5, "ObjectId") && (t5 = t5.toString()), false === (r4 = r4 || {}).getters ? c(h2(e3.prototype), "get", this).call(this, t5) : this.$__schemaType.applyGetters(c(h2(e3.prototype), "get", this).call(this, t5), this.$__parent);
        } }, { key: "set", value: function(t5, r4) {
          if (w2(t5, "ObjectId") && (t5 = t5.toString()), j(t5), r4 = v(r4), null == this.$__schemaType)
            return this.$__deferred = this.$__deferred || [], void this.$__deferred.push({ key: t5, value: r4 });
          var n2, i3 = this.$__parent, o3 = null != i3 && i3.$__ && i3.$__.populated ? i3.$populated(u2.call(this), true) || i3.$populated(this.$__path, true) : null, a2 = this.get(t5);
          if (null != o3) {
            if (this.$__schemaType.$isSingleNested)
              throw new d2("Cannot manually populate single nested subdoc underneath Map " + 'at path "'.concat(this.$__path, '". Try using an array instead of a Map.'));
            Array.isArray(r4) && this.$__schemaType.$isMongooseArray ? r4 = r4.map(function(t6) {
              return null == t6.$__ && (t6 = new o3.options[S](t6)), t6.$__.wasPopulated = { value: t6._id }, t6;
            }) : (null == r4.$__ && (r4 = new o3.options[S](r4)), r4.$__.wasPopulated = { value: r4._id });
          } else
            try {
              var s3 = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ? { path: u2.call(this) } : null;
              r4 = this.$__schemaType.applySetters(r4, this.$__parent, false, this.get(t5), s3);
            } catch (t6) {
              if (null != this.$__parent && null != this.$__parent.$__)
                return void this.$__parent.invalidate(u2.call(this), t6);
              throw t6;
            }
          function u2() {
            return n2 || (n2 = this.$__path + "." + t5);
          }
          c(h2(e3.prototype), "set", this).call(this, t5, r4), null == i3 || null == i3.$__ || b(r4, a2) || i3.markModified(u2.call(this));
        } }, { key: "clear", value: function() {
          c(h2(e3.prototype), "clear", this).call(this);
          var t5 = this.$__parent;
          null != t5 && t5.markModified(this.$__path);
        } }, { key: "delete", value: function(t5) {
          return w2(t5, "ObjectId") && (t5 = t5.toString()), this.set(t5, void 0), c(h2(e3.prototype), "delete", this).call(this, t5);
        } }, { key: "toBSON", value: function() {
          return new Map(this);
        } }, { key: "toObject", value: function(t5) {
          if (t5 && t5.flattenMaps) {
            var e4, r4 = {}, n2 = i2(this.keys());
            try {
              for (n2.s(); !(e4 = n2.n()).done; ) {
                var o3 = e4.value;
                r4[o3] = y2(this.get(o3), t5);
              }
            } catch (t6) {
              n2.e(t6);
            } finally {
              n2.f();
            }
            return r4;
          }
          return new Map(this);
        } }, { key: "$toObject", value: function() {
          return this.constructor.prototype.toObject.apply(this, arguments);
        } }, { key: "toJSON", value: function(t5) {
          if ("boolean" != typeof (t5 && t5.flattenMaps) || t5.flattenMaps) {
            var e4, r4 = {}, n2 = i2(this.keys());
            try {
              for (n2.s(); !(e4 = n2.n()).done; ) {
                var o3 = e4.value;
                r4[o3] = y2(this.get(o3), t5);
              }
            } catch (t6) {
              n2.e(t6);
            } finally {
              n2.f();
            }
            return r4;
          }
          return new Map(this);
        } }, { key: "inspect", value: function() {
          return new Map(this);
        } }, { key: "$__runDeferred", value: function() {
          if (this.$__deferred) {
            var t5, e4 = i2(this.$__deferred);
            try {
              for (e4.s(); !(t5 = e4.n()).done; ) {
                var r4 = t5.value;
                this.set(r4.key, r4.value);
              }
            } catch (t6) {
              e4.e(t6);
            } finally {
              e4.f();
            }
            this.$__deferred = null;
          }
        } }], o2 && a(r3.prototype, o2), Object.defineProperty(r3, "prototype", { writable: false }), r3;
        var r3, o2;
      }(u(Map));
      function j(t4) {
        var e3 = n(t4);
        if ("string" !== e3)
          throw new TypeError("Mongoose maps only support string keys, got ".concat(e3));
        if (t4.startsWith("$"))
          throw new Error('Mongoose maps do not support keys that start with "$", got "'.concat(t4, '"'));
        if (t4.includes("."))
          throw new Error('Mongoose maps do not support keys that contain ".", got "'.concat(t4, '"'));
        if (_.has(t4))
          throw new Error('Mongoose maps do not support reserved key name "'.concat(t4, '"'));
      }
      g.inspect.custom && Object.defineProperty(O.prototype, g.inspect.custom, { enumerable: false, writable: false, configurable: false, value: O.prototype.inspect }), Object.defineProperty(O.prototype, "$__set", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(O.prototype, "$__parent", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(O.prototype, "$__path", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(O.prototype, "$__schemaType", { enumerable: false, writable: true, configurable: false }), Object.defineProperty(O.prototype, "$isMongooseMap", { enumerable: false, writable: false, configurable: false, value: true }), Object.defineProperty(O.prototype, "$__deferredCalls", { enumerable: false, writable: false, configurable: false, value: true }), t3.exports = O;
    }, 6704: (t3, e2, r2) => {
      var n = r2(3633).ObjectId, i2 = r2(5625).objectIdSymbol;
      Object.defineProperty(n.prototype, "_id", { enumerable: false, configurable: true, get: function() {
        return this;
      } }), n.prototype.hasOwnProperty("valueOf") || (n.prototype.valueOf = function() {
        return this.toString();
      }), n.prototype[i2] = true, t3.exports = n;
    }, 292: (t3, e2, r2) => {
      function n() {
        n = function() {
          return e3;
        };
        var t4, e3 = {}, r3 = Object.prototype, i3 = r3.hasOwnProperty, a2 = Object.defineProperty || function(t5, e4, r4) {
          t5[e4] = r4.value;
        }, s3 = "function" == typeof Symbol ? Symbol : {}, c2 = s3.iterator || "@@iterator", u2 = s3.asyncIterator || "@@asyncIterator", f2 = s3.toStringTag || "@@toStringTag";
        function l2(t5, e4, r4) {
          return Object.defineProperty(t5, e4, { value: r4, enumerable: true, configurable: true, writable: true }), t5[e4];
        }
        try {
          l2({}, "");
        } catch (t5) {
          l2 = function(t6, e4, r4) {
            return t6[e4] = r4;
          };
        }
        function h2(t5, e4, r4, n2) {
          var i4 = e4 && e4.prototype instanceof g ? e4 : g, o2 = Object.create(i4.prototype), s4 = new I(n2 || []);
          return a2(o2, "_invoke", { value: x(t5, r4, s4) }), o2;
        }
        function p(t5, e4, r4) {
          try {
            return { type: "normal", arg: t5.call(e4, r4) };
          } catch (t6) {
            return { type: "throw", arg: t6 };
          }
        }
        e3.wrap = h2;
        var d2 = "suspendedStart", y2 = "suspendedYield", b = "executing", m2 = "completed", v = {};
        function g() {
        }
        function _() {
        }
        function w2() {
        }
        var S = {};
        l2(S, c2, function() {
          return this;
        });
        var O = Object.getPrototypeOf, j = O && O(O(B([])));
        j && j !== r3 && i3.call(j, c2) && (S = j);
        var $ = w2.prototype = g.prototype = Object.create(S);
        function A(t5) {
          ["next", "throw", "return"].forEach(function(e4) {
            l2(t5, e4, function(t6) {
              return this._invoke(e4, t6);
            });
          });
        }
        function E(t5, e4) {
          function r4(n3, a3, s4, c3) {
            var u3 = p(t5[n3], t5, a3);
            if ("throw" !== u3.type) {
              var f3 = u3.arg, l3 = f3.value;
              return l3 && "object" == o(l3) && i3.call(l3, "__await") ? e4.resolve(l3.__await).then(function(t6) {
                r4("next", t6, s4, c3);
              }, function(t6) {
                r4("throw", t6, s4, c3);
              }) : e4.resolve(l3).then(function(t6) {
                f3.value = t6, s4(f3);
              }, function(t6) {
                return r4("throw", t6, s4, c3);
              });
            }
            c3(u3.arg);
          }
          var n2;
          a2(this, "_invoke", { value: function(t6, i4) {
            function o2() {
              return new e4(function(e5, n3) {
                r4(t6, i4, e5, n3);
              });
            }
            return n2 = n2 ? n2.then(o2, o2) : o2();
          } });
        }
        function x(e4, r4, n2) {
          var i4 = d2;
          return function(o2, a3) {
            if (i4 === b)
              throw Error("Generator is already running");
            if (i4 === m2) {
              if ("throw" === o2)
                throw a3;
              return { value: t4, done: true };
            }
            for (n2.method = o2, n2.arg = a3; ; ) {
              var s4 = n2.delegate;
              if (s4) {
                var c3 = P(s4, n2);
                if (c3) {
                  if (c3 === v)
                    continue;
                  return c3;
                }
              }
              if ("next" === n2.method)
                n2.sent = n2._sent = n2.arg;
              else if ("throw" === n2.method) {
                if (i4 === d2)
                  throw i4 = m2, n2.arg;
                n2.dispatchException(n2.arg);
              } else
                "return" === n2.method && n2.abrupt("return", n2.arg);
              i4 = b;
              var u3 = p(e4, r4, n2);
              if ("normal" === u3.type) {
                if (i4 = n2.done ? m2 : y2, u3.arg === v)
                  continue;
                return { value: u3.arg, done: n2.done };
              }
              "throw" === u3.type && (i4 = m2, n2.method = "throw", n2.arg = u3.arg);
            }
          };
        }
        function P(e4, r4) {
          var n2 = r4.method, i4 = e4.iterator[n2];
          if (i4 === t4)
            return r4.delegate = null, "throw" === n2 && e4.iterator.return && (r4.method = "return", r4.arg = t4, P(e4, r4), "throw" === r4.method) || "return" !== n2 && (r4.method = "throw", r4.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), v;
          var o2 = p(i4, e4.iterator, r4.arg);
          if ("throw" === o2.type)
            return r4.method = "throw", r4.arg = o2.arg, r4.delegate = null, v;
          var a3 = o2.arg;
          return a3 ? a3.done ? (r4[e4.resultName] = a3.value, r4.next = e4.nextLoc, "return" !== r4.method && (r4.method = "next", r4.arg = t4), r4.delegate = null, v) : a3 : (r4.method = "throw", r4.arg = new TypeError("iterator result is not an object"), r4.delegate = null, v);
        }
        function k(t5) {
          var e4 = { tryLoc: t5[0] };
          1 in t5 && (e4.catchLoc = t5[1]), 2 in t5 && (e4.finallyLoc = t5[2], e4.afterLoc = t5[3]), this.tryEntries.push(e4);
        }
        function M(t5) {
          var e4 = t5.completion || {};
          e4.type = "normal", delete e4.arg, t5.completion = e4;
        }
        function I(t5) {
          this.tryEntries = [{ tryLoc: "root" }], t5.forEach(k, this), this.reset(true);
        }
        function B(e4) {
          if (e4 || "" === e4) {
            var r4 = e4[c2];
            if (r4)
              return r4.call(e4);
            if ("function" == typeof e4.next)
              return e4;
            if (!isNaN(e4.length)) {
              var n2 = -1, a3 = function r5() {
                for (; ++n2 < e4.length; )
                  if (i3.call(e4, n2))
                    return r5.value = e4[n2], r5.done = false, r5;
                return r5.value = t4, r5.done = true, r5;
              };
              return a3.next = a3;
            }
          }
          throw new TypeError(o(e4) + " is not iterable");
        }
        return _.prototype = w2, a2($, "constructor", { value: w2, configurable: true }), a2(w2, "constructor", { value: _, configurable: true }), _.displayName = l2(w2, f2, "GeneratorFunction"), e3.isGeneratorFunction = function(t5) {
          var e4 = "function" == typeof t5 && t5.constructor;
          return !!e4 && (e4 === _ || "GeneratorFunction" === (e4.displayName || e4.name));
        }, e3.mark = function(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, w2) : (t5.__proto__ = w2, l2(t5, f2, "GeneratorFunction")), t5.prototype = Object.create($), t5;
        }, e3.awrap = function(t5) {
          return { __await: t5 };
        }, A(E.prototype), l2(E.prototype, u2, function() {
          return this;
        }), e3.AsyncIterator = E, e3.async = function(t5, r4, n2, i4, o2) {
          void 0 === o2 && (o2 = Promise);
          var a3 = new E(h2(t5, r4, n2, i4), o2);
          return e3.isGeneratorFunction(r4) ? a3 : a3.next().then(function(t6) {
            return t6.done ? t6.value : a3.next();
          });
        }, A($), l2($, f2, "Generator"), l2($, c2, function() {
          return this;
        }), l2($, "toString", function() {
          return "[object Generator]";
        }), e3.keys = function(t5) {
          var e4 = Object(t5), r4 = [];
          for (var n2 in e4)
            r4.push(n2);
          return r4.reverse(), function t6() {
            for (; r4.length; ) {
              var n3 = r4.pop();
              if (n3 in e4)
                return t6.value = n3, t6.done = false, t6;
            }
            return t6.done = true, t6;
          };
        }, e3.values = B, I.prototype = { constructor: I, reset: function(e4) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t4, this.done = false, this.delegate = null, this.method = "next", this.arg = t4, this.tryEntries.forEach(M), !e4)
            for (var r4 in this)
              "t" === r4.charAt(0) && i3.call(this, r4) && !isNaN(+r4.slice(1)) && (this[r4] = t4);
        }, stop: function() {
          this.done = true;
          var t5 = this.tryEntries[0].completion;
          if ("throw" === t5.type)
            throw t5.arg;
          return this.rval;
        }, dispatchException: function(e4) {
          if (this.done)
            throw e4;
          var r4 = this;
          function n2(n3, i4) {
            return s4.type = "throw", s4.arg = e4, r4.next = n3, i4 && (r4.method = "next", r4.arg = t4), !!i4;
          }
          for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
            var a3 = this.tryEntries[o2], s4 = a3.completion;
            if ("root" === a3.tryLoc)
              return n2("end");
            if (a3.tryLoc <= this.prev) {
              var c3 = i3.call(a3, "catchLoc"), u3 = i3.call(a3, "finallyLoc");
              if (c3 && u3) {
                if (this.prev < a3.catchLoc)
                  return n2(a3.catchLoc, true);
                if (this.prev < a3.finallyLoc)
                  return n2(a3.finallyLoc);
              } else if (c3) {
                if (this.prev < a3.catchLoc)
                  return n2(a3.catchLoc, true);
              } else {
                if (!u3)
                  throw Error("try statement without catch or finally");
                if (this.prev < a3.finallyLoc)
                  return n2(a3.finallyLoc);
              }
            }
          }
        }, abrupt: function(t5, e4) {
          for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
            var n2 = this.tryEntries[r4];
            if (n2.tryLoc <= this.prev && i3.call(n2, "finallyLoc") && this.prev < n2.finallyLoc) {
              var o2 = n2;
              break;
            }
          }
          o2 && ("break" === t5 || "continue" === t5) && o2.tryLoc <= e4 && e4 <= o2.finallyLoc && (o2 = null);
          var a3 = o2 ? o2.completion : {};
          return a3.type = t5, a3.arg = e4, o2 ? (this.method = "next", this.next = o2.finallyLoc, v) : this.complete(a3);
        }, complete: function(t5, e4) {
          if ("throw" === t5.type)
            throw t5.arg;
          return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && e4 && (this.next = e4), v;
        }, finish: function(t5) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r4 = this.tryEntries[e4];
            if (r4.finallyLoc === t5)
              return this.complete(r4.completion, r4.afterLoc), M(r4), v;
          }
        }, catch: function(t5) {
          for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
            var r4 = this.tryEntries[e4];
            if (r4.tryLoc === t5) {
              var n2 = r4.completion;
              if ("throw" === n2.type) {
                var i4 = n2.arg;
                M(r4);
              }
              return i4;
            }
          }
          throw Error("illegal catch attempt");
        }, delegateYield: function(e4, r4, n2) {
          return this.delegate = { iterator: B(e4), resultName: r4, nextLoc: n2 }, "next" === this.method && (this.arg = t4), v;
        } }, e3;
      }
      function i2(t4, e3, r3, n2, i3, o2, a2) {
        try {
          var s3 = t4[o2](a2), c2 = s3.value;
        } catch (t5) {
          return void r3(t5);
        }
        s3.done ? e3(c2) : Promise.resolve(c2).then(n2, i3);
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, o(t4);
      }
      var a = r2(3293), s2 = r2(3933), c = r2(3920)._, u = r2(7352), f = r2(335);
      function l(t4, e3, r3, n2, i3) {
        if ("object" === o(n2) && null != n2 && null == i3 && (i3 = n2, n2 = void 0), null != r3) {
          var s3 = { isNew: r3.isNew };
          "defaults" in r3.$__ && (s3.defaults = r3.$__.defaults), i3 = Object.assign(s3, i3);
        }
        null != i3 && null != i3.path && (this.$basePath = i3.path), a.call(this, t4, e3, n2, i3), delete this.$__.priorDoc;
      }
      t3.exports = l, l.prototype = Object.create(a.prototype), Object.defineProperty(l.prototype, "$isSubdocument", { configurable: false, writable: false, value: true }), Object.defineProperty(l.prototype, "$isSingleNested", { configurable: false, writable: false, value: true }), l.prototype.toBSON = function() {
        return this.toObject(c);
      }, l.prototype.save = function() {
        var t4, e3 = (t4 = n().mark(function t5(e4) {
          var r3 = this;
          return n().wrap(function(t6) {
            for (; ; )
              switch (t6.prev = t6.next) {
                case 0:
                  return (e4 = e4 || {}).suppressWarning || f.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app."), t6.abrupt("return", new Promise(function(t7, e5) {
                    r3.$__save(function(n2) {
                      if (null != n2)
                        return e5(n2);
                      t7(r3);
                    });
                  }));
                case 3:
                case "end":
                  return t6.stop();
              }
          }, t5);
        }), function() {
          var e4 = this, r3 = arguments;
          return new Promise(function(n2, o2) {
            var a2 = t4.apply(e4, r3);
            function s3(t5) {
              i2(a2, n2, o2, s3, c2, "next", t5);
            }
            function c2(t5) {
              i2(a2, n2, o2, s3, c2, "throw", t5);
            }
            s3(void 0);
          });
        });
        return function(t5) {
          return e3.apply(this, arguments);
        };
      }(), l.prototype.$__fullPath = function(t4) {
        return this.$__.fullPath || this.ownerDocument(), t4 ? this.$__.fullPath + "." + t4 : this.$__.fullPath;
      }, l.prototype.$__pathRelativeToParent = function(t4) {
        return null == t4 ? this.$basePath : [this.$basePath, t4].join(".");
      }, l.prototype.$__save = function(t4) {
        var e3 = this;
        return s2(function() {
          return t4(null, e3);
        });
      }, l.prototype.$isValid = function(t4) {
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        return null != e3 && null != r3 ? e3.$isValid(r3) : a.prototype.$isValid.call(this, t4);
      }, l.prototype.markModified = function(t4) {
        a.prototype.markModified.call(this, t4);
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        if (null != e3 && null != r3) {
          var n2 = this.$__pathRelativeToParent().replace(/\.$/, "");
          e3.isDirectModified(n2) || this.isNew || this.$__parent.markModified(r3, this);
        }
      }, l.prototype.isModified = function(t4, e3, r3) {
        var n2 = this, i3 = this.$parent();
        return null != i3 ? (Array.isArray(t4) || "string" == typeof t4 ? t4 = (t4 = Array.isArray(t4) ? t4 : t4.split(" ")).map(function(t5) {
          return n2.$__pathRelativeToParent(t5);
        }).filter(function(t5) {
          return null != t5;
        }) : t4 || (t4 = this.$__pathRelativeToParent()), i3.$isModified(t4, e3, r3)) : a.prototype.isModified.call(this, t4, e3, r3);
      }, l.prototype.$markValid = function(t4) {
        a.prototype.$markValid.call(this, t4);
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        null != e3 && null != r3 && e3.$markValid(r3);
      }, l.prototype.invalidate = function(t4, e3, r3) {
        a.prototype.invalidate.call(this, t4, e3, r3);
        var n2 = this.$parent(), i3 = this.$__pathRelativeToParent(t4);
        if (null != n2 && null != i3)
          n2.invalidate(i3, e3, r3);
        else if ("cast" === e3.kind || "CastError" === e3.name || null == i3)
          throw e3;
        return this.ownerDocument().$__.validationError;
      }, l.prototype.$ignore = function(t4) {
        a.prototype.$ignore.call(this, t4);
        var e3 = this.$parent(), r3 = this.$__pathRelativeToParent(t4);
        null != e3 && null != r3 && e3.$ignore(r3);
      }, l.prototype.ownerDocument = function() {
        if (this.$__.ownerDocument)
          return this.$__.ownerDocument;
        for (var t4 = this, e3 = [], r3 = /* @__PURE__ */ new Set([t4]); "function" == typeof t4.$__pathRelativeToParent; ) {
          e3.unshift(t4.$__pathRelativeToParent(void 0, true));
          var n2 = t4.$parent();
          if (null == n2)
            break;
          if (t4 = n2, r3.has(t4))
            throw new Error("Infinite subdocument loop: subdoc with _id " + t4._id + " is a parent of itself");
          r3.add(t4);
        }
        return this.$__.fullPath = e3.join("."), this.$__.ownerDocument = t4, this.$__.ownerDocument;
      }, l.prototype.$__fullPathWithIndexes = function() {
        for (var t4 = this, e3 = [], r3 = /* @__PURE__ */ new Set([t4]); "function" == typeof t4.$__pathRelativeToParent; ) {
          e3.unshift(t4.$__pathRelativeToParent(void 0, false));
          var n2 = t4.$parent();
          if (null == n2)
            break;
          if (t4 = n2, r3.has(t4))
            throw new Error("Infinite subdocument loop: subdoc with _id " + t4._id + " is a parent of itself");
          r3.add(t4);
        }
        return e3.join(".");
      }, l.prototype.parent = function() {
        return this.$__parent;
      }, l.prototype.$parent = l.prototype.parent, l.prototype.$__deleteOne = function(t4) {
        if (null != t4)
          return t4(null, this);
      }, l.prototype.$__removeFromParent = function() {
        this.$__parent.set(this.$basePath, null);
      }, l.prototype.deleteOne = function(t4, e3) {
        return "function" == typeof t4 && (e3 = t4, t4 = null), function(t5) {
          var e4 = t5.ownerDocument();
          function r3() {
            e4.$removeListener("save", r3), e4.$removeListener("deleteOne", r3), t5.emit("deleteOne", t5), t5.constructor.emit("deleteOne", t5), e4 = t5 = null;
          }
          e4.$on("save", r3), e4.$on("deleteOne", r3);
        }(this), t4 && t4.noop || this.$__removeFromParent(), this.$__deleteOne(e3);
      }, l.prototype.populate = function() {
        throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
      }, l.prototype.inspect = function() {
        return this.toObject();
      }, u.inspect.custom && (l.prototype[u.inspect.custom] = l.prototype.inspect);
    }, 2417: (t3, e2, r2) => {
      t3.exports = r2(3633).UUID;
    }, 335: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      function i2(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return o(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? o(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, i3 = function() {
            };
            return { s: i3, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: i3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function o(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function a(t4) {
        return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, a(t4);
      }
      var s2, c = r2(3633).UUID, u = r2(354), f = r2(5678), l = r2(6704), h2 = r2(6591), p = r2(1829), d2 = r2(3933), y2 = r2(4797), b = r2(9240), m2 = r2(3640), v = r2(2128), g = r2(5515), _ = r2(6504), w2 = r2(8183), S = r2(5682), O = r2(8150), j = r2(3692).trustedSymbol;
      e2.specialProperties = O, e2.isMongooseArray = b.isMongooseArray, e2.isMongooseDocumentArray = m2.isMongooseDocumentArray, e2.registerMongooseArray = b.registerMongooseArray, e2.registerMongooseDocumentArray = m2.registerMongooseDocumentArray;
      var $ = /\s/, A = /\s+/;
      e2.toCollectionName = function(t4, e3) {
        return "system.profile" === t4 || "system.indexes" === t4 ? t4 : "function" == typeof e3 ? e3(t4) : t4;
      }, e2.deepEqual = function t4(r3, i3) {
        if (r3 === i3)
          return true;
        if ("object" !== a(r3) || "object" !== a(i3))
          return r3 === i3;
        if (r3 instanceof Date && i3 instanceof Date)
          return r3.getTime() === i3.getTime();
        if (v(r3, "ObjectId") && v(i3, "ObjectId") || v(r3, "Decimal128") && v(i3, "Decimal128"))
          return r3.toString() === i3.toString();
        if (r3 instanceof RegExp && i3 instanceof RegExp)
          return r3.source === i3.source && r3.ignoreCase === i3.ignoreCase && r3.multiline === i3.multiline && r3.global === i3.global && r3.dotAll === i3.dotAll && r3.unicode === i3.unicode && r3.sticky === i3.sticky && r3.hasIndices === i3.hasIndices;
        if (null == r3 || null == i3)
          return false;
        if (r3.prototype !== i3.prototype)
          return false;
        if (r3 instanceof Map || i3 instanceof Map)
          return r3 instanceof Map && i3 instanceof Map && t4(Array.from(r3.keys()), Array.from(i3.keys())) && t4(Array.from(r3.values()), Array.from(i3.values()));
        if (r3 instanceof Number && i3 instanceof Number)
          return r3.valueOf() === i3.valueOf();
        if (n.isBuffer(r3))
          return e2.buffer.areEqual(r3, i3);
        if (Array.isArray(r3) || Array.isArray(i3)) {
          if (!Array.isArray(r3) || !Array.isArray(i3))
            return false;
          var o2 = r3.length;
          if (o2 !== i3.length)
            return false;
          for (var s3 = 0; s3 < o2; ++s3)
            if (!t4(r3[s3], i3[s3]))
              return false;
          return true;
        }
        null != r3.$__ ? r3 = r3._doc : _(r3) && (r3 = r3.toObject()), null != i3.$__ ? i3 = i3._doc : _(i3) && (i3 = i3.toObject());
        var c2 = Object.keys(r3), u2 = Object.keys(i3), f2 = c2.length;
        if (f2 !== u2.length)
          return false;
        for (var l2 = f2 - 1; l2 >= 0; l2--)
          if (c2[l2] !== u2[l2])
            return false;
        for (var h3 = 0, p2 = c2; h3 < p2.length; h3++) {
          var d3 = p2[h3];
          if (!t4(r3[d3], i3[d3]))
            return false;
        }
        return true;
      }, e2.last = function(t4) {
        if (t4.length > 0)
          return t4[t4.length - 1];
      }, e2.promiseOrCallback = w2, e2.cloneArrays = function(t4) {
        return Array.isArray(t4) ? t4.map(function(t5) {
          return e2.cloneArrays(t5);
        }) : t4;
      }, e2.omit = function(t4, e3) {
        if (null == e3)
          return Object.assign({}, t4);
        Array.isArray(e3) || (e3 = [e3]);
        var r3, n2 = Object.assign({}, t4), o2 = i2(e3);
        try {
          for (o2.s(); !(r3 = o2.n()).done; )
            delete n2[r3.value];
        } catch (t5) {
          o2.e(t5);
        } finally {
          o2.f();
        }
        return n2;
      }, e2.merge = function t4(r3, n2, i3, o2) {
        i3 = i3 || {};
        var a2, s3 = Object.keys(n2), c2 = 0, u2 = s3.length;
        n2[j] && (r3[j] = n2[j]), o2 = o2 || "";
        for (var f2 = i3.omitNested || {}; c2 < u2; )
          if (a2 = s3[c2++], !(i3.omit && i3.omit[a2] || f2[o2] || O.has(a2)))
            if (null == r3[a2])
              r3[a2] = n2[a2];
            else if (e2.isObject(n2[a2])) {
              if (e2.isObject(r3[a2]) || (r3[a2] = {}), null != n2[a2]) {
                if (i3.isDiscriminatorSchemaMerge && n2[a2].$isSingleNested && r3[a2].$isMongooseDocumentArray || n2[a2].$isMongooseDocumentArray && r3[a2].$isSingleNested)
                  continue;
                if (n2[a2].instanceOfSchema) {
                  r3[a2].instanceOfSchema ? S(r3[a2], n2[a2].clone(), i3.isDiscriminatorSchemaMerge) : r3[a2] = n2[a2].clone();
                  continue;
                }
                if (v(n2[a2], "ObjectId")) {
                  r3[a2] = new l(n2[a2]);
                  continue;
                }
              }
              t4(r3[a2], n2[a2], i3, o2 ? o2 + "." + a2 : a2);
            } else
              i3.overwrite && (r3[a2] = n2[a2]);
      }, e2.toObject = function t4(n2) {
        var o2;
        if (s2 || (s2 = r2(3293)), null == n2)
          return n2;
        if (n2 instanceof s2)
          return n2.toObject();
        if (Array.isArray(n2)) {
          o2 = [];
          var a2, c2 = i2(n2);
          try {
            for (c2.s(); !(a2 = c2.n()).done; ) {
              var u2 = a2.value;
              o2.push(t4(u2));
            }
          } catch (t5) {
            c2.e(t5);
          } finally {
            c2.f();
          }
          return o2;
        }
        if (e2.isPOJO(n2)) {
          o2 = {}, n2[j] && (o2[j] = n2[j]);
          for (var f2 = 0, l2 = Object.keys(n2); f2 < l2.length; f2++) {
            var h3 = l2[f2];
            O.has(h3) || (o2[h3] = t4(n2[h3]));
          }
          return o2;
        }
        return n2;
      }, e2.isObject = y2, e2.isPOJO = r2(6288), e2.isNonBuiltinObject = function(t4) {
        return !("object" !== a(t4) || e2.isNativeObject(t4) || e2.isMongooseType(t4) || t4 instanceof c || null == t4);
      }, e2.isNativeObject = function(t4) {
        return Array.isArray(t4) || t4 instanceof Date || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String;
      }, e2.isEmptyObject = function(t4) {
        return null != t4 && "object" === a(t4) && 0 === Object.keys(t4).length;
      }, e2.hasKey = function(t4, r3) {
        for (var n2 = 0, i3 = Object.keys(t4); n2 < i3.length; n2++) {
          var o2 = i3[n2];
          if (o2 === r3)
            return true;
          if (e2.isPOJO(t4[o2]) && e2.hasKey(t4[o2], r3))
            return true;
        }
        return false;
      }, e2.tick = function(t4) {
        if ("function" == typeof t4)
          return function() {
            try {
              t4.apply(this, arguments);
            } catch (t5) {
              d2(function() {
                throw t5;
              });
            }
          };
      }, e2.isMongooseType = function(t4) {
        return v(t4, "ObjectId") || v(t4, "Decimal128") || t4 instanceof n;
      }, e2.isMongooseObject = _, e2.expires = function(t4) {
        t4 && "Object" === t4.constructor.name && "expires" in t4 && (t4.expireAfterSeconds = "string" != typeof t4.expires ? t4.expires : Math.round(u(t4.expires) / 1e3), delete t4.expires);
      }, e2.populate = function(t4, r3, n2, o2, s3, c2, u2, f2) {
        var l2, d3 = null;
        if (1 === arguments.length) {
          if (t4 instanceof h2)
            return t4._docs = [], t4._childDocs = [], [t4];
          if (Array.isArray(t4)) {
            var y3 = (l2 = [], t4.forEach(function(t5) {
              $.test(t5.path) ? t5.path.split(A).forEach(function(e3) {
                var r4 = Object.assign({}, t5);
                r4.path = e3, l2.push(r4);
              }) : l2.push(t5);
            }), l2);
            return y3.map(function(t5) {
              return e2.populate(t5)[0];
            });
          }
          d3 = e2.isObject(t4) ? Object.assign({}, t4) : { path: t4 };
        } else
          d3 = "object" === a(n2) ? { path: t4, select: r3, match: n2, options: o2 } : { path: t4, select: r3, model: n2, match: o2, options: s3, populate: c2, justOne: u2, count: f2 };
        if ("string" != typeof d3.path)
          throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + a(t4) + "`");
        return function(t5) {
          if (Array.isArray(t5.populate)) {
            var r4 = [];
            t5.populate.forEach(function(t6) {
              if ($.test(t6.path)) {
                var n4 = Object.assign({}, t6);
                n4.path.split(A).forEach(function(t7) {
                  n4.path = t7, r4.push(e2.populate(n4)[0]);
                });
              } else
                r4.push(e2.populate(t6)[0]);
            }), t5.populate = e2.populate(r4);
          } else
            null != t5.populate && "object" === a(t5.populate) && (t5.populate = e2.populate(t5.populate));
          var n3 = [], o3 = $.test(t5.path) ? t5.path.split(A) : [t5.path];
          null != t5.options && (t5.options = p(t5.options));
          var s4, c3 = i2(o3);
          try {
            for (c3.s(); !(s4 = c3.n()).done; ) {
              var u3 = s4.value;
              n3.push(new h2(Object.assign({}, t5, { path: u3 })));
            }
          } catch (t6) {
            c3.e(t6);
          } finally {
            c3.f();
          }
          return n3;
        }(d3);
      }, e2.getValue = function(t4, e3, r3) {
        return f.get(t4, e3, x, r3);
      };
      var E = Object.freeze({ getters: false });
      function x(t4, e3) {
        var r3 = (null == t4 ? void 0 : t4._doc) || t4;
        return null != r3 && r3.isMongooseArrayProxy && (r3 = r3.__array), r3 instanceof Map ? r3.get(e3, E) : r3[e3];
      }
      e2.setValue = function(t4, e3, r3, n2, i3) {
        f.set(t4, e3, r3, "_doc", n2, i3);
      }, e2.object = {}, e2.object.vals = function(t4) {
        for (var e3 = Object.keys(t4), r3 = e3.length, n2 = []; r3--; )
          n2.push(t4[e3[r3]]);
        return n2;
      };
      var P = Object.prototype.hasOwnProperty;
      e2.object.hasOwnProperty = function(t4, e3) {
        return P.call(t4, e3);
      }, e2.isNullOrUndefined = function(t4) {
        return null == t4;
      }, e2.array = {}, e2.array.flatten = function t4(e3, r3, n2) {
        return n2 || (n2 = []), e3.forEach(function(e4) {
          Array.isArray(e4) ? t4(e4, r3, n2) : r3 && !r3(e4) || n2.push(e4);
        }), n2;
      };
      var k = Object.prototype.hasOwnProperty;
      e2.hasUserDefinedProperty = function(t4, r3) {
        if (null == t4)
          return false;
        if (Array.isArray(r3)) {
          var n2, o2 = i2(r3);
          try {
            for (o2.s(); !(n2 = o2.n()).done; ) {
              var s3 = n2.value;
              if (e2.hasUserDefinedProperty(t4, s3))
                return true;
            }
          } catch (t5) {
            o2.e(t5);
          } finally {
            o2.f();
          }
          return false;
        }
        if (k.call(t4, r3))
          return true;
        if ("object" === a(t4) && r3 in t4) {
          var c2 = t4[r3];
          return c2 !== Object.prototype[r3] && c2 !== Array.prototype[r3];
        }
        return false;
      };
      var M = Math.pow(2, 32) - 1;
      e2.isArrayIndex = function(t4) {
        return "number" == typeof t4 ? t4 >= 0 && t4 <= M : "string" == typeof t4 && !!/^\d+$/.test(t4) && (t4 = +t4) >= 0 && t4 <= M;
      }, e2.array.unique = function(t4) {
        var e3, r3 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), o2 = [], a2 = i2(t4);
        try {
          for (a2.s(); !(e3 = a2.n()).done; ) {
            var s3 = e3.value;
            if ("number" == typeof s3 || "string" == typeof s3 || null == s3) {
              if (r3.has(s3))
                continue;
              o2.push(s3), r3.add(s3);
            } else if (v(s3, "ObjectId")) {
              if (n2.has(s3.toString()))
                continue;
              o2.push(s3), n2.add(s3.toString());
            } else
              o2.push(s3);
          }
        } catch (t5) {
          a2.e(t5);
        } finally {
          a2.f();
        }
        return o2;
      }, e2.buffer = {}, e2.buffer.areEqual = function(t4, e3) {
        if (!n.isBuffer(t4))
          return false;
        if (!n.isBuffer(e3))
          return false;
        if (t4.length !== e3.length)
          return false;
        for (var r3 = 0, i3 = t4.length; r3 < i3; ++r3)
          if (t4[r3] !== e3[r3])
            return false;
        return true;
      }, e2.getFunctionName = g, e2.decorate = function(t4, e3) {
        for (var r3 in e3)
          O.has(r3) || (t4[r3] = e3[r3]);
      }, e2.mergeClone = function(t4, r3) {
        _(r3) && (r3 = r3.toObject({ transform: false, virtuals: false, depopulate: true, getters: false, flattenDecimals: false }));
        for (var i3, o2 = Object.keys(r3), a2 = o2.length, s3 = 0; s3 < a2; )
          if (i3 = o2[s3++], !O.has(i3))
            if (void 0 === t4[i3])
              t4[i3] = p(r3[i3], { transform: false, virtuals: false, depopulate: true, getters: false, flattenDecimals: false });
            else {
              var c2 = r3[i3];
              if (null == c2 || !c2.valueOf || c2 instanceof Date || (c2 = c2.valueOf()), e2.isObject(c2)) {
                var u2 = c2;
                _(c2) && !c2.isMongooseBuffer && (u2 = u2.toObject({ transform: false, virtuals: false, depopulate: true, getters: false, flattenDecimals: false })), c2.isMongooseBuffer && (u2 = n.from(u2)), e2.mergeClone(t4[i3], u2);
              } else
                t4[i3] = p(c2, { flattenDecimals: false });
            }
      }, e2.each = function(t4, e3) {
        var r3, n2 = i2(t4);
        try {
          for (n2.s(); !(r3 = n2.n()).done; )
            e3(r3.value);
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
      }, e2.renameObjKey = function(t4, e3, r3) {
        return Object.keys(t4).reduce(function(n2, i3) {
          return i3 === e3 ? n2[r3] = t4[e3] : n2[i3] = t4[i3], n2;
        }, {});
      }, e2.getOption = function(t4) {
        var e3, r3 = i2(Array.prototype.slice.call(arguments, 1));
        try {
          for (r3.s(); !(e3 = r3.n()).done; ) {
            var n2 = e3.value;
            if (null != n2 && null != n2[t4])
              return n2[t4];
          }
        } catch (t5) {
          r3.e(t5);
        } finally {
          r3.f();
        }
        return null;
      }, e2.noop = function() {
      }, e2.errorToPOJO = function(t4) {
        if (!(t4 instanceof Error))
          throw new Error("`error` must be `instanceof Error`.");
        var e3, r3 = {}, n2 = i2(Object.getOwnPropertyNames(t4));
        try {
          for (n2.s(); !(e3 = n2.n()).done; ) {
            var o2 = e3.value;
            r3[o2] = t4[o2];
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        return r3;
      }, e2.warn = function(t4) {
        return { env: {} }.emitWarning(t4, { code: "MONGOOSE" });
      }, e2.injectTimestampsOption = function(t4, e3) {
        null != e3 && (t4.timestamps = e3);
      };
    }, 5165: (t3, e2, r2) => {
      function n(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = function(t5, e4) {
            if (t5) {
              if ("string" == typeof t5)
                return i2(t5, e4);
              var r4 = Object.prototype.toString.call(t5).slice(8, -1);
              return "Object" === r4 && t5.constructor && (r4 = t5.constructor.name), "Map" === r4 || "Set" === r4 ? Array.from(t5) : "Arguments" === r4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? i2(t5, e4) : void 0;
            }
          }(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var n2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return n2 >= t4.length ? { done: true } : { done: false, value: t4[n2++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s2 = true, c = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s2 = t5.done, t5;
        }, e: function(t5) {
          c = true, a2 = t5;
        }, f: function() {
          try {
            s2 || null == r3.return || r3.return();
          } finally {
            if (c)
              throw a2;
          }
        } };
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      var o = r2(335);
      function a(t4, e3) {
        this.path = e3, this.getters = [], this.setters = [], this.options = Object.assign({}, t4);
      }
      a.prototype._applyDefaultGetters = function() {
        if (!(this.getters.length > 0 || this.setters.length > 0)) {
          var t4 = "$" + this.path;
          this.getters.push(function() {
            return this.$locals[t4];
          }), this.setters.push(function(e3) {
            this.$locals[t4] = e3;
          });
        }
      }, a.prototype.clone = function() {
        var t4 = new a(this.options, this.path);
        return t4.getters = [].concat(this.getters), t4.setters = [].concat(this.setters), t4;
      }, a.prototype.get = function(t4) {
        return this.getters.push(t4), this;
      }, a.prototype.set = function(t4) {
        return this.setters.push(t4), this;
      }, a.prototype.applyGetters = function(t4, e3) {
        o.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && e3.$$populatedVirtuals && e3.$$populatedVirtuals.hasOwnProperty(this.path) && (t4 = e3.$$populatedVirtuals[this.path]);
        var r3, i3 = t4, a2 = n(this.getters);
        try {
          for (a2.s(); !(r3 = a2.n()).done; )
            i3 = r3.value.call(e3, i3, this, e3);
        } catch (t5) {
          a2.e(t5);
        } finally {
          a2.f();
        }
        return i3;
      }, a.prototype.applySetters = function(t4, e3) {
        var r3, i3 = t4, o2 = n(this.setters);
        try {
          for (o2.s(); !(r3 = o2.n()).done; )
            i3 = r3.value.call(e3, i3, this, e3);
        } catch (t5) {
          o2.e(t5);
        } finally {
          o2.f();
        }
        return i3;
      }, t3.exports = a;
    }, 1419: (t3, e2, r2) => {
      var n = e2;
      n.bignum = r2(7799), n.define = r2(2392).define, n.base = r2(1620), n.constants = r2(8050), n.decoders = r2(2240), n.encoders = r2(9176);
    }, 2392: (t3, e2, r2) => {
      var n = r2(1419), i2 = r2(1679);
      function o(t4, e3) {
        this.name = t4, this.body = e3, this.decoders = {}, this.encoders = {};
      }
      e2.define = function(t4, e3) {
        return new o(t4, e3);
      }, o.prototype._createNamed = function(t4) {
        var e3;
        try {
          e3 = Object(function() {
            var t5 = new Error("Cannot find module 'vm'");
            throw t5.code = "MODULE_NOT_FOUND", t5;
          }())("(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})");
        } catch (t5) {
          e3 = function(t6) {
            this._initNamed(t6);
          };
        }
        return i2(e3, t4), e3.prototype._initNamed = function(e4) {
          t4.call(this, e4);
        }, new e3(this);
      }, o.prototype._getDecoder = function(t4) {
        return t4 = t4 || "der", this.decoders.hasOwnProperty(t4) || (this.decoders[t4] = this._createNamed(n.decoders[t4])), this.decoders[t4];
      }, o.prototype.decode = function(t4, e3, r3) {
        return this._getDecoder(e3).decode(t4, r3);
      }, o.prototype._getEncoder = function(t4) {
        return t4 = t4 || "der", this.encoders.hasOwnProperty(t4) || (this.encoders[t4] = this._createNamed(n.encoders[t4])), this.encoders[t4];
      }, o.prototype.encode = function(t4, e3, r3) {
        return this._getEncoder(e3).encode(t4, r3);
      };
    }, 8260: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(1679), o = r2(1620).Reporter, a = r2(5832).Buffer;
      function s2(t4, e3) {
        o.call(this, e3), a.isBuffer(t4) ? (this.base = t4, this.offset = 0, this.length = t4.length) : this.error("Input not Buffer");
      }
      function c(t4, e3) {
        if (Array.isArray(t4))
          this.length = 0, this.value = t4.map(function(t5) {
            return t5 instanceof c || (t5 = new c(t5, e3)), this.length += t5.length, t5;
          }, this);
        else if ("number" == typeof t4) {
          if (!(0 <= t4 && t4 <= 255))
            return e3.error("non-byte EncoderBuffer value");
          this.value = t4, this.length = 1;
        } else if ("string" == typeof t4)
          this.value = t4, this.length = a.byteLength(t4);
        else {
          if (!a.isBuffer(t4))
            return e3.error("Unsupported type: " + n(t4));
          this.value = t4, this.length = t4.length;
        }
      }
      i2(s2, o), e2.t = s2, s2.prototype.save = function() {
        return { offset: this.offset, reporter: o.prototype.save.call(this) };
      }, s2.prototype.restore = function(t4) {
        var e3 = new s2(this.base);
        return e3.offset = t4.offset, e3.length = this.offset, this.offset = t4.offset, o.prototype.restore.call(this, t4.reporter), e3;
      }, s2.prototype.isEmpty = function() {
        return this.offset === this.length;
      }, s2.prototype.readUInt8 = function(t4) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(t4 || "DecoderBuffer overrun");
      }, s2.prototype.skip = function(t4, e3) {
        if (!(this.offset + t4 <= this.length))
          return this.error(e3 || "DecoderBuffer overrun");
        var r3 = new s2(this.base);
        return r3._reporterState = this._reporterState, r3.offset = this.offset, r3.length = this.offset + t4, this.offset += t4, r3;
      }, s2.prototype.raw = function(t4) {
        return this.base.slice(t4 ? t4.offset : this.offset, this.length);
      }, e2.d = c, c.prototype.join = function(t4, e3) {
        return t4 || (t4 = new a(this.length)), e3 || (e3 = 0), 0 === this.length || (Array.isArray(this.value) ? this.value.forEach(function(r3) {
          r3.join(t4, e3), e3 += r3.length;
        }) : ("number" == typeof this.value ? t4[e3] = this.value : "string" == typeof this.value ? t4.write(this.value, e3) : a.isBuffer(this.value) && this.value.copy(t4, e3), e3 += this.length)), t4;
      };
    }, 1620: (t3, e2, r2) => {
      var n = e2;
      n.Reporter = r2(6555).a, n.DecoderBuffer = r2(8260).t, n.EncoderBuffer = r2(8260).d, n.Node = r2(4258);
    }, 4258: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(1620).Reporter, o = r2(1620).EncoderBuffer, a = r2(1620).DecoderBuffer, s2 = r2(3528), c = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], u = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(c);
      function f(t4, e3) {
        var r3 = {};
        this._baseState = r3, r3.enc = t4, r3.parent = e3 || null, r3.children = null, r3.tag = null, r3.args = null, r3.reverseArgs = null, r3.choice = null, r3.optional = false, r3.any = false, r3.obj = false, r3.use = null, r3.useDecoder = null, r3.key = null, r3.default = null, r3.explicit = null, r3.implicit = null, r3.contains = null, r3.parent || (r3.children = [], this._wrap());
      }
      t3.exports = f;
      var l = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
      f.prototype.clone = function() {
        var t4 = this._baseState, e3 = {};
        l.forEach(function(r4) {
          e3[r4] = t4[r4];
        });
        var r3 = new this.constructor(e3.parent);
        return r3._baseState = e3, r3;
      }, f.prototype._wrap = function() {
        var t4 = this._baseState;
        u.forEach(function(e3) {
          this[e3] = function() {
            var r3 = new this.constructor(this);
            return t4.children.push(r3), r3[e3].apply(r3, arguments);
          };
        }, this);
      }, f.prototype._init = function(t4) {
        var e3 = this._baseState;
        s2(null === e3.parent), t4.call(this), e3.children = e3.children.filter(function(t5) {
          return t5._baseState.parent === this;
        }, this), s2.equal(e3.children.length, 1, "Root node can have only one child");
      }, f.prototype._useArgs = function(t4) {
        var e3 = this._baseState, r3 = t4.filter(function(t5) {
          return t5 instanceof this.constructor;
        }, this);
        t4 = t4.filter(function(t5) {
          return !(t5 instanceof this.constructor);
        }, this), 0 !== r3.length && (s2(null === e3.children), e3.children = r3, r3.forEach(function(t5) {
          t5._baseState.parent = this;
        }, this)), 0 !== t4.length && (s2(null === e3.args), e3.args = t4, e3.reverseArgs = t4.map(function(t5) {
          if ("object" !== n(t5) || t5.constructor !== Object)
            return t5;
          var e4 = {};
          return Object.keys(t5).forEach(function(r4) {
            r4 == (0 | r4) && (r4 |= 0);
            var n2 = t5[r4];
            e4[n2] = r4;
          }), e4;
        }));
      }, ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach(function(t4) {
        f.prototype[t4] = function() {
          var e3 = this._baseState;
          throw new Error(t4 + " not implemented for encoding: " + e3.enc);
        };
      }), c.forEach(function(t4) {
        f.prototype[t4] = function() {
          var e3 = this._baseState, r3 = Array.prototype.slice.call(arguments);
          return s2(null === e3.tag), e3.tag = t4, this._useArgs(r3), this;
        };
      }), f.prototype.use = function(t4) {
        s2(t4);
        var e3 = this._baseState;
        return s2(null === e3.use), e3.use = t4, this;
      }, f.prototype.optional = function() {
        return this._baseState.optional = true, this;
      }, f.prototype.def = function(t4) {
        var e3 = this._baseState;
        return s2(null === e3.default), e3.default = t4, e3.optional = true, this;
      }, f.prototype.explicit = function(t4) {
        var e3 = this._baseState;
        return s2(null === e3.explicit && null === e3.implicit), e3.explicit = t4, this;
      }, f.prototype.implicit = function(t4) {
        var e3 = this._baseState;
        return s2(null === e3.explicit && null === e3.implicit), e3.implicit = t4, this;
      }, f.prototype.obj = function() {
        var t4 = this._baseState, e3 = Array.prototype.slice.call(arguments);
        return t4.obj = true, 0 !== e3.length && this._useArgs(e3), this;
      }, f.prototype.key = function(t4) {
        var e3 = this._baseState;
        return s2(null === e3.key), e3.key = t4, this;
      }, f.prototype.any = function() {
        return this._baseState.any = true, this;
      }, f.prototype.choice = function(t4) {
        var e3 = this._baseState;
        return s2(null === e3.choice), e3.choice = t4, this._useArgs(Object.keys(t4).map(function(e4) {
          return t4[e4];
        })), this;
      }, f.prototype.contains = function(t4) {
        var e3 = this._baseState;
        return s2(null === e3.use), e3.contains = t4, this;
      }, f.prototype._decode = function(t4, e3) {
        var r3 = this._baseState;
        if (null === r3.parent)
          return t4.wrapResult(r3.children[0]._decode(t4, e3));
        var n2, i3 = r3.default, o2 = true, s3 = null;
        if (null !== r3.key && (s3 = t4.enterKey(r3.key)), r3.optional) {
          var c2 = null;
          if (null !== r3.explicit ? c2 = r3.explicit : null !== r3.implicit ? c2 = r3.implicit : null !== r3.tag && (c2 = r3.tag), null !== c2 || r3.any) {
            if (o2 = this._peekTag(t4, c2, r3.any), t4.isError(o2))
              return o2;
          } else {
            var u2 = t4.save();
            try {
              null === r3.choice ? this._decodeGeneric(r3.tag, t4, e3) : this._decodeChoice(t4, e3), o2 = true;
            } catch (t5) {
              o2 = false;
            }
            t4.restore(u2);
          }
        }
        if (r3.obj && o2 && (n2 = t4.enterObject()), o2) {
          if (null !== r3.explicit) {
            var f2 = this._decodeTag(t4, r3.explicit);
            if (t4.isError(f2))
              return f2;
            t4 = f2;
          }
          var l2 = t4.offset;
          if (null === r3.use && null === r3.choice) {
            r3.any && (u2 = t4.save());
            var h2 = this._decodeTag(t4, null !== r3.implicit ? r3.implicit : r3.tag, r3.any);
            if (t4.isError(h2))
              return h2;
            r3.any ? i3 = t4.raw(u2) : t4 = h2;
          }
          if (e3 && e3.track && null !== r3.tag && e3.track(t4.path(), l2, t4.length, "tagged"), e3 && e3.track && null !== r3.tag && e3.track(t4.path(), t4.offset, t4.length, "content"), r3.any || (i3 = null === r3.choice ? this._decodeGeneric(r3.tag, t4, e3) : this._decodeChoice(t4, e3)), t4.isError(i3))
            return i3;
          if (r3.any || null !== r3.choice || null === r3.children || r3.children.forEach(function(r4) {
            r4._decode(t4, e3);
          }), r3.contains && ("octstr" === r3.tag || "bitstr" === r3.tag)) {
            var p = new a(i3);
            i3 = this._getUse(r3.contains, t4._reporterState.obj)._decode(p, e3);
          }
        }
        return r3.obj && o2 && (i3 = t4.leaveObject(n2)), null === r3.key || null === i3 && true !== o2 ? null !== s3 && t4.exitKey(s3) : t4.leaveKey(s3, r3.key, i3), i3;
      }, f.prototype._decodeGeneric = function(t4, e3, r3) {
        var n2 = this._baseState;
        return "seq" === t4 || "set" === t4 ? null : "seqof" === t4 || "setof" === t4 ? this._decodeList(e3, t4, n2.args[0], r3) : /str$/.test(t4) ? this._decodeStr(e3, t4, r3) : "objid" === t4 && n2.args ? this._decodeObjid(e3, n2.args[0], n2.args[1], r3) : "objid" === t4 ? this._decodeObjid(e3, null, null, r3) : "gentime" === t4 || "utctime" === t4 ? this._decodeTime(e3, t4, r3) : "null_" === t4 ? this._decodeNull(e3, r3) : "bool" === t4 ? this._decodeBool(e3, r3) : "objDesc" === t4 ? this._decodeStr(e3, t4, r3) : "int" === t4 || "enum" === t4 ? this._decodeInt(e3, n2.args && n2.args[0], r3) : null !== n2.use ? this._getUse(n2.use, e3._reporterState.obj)._decode(e3, r3) : e3.error("unknown tag: " + t4);
      }, f.prototype._getUse = function(t4, e3) {
        var r3 = this._baseState;
        return r3.useDecoder = this._use(t4, e3), s2(null === r3.useDecoder._baseState.parent), r3.useDecoder = r3.useDecoder._baseState.children[0], r3.implicit !== r3.useDecoder._baseState.implicit && (r3.useDecoder = r3.useDecoder.clone(), r3.useDecoder._baseState.implicit = r3.implicit), r3.useDecoder;
      }, f.prototype._decodeChoice = function(t4, e3) {
        var r3 = this._baseState, n2 = null, i3 = false;
        return Object.keys(r3.choice).some(function(o2) {
          var a2 = t4.save(), s3 = r3.choice[o2];
          try {
            var c2 = s3._decode(t4, e3);
            if (t4.isError(c2))
              return false;
            n2 = { type: o2, value: c2 }, i3 = true;
          } catch (e4) {
            return t4.restore(a2), false;
          }
          return true;
        }, this), i3 ? n2 : t4.error("Choice not matched");
      }, f.prototype._createEncoderBuffer = function(t4) {
        return new o(t4, this.reporter);
      }, f.prototype._encode = function(t4, e3, r3) {
        var n2 = this._baseState;
        if (null === n2.default || n2.default !== t4) {
          var i3 = this._encodeValue(t4, e3, r3);
          if (void 0 !== i3 && !this._skipDefault(i3, e3, r3))
            return i3;
        }
      }, f.prototype._encodeValue = function(t4, e3, r3) {
        var o2 = this._baseState;
        if (null === o2.parent)
          return o2.children[0]._encode(t4, e3 || new i2());
        var a2 = null;
        if (this.reporter = e3, o2.optional && void 0 === t4) {
          if (null === o2.default)
            return;
          t4 = o2.default;
        }
        var s3 = null, c2 = false;
        if (o2.any)
          a2 = this._createEncoderBuffer(t4);
        else if (o2.choice)
          a2 = this._encodeChoice(t4, e3);
        else if (o2.contains)
          s3 = this._getUse(o2.contains, r3)._encode(t4, e3), c2 = true;
        else if (o2.children)
          s3 = o2.children.map(function(r4) {
            if ("null_" === r4._baseState.tag)
              return r4._encode(null, e3, t4);
            if (null === r4._baseState.key)
              return e3.error("Child should have a key");
            var i3 = e3.enterKey(r4._baseState.key);
            if ("object" !== n(t4))
              return e3.error("Child expected, but input is not object");
            var o3 = r4._encode(t4[r4._baseState.key], e3, t4);
            return e3.leaveKey(i3), o3;
          }, this).filter(function(t5) {
            return t5;
          }), s3 = this._createEncoderBuffer(s3);
        else if ("seqof" === o2.tag || "setof" === o2.tag) {
          if (!o2.args || 1 !== o2.args.length)
            return e3.error("Too many args for : " + o2.tag);
          if (!Array.isArray(t4))
            return e3.error("seqof/setof, but data is not Array");
          var u2 = this.clone();
          u2._baseState.implicit = null, s3 = this._createEncoderBuffer(t4.map(function(r4) {
            var n2 = this._baseState;
            return this._getUse(n2.args[0], t4)._encode(r4, e3);
          }, u2));
        } else
          null !== o2.use ? a2 = this._getUse(o2.use, r3)._encode(t4, e3) : (s3 = this._encodePrimitive(o2.tag, t4), c2 = true);
        if (!o2.any && null === o2.choice) {
          var f2 = null !== o2.implicit ? o2.implicit : o2.tag, l2 = null === o2.implicit ? "universal" : "context";
          null === f2 ? null === o2.use && e3.error("Tag could be omitted only for .use()") : null === o2.use && (a2 = this._encodeComposite(f2, c2, l2, s3));
        }
        return null !== o2.explicit && (a2 = this._encodeComposite(o2.explicit, false, "context", a2)), a2;
      }, f.prototype._encodeChoice = function(t4, e3) {
        var r3 = this._baseState, n2 = r3.choice[t4.type];
        return n2 || s2(false, t4.type + " not found in " + JSON.stringify(Object.keys(r3.choice))), n2._encode(t4.value, e3);
      }, f.prototype._encodePrimitive = function(t4, e3) {
        var r3 = this._baseState;
        if (/str$/.test(t4))
          return this._encodeStr(e3, t4);
        if ("objid" === t4 && r3.args)
          return this._encodeObjid(e3, r3.reverseArgs[0], r3.args[1]);
        if ("objid" === t4)
          return this._encodeObjid(e3, null, null);
        if ("gentime" === t4 || "utctime" === t4)
          return this._encodeTime(e3, t4);
        if ("null_" === t4)
          return this._encodeNull();
        if ("int" === t4 || "enum" === t4)
          return this._encodeInt(e3, r3.args && r3.reverseArgs[0]);
        if ("bool" === t4)
          return this._encodeBool(e3);
        if ("objDesc" === t4)
          return this._encodeStr(e3, t4);
        throw new Error("Unsupported tag: " + t4);
      }, f.prototype._isNumstr = function(t4) {
        return /^[0-9 ]*$/.test(t4);
      }, f.prototype._isPrintstr = function(t4) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(t4);
      };
    }, 6555: (t3, e2, r2) => {
      var n = r2(1679);
      function i2(t4) {
        this._reporterState = { obj: null, path: [], options: t4 || {}, errors: [] };
      }
      function o(t4, e3) {
        this.path = t4, this.rethrow(e3);
      }
      e2.a = i2, i2.prototype.isError = function(t4) {
        return t4 instanceof o;
      }, i2.prototype.save = function() {
        var t4 = this._reporterState;
        return { obj: t4.obj, pathLen: t4.path.length };
      }, i2.prototype.restore = function(t4) {
        var e3 = this._reporterState;
        e3.obj = t4.obj, e3.path = e3.path.slice(0, t4.pathLen);
      }, i2.prototype.enterKey = function(t4) {
        return this._reporterState.path.push(t4);
      }, i2.prototype.exitKey = function(t4) {
        var e3 = this._reporterState;
        e3.path = e3.path.slice(0, t4 - 1);
      }, i2.prototype.leaveKey = function(t4, e3, r3) {
        var n2 = this._reporterState;
        this.exitKey(t4), null !== n2.obj && (n2.obj[e3] = r3);
      }, i2.prototype.path = function() {
        return this._reporterState.path.join("/");
      }, i2.prototype.enterObject = function() {
        var t4 = this._reporterState, e3 = t4.obj;
        return t4.obj = {}, e3;
      }, i2.prototype.leaveObject = function(t4) {
        var e3 = this._reporterState, r3 = e3.obj;
        return e3.obj = t4, r3;
      }, i2.prototype.error = function(t4) {
        var e3, r3 = this._reporterState, n2 = t4 instanceof o;
        if (e3 = n2 ? t4 : new o(r3.path.map(function(t5) {
          return "[" + JSON.stringify(t5) + "]";
        }).join(""), t4.message || t4, t4.stack), !r3.options.partial)
          throw e3;
        return n2 || r3.errors.push(e3), e3;
      }, i2.prototype.wrapResult = function(t4) {
        var e3 = this._reporterState;
        return e3.options.partial ? { result: this.isError(t4) ? null : t4, errors: e3.errors } : t4;
      }, n(o, Error), o.prototype.rethrow = function(t4) {
        if (this.message = t4 + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, o), !this.stack)
          try {
            throw new Error(this.message);
          } catch (t5) {
            this.stack = t5.stack;
          }
        return this;
      };
    }, 425: (t3, e2, r2) => {
      var n = r2(8050);
      e2.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, e2.tagClassByName = n._reverse(e2.tagClass), e2.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, e2.tagByName = n._reverse(e2.tag);
    }, 8050: (t3, e2, r2) => {
      var n = e2;
      n._reverse = function(t4) {
        var e3 = {};
        return Object.keys(t4).forEach(function(r3) {
          (0 | r3) == r3 && (r3 |= 0);
          var n2 = t4[r3];
          e3[n2] = r3;
        }), e3;
      }, n.der = r2(425);
    }, 3879: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(1419), o = i2.base, a = i2.bignum, s2 = i2.constants.der;
      function c(t4) {
        this.enc = "der", this.name = t4.name, this.entity = t4, this.tree = new u(), this.tree._init(t4.body);
      }
      function u(t4) {
        o.Node.call(this, "der", t4);
      }
      function f(t4, e3) {
        var r3 = t4.readUInt8(e3);
        if (t4.isError(r3))
          return r3;
        var n2 = s2.tagClass[r3 >> 6], i3 = !(32 & r3);
        if (31 & ~r3)
          r3 &= 31;
        else {
          var o2 = r3;
          for (r3 = 0; !(128 & ~o2); ) {
            if (o2 = t4.readUInt8(e3), t4.isError(o2))
              return o2;
            r3 <<= 7, r3 |= 127 & o2;
          }
        }
        return { cls: n2, primitive: i3, tag: r3, tagStr: s2.tag[r3] };
      }
      function l(t4, e3, r3) {
        var n2 = t4.readUInt8(r3);
        if (t4.isError(n2))
          return n2;
        if (!e3 && 128 === n2)
          return null;
        if (!(128 & n2))
          return n2;
        var i3 = 127 & n2;
        if (i3 > 4)
          return t4.error("length octect is too long");
        n2 = 0;
        for (var o2 = 0; o2 < i3; o2++) {
          n2 <<= 8;
          var a2 = t4.readUInt8(r3);
          if (t4.isError(a2))
            return a2;
          n2 |= a2;
        }
        return n2;
      }
      t3.exports = c, c.prototype.decode = function(t4, e3) {
        return t4 instanceof o.DecoderBuffer || (t4 = new o.DecoderBuffer(t4, e3)), this.tree._decode(t4, e3);
      }, n(u, o.Node), u.prototype._peekTag = function(t4, e3, r3) {
        if (t4.isEmpty())
          return false;
        var n2 = t4.save(), i3 = f(t4, 'Failed to peek tag: "' + e3 + '"');
        return t4.isError(i3) ? i3 : (t4.restore(n2), i3.tag === e3 || i3.tagStr === e3 || i3.tagStr + "of" === e3 || r3);
      }, u.prototype._decodeTag = function(t4, e3, r3) {
        var n2 = f(t4, 'Failed to decode tag of "' + e3 + '"');
        if (t4.isError(n2))
          return n2;
        var i3 = l(t4, n2.primitive, 'Failed to get length of "' + e3 + '"');
        if (t4.isError(i3))
          return i3;
        if (!r3 && n2.tag !== e3 && n2.tagStr !== e3 && n2.tagStr + "of" !== e3)
          return t4.error('Failed to match tag: "' + e3 + '"');
        if (n2.primitive || null !== i3)
          return t4.skip(i3, 'Failed to match body of: "' + e3 + '"');
        var o2 = t4.save(), a2 = this._skipUntilEnd(t4, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return t4.isError(a2) ? a2 : (i3 = t4.offset - o2.offset, t4.restore(o2), t4.skip(i3, 'Failed to match body of: "' + e3 + '"'));
      }, u.prototype._skipUntilEnd = function(t4, e3) {
        for (; ; ) {
          var r3 = f(t4, e3);
          if (t4.isError(r3))
            return r3;
          var n2, i3 = l(t4, r3.primitive, e3);
          if (t4.isError(i3))
            return i3;
          if (n2 = r3.primitive || null !== i3 ? t4.skip(i3) : this._skipUntilEnd(t4, e3), t4.isError(n2))
            return n2;
          if ("end" === r3.tagStr)
            break;
        }
      }, u.prototype._decodeList = function(t4, e3, r3, n2) {
        for (var i3 = []; !t4.isEmpty(); ) {
          var o2 = this._peekTag(t4, "end");
          if (t4.isError(o2))
            return o2;
          var a2 = r3.decode(t4, "der", n2);
          if (t4.isError(a2) && o2)
            break;
          i3.push(a2);
        }
        return i3;
      }, u.prototype._decodeStr = function(t4, e3) {
        if ("bitstr" === e3) {
          var r3 = t4.readUInt8();
          return t4.isError(r3) ? r3 : { unused: r3, data: t4.raw() };
        }
        if ("bmpstr" === e3) {
          var n2 = t4.raw();
          if (n2.length % 2 == 1)
            return t4.error("Decoding of string type: bmpstr length mismatch");
          for (var i3 = "", o2 = 0; o2 < n2.length / 2; o2++)
            i3 += String.fromCharCode(n2.readUInt16BE(2 * o2));
          return i3;
        }
        if ("numstr" === e3) {
          var a2 = t4.raw().toString("ascii");
          return this._isNumstr(a2) ? a2 : t4.error("Decoding of string type: numstr unsupported characters");
        }
        if ("octstr" === e3)
          return t4.raw();
        if ("objDesc" === e3)
          return t4.raw();
        if ("printstr" === e3) {
          var s3 = t4.raw().toString("ascii");
          return this._isPrintstr(s3) ? s3 : t4.error("Decoding of string type: printstr unsupported characters");
        }
        return /str$/.test(e3) ? t4.raw().toString() : t4.error("Decoding of string type: " + e3 + " unsupported");
      }, u.prototype._decodeObjid = function(t4, e3, r3) {
        for (var n2, i3 = [], o2 = 0; !t4.isEmpty(); ) {
          var a2 = t4.readUInt8();
          o2 <<= 7, o2 |= 127 & a2, 128 & a2 || (i3.push(o2), o2 = 0);
        }
        128 & a2 && i3.push(o2);
        var s3 = i3[0] / 40 | 0, c2 = i3[0] % 40;
        if (n2 = r3 ? i3 : [s3, c2].concat(i3.slice(1)), e3) {
          var u2 = e3[n2.join(" ")];
          void 0 === u2 && (u2 = e3[n2.join(".")]), void 0 !== u2 && (n2 = u2);
        }
        return n2;
      }, u.prototype._decodeTime = function(t4, e3) {
        var r3 = t4.raw().toString();
        if ("gentime" === e3)
          var n2 = 0 | r3.slice(0, 4), i3 = 0 | r3.slice(4, 6), o2 = 0 | r3.slice(6, 8), a2 = 0 | r3.slice(8, 10), s3 = 0 | r3.slice(10, 12), c2 = 0 | r3.slice(12, 14);
        else {
          if ("utctime" !== e3)
            return t4.error("Decoding " + e3 + " time is not supported yet");
          n2 = 0 | r3.slice(0, 2), i3 = 0 | r3.slice(2, 4), o2 = 0 | r3.slice(4, 6), a2 = 0 | r3.slice(6, 8), s3 = 0 | r3.slice(8, 10), c2 = 0 | r3.slice(10, 12), n2 = n2 < 70 ? 2e3 + n2 : 1900 + n2;
        }
        return Date.UTC(n2, i3 - 1, o2, a2, s3, c2, 0);
      }, u.prototype._decodeNull = function(t4) {
        return null;
      }, u.prototype._decodeBool = function(t4) {
        var e3 = t4.readUInt8();
        return t4.isError(e3) ? e3 : 0 !== e3;
      }, u.prototype._decodeInt = function(t4, e3) {
        var r3 = t4.raw(), n2 = new a(r3);
        return e3 && (n2 = e3[n2.toString(10)] || n2), n2;
      }, u.prototype._use = function(t4, e3) {
        return "function" == typeof t4 && (t4 = t4(e3)), t4._getDecoder("der").tree;
      };
    }, 2240: (t3, e2, r2) => {
      var n = e2;
      n.der = r2(3879), n.pem = r2(8330);
    }, 8330: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(5832).Buffer, o = r2(3879);
      function a(t4) {
        o.call(this, t4), this.enc = "pem";
      }
      n(a, o), t3.exports = a, a.prototype.decode = function(t4, e3) {
        for (var r3 = t4.toString().split(/[\r\n]+/g), n2 = e3.label.toUpperCase(), a2 = /^-----(BEGIN|END) ([^-]+)-----$/, s2 = -1, c = -1, u = 0; u < r3.length; u++) {
          var f = r3[u].match(a2);
          if (null !== f && f[2] === n2) {
            if (-1 !== s2) {
              if ("END" !== f[1])
                break;
              c = u;
              break;
            }
            if ("BEGIN" !== f[1])
              break;
            s2 = u;
          }
        }
        if (-1 === s2 || -1 === c)
          throw new Error("PEM section not found for: " + n2);
        var l = r3.slice(s2 + 1, c).join("");
        l.replace(/[^a-z0-9\+\/=]+/gi, "");
        var h2 = new i2(l, "base64");
        return o.prototype.decode.call(this, h2, e3);
      };
    }, 2655: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(5832).Buffer, o = r2(1419), a = o.base, s2 = o.constants.der;
      function c(t4) {
        this.enc = "der", this.name = t4.name, this.entity = t4, this.tree = new u(), this.tree._init(t4.body);
      }
      function u(t4) {
        a.Node.call(this, "der", t4);
      }
      function f(t4) {
        return t4 < 10 ? "0" + t4 : t4;
      }
      t3.exports = c, c.prototype.encode = function(t4, e3) {
        return this.tree._encode(t4, e3).join();
      }, n(u, a.Node), u.prototype._encodeComposite = function(t4, e3, r3, n2) {
        var o2, a2 = function(t5, e4, r4, n3) {
          var i3;
          if ("seqof" === t5 ? t5 = "seq" : "setof" === t5 && (t5 = "set"), s2.tagByName.hasOwnProperty(t5))
            i3 = s2.tagByName[t5];
          else {
            if ("number" != typeof t5 || (0 | t5) !== t5)
              return n3.error("Unknown tag: " + t5);
            i3 = t5;
          }
          return i3 >= 31 ? n3.error("Multi-octet tag encoding unsupported") : (e4 || (i3 |= 32), i3 |= s2.tagClassByName[r4 || "universal"] << 6);
        }(t4, e3, r3, this.reporter);
        if (n2.length < 128)
          return (o2 = new i2(2))[0] = a2, o2[1] = n2.length, this._createEncoderBuffer([o2, n2]);
        for (var c2 = 1, u2 = n2.length; u2 >= 256; u2 >>= 8)
          c2++;
        (o2 = new i2(2 + c2))[0] = a2, o2[1] = 128 | c2, u2 = 1 + c2;
        for (var f2 = n2.length; f2 > 0; u2--, f2 >>= 8)
          o2[u2] = 255 & f2;
        return this._createEncoderBuffer([o2, n2]);
      }, u.prototype._encodeStr = function(t4, e3) {
        if ("bitstr" === e3)
          return this._createEncoderBuffer([0 | t4.unused, t4.data]);
        if ("bmpstr" === e3) {
          for (var r3 = new i2(2 * t4.length), n2 = 0; n2 < t4.length; n2++)
            r3.writeUInt16BE(t4.charCodeAt(n2), 2 * n2);
          return this._createEncoderBuffer(r3);
        }
        return "numstr" === e3 ? this._isNumstr(t4) ? this._createEncoderBuffer(t4) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : "printstr" === e3 ? this._isPrintstr(t4) ? this._createEncoderBuffer(t4) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(e3) || "objDesc" === e3 ? this._createEncoderBuffer(t4) : this.reporter.error("Encoding of string type: " + e3 + " unsupported");
      }, u.prototype._encodeObjid = function(t4, e3, r3) {
        if ("string" == typeof t4) {
          if (!e3)
            return this.reporter.error("string objid given, but no values map found");
          if (!e3.hasOwnProperty(t4))
            return this.reporter.error("objid not found in values map");
          t4 = e3[t4].split(/[\s\.]+/g);
          for (var n2 = 0; n2 < t4.length; n2++)
            t4[n2] |= 0;
        } else if (Array.isArray(t4))
          for (t4 = t4.slice(), n2 = 0; n2 < t4.length; n2++)
            t4[n2] |= 0;
        if (!Array.isArray(t4))
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(t4));
        if (!r3) {
          if (t4[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          t4.splice(0, 2, 40 * t4[0] + t4[1]);
        }
        var o2 = 0;
        for (n2 = 0; n2 < t4.length; n2++) {
          var a2 = t4[n2];
          for (o2++; a2 >= 128; a2 >>= 7)
            o2++;
        }
        var s3 = new i2(o2), c2 = s3.length - 1;
        for (n2 = t4.length - 1; n2 >= 0; n2--)
          for (a2 = t4[n2], s3[c2--] = 127 & a2; (a2 >>= 7) > 0; )
            s3[c2--] = 128 | 127 & a2;
        return this._createEncoderBuffer(s3);
      }, u.prototype._encodeTime = function(t4, e3) {
        var r3, n2 = new Date(t4);
        return "gentime" === e3 ? r3 = [f(n2.getFullYear()), f(n2.getUTCMonth() + 1), f(n2.getUTCDate()), f(n2.getUTCHours()), f(n2.getUTCMinutes()), f(n2.getUTCSeconds()), "Z"].join("") : "utctime" === e3 ? r3 = [f(n2.getFullYear() % 100), f(n2.getUTCMonth() + 1), f(n2.getUTCDate()), f(n2.getUTCHours()), f(n2.getUTCMinutes()), f(n2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + e3 + " time is not supported yet"), this._encodeStr(r3, "octstr");
      }, u.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
      }, u.prototype._encodeInt = function(t4, e3) {
        if ("string" == typeof t4) {
          if (!e3)
            return this.reporter.error("String int or enum given, but no values map");
          if (!e3.hasOwnProperty(t4))
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(t4));
          t4 = e3[t4];
        }
        if ("number" != typeof t4 && !i2.isBuffer(t4)) {
          var r3 = t4.toArray();
          !t4.sign && 128 & r3[0] && r3.unshift(0), t4 = new i2(r3);
        }
        if (i2.isBuffer(t4)) {
          var n2 = t4.length;
          0 === t4.length && n2++;
          var o2 = new i2(n2);
          return t4.copy(o2), 0 === t4.length && (o2[0] = 0), this._createEncoderBuffer(o2);
        }
        if (t4 < 128)
          return this._createEncoderBuffer(t4);
        if (t4 < 256)
          return this._createEncoderBuffer([0, t4]);
        n2 = 1;
        for (var a2 = t4; a2 >= 256; a2 >>= 8)
          n2++;
        for (a2 = (o2 = new Array(n2)).length - 1; a2 >= 0; a2--)
          o2[a2] = 255 & t4, t4 >>= 8;
        return 128 & o2[0] && o2.unshift(0), this._createEncoderBuffer(new i2(o2));
      }, u.prototype._encodeBool = function(t4) {
        return this._createEncoderBuffer(t4 ? 255 : 0);
      }, u.prototype._use = function(t4, e3) {
        return "function" == typeof t4 && (t4 = t4(e3)), t4._getEncoder("der").tree;
      }, u.prototype._skipDefault = function(t4, e3, r3) {
        var n2, i3 = this._baseState;
        if (null === i3.default)
          return false;
        var o2 = t4.join();
        if (void 0 === i3.defaultBuffer && (i3.defaultBuffer = this._encodeValue(i3.default, e3, r3).join()), o2.length !== i3.defaultBuffer.length)
          return false;
        for (n2 = 0; n2 < o2.length; n2++)
          if (o2[n2] !== i3.defaultBuffer[n2])
            return false;
        return true;
      };
    }, 9176: (t3, e2, r2) => {
      var n = e2;
      n.der = r2(2655), n.pem = r2(8418);
    }, 8418: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(2655);
      function o(t4) {
        i2.call(this, t4), this.enc = "pem";
      }
      n(o, i2), t3.exports = o, o.prototype.encode = function(t4, e3) {
        for (var r3 = i2.prototype.encode.call(this, t4).toString("base64"), n2 = ["-----BEGIN " + e3.label + "-----"], o2 = 0; o2 < r3.length; o2 += 64)
          n2.push(r3.slice(o2, o2 + 64));
        return n2.push("-----END " + e3.label + "-----"), n2.join("\n");
      };
    }, 2402: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, i2(t4);
      }
      var o, a, s2 = r2(3743).codes, c = s2.ERR_AMBIGUOUS_ARGUMENT, u = s2.ERR_INVALID_ARG_TYPE, f = s2.ERR_INVALID_ARG_VALUE, l = s2.ERR_INVALID_RETURN_VALUE, h2 = s2.ERR_MISSING_ARGS, p = r2(9068), d2 = r2(7352).inspect, y2 = r2(7352).types, b = y2.isPromise, m2 = y2.isRegExp, v = Object.assign ? Object.assign : r2(6182).assign, g = Object.is ? Object.is : r2(2064);
      function _() {
        var t4 = r2(6193);
        o = t4.isDeepEqual, a = t4.isDeepStrictEqual;
      }
      var w2 = false, S = t3.exports = A, O = {};
      function j(t4) {
        if (t4.message instanceof Error)
          throw t4.message;
        throw new p(t4);
      }
      function $(t4, e3, r3, n2) {
        if (!r3) {
          var i3 = false;
          if (0 === e3)
            i3 = true, n2 = "No value argument passed to `assert.ok()`";
          else if (n2 instanceof Error)
            throw n2;
          var o2 = new p({ actual: r3, expected: true, message: n2, operator: "==", stackStartFn: t4 });
          throw o2.generatedMessage = i3, o2;
        }
      }
      function A() {
        for (var t4 = arguments.length, e3 = new Array(t4), r3 = 0; r3 < t4; r3++)
          e3[r3] = arguments[r3];
        $.apply(void 0, [A, e3.length].concat(e3));
      }
      S.fail = function t4(e3, r3, n2, i3, o2) {
        var a2, s3 = arguments.length;
        if (0 === s3 ? a2 = "Failed" : 1 === s3 ? (n2 = e3, e3 = void 0) : (false === w2 && (w2 = true, ({ env: {} }.emitWarning ? { env: {} }.emitWarning : console.warn.bind(console))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")), 2 === s3 && (i3 = "!=")), n2 instanceof Error)
          throw n2;
        var c2 = { actual: e3, expected: r3, operator: void 0 === i3 ? "fail" : i3, stackStartFn: o2 || t4 };
        void 0 !== n2 && (c2.message = n2);
        var u2 = new p(c2);
        throw a2 && (u2.message = a2, u2.generatedMessage = true), u2;
      }, S.AssertionError = p, S.ok = A, S.equal = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        e3 != r3 && j({ actual: e3, expected: r3, message: n2, operator: "==", stackStartFn: t4 });
      }, S.notEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        e3 == r3 && j({ actual: e3, expected: r3, message: n2, operator: "!=", stackStartFn: t4 });
      }, S.deepEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        void 0 === o && _(), o(e3, r3) || j({ actual: e3, expected: r3, message: n2, operator: "deepEqual", stackStartFn: t4 });
      }, S.notDeepEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        void 0 === o && _(), o(e3, r3) && j({ actual: e3, expected: r3, message: n2, operator: "notDeepEqual", stackStartFn: t4 });
      }, S.deepStrictEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        void 0 === o && _(), a(e3, r3) || j({ actual: e3, expected: r3, message: n2, operator: "deepStrictEqual", stackStartFn: t4 });
      }, S.notDeepStrictEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        void 0 === o && _(), a(e3, r3) && j({ actual: e3, expected: r3, message: n2, operator: "notDeepStrictEqual", stackStartFn: t4 });
      }, S.strictEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        g(e3, r3) || j({ actual: e3, expected: r3, message: n2, operator: "strictEqual", stackStartFn: t4 });
      }, S.notStrictEqual = function t4(e3, r3, n2) {
        if (arguments.length < 2)
          throw new h2("actual", "expected");
        g(e3, r3) && j({ actual: e3, expected: r3, message: n2, operator: "notStrictEqual", stackStartFn: t4 });
      };
      var E = function t4(e3, r3, n2) {
        var i3 = this;
        !function(t5, e4) {
          if (!(t5 instanceof e4))
            throw new TypeError("Cannot call a class as a function");
        }(this, t4), r3.forEach(function(t5) {
          t5 in e3 && (void 0 !== n2 && "string" == typeof n2[t5] && m2(e3[t5]) && e3[t5].test(n2[t5]) ? i3[t5] = n2[t5] : i3[t5] = e3[t5]);
        });
      };
      function x(t4, e3, r3, n2) {
        if ("function" != typeof e3) {
          if (m2(e3))
            return e3.test(t4);
          if (2 === arguments.length)
            throw new u("expected", ["Function", "RegExp"], e3);
          if ("object" !== i2(t4) || null === t4) {
            var s3 = new p({ actual: t4, expected: e3, message: r3, operator: "deepStrictEqual", stackStartFn: n2 });
            throw s3.operator = n2.name, s3;
          }
          var c2 = Object.keys(e3);
          if (e3 instanceof Error)
            c2.push("name", "message");
          else if (0 === c2.length)
            throw new f("error", e3, "may not be an empty object");
          return void 0 === o && _(), c2.forEach(function(i3) {
            "string" == typeof t4[i3] && m2(e3[i3]) && e3[i3].test(t4[i3]) || function(t5, e4, r4, n3, i4, o2) {
              if (!(r4 in t5) || !a(t5[r4], e4[r4])) {
                if (!n3) {
                  var s4 = new E(t5, i4), c3 = new E(e4, i4, t5), u2 = new p({ actual: s4, expected: c3, operator: "deepStrictEqual", stackStartFn: o2 });
                  throw u2.actual = t5, u2.expected = e4, u2.operator = o2.name, u2;
                }
                j({ actual: t5, expected: e4, message: n3, operator: o2.name, stackStartFn: o2 });
              }
            }(t4, e3, i3, r3, c2, n2);
          }), true;
        }
        return void 0 !== e3.prototype && t4 instanceof e3 || !Error.isPrototypeOf(e3) && true === e3.call({}, t4);
      }
      function P(t4) {
        if ("function" != typeof t4)
          throw new u("fn", "Function", t4);
        try {
          t4();
        } catch (t5) {
          return t5;
        }
        return O;
      }
      function k(t4) {
        return b(t4) || null !== t4 && "object" === i2(t4) && "function" == typeof t4.then && "function" == typeof t4.catch;
      }
      function M(t4) {
        return Promise.resolve().then(function() {
          var e3;
          if ("function" == typeof t4) {
            if (!k(e3 = t4()))
              throw new l("instance of Promise", "promiseFn", e3);
          } else {
            if (!k(t4))
              throw new u("promiseFn", ["Function", "Promise"], t4);
            e3 = t4;
          }
          return Promise.resolve().then(function() {
            return e3;
          }).then(function() {
            return O;
          }).catch(function(t5) {
            return t5;
          });
        });
      }
      function I(t4, e3, r3, n2) {
        if ("string" == typeof r3) {
          if (4 === arguments.length)
            throw new u("error", ["Object", "Error", "Function", "RegExp"], r3);
          if ("object" === i2(e3) && null !== e3) {
            if (e3.message === r3)
              throw new c("error/message", 'The error message "'.concat(e3.message, '" is identical to the message.'));
          } else if (e3 === r3)
            throw new c("error/message", 'The error "'.concat(e3, '" is identical to the message.'));
          n2 = r3, r3 = void 0;
        } else if (null != r3 && "object" !== i2(r3) && "function" != typeof r3)
          throw new u("error", ["Object", "Error", "Function", "RegExp"], r3);
        if (e3 === O) {
          var o2 = "";
          r3 && r3.name && (o2 += " (".concat(r3.name, ")")), o2 += n2 ? ": ".concat(n2) : ".";
          var a2 = "rejects" === t4.name ? "rejection" : "exception";
          j({ actual: void 0, expected: r3, operator: t4.name, message: "Missing expected ".concat(a2).concat(o2), stackStartFn: t4 });
        }
        if (r3 && !x(e3, r3, n2, t4))
          throw e3;
      }
      function B(t4, e3, r3, n2) {
        if (e3 !== O) {
          if ("string" == typeof r3 && (n2 = r3, r3 = void 0), !r3 || x(e3, r3)) {
            var i3 = n2 ? ": ".concat(n2) : ".", o2 = "doesNotReject" === t4.name ? "rejection" : "exception";
            j({ actual: e3, expected: r3, operator: t4.name, message: "Got unwanted ".concat(o2).concat(i3, "\n") + 'Actual message: "'.concat(e3 && e3.message, '"'), stackStartFn: t4 });
          }
          throw e3;
        }
      }
      function T() {
        for (var t4 = arguments.length, e3 = new Array(t4), r3 = 0; r3 < t4; r3++)
          e3[r3] = arguments[r3];
        $.apply(void 0, [T, e3.length].concat(e3));
      }
      S.throws = function t4(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), i3 = 1; i3 < r3; i3++)
          n2[i3 - 1] = arguments[i3];
        I.apply(void 0, [t4, P(e3)].concat(n2));
      }, S.rejects = function t4(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), i3 = 1; i3 < r3; i3++)
          n2[i3 - 1] = arguments[i3];
        return M(e3).then(function(e4) {
          return I.apply(void 0, [t4, e4].concat(n2));
        });
      }, S.doesNotThrow = function t4(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), i3 = 1; i3 < r3; i3++)
          n2[i3 - 1] = arguments[i3];
        B.apply(void 0, [t4, P(e3)].concat(n2));
      }, S.doesNotReject = function t4(e3) {
        for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), i3 = 1; i3 < r3; i3++)
          n2[i3 - 1] = arguments[i3];
        return M(e3).then(function(e4) {
          return B.apply(void 0, [t4, e4].concat(n2));
        });
      }, S.ifError = function t4(e3) {
        if (null != e3) {
          var r3 = "ifError got unwanted exception: ";
          "object" === i2(e3) && "string" == typeof e3.message ? 0 === e3.message.length && e3.constructor ? r3 += e3.constructor.name : r3 += e3.message : r3 += d2(e3);
          var n2 = new p({ actual: e3, expected: null, operator: "ifError", message: r3, stackStartFn: t4 }), o2 = e3.stack;
          if ("string" == typeof o2) {
            var a2 = o2.split("\n");
            a2.shift();
            for (var s3 = n2.stack.split("\n"), c2 = 0; c2 < a2.length; c2++) {
              var u2 = s3.indexOf(a2[c2]);
              if (-1 !== u2) {
                s3 = s3.slice(0, u2);
                break;
              }
            }
            n2.stack = "".concat(s3.join("\n"), "\n").concat(a2.join("\n"));
          }
          throw n2;
        }
      }, S.strict = v(T, S, { equal: S.strictEqual, deepEqual: S.deepStrictEqual, notEqual: S.notStrictEqual, notDeepEqual: S.notDeepStrictEqual }), S.strict.strict = S.strict;
    }, 9068: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3, r3) {
        return e3 in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function o(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, n2.key, n2);
        }
      }
      function a(t4, e3) {
        return !e3 || "object" !== h2(e3) && "function" != typeof e3 ? s2(t4) : e3;
      }
      function s2(t4) {
        if (void 0 === t4)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      function c(t4) {
        var e3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return c = function(t5) {
          if (null === t5 || (r3 = t5, -1 === Function.toString.call(r3).indexOf("[native code]")))
            return t5;
          var r3;
          if ("function" != typeof t5)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e3) {
            if (e3.has(t5))
              return e3.get(t5);
            e3.set(t5, n2);
          }
          function n2() {
            return u(t5, arguments, l(this).constructor);
          }
          return n2.prototype = Object.create(t5.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), f(n2, t5);
        }, c(t4);
      }
      function u(t4, e3, r3) {
        return u = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t5) {
            return false;
          }
        }() ? Reflect.construct : function(t5, e4, r4) {
          var n2 = [null];
          n2.push.apply(n2, e4);
          var i3 = new (Function.bind.apply(t5, n2))();
          return r4 && f(i3, r4.prototype), i3;
        }, u.apply(null, arguments);
      }
      function f(t4, e3) {
        return f = Object.setPrototypeOf || function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, f(t4, e3);
      }
      function l(t4) {
        return l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, l(t4);
      }
      function h2(t4) {
        return h2 = "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, h2(t4);
      }
      var p = r2(7352).inspect, d2 = r2(3743).codes.ERR_INVALID_ARG_TYPE;
      function y2(t4, e3, r3) {
        return (void 0 === r3 || r3 > t4.length) && (r3 = t4.length), t4.substring(r3 - e3.length, r3) === e3;
      }
      var b = "", m2 = "", v = "", g = "", _ = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
      function w2(t4) {
        var e3 = Object.keys(t4), r3 = Object.create(Object.getPrototypeOf(t4));
        return e3.forEach(function(e4) {
          r3[e4] = t4[e4];
        }), Object.defineProperty(r3, "message", { value: t4.message }), r3;
      }
      function S(t4) {
        return p(t4, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
      }
      var O = function(t4) {
        function e3(t5) {
          var r4;
          if (function(t6, e4) {
            if (!(t6 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), "object" !== h2(t5) || null === t5)
            throw new d2("options", "Object", t5);
          var n3 = t5.message, i3 = t5.operator, o2 = t5.stackStartFn, c2 = t5.actual, u2 = t5.expected, f2 = Error.stackTraceLimit;
          if (Error.stackTraceLimit = 0, null != n3)
            r4 = a(this, l(e3).call(this, String(n3)));
          else if ({ env: {} }.stderr && { env: {} }.stderr.isTTY && ({ env: {} }.stderr && { env: {} }.stderr.getColorDepth && 1 !== { env: {} }.stderr.getColorDepth() ? (b = "\x1B[34m", m2 = "\x1B[32m", g = "\x1B[39m", v = "\x1B[31m") : (b = "", m2 = "", g = "", v = "")), "object" === h2(c2) && null !== c2 && "object" === h2(u2) && null !== u2 && "stack" in c2 && c2 instanceof Error && "stack" in u2 && u2 instanceof Error && (c2 = w2(c2), u2 = w2(u2)), "deepStrictEqual" === i3 || "strictEqual" === i3)
            r4 = a(this, l(e3).call(this, function(t6, e4, r5) {
              var n4 = "", i4 = "", o3 = 0, a2 = "", s3 = false, c3 = S(t6), u3 = c3.split("\n"), f3 = S(e4).split("\n"), l2 = 0, p3 = "";
              if ("strictEqual" === r5 && "object" === h2(t6) && "object" === h2(e4) && null !== t6 && null !== e4 && (r5 = "strictEqualObject"), 1 === u3.length && 1 === f3.length && u3[0] !== f3[0]) {
                var d3 = u3[0].length + f3[0].length;
                if (d3 <= 10) {
                  if (!("object" === h2(t6) && null !== t6 || "object" === h2(e4) && null !== e4 || 0 === t6 && 0 === e4))
                    return "".concat(_[r5], "\n\n") + "".concat(u3[0], " !== ").concat(f3[0], "\n");
                } else if ("strictEqualObject" !== r5 && d3 < ({ env: {} }.stderr && { env: {} }.stderr.isTTY ? { env: {} }.stderr.columns : 80)) {
                  for (; u3[0][l2] === f3[0][l2]; )
                    l2++;
                  l2 > 2 && (p3 = "\n  ".concat(function(t7, e5) {
                    if (e5 = Math.floor(e5), 0 == t7.length || 0 == e5)
                      return "";
                    var r6 = t7.length * e5;
                    for (e5 = Math.floor(Math.log(e5) / Math.log(2)); e5; )
                      t7 += t7, e5--;
                    return t7 + t7.substring(0, r6 - t7.length);
                  }(" ", l2), "^"), l2 = 0);
                }
              }
              for (var w3 = u3[u3.length - 1], O3 = f3[f3.length - 1]; w3 === O3 && (l2++ < 2 ? a2 = "\n  ".concat(w3).concat(a2) : n4 = w3, u3.pop(), f3.pop(), 0 !== u3.length && 0 !== f3.length); )
                w3 = u3[u3.length - 1], O3 = f3[f3.length - 1];
              var j2 = Math.max(u3.length, f3.length);
              if (0 === j2) {
                var $2 = c3.split("\n");
                if ($2.length > 30)
                  for ($2[26] = "".concat(b, "...").concat(g); $2.length > 27; )
                    $2.pop();
                return "".concat(_.notIdentical, "\n\n").concat($2.join("\n"), "\n");
              }
              l2 > 3 && (a2 = "\n".concat(b, "...").concat(g).concat(a2), s3 = true), "" !== n4 && (a2 = "\n  ".concat(n4).concat(a2), n4 = "");
              var A2 = 0, E = _[r5] + "\n".concat(m2, "+ actual").concat(g, " ").concat(v, "- expected").concat(g), x = " ".concat(b, "...").concat(g, " Lines skipped");
              for (l2 = 0; l2 < j2; l2++) {
                var P = l2 - o3;
                if (u3.length < l2 + 1)
                  P > 1 && l2 > 2 && (P > 4 ? (i4 += "\n".concat(b, "...").concat(g), s3 = true) : P > 3 && (i4 += "\n  ".concat(f3[l2 - 2]), A2++), i4 += "\n  ".concat(f3[l2 - 1]), A2++), o3 = l2, n4 += "\n".concat(v, "-").concat(g, " ").concat(f3[l2]), A2++;
                else if (f3.length < l2 + 1)
                  P > 1 && l2 > 2 && (P > 4 ? (i4 += "\n".concat(b, "...").concat(g), s3 = true) : P > 3 && (i4 += "\n  ".concat(u3[l2 - 2]), A2++), i4 += "\n  ".concat(u3[l2 - 1]), A2++), o3 = l2, i4 += "\n".concat(m2, "+").concat(g, " ").concat(u3[l2]), A2++;
                else {
                  var k = f3[l2], M = u3[l2], I = M !== k && (!y2(M, ",") || M.slice(0, -1) !== k);
                  I && y2(k, ",") && k.slice(0, -1) === M && (I = false, M += ","), I ? (P > 1 && l2 > 2 && (P > 4 ? (i4 += "\n".concat(b, "...").concat(g), s3 = true) : P > 3 && (i4 += "\n  ".concat(u3[l2 - 2]), A2++), i4 += "\n  ".concat(u3[l2 - 1]), A2++), o3 = l2, i4 += "\n".concat(m2, "+").concat(g, " ").concat(M), n4 += "\n".concat(v, "-").concat(g, " ").concat(k), A2 += 2) : (i4 += n4, n4 = "", 1 !== P && 0 !== l2 || (i4 += "\n  ".concat(M), A2++));
                }
                if (A2 > 20 && l2 < j2 - 2)
                  return "".concat(E).concat(x, "\n").concat(i4, "\n").concat(b, "...").concat(g).concat(n4, "\n") + "".concat(b, "...").concat(g);
              }
              return "".concat(E).concat(s3 ? x : "", "\n").concat(i4).concat(n4).concat(a2).concat(p3);
            }(c2, u2, i3)));
          else if ("notDeepStrictEqual" === i3 || "notStrictEqual" === i3) {
            var p2 = _[i3], O2 = S(c2).split("\n");
            if ("notStrictEqual" === i3 && "object" === h2(c2) && null !== c2 && (p2 = _.notStrictEqualObject), O2.length > 30)
              for (O2[26] = "".concat(b, "...").concat(g); O2.length > 27; )
                O2.pop();
            r4 = 1 === O2.length ? a(this, l(e3).call(this, "".concat(p2, " ").concat(O2[0]))) : a(this, l(e3).call(this, "".concat(p2, "\n\n").concat(O2.join("\n"), "\n")));
          } else {
            var j = S(c2), $ = "", A = _[i3];
            "notDeepEqual" === i3 || "notEqual" === i3 ? (j = "".concat(_[i3], "\n\n").concat(j)).length > 1024 && (j = "".concat(j.slice(0, 1021), "...")) : ($ = "".concat(S(u2)), j.length > 512 && (j = "".concat(j.slice(0, 509), "...")), $.length > 512 && ($ = "".concat($.slice(0, 509), "...")), "deepEqual" === i3 || "equal" === i3 ? j = "".concat(A, "\n\n").concat(j, "\n\nshould equal\n\n") : $ = " ".concat(i3, " ").concat($)), r4 = a(this, l(e3).call(this, "".concat(j).concat($)));
          }
          return Error.stackTraceLimit = f2, r4.generatedMessage = !n3, Object.defineProperty(s2(r4), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r4.code = "ERR_ASSERTION", r4.actual = c2, r4.expected = u2, r4.operator = i3, Error.captureStackTrace && Error.captureStackTrace(s2(r4), o2), r4.stack, r4.name = "AssertionError", a(r4);
        }
        var r3, n2;
        return function(t5, e4) {
          if ("function" != typeof e4 && null !== e4)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), e4 && f(t5, e4);
        }(e3, t4), r3 = e3, n2 = [{ key: "toString", value: function() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        } }, { key: p.custom, value: function(t5, e4) {
          return p(this, function(t6) {
            for (var e5 = 1; e5 < arguments.length; e5++) {
              var r4 = null != arguments[e5] ? arguments[e5] : {}, n3 = Object.keys(r4);
              "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(r4).filter(function(t7) {
                return Object.getOwnPropertyDescriptor(r4, t7).enumerable;
              }))), n3.forEach(function(e6) {
                i2(t6, e6, r4[e6]);
              });
            }
            return t6;
          }({}, e4, { customInspect: false, depth: 0 }));
        } }], n2 && o(r3.prototype, n2), e3;
      }(c(Error));
      t3.exports = O;
    }, 3743: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4) {
        return i2 = "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, i2(t4);
      }
      function o(t4) {
        return o = Object.setPrototypeOf ? Object.getPrototypeOf : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, o(t4);
      }
      function a(t4, e3) {
        return a = Object.setPrototypeOf || function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, a(t4, e3);
      }
      var s2, c, u = {};
      function f(t4, e3, r3) {
        r3 || (r3 = Error);
        var n2 = function(r4) {
          function n3(r5, a2, s3) {
            var c2;
            return function(t5, e4) {
              if (!(t5 instanceof e4))
                throw new TypeError("Cannot call a class as a function");
            }(this, n3), c2 = function(t5, e4) {
              return !e4 || "object" !== i2(e4) && "function" != typeof e4 ? function(t6) {
                if (void 0 === t6)
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t6;
              }(t5) : e4;
            }(this, o(n3).call(this, function(t5, r6, n4) {
              return "string" == typeof e3 ? e3 : e3(t5, r6, n4);
            }(r5, a2, s3))), c2.code = t4, c2;
          }
          return function(t5, e4) {
            if ("function" != typeof e4 && null !== e4)
              throw new TypeError("Super expression must either be null or a function");
            t5.prototype = Object.create(e4 && e4.prototype, { constructor: { value: t5, writable: true, configurable: true } }), e4 && a(t5, e4);
          }(n3, r4), n3;
        }(r3);
        u[t4] = n2;
      }
      function l(t4, e3) {
        if (Array.isArray(t4)) {
          var r3 = t4.length;
          return t4 = t4.map(function(t5) {
            return String(t5);
          }), r3 > 2 ? "one of ".concat(e3, " ").concat(t4.slice(0, r3 - 1).join(", "), ", or ") + t4[r3 - 1] : 2 === r3 ? "one of ".concat(e3, " ").concat(t4[0], " or ").concat(t4[1]) : "of ".concat(e3, " ").concat(t4[0]);
        }
        return "of ".concat(e3, " ").concat(String(t4));
      }
      f("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f("ERR_INVALID_ARG_TYPE", function(t4, e3, n2) {
        var o2, a2, c2, u2, f2;
        if (void 0 === s2 && (s2 = r2(2402)), s2("string" == typeof t4, "'name' must be a string"), "string" == typeof e3 && (a2 = "not ", e3.substr(0, 4) === a2) ? (o2 = "must not be", e3 = e3.replace(/^not /, "")) : o2 = "must be", function(t5, e4, r3) {
          return (void 0 === r3 || r3 > t5.length) && (r3 = t5.length), t5.substring(r3 - 9, r3) === e4;
        }(t4, " argument"))
          c2 = "The ".concat(t4, " ").concat(o2, " ").concat(l(e3, "type"));
        else {
          var h2 = ("number" != typeof f2 && (f2 = 0), f2 + 1 > (u2 = t4).length || -1 === u2.indexOf(".", f2) ? "argument" : "property");
          c2 = 'The "'.concat(t4, '" ').concat(h2, " ").concat(o2, " ").concat(l(e3, "type"));
        }
        return c2 + ". Received type ".concat(i2(n2));
      }, TypeError), f("ERR_INVALID_ARG_VALUE", function(t4, e3) {
        var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
        void 0 === c && (c = r2(7352));
        var i3 = c.inspect(e3);
        return i3.length > 128 && (i3 = "".concat(i3.slice(0, 128), "...")), "The argument '".concat(t4, "' ").concat(n2, ". Received ").concat(i3);
      }, TypeError), f("ERR_INVALID_RETURN_VALUE", function(t4, e3, r3) {
        var n2;
        return n2 = r3 && r3.constructor && r3.constructor.name ? "instance of ".concat(r3.constructor.name) : "type ".concat(i2(r3)), "Expected ".concat(t4, ' to be returned from the "').concat(e3, '"') + " function but got ".concat(n2, ".");
      }, TypeError), f("ERR_MISSING_ARGS", function() {
        for (var t4 = arguments.length, e3 = new Array(t4), n2 = 0; n2 < t4; n2++)
          e3[n2] = arguments[n2];
        void 0 === s2 && (s2 = r2(2402)), s2(e3.length > 0, "At least one arg needs to be specified");
        var i3 = "The ", o2 = e3.length;
        switch (e3 = e3.map(function(t5) {
          return '"'.concat(t5, '"');
        }), o2) {
          case 1:
            i3 += "".concat(e3[0], " argument");
            break;
          case 2:
            i3 += "".concat(e3[0], " and ").concat(e3[1], " arguments");
            break;
          default:
            i3 += e3.slice(0, o2 - 1).join(", "), i3 += ", and ".concat(e3[o2 - 1], " arguments");
        }
        return "".concat(i3, " must be specified");
      }, TypeError), t3.exports.codes = u;
    }, 6193: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        return function(t5) {
          if (Array.isArray(t5))
            return t5;
        }(t4) || function(t5, e4) {
          var r3 = [], n2 = true, i3 = false, o2 = void 0;
          try {
            for (var a2, s3 = t5[Symbol.iterator](); !(n2 = (a2 = s3.next()).done) && (r3.push(a2.value), !e4 || r3.length !== e4); n2 = true)
              ;
          } catch (t6) {
            i3 = true, o2 = t6;
          } finally {
            try {
              n2 || null == s3.return || s3.return();
            } finally {
              if (i3)
                throw o2;
            }
          }
          return r3;
        }(t4, e3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }();
      }
      function o(t4) {
        return o = "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? function(t5) {
          return n(t5);
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : n(t5);
        }, o(t4);
      }
      var a = void 0 !== /a/g.flags, s2 = function(t4) {
        var e3 = [];
        return t4.forEach(function(t5) {
          return e3.push(t5);
        }), e3;
      }, c = function(t4) {
        var e3 = [];
        return t4.forEach(function(t5, r3) {
          return e3.push([r3, t5]);
        }), e3;
      }, u = Object.is ? Object.is : r2(2064), f = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      }, l = Number.isNaN ? Number.isNaN : r2(6062);
      function h2(t4) {
        return t4.call.bind(t4);
      }
      var p = h2(Object.prototype.hasOwnProperty), d2 = h2(Object.prototype.propertyIsEnumerable), y2 = h2(Object.prototype.toString), b = r2(7352).types, m2 = b.isAnyArrayBuffer, v = b.isArrayBufferView, g = b.isDate, _ = b.isMap, w2 = b.isRegExp, S = b.isSet, O = b.isNativeError, j = b.isBoxedPrimitive, $ = b.isNumberObject, A = b.isStringObject, E = b.isBooleanObject, x = b.isBigIntObject, P = b.isSymbolObject, k = b.isFloat32Array, M = b.isFloat64Array;
      function I(t4) {
        if (0 === t4.length || t4.length > 10)
          return true;
        for (var e3 = 0; e3 < t4.length; e3++) {
          var r3 = t4.charCodeAt(e3);
          if (r3 < 48 || r3 > 57)
            return true;
        }
        return 10 === t4.length && t4 >= Math.pow(2, 32);
      }
      function B(t4) {
        return Object.keys(t4).filter(I).concat(f(t4).filter(Object.prototype.propertyIsEnumerable.bind(t4)));
      }
      function T(t4, e3) {
        if (t4 === e3)
          return 0;
        for (var r3 = t4.length, n2 = e3.length, i3 = 0, o2 = Math.min(r3, n2); i3 < o2; ++i3)
          if (t4[i3] !== e3[i3]) {
            r3 = t4[i3], n2 = e3[i3];
            break;
          }
        return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
      }
      var R = 0, N = 1, D = 2, L = 3;
      function U(t4, e3, r3, n2) {
        if (t4 === e3)
          return 0 !== t4 || !r3 || u(t4, e3);
        if (r3) {
          if ("object" !== o(t4))
            return "number" == typeof t4 && l(t4) && l(e3);
          if ("object" !== o(e3) || null === t4 || null === e3)
            return false;
          if (Object.getPrototypeOf(t4) !== Object.getPrototypeOf(e3))
            return false;
        } else {
          if (null === t4 || "object" !== o(t4))
            return (null === e3 || "object" !== o(e3)) && t4 == e3;
          if (null === e3 || "object" !== o(e3))
            return false;
        }
        var i3, s3, c2, f2, h3 = y2(t4);
        if (h3 !== y2(e3))
          return false;
        if (Array.isArray(t4)) {
          if (t4.length !== e3.length)
            return false;
          var p2 = B(t4), d3 = B(e3);
          return p2.length === d3.length && q(t4, e3, r3, n2, N, p2);
        }
        if ("[object Object]" === h3 && (!_(t4) && _(e3) || !S(t4) && S(e3)))
          return false;
        if (g(t4)) {
          if (!g(e3) || Date.prototype.getTime.call(t4) !== Date.prototype.getTime.call(e3))
            return false;
        } else if (w2(t4)) {
          if (!w2(e3) || (c2 = t4, f2 = e3, !(a ? c2.source === f2.source && c2.flags === f2.flags : RegExp.prototype.toString.call(c2) === RegExp.prototype.toString.call(f2))))
            return false;
        } else if (O(t4) || t4 instanceof Error) {
          if (t4.message !== e3.message || t4.name !== e3.name)
            return false;
        } else {
          if (v(t4)) {
            if (r3 || !k(t4) && !M(t4)) {
              if (!function(t5, e4) {
                return t5.byteLength === e4.byteLength && 0 === T(new Uint8Array(t5.buffer, t5.byteOffset, t5.byteLength), new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength));
              }(t4, e3))
                return false;
            } else if (!function(t5, e4) {
              if (t5.byteLength !== e4.byteLength)
                return false;
              for (var r4 = 0; r4 < t5.byteLength; r4++)
                if (t5[r4] !== e4[r4])
                  return false;
              return true;
            }(t4, e3))
              return false;
            var b2 = B(t4), I2 = B(e3);
            return b2.length === I2.length && q(t4, e3, r3, n2, R, b2);
          }
          if (S(t4))
            return !(!S(e3) || t4.size !== e3.size) && q(t4, e3, r3, n2, D);
          if (_(t4))
            return !(!_(e3) || t4.size !== e3.size) && q(t4, e3, r3, n2, L);
          if (m2(t4)) {
            if (s3 = e3, (i3 = t4).byteLength !== s3.byteLength || 0 !== T(new Uint8Array(i3), new Uint8Array(s3)))
              return false;
          } else if (j(t4) && !function(t5, e4) {
            return $(t5) ? $(e4) && u(Number.prototype.valueOf.call(t5), Number.prototype.valueOf.call(e4)) : A(t5) ? A(e4) && String.prototype.valueOf.call(t5) === String.prototype.valueOf.call(e4) : E(t5) ? E(e4) && Boolean.prototype.valueOf.call(t5) === Boolean.prototype.valueOf.call(e4) : x(t5) ? x(e4) && BigInt.prototype.valueOf.call(t5) === BigInt.prototype.valueOf.call(e4) : P(e4) && Symbol.prototype.valueOf.call(t5) === Symbol.prototype.valueOf.call(e4);
          }(t4, e3))
            return false;
        }
        return q(t4, e3, r3, n2, R);
      }
      function C(t4, e3) {
        return e3.filter(function(e4) {
          return d2(t4, e4);
        });
      }
      function q(t4, e3, r3, n2, a2, u2) {
        if (5 === arguments.length) {
          u2 = Object.keys(t4);
          var l2 = Object.keys(e3);
          if (u2.length !== l2.length)
            return false;
        }
        for (var h3 = 0; h3 < u2.length; h3++)
          if (!p(e3, u2[h3]))
            return false;
        if (r3 && 5 === arguments.length) {
          var y3 = f(t4);
          if (0 !== y3.length) {
            var b2 = 0;
            for (h3 = 0; h3 < y3.length; h3++) {
              var m3 = y3[h3];
              if (d2(t4, m3)) {
                if (!d2(e3, m3))
                  return false;
                u2.push(m3), b2++;
              } else if (d2(e3, m3))
                return false;
            }
            var v2 = f(e3);
            if (y3.length !== v2.length && C(e3, v2).length !== b2)
              return false;
          } else {
            var g2 = f(e3);
            if (0 !== g2.length && 0 !== C(e3, g2).length)
              return false;
          }
        }
        if (0 === u2.length && (a2 === R || a2 === N && 0 === t4.length || 0 === t4.size))
          return true;
        if (void 0 === n2)
          n2 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
        else {
          var _2 = n2.val1.get(t4);
          if (void 0 !== _2) {
            var w3 = n2.val2.get(e3);
            if (void 0 !== w3)
              return _2 === w3;
          }
          n2.position++;
        }
        n2.val1.set(t4, n2.position), n2.val2.set(e3, n2.position);
        var S2 = function(t5, e4, r4, n3, a3, u3) {
          var f2 = 0;
          if (u3 === D) {
            if (!function(t6, e5, r5, n4) {
              for (var i3 = null, a4 = s2(t6), c2 = 0; c2 < a4.length; c2++) {
                var u4 = a4[c2];
                if ("object" === o(u4) && null !== u4)
                  null === i3 && (i3 = /* @__PURE__ */ new Set()), i3.add(u4);
                else if (!e5.has(u4)) {
                  if (r5)
                    return false;
                  if (!z(t6, e5, u4))
                    return false;
                  null === i3 && (i3 = /* @__PURE__ */ new Set()), i3.add(u4);
                }
              }
              if (null !== i3) {
                for (var f3 = s2(e5), l4 = 0; l4 < f3.length; l4++) {
                  var h5 = f3[l4];
                  if ("object" === o(h5) && null !== h5) {
                    if (!F(i3, h5, r5, n4))
                      return false;
                  } else if (!r5 && !t6.has(h5) && !F(i3, h5, r5, n4))
                    return false;
                }
                return 0 === i3.size;
              }
              return true;
            }(t5, e4, r4, a3))
              return false;
          } else if (u3 === L) {
            if (!function(t6, e5, r5, n4) {
              for (var a4 = null, s3 = c(t6), u4 = 0; u4 < s3.length; u4++) {
                var f3 = i2(s3[u4], 2), l4 = f3[0], h5 = f3[1];
                if ("object" === o(l4) && null !== l4)
                  null === a4 && (a4 = /* @__PURE__ */ new Set()), a4.add(l4);
                else {
                  var p2 = e5.get(l4);
                  if (void 0 === p2 && !e5.has(l4) || !U(h5, p2, r5, n4)) {
                    if (r5)
                      return false;
                    if (!K(t6, e5, l4, h5, n4))
                      return false;
                    null === a4 && (a4 = /* @__PURE__ */ new Set()), a4.add(l4);
                  }
                }
              }
              if (null !== a4) {
                for (var d4 = c(e5), y4 = 0; y4 < d4.length; y4++) {
                  var b3 = i2(d4[y4], 2), m4 = (l4 = b3[0], b3[1]);
                  if ("object" === o(l4) && null !== l4) {
                    if (!H(a4, t6, l4, m4, r5, n4))
                      return false;
                  } else if (!(r5 || t6.has(l4) && U(t6.get(l4), m4, false, n4) || H(a4, t6, l4, m4, false, n4)))
                    return false;
                }
                return 0 === a4.size;
              }
              return true;
            }(t5, e4, r4, a3))
              return false;
          } else if (u3 === N)
            for (; f2 < t5.length; f2++) {
              if (!p(t5, f2)) {
                if (p(e4, f2))
                  return false;
                for (var l3 = Object.keys(t5); f2 < l3.length; f2++) {
                  var h4 = l3[f2];
                  if (!p(e4, h4) || !U(t5[h4], e4[h4], r4, a3))
                    return false;
                }
                return l3.length === Object.keys(e4).length;
              }
              if (!p(e4, f2) || !U(t5[f2], e4[f2], r4, a3))
                return false;
            }
          for (f2 = 0; f2 < n3.length; f2++) {
            var d3 = n3[f2];
            if (!U(t5[d3], e4[d3], r4, a3))
              return false;
          }
          return true;
        }(t4, e3, r3, u2, n2, a2);
        return n2.val1.delete(t4), n2.val2.delete(e3), S2;
      }
      function F(t4, e3, r3, n2) {
        for (var i3 = s2(t4), o2 = 0; o2 < i3.length; o2++) {
          var a2 = i3[o2];
          if (U(e3, a2, r3, n2))
            return t4.delete(a2), true;
        }
        return false;
      }
      function V(t4) {
        switch (o(t4)) {
          case "undefined":
            return null;
          case "object":
            return;
          case "symbol":
            return false;
          case "string":
            t4 = +t4;
          case "number":
            if (l(t4))
              return false;
        }
        return true;
      }
      function z(t4, e3, r3) {
        var n2 = V(r3);
        return null != n2 ? n2 : e3.has(n2) && !t4.has(n2);
      }
      function K(t4, e3, r3, n2, i3) {
        var o2 = V(r3);
        if (null != o2)
          return o2;
        var a2 = e3.get(o2);
        return !(void 0 === a2 && !e3.has(o2) || !U(n2, a2, false, i3)) && !t4.has(o2) && U(n2, a2, false, i3);
      }
      function H(t4, e3, r3, n2, i3, o2) {
        for (var a2 = s2(t4), c2 = 0; c2 < a2.length; c2++) {
          var u2 = a2[c2];
          if (U(r3, u2, i3, o2) && U(n2, e3.get(u2), i3, o2))
            return t4.delete(u2), true;
        }
        return false;
      }
      t3.exports = { isDeepEqual: function(t4, e3) {
        return U(t4, e3, false);
      }, isDeepStrictEqual: function(t4, e3) {
        return U(t4, e3, true);
      } };
    }, 6775: (t3, e2) => {
      e2.byteLength = function(t4) {
        var e3 = s2(t4), r3 = e3[0], n2 = e3[1];
        return 3 * (r3 + n2) / 4 - n2;
      }, e2.toByteArray = function(t4) {
        var e3, r3, o2 = s2(t4), a2 = o2[0], c2 = o2[1], u = new i2(function(t5, e4, r4) {
          return 3 * (e4 + r4) / 4 - r4;
        }(0, a2, c2)), f = 0, l = c2 > 0 ? a2 - 4 : a2;
        for (r3 = 0; r3 < l; r3 += 4)
          e3 = n[t4.charCodeAt(r3)] << 18 | n[t4.charCodeAt(r3 + 1)] << 12 | n[t4.charCodeAt(r3 + 2)] << 6 | n[t4.charCodeAt(r3 + 3)], u[f++] = e3 >> 16 & 255, u[f++] = e3 >> 8 & 255, u[f++] = 255 & e3;
        return 2 === c2 && (e3 = n[t4.charCodeAt(r3)] << 2 | n[t4.charCodeAt(r3 + 1)] >> 4, u[f++] = 255 & e3), 1 === c2 && (e3 = n[t4.charCodeAt(r3)] << 10 | n[t4.charCodeAt(r3 + 1)] << 4 | n[t4.charCodeAt(r3 + 2)] >> 2, u[f++] = e3 >> 8 & 255, u[f++] = 255 & e3), u;
      }, e2.fromByteArray = function(t4) {
        for (var e3, n2 = t4.length, i3 = n2 % 3, o2 = [], a2 = 16383, s3 = 0, u = n2 - i3; s3 < u; s3 += a2)
          o2.push(c(t4, s3, s3 + a2 > u ? u : s3 + a2));
        return 1 === i3 ? (e3 = t4[n2 - 1], o2.push(r2[e3 >> 2] + r2[e3 << 4 & 63] + "==")) : 2 === i3 && (e3 = (t4[n2 - 2] << 8) + t4[n2 - 1], o2.push(r2[e3 >> 10] + r2[e3 >> 4 & 63] + r2[e3 << 2 & 63] + "=")), o2.join("");
      };
      for (var r2 = [], n = [], i2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0; a < 64; ++a)
        r2[a] = o[a], n[o.charCodeAt(a)] = a;
      function s2(t4) {
        var e3 = t4.length;
        if (e3 % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var r3 = t4.indexOf("=");
        return -1 === r3 && (r3 = e3), [r3, r3 === e3 ? 0 : 4 - r3 % 4];
      }
      function c(t4, e3, n2) {
        for (var i3, o2, a2 = [], s3 = e3; s3 < n2; s3 += 3)
          i3 = (t4[s3] << 16 & 16711680) + (t4[s3 + 1] << 8 & 65280) + (255 & t4[s3 + 2]), a2.push(r2[(o2 = i3) >> 18 & 63] + r2[o2 >> 12 & 63] + r2[o2 >> 6 & 63] + r2[63 & o2]);
        return a2.join("");
      }
      n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
    }, 7799: function(t3, e2, r2) {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      !function(t4, e3) {
        function i2(t5, e4) {
          if (!t5)
            throw new Error(e4 || "Assertion failed");
        }
        function o(t5, e4) {
          t5.super_ = e4;
          var r3 = function() {
          };
          r3.prototype = e4.prototype, t5.prototype = new r3(), t5.prototype.constructor = t5;
        }
        function a(t5, e4, r3) {
          if (a.isBN(t5))
            return t5;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t5 && ("le" !== e4 && "be" !== e4 || (r3 = e4, e4 = 10), this._init(t5 || 0, e4 || 10, r3 || "be"));
        }
        var s2;
        "object" === n(t4) ? t4.exports = a : e3.BN = a, a.BN = a, a.wordSize = 26;
        try {
          s2 = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : r2(7790).Buffer;
        } catch (t5) {
        }
        function c(t5, e4) {
          var r3 = t5.charCodeAt(e4);
          return r3 >= 48 && r3 <= 57 ? r3 - 48 : r3 >= 65 && r3 <= 70 ? r3 - 55 : r3 >= 97 && r3 <= 102 ? r3 - 87 : void i2(false, "Invalid character in " + t5);
        }
        function u(t5, e4, r3) {
          var n2 = c(t5, r3);
          return r3 - 1 >= e4 && (n2 |= c(t5, r3 - 1) << 4), n2;
        }
        function f(t5, e4, r3, n2) {
          for (var o2 = 0, a2 = 0, s3 = Math.min(t5.length, r3), c2 = e4; c2 < s3; c2++) {
            var u2 = t5.charCodeAt(c2) - 48;
            o2 *= n2, a2 = u2 >= 49 ? u2 - 49 + 10 : u2 >= 17 ? u2 - 17 + 10 : u2, i2(u2 >= 0 && a2 < n2, "Invalid character"), o2 += a2;
          }
          return o2;
        }
        function l(t5, e4) {
          t5.words = e4.words, t5.length = e4.length, t5.negative = e4.negative, t5.red = e4.red;
        }
        if (a.isBN = function(t5) {
          return t5 instanceof a || null !== t5 && "object" === n(t5) && t5.constructor.wordSize === a.wordSize && Array.isArray(t5.words);
        }, a.max = function(t5, e4) {
          return t5.cmp(e4) > 0 ? t5 : e4;
        }, a.min = function(t5, e4) {
          return t5.cmp(e4) < 0 ? t5 : e4;
        }, a.prototype._init = function(t5, e4, r3) {
          if ("number" == typeof t5)
            return this._initNumber(t5, e4, r3);
          if ("object" === n(t5))
            return this._initArray(t5, e4, r3);
          "hex" === e4 && (e4 = 16), i2(e4 === (0 | e4) && e4 >= 2 && e4 <= 36);
          var o2 = 0;
          "-" === (t5 = t5.toString().replace(/\s+/g, ""))[0] && (o2++, this.negative = 1), o2 < t5.length && (16 === e4 ? this._parseHex(t5, o2, r3) : (this._parseBase(t5, e4, o2), "le" === r3 && this._initArray(this.toArray(), e4, r3)));
        }, a.prototype._initNumber = function(t5, e4, r3) {
          t5 < 0 && (this.negative = 1, t5 = -t5), t5 < 67108864 ? (this.words = [67108863 & t5], this.length = 1) : t5 < 4503599627370496 ? (this.words = [67108863 & t5, t5 / 67108864 & 67108863], this.length = 2) : (i2(t5 < 9007199254740992), this.words = [67108863 & t5, t5 / 67108864 & 67108863, 1], this.length = 3), "le" === r3 && this._initArray(this.toArray(), e4, r3);
        }, a.prototype._initArray = function(t5, e4, r3) {
          if (i2("number" == typeof t5.length), t5.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(t5.length / 3), this.words = new Array(this.length);
          for (var n2 = 0; n2 < this.length; n2++)
            this.words[n2] = 0;
          var o2, a2, s3 = 0;
          if ("be" === r3)
            for (n2 = t5.length - 1, o2 = 0; n2 >= 0; n2 -= 3)
              a2 = t5[n2] | t5[n2 - 1] << 8 | t5[n2 - 2] << 16, this.words[o2] |= a2 << s3 & 67108863, this.words[o2 + 1] = a2 >>> 26 - s3 & 67108863, (s3 += 24) >= 26 && (s3 -= 26, o2++);
          else if ("le" === r3)
            for (n2 = 0, o2 = 0; n2 < t5.length; n2 += 3)
              a2 = t5[n2] | t5[n2 + 1] << 8 | t5[n2 + 2] << 16, this.words[o2] |= a2 << s3 & 67108863, this.words[o2 + 1] = a2 >>> 26 - s3 & 67108863, (s3 += 24) >= 26 && (s3 -= 26, o2++);
          return this._strip();
        }, a.prototype._parseHex = function(t5, e4, r3) {
          this.length = Math.ceil((t5.length - e4) / 6), this.words = new Array(this.length);
          for (var n2 = 0; n2 < this.length; n2++)
            this.words[n2] = 0;
          var i3, o2 = 0, a2 = 0;
          if ("be" === r3)
            for (n2 = t5.length - 1; n2 >= e4; n2 -= 2)
              i3 = u(t5, e4, n2) << o2, this.words[a2] |= 67108863 & i3, o2 >= 18 ? (o2 -= 18, a2 += 1, this.words[a2] |= i3 >>> 26) : o2 += 8;
          else
            for (n2 = (t5.length - e4) % 2 == 0 ? e4 + 1 : e4; n2 < t5.length; n2 += 2)
              i3 = u(t5, e4, n2) << o2, this.words[a2] |= 67108863 & i3, o2 >= 18 ? (o2 -= 18, a2 += 1, this.words[a2] |= i3 >>> 26) : o2 += 8;
          this._strip();
        }, a.prototype._parseBase = function(t5, e4, r3) {
          this.words = [0], this.length = 1;
          for (var n2 = 0, i3 = 1; i3 <= 67108863; i3 *= e4)
            n2++;
          n2--, i3 = i3 / e4 | 0;
          for (var o2 = t5.length - r3, a2 = o2 % n2, s3 = Math.min(o2, o2 - a2) + r3, c2 = 0, u2 = r3; u2 < s3; u2 += n2)
            c2 = f(t5, u2, u2 + n2, e4), this.imuln(i3), this.words[0] + c2 < 67108864 ? this.words[0] += c2 : this._iaddn(c2);
          if (0 !== a2) {
            var l2 = 1;
            for (c2 = f(t5, u2, t5.length, e4), u2 = 0; u2 < a2; u2++)
              l2 *= e4;
            this.imuln(l2), this.words[0] + c2 < 67108864 ? this.words[0] += c2 : this._iaddn(c2);
          }
          this._strip();
        }, a.prototype.copy = function(t5) {
          t5.words = new Array(this.length);
          for (var e4 = 0; e4 < this.length; e4++)
            t5.words[e4] = this.words[e4];
          t5.length = this.length, t5.negative = this.negative, t5.red = this.red;
        }, a.prototype._move = function(t5) {
          l(t5, this);
        }, a.prototype.clone = function() {
          var t5 = new a(null);
          return this.copy(t5), t5;
        }, a.prototype._expand = function(t5) {
          for (; this.length < t5; )
            this.words[this.length++] = 0;
          return this;
        }, a.prototype._strip = function() {
          for (; this.length > 1 && 0 === this.words[this.length - 1]; )
            this.length--;
          return this._normSign();
        }, a.prototype._normSign = function() {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
        }, "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          try {
            a.prototype[Symbol.for("nodejs.util.inspect.custom")] = h2;
          } catch (t5) {
            a.prototype.inspect = h2;
          }
        else
          a.prototype.inspect = h2;
        function h2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var p = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], d2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], y2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        function b(t5, e4, r3) {
          r3.negative = e4.negative ^ t5.negative;
          var n2 = t5.length + e4.length | 0;
          r3.length = n2, n2 = n2 - 1 | 0;
          var i3 = 0 | t5.words[0], o2 = 0 | e4.words[0], a2 = i3 * o2, s3 = 67108863 & a2, c2 = a2 / 67108864 | 0;
          r3.words[0] = s3;
          for (var u2 = 1; u2 < n2; u2++) {
            for (var f2 = c2 >>> 26, l2 = 67108863 & c2, h3 = Math.min(u2, e4.length - 1), p2 = Math.max(0, u2 - t5.length + 1); p2 <= h3; p2++) {
              var d3 = u2 - p2 | 0;
              f2 += (a2 = (i3 = 0 | t5.words[d3]) * (o2 = 0 | e4.words[p2]) + l2) / 67108864 | 0, l2 = 67108863 & a2;
            }
            r3.words[u2] = 0 | l2, c2 = 0 | f2;
          }
          return 0 !== c2 ? r3.words[u2] = 0 | c2 : r3.length--, r3._strip();
        }
        a.prototype.toString = function(t5, e4) {
          var r3;
          if (e4 = 0 | e4 || 1, 16 === (t5 = t5 || 10) || "hex" === t5) {
            r3 = "";
            for (var n2 = 0, o2 = 0, a2 = 0; a2 < this.length; a2++) {
              var s3 = this.words[a2], c2 = (16777215 & (s3 << n2 | o2)).toString(16);
              o2 = s3 >>> 24 - n2 & 16777215, (n2 += 2) >= 26 && (n2 -= 26, a2--), r3 = 0 !== o2 || a2 !== this.length - 1 ? p[6 - c2.length] + c2 + r3 : c2 + r3;
            }
            for (0 !== o2 && (r3 = o2.toString(16) + r3); r3.length % e4 != 0; )
              r3 = "0" + r3;
            return 0 !== this.negative && (r3 = "-" + r3), r3;
          }
          if (t5 === (0 | t5) && t5 >= 2 && t5 <= 36) {
            var u2 = d2[t5], f2 = y2[t5];
            r3 = "";
            var l2 = this.clone();
            for (l2.negative = 0; !l2.isZero(); ) {
              var h3 = l2.modrn(f2).toString(t5);
              r3 = (l2 = l2.idivn(f2)).isZero() ? h3 + r3 : p[u2 - h3.length] + h3 + r3;
            }
            for (this.isZero() && (r3 = "0" + r3); r3.length % e4 != 0; )
              r3 = "0" + r3;
            return 0 !== this.negative && (r3 = "-" + r3), r3;
          }
          i2(false, "Base should be between 2 and 36");
        }, a.prototype.toNumber = function() {
          var t5 = this.words[0];
          return 2 === this.length ? t5 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t5 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && i2(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t5 : t5;
        }, a.prototype.toJSON = function() {
          return this.toString(16, 2);
        }, s2 && (a.prototype.toBuffer = function(t5, e4) {
          return this.toArrayLike(s2, t5, e4);
        }), a.prototype.toArray = function(t5, e4) {
          return this.toArrayLike(Array, t5, e4);
        }, a.prototype.toArrayLike = function(t5, e4, r3) {
          this._strip();
          var n2 = this.byteLength(), o2 = r3 || Math.max(1, n2);
          i2(n2 <= o2, "byte array longer than desired length"), i2(o2 > 0, "Requested array length <= 0");
          var a2 = function(t6, e5) {
            return t6.allocUnsafe ? t6.allocUnsafe(e5) : new t6(e5);
          }(t5, o2);
          return this["_toArrayLike" + ("le" === e4 ? "LE" : "BE")](a2, n2), a2;
        }, a.prototype._toArrayLikeLE = function(t5, e4) {
          for (var r3 = 0, n2 = 0, i3 = 0, o2 = 0; i3 < this.length; i3++) {
            var a2 = this.words[i3] << o2 | n2;
            t5[r3++] = 255 & a2, r3 < t5.length && (t5[r3++] = a2 >> 8 & 255), r3 < t5.length && (t5[r3++] = a2 >> 16 & 255), 6 === o2 ? (r3 < t5.length && (t5[r3++] = a2 >> 24 & 255), n2 = 0, o2 = 0) : (n2 = a2 >>> 24, o2 += 2);
          }
          if (r3 < t5.length)
            for (t5[r3++] = n2; r3 < t5.length; )
              t5[r3++] = 0;
        }, a.prototype._toArrayLikeBE = function(t5, e4) {
          for (var r3 = t5.length - 1, n2 = 0, i3 = 0, o2 = 0; i3 < this.length; i3++) {
            var a2 = this.words[i3] << o2 | n2;
            t5[r3--] = 255 & a2, r3 >= 0 && (t5[r3--] = a2 >> 8 & 255), r3 >= 0 && (t5[r3--] = a2 >> 16 & 255), 6 === o2 ? (r3 >= 0 && (t5[r3--] = a2 >> 24 & 255), n2 = 0, o2 = 0) : (n2 = a2 >>> 24, o2 += 2);
          }
          if (r3 >= 0)
            for (t5[r3--] = n2; r3 >= 0; )
              t5[r3--] = 0;
        }, Math.clz32 ? a.prototype._countBits = function(t5) {
          return 32 - Math.clz32(t5);
        } : a.prototype._countBits = function(t5) {
          var e4 = t5, r3 = 0;
          return e4 >= 4096 && (r3 += 13, e4 >>>= 13), e4 >= 64 && (r3 += 7, e4 >>>= 7), e4 >= 8 && (r3 += 4, e4 >>>= 4), e4 >= 2 && (r3 += 2, e4 >>>= 2), r3 + e4;
        }, a.prototype._zeroBits = function(t5) {
          if (0 === t5)
            return 26;
          var e4 = t5, r3 = 0;
          return 8191 & e4 || (r3 += 13, e4 >>>= 13), 127 & e4 || (r3 += 7, e4 >>>= 7), 15 & e4 || (r3 += 4, e4 >>>= 4), 3 & e4 || (r3 += 2, e4 >>>= 2), 1 & e4 || r3++, r3;
        }, a.prototype.bitLength = function() {
          var t5 = this.words[this.length - 1], e4 = this._countBits(t5);
          return 26 * (this.length - 1) + e4;
        }, a.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var t5 = 0, e4 = 0; e4 < this.length; e4++) {
            var r3 = this._zeroBits(this.words[e4]);
            if (t5 += r3, 26 !== r3)
              break;
          }
          return t5;
        }, a.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, a.prototype.toTwos = function(t5) {
          return 0 !== this.negative ? this.abs().inotn(t5).iaddn(1) : this.clone();
        }, a.prototype.fromTwos = function(t5) {
          return this.testn(t5 - 1) ? this.notn(t5).iaddn(1).ineg() : this.clone();
        }, a.prototype.isNeg = function() {
          return 0 !== this.negative;
        }, a.prototype.neg = function() {
          return this.clone().ineg();
        }, a.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, a.prototype.iuor = function(t5) {
          for (; this.length < t5.length; )
            this.words[this.length++] = 0;
          for (var e4 = 0; e4 < t5.length; e4++)
            this.words[e4] = this.words[e4] | t5.words[e4];
          return this._strip();
        }, a.prototype.ior = function(t5) {
          return i2(!(this.negative | t5.negative)), this.iuor(t5);
        }, a.prototype.or = function(t5) {
          return this.length > t5.length ? this.clone().ior(t5) : t5.clone().ior(this);
        }, a.prototype.uor = function(t5) {
          return this.length > t5.length ? this.clone().iuor(t5) : t5.clone().iuor(this);
        }, a.prototype.iuand = function(t5) {
          var e4;
          e4 = this.length > t5.length ? t5 : this;
          for (var r3 = 0; r3 < e4.length; r3++)
            this.words[r3] = this.words[r3] & t5.words[r3];
          return this.length = e4.length, this._strip();
        }, a.prototype.iand = function(t5) {
          return i2(!(this.negative | t5.negative)), this.iuand(t5);
        }, a.prototype.and = function(t5) {
          return this.length > t5.length ? this.clone().iand(t5) : t5.clone().iand(this);
        }, a.prototype.uand = function(t5) {
          return this.length > t5.length ? this.clone().iuand(t5) : t5.clone().iuand(this);
        }, a.prototype.iuxor = function(t5) {
          var e4, r3;
          this.length > t5.length ? (e4 = this, r3 = t5) : (e4 = t5, r3 = this);
          for (var n2 = 0; n2 < r3.length; n2++)
            this.words[n2] = e4.words[n2] ^ r3.words[n2];
          if (this !== e4)
            for (; n2 < e4.length; n2++)
              this.words[n2] = e4.words[n2];
          return this.length = e4.length, this._strip();
        }, a.prototype.ixor = function(t5) {
          return i2(!(this.negative | t5.negative)), this.iuxor(t5);
        }, a.prototype.xor = function(t5) {
          return this.length > t5.length ? this.clone().ixor(t5) : t5.clone().ixor(this);
        }, a.prototype.uxor = function(t5) {
          return this.length > t5.length ? this.clone().iuxor(t5) : t5.clone().iuxor(this);
        }, a.prototype.inotn = function(t5) {
          i2("number" == typeof t5 && t5 >= 0);
          var e4 = 0 | Math.ceil(t5 / 26), r3 = t5 % 26;
          this._expand(e4), r3 > 0 && e4--;
          for (var n2 = 0; n2 < e4; n2++)
            this.words[n2] = 67108863 & ~this.words[n2];
          return r3 > 0 && (this.words[n2] = ~this.words[n2] & 67108863 >> 26 - r3), this._strip();
        }, a.prototype.notn = function(t5) {
          return this.clone().inotn(t5);
        }, a.prototype.setn = function(t5, e4) {
          i2("number" == typeof t5 && t5 >= 0);
          var r3 = t5 / 26 | 0, n2 = t5 % 26;
          return this._expand(r3 + 1), this.words[r3] = e4 ? this.words[r3] | 1 << n2 : this.words[r3] & ~(1 << n2), this._strip();
        }, a.prototype.iadd = function(t5) {
          var e4, r3, n2;
          if (0 !== this.negative && 0 === t5.negative)
            return this.negative = 0, e4 = this.isub(t5), this.negative ^= 1, this._normSign();
          if (0 === this.negative && 0 !== t5.negative)
            return t5.negative = 0, e4 = this.isub(t5), t5.negative = 1, e4._normSign();
          this.length > t5.length ? (r3 = this, n2 = t5) : (r3 = t5, n2 = this);
          for (var i3 = 0, o2 = 0; o2 < n2.length; o2++)
            e4 = (0 | r3.words[o2]) + (0 | n2.words[o2]) + i3, this.words[o2] = 67108863 & e4, i3 = e4 >>> 26;
          for (; 0 !== i3 && o2 < r3.length; o2++)
            e4 = (0 | r3.words[o2]) + i3, this.words[o2] = 67108863 & e4, i3 = e4 >>> 26;
          if (this.length = r3.length, 0 !== i3)
            this.words[this.length] = i3, this.length++;
          else if (r3 !== this)
            for (; o2 < r3.length; o2++)
              this.words[o2] = r3.words[o2];
          return this;
        }, a.prototype.add = function(t5) {
          var e4;
          return 0 !== t5.negative && 0 === this.negative ? (t5.negative = 0, e4 = this.sub(t5), t5.negative ^= 1, e4) : 0 === t5.negative && 0 !== this.negative ? (this.negative = 0, e4 = t5.sub(this), this.negative = 1, e4) : this.length > t5.length ? this.clone().iadd(t5) : t5.clone().iadd(this);
        }, a.prototype.isub = function(t5) {
          if (0 !== t5.negative) {
            t5.negative = 0;
            var e4 = this.iadd(t5);
            return t5.negative = 1, e4._normSign();
          }
          if (0 !== this.negative)
            return this.negative = 0, this.iadd(t5), this.negative = 1, this._normSign();
          var r3, n2, i3 = this.cmp(t5);
          if (0 === i3)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          i3 > 0 ? (r3 = this, n2 = t5) : (r3 = t5, n2 = this);
          for (var o2 = 0, a2 = 0; a2 < n2.length; a2++)
            o2 = (e4 = (0 | r3.words[a2]) - (0 | n2.words[a2]) + o2) >> 26, this.words[a2] = 67108863 & e4;
          for (; 0 !== o2 && a2 < r3.length; a2++)
            o2 = (e4 = (0 | r3.words[a2]) + o2) >> 26, this.words[a2] = 67108863 & e4;
          if (0 === o2 && a2 < r3.length && r3 !== this)
            for (; a2 < r3.length; a2++)
              this.words[a2] = r3.words[a2];
          return this.length = Math.max(this.length, a2), r3 !== this && (this.negative = 1), this._strip();
        }, a.prototype.sub = function(t5) {
          return this.clone().isub(t5);
        };
        var m2 = function(t5, e4, r3) {
          var n2, i3, o2, a2 = t5.words, s3 = e4.words, c2 = r3.words, u2 = 0, f2 = 0 | a2[0], l2 = 8191 & f2, h3 = f2 >>> 13, p2 = 0 | a2[1], d3 = 8191 & p2, y3 = p2 >>> 13, b2 = 0 | a2[2], m3 = 8191 & b2, v2 = b2 >>> 13, g2 = 0 | a2[3], _ = 8191 & g2, w3 = g2 >>> 13, S2 = 0 | a2[4], O2 = 8191 & S2, j2 = S2 >>> 13, $2 = 0 | a2[5], A2 = 8191 & $2, E2 = $2 >>> 13, x2 = 0 | a2[6], P = 8191 & x2, k = x2 >>> 13, M = 0 | a2[7], I = 8191 & M, B = M >>> 13, T = 0 | a2[8], R = 8191 & T, N = T >>> 13, D = 0 | a2[9], L = 8191 & D, U = D >>> 13, C = 0 | s3[0], q = 8191 & C, F = C >>> 13, V = 0 | s3[1], z = 8191 & V, K = V >>> 13, H = 0 | s3[2], W = 8191 & H, J = H >>> 13, G = 0 | s3[3], Y = 8191 & G, Q = G >>> 13, X = 0 | s3[4], Z = 8191 & X, tt = X >>> 13, et = 0 | s3[5], rt = 8191 & et, nt = et >>> 13, it = 0 | s3[6], ot = 8191 & it, at = it >>> 13, st = 0 | s3[7], ct = 8191 & st, ut = st >>> 13, ft = 0 | s3[8], lt2 = 8191 & ft, ht = ft >>> 13, pt = 0 | s3[9], dt = 8191 & pt, yt = pt >>> 13;
          r3.negative = t5.negative ^ e4.negative, r3.length = 19;
          var bt = (u2 + (n2 = Math.imul(l2, q)) | 0) + ((8191 & (i3 = (i3 = Math.imul(l2, F)) + Math.imul(h3, q) | 0)) << 13) | 0;
          u2 = ((o2 = Math.imul(h3, F)) + (i3 >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n2 = Math.imul(d3, q), i3 = (i3 = Math.imul(d3, F)) + Math.imul(y3, q) | 0, o2 = Math.imul(y3, F);
          var mt = (u2 + (n2 = n2 + Math.imul(l2, z) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, K) | 0) + Math.imul(h3, z) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, K) | 0) + (i3 >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, n2 = Math.imul(m3, q), i3 = (i3 = Math.imul(m3, F)) + Math.imul(v2, q) | 0, o2 = Math.imul(v2, F), n2 = n2 + Math.imul(d3, z) | 0, i3 = (i3 = i3 + Math.imul(d3, K) | 0) + Math.imul(y3, z) | 0, o2 = o2 + Math.imul(y3, K) | 0;
          var vt = (u2 + (n2 = n2 + Math.imul(l2, W) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, J) | 0) + Math.imul(h3, W) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, J) | 0) + (i3 >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n2 = Math.imul(_, q), i3 = (i3 = Math.imul(_, F)) + Math.imul(w3, q) | 0, o2 = Math.imul(w3, F), n2 = n2 + Math.imul(m3, z) | 0, i3 = (i3 = i3 + Math.imul(m3, K) | 0) + Math.imul(v2, z) | 0, o2 = o2 + Math.imul(v2, K) | 0, n2 = n2 + Math.imul(d3, W) | 0, i3 = (i3 = i3 + Math.imul(d3, J) | 0) + Math.imul(y3, W) | 0, o2 = o2 + Math.imul(y3, J) | 0;
          var gt2 = (u2 + (n2 = n2 + Math.imul(l2, Y) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, Q) | 0) + Math.imul(h3, Y) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, Q) | 0) + (i3 >>> 13) | 0) + (gt2 >>> 26) | 0, gt2 &= 67108863, n2 = Math.imul(O2, q), i3 = (i3 = Math.imul(O2, F)) + Math.imul(j2, q) | 0, o2 = Math.imul(j2, F), n2 = n2 + Math.imul(_, z) | 0, i3 = (i3 = i3 + Math.imul(_, K) | 0) + Math.imul(w3, z) | 0, o2 = o2 + Math.imul(w3, K) | 0, n2 = n2 + Math.imul(m3, W) | 0, i3 = (i3 = i3 + Math.imul(m3, J) | 0) + Math.imul(v2, W) | 0, o2 = o2 + Math.imul(v2, J) | 0, n2 = n2 + Math.imul(d3, Y) | 0, i3 = (i3 = i3 + Math.imul(d3, Q) | 0) + Math.imul(y3, Y) | 0, o2 = o2 + Math.imul(y3, Q) | 0;
          var _t = (u2 + (n2 = n2 + Math.imul(l2, Z) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, tt) | 0) + Math.imul(h3, Z) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, tt) | 0) + (i3 >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n2 = Math.imul(A2, q), i3 = (i3 = Math.imul(A2, F)) + Math.imul(E2, q) | 0, o2 = Math.imul(E2, F), n2 = n2 + Math.imul(O2, z) | 0, i3 = (i3 = i3 + Math.imul(O2, K) | 0) + Math.imul(j2, z) | 0, o2 = o2 + Math.imul(j2, K) | 0, n2 = n2 + Math.imul(_, W) | 0, i3 = (i3 = i3 + Math.imul(_, J) | 0) + Math.imul(w3, W) | 0, o2 = o2 + Math.imul(w3, J) | 0, n2 = n2 + Math.imul(m3, Y) | 0, i3 = (i3 = i3 + Math.imul(m3, Q) | 0) + Math.imul(v2, Y) | 0, o2 = o2 + Math.imul(v2, Q) | 0, n2 = n2 + Math.imul(d3, Z) | 0, i3 = (i3 = i3 + Math.imul(d3, tt) | 0) + Math.imul(y3, Z) | 0, o2 = o2 + Math.imul(y3, tt) | 0;
          var wt = (u2 + (n2 = n2 + Math.imul(l2, rt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, nt) | 0) + Math.imul(h3, rt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, nt) | 0) + (i3 >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n2 = Math.imul(P, q), i3 = (i3 = Math.imul(P, F)) + Math.imul(k, q) | 0, o2 = Math.imul(k, F), n2 = n2 + Math.imul(A2, z) | 0, i3 = (i3 = i3 + Math.imul(A2, K) | 0) + Math.imul(E2, z) | 0, o2 = o2 + Math.imul(E2, K) | 0, n2 = n2 + Math.imul(O2, W) | 0, i3 = (i3 = i3 + Math.imul(O2, J) | 0) + Math.imul(j2, W) | 0, o2 = o2 + Math.imul(j2, J) | 0, n2 = n2 + Math.imul(_, Y) | 0, i3 = (i3 = i3 + Math.imul(_, Q) | 0) + Math.imul(w3, Y) | 0, o2 = o2 + Math.imul(w3, Q) | 0, n2 = n2 + Math.imul(m3, Z) | 0, i3 = (i3 = i3 + Math.imul(m3, tt) | 0) + Math.imul(v2, Z) | 0, o2 = o2 + Math.imul(v2, tt) | 0, n2 = n2 + Math.imul(d3, rt) | 0, i3 = (i3 = i3 + Math.imul(d3, nt) | 0) + Math.imul(y3, rt) | 0, o2 = o2 + Math.imul(y3, nt) | 0;
          var St = (u2 + (n2 = n2 + Math.imul(l2, ot) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, at) | 0) + Math.imul(h3, ot) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, at) | 0) + (i3 >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n2 = Math.imul(I, q), i3 = (i3 = Math.imul(I, F)) + Math.imul(B, q) | 0, o2 = Math.imul(B, F), n2 = n2 + Math.imul(P, z) | 0, i3 = (i3 = i3 + Math.imul(P, K) | 0) + Math.imul(k, z) | 0, o2 = o2 + Math.imul(k, K) | 0, n2 = n2 + Math.imul(A2, W) | 0, i3 = (i3 = i3 + Math.imul(A2, J) | 0) + Math.imul(E2, W) | 0, o2 = o2 + Math.imul(E2, J) | 0, n2 = n2 + Math.imul(O2, Y) | 0, i3 = (i3 = i3 + Math.imul(O2, Q) | 0) + Math.imul(j2, Y) | 0, o2 = o2 + Math.imul(j2, Q) | 0, n2 = n2 + Math.imul(_, Z) | 0, i3 = (i3 = i3 + Math.imul(_, tt) | 0) + Math.imul(w3, Z) | 0, o2 = o2 + Math.imul(w3, tt) | 0, n2 = n2 + Math.imul(m3, rt) | 0, i3 = (i3 = i3 + Math.imul(m3, nt) | 0) + Math.imul(v2, rt) | 0, o2 = o2 + Math.imul(v2, nt) | 0, n2 = n2 + Math.imul(d3, ot) | 0, i3 = (i3 = i3 + Math.imul(d3, at) | 0) + Math.imul(y3, ot) | 0, o2 = o2 + Math.imul(y3, at) | 0;
          var Ot = (u2 + (n2 = n2 + Math.imul(l2, ct) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, ut) | 0) + Math.imul(h3, ct) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, ut) | 0) + (i3 >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n2 = Math.imul(R, q), i3 = (i3 = Math.imul(R, F)) + Math.imul(N, q) | 0, o2 = Math.imul(N, F), n2 = n2 + Math.imul(I, z) | 0, i3 = (i3 = i3 + Math.imul(I, K) | 0) + Math.imul(B, z) | 0, o2 = o2 + Math.imul(B, K) | 0, n2 = n2 + Math.imul(P, W) | 0, i3 = (i3 = i3 + Math.imul(P, J) | 0) + Math.imul(k, W) | 0, o2 = o2 + Math.imul(k, J) | 0, n2 = n2 + Math.imul(A2, Y) | 0, i3 = (i3 = i3 + Math.imul(A2, Q) | 0) + Math.imul(E2, Y) | 0, o2 = o2 + Math.imul(E2, Q) | 0, n2 = n2 + Math.imul(O2, Z) | 0, i3 = (i3 = i3 + Math.imul(O2, tt) | 0) + Math.imul(j2, Z) | 0, o2 = o2 + Math.imul(j2, tt) | 0, n2 = n2 + Math.imul(_, rt) | 0, i3 = (i3 = i3 + Math.imul(_, nt) | 0) + Math.imul(w3, rt) | 0, o2 = o2 + Math.imul(w3, nt) | 0, n2 = n2 + Math.imul(m3, ot) | 0, i3 = (i3 = i3 + Math.imul(m3, at) | 0) + Math.imul(v2, ot) | 0, o2 = o2 + Math.imul(v2, at) | 0, n2 = n2 + Math.imul(d3, ct) | 0, i3 = (i3 = i3 + Math.imul(d3, ut) | 0) + Math.imul(y3, ct) | 0, o2 = o2 + Math.imul(y3, ut) | 0;
          var jt = (u2 + (n2 = n2 + Math.imul(l2, lt2) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, ht) | 0) + Math.imul(h3, lt2) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, ht) | 0) + (i3 >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, n2 = Math.imul(L, q), i3 = (i3 = Math.imul(L, F)) + Math.imul(U, q) | 0, o2 = Math.imul(U, F), n2 = n2 + Math.imul(R, z) | 0, i3 = (i3 = i3 + Math.imul(R, K) | 0) + Math.imul(N, z) | 0, o2 = o2 + Math.imul(N, K) | 0, n2 = n2 + Math.imul(I, W) | 0, i3 = (i3 = i3 + Math.imul(I, J) | 0) + Math.imul(B, W) | 0, o2 = o2 + Math.imul(B, J) | 0, n2 = n2 + Math.imul(P, Y) | 0, i3 = (i3 = i3 + Math.imul(P, Q) | 0) + Math.imul(k, Y) | 0, o2 = o2 + Math.imul(k, Q) | 0, n2 = n2 + Math.imul(A2, Z) | 0, i3 = (i3 = i3 + Math.imul(A2, tt) | 0) + Math.imul(E2, Z) | 0, o2 = o2 + Math.imul(E2, tt) | 0, n2 = n2 + Math.imul(O2, rt) | 0, i3 = (i3 = i3 + Math.imul(O2, nt) | 0) + Math.imul(j2, rt) | 0, o2 = o2 + Math.imul(j2, nt) | 0, n2 = n2 + Math.imul(_, ot) | 0, i3 = (i3 = i3 + Math.imul(_, at) | 0) + Math.imul(w3, ot) | 0, o2 = o2 + Math.imul(w3, at) | 0, n2 = n2 + Math.imul(m3, ct) | 0, i3 = (i3 = i3 + Math.imul(m3, ut) | 0) + Math.imul(v2, ct) | 0, o2 = o2 + Math.imul(v2, ut) | 0, n2 = n2 + Math.imul(d3, lt2) | 0, i3 = (i3 = i3 + Math.imul(d3, ht) | 0) + Math.imul(y3, lt2) | 0, o2 = o2 + Math.imul(y3, ht) | 0;
          var $t = (u2 + (n2 = n2 + Math.imul(l2, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(l2, yt) | 0) + Math.imul(h3, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(h3, yt) | 0) + (i3 >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, n2 = Math.imul(L, z), i3 = (i3 = Math.imul(L, K)) + Math.imul(U, z) | 0, o2 = Math.imul(U, K), n2 = n2 + Math.imul(R, W) | 0, i3 = (i3 = i3 + Math.imul(R, J) | 0) + Math.imul(N, W) | 0, o2 = o2 + Math.imul(N, J) | 0, n2 = n2 + Math.imul(I, Y) | 0, i3 = (i3 = i3 + Math.imul(I, Q) | 0) + Math.imul(B, Y) | 0, o2 = o2 + Math.imul(B, Q) | 0, n2 = n2 + Math.imul(P, Z) | 0, i3 = (i3 = i3 + Math.imul(P, tt) | 0) + Math.imul(k, Z) | 0, o2 = o2 + Math.imul(k, tt) | 0, n2 = n2 + Math.imul(A2, rt) | 0, i3 = (i3 = i3 + Math.imul(A2, nt) | 0) + Math.imul(E2, rt) | 0, o2 = o2 + Math.imul(E2, nt) | 0, n2 = n2 + Math.imul(O2, ot) | 0, i3 = (i3 = i3 + Math.imul(O2, at) | 0) + Math.imul(j2, ot) | 0, o2 = o2 + Math.imul(j2, at) | 0, n2 = n2 + Math.imul(_, ct) | 0, i3 = (i3 = i3 + Math.imul(_, ut) | 0) + Math.imul(w3, ct) | 0, o2 = o2 + Math.imul(w3, ut) | 0, n2 = n2 + Math.imul(m3, lt2) | 0, i3 = (i3 = i3 + Math.imul(m3, ht) | 0) + Math.imul(v2, lt2) | 0, o2 = o2 + Math.imul(v2, ht) | 0;
          var At = (u2 + (n2 = n2 + Math.imul(d3, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(d3, yt) | 0) + Math.imul(y3, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(y3, yt) | 0) + (i3 >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n2 = Math.imul(L, W), i3 = (i3 = Math.imul(L, J)) + Math.imul(U, W) | 0, o2 = Math.imul(U, J), n2 = n2 + Math.imul(R, Y) | 0, i3 = (i3 = i3 + Math.imul(R, Q) | 0) + Math.imul(N, Y) | 0, o2 = o2 + Math.imul(N, Q) | 0, n2 = n2 + Math.imul(I, Z) | 0, i3 = (i3 = i3 + Math.imul(I, tt) | 0) + Math.imul(B, Z) | 0, o2 = o2 + Math.imul(B, tt) | 0, n2 = n2 + Math.imul(P, rt) | 0, i3 = (i3 = i3 + Math.imul(P, nt) | 0) + Math.imul(k, rt) | 0, o2 = o2 + Math.imul(k, nt) | 0, n2 = n2 + Math.imul(A2, ot) | 0, i3 = (i3 = i3 + Math.imul(A2, at) | 0) + Math.imul(E2, ot) | 0, o2 = o2 + Math.imul(E2, at) | 0, n2 = n2 + Math.imul(O2, ct) | 0, i3 = (i3 = i3 + Math.imul(O2, ut) | 0) + Math.imul(j2, ct) | 0, o2 = o2 + Math.imul(j2, ut) | 0, n2 = n2 + Math.imul(_, lt2) | 0, i3 = (i3 = i3 + Math.imul(_, ht) | 0) + Math.imul(w3, lt2) | 0, o2 = o2 + Math.imul(w3, ht) | 0;
          var Et = (u2 + (n2 = n2 + Math.imul(m3, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(m3, yt) | 0) + Math.imul(v2, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(v2, yt) | 0) + (i3 >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n2 = Math.imul(L, Y), i3 = (i3 = Math.imul(L, Q)) + Math.imul(U, Y) | 0, o2 = Math.imul(U, Q), n2 = n2 + Math.imul(R, Z) | 0, i3 = (i3 = i3 + Math.imul(R, tt) | 0) + Math.imul(N, Z) | 0, o2 = o2 + Math.imul(N, tt) | 0, n2 = n2 + Math.imul(I, rt) | 0, i3 = (i3 = i3 + Math.imul(I, nt) | 0) + Math.imul(B, rt) | 0, o2 = o2 + Math.imul(B, nt) | 0, n2 = n2 + Math.imul(P, ot) | 0, i3 = (i3 = i3 + Math.imul(P, at) | 0) + Math.imul(k, ot) | 0, o2 = o2 + Math.imul(k, at) | 0, n2 = n2 + Math.imul(A2, ct) | 0, i3 = (i3 = i3 + Math.imul(A2, ut) | 0) + Math.imul(E2, ct) | 0, o2 = o2 + Math.imul(E2, ut) | 0, n2 = n2 + Math.imul(O2, lt2) | 0, i3 = (i3 = i3 + Math.imul(O2, ht) | 0) + Math.imul(j2, lt2) | 0, o2 = o2 + Math.imul(j2, ht) | 0;
          var xt = (u2 + (n2 = n2 + Math.imul(_, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(_, yt) | 0) + Math.imul(w3, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(w3, yt) | 0) + (i3 >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n2 = Math.imul(L, Z), i3 = (i3 = Math.imul(L, tt)) + Math.imul(U, Z) | 0, o2 = Math.imul(U, tt), n2 = n2 + Math.imul(R, rt) | 0, i3 = (i3 = i3 + Math.imul(R, nt) | 0) + Math.imul(N, rt) | 0, o2 = o2 + Math.imul(N, nt) | 0, n2 = n2 + Math.imul(I, ot) | 0, i3 = (i3 = i3 + Math.imul(I, at) | 0) + Math.imul(B, ot) | 0, o2 = o2 + Math.imul(B, at) | 0, n2 = n2 + Math.imul(P, ct) | 0, i3 = (i3 = i3 + Math.imul(P, ut) | 0) + Math.imul(k, ct) | 0, o2 = o2 + Math.imul(k, ut) | 0, n2 = n2 + Math.imul(A2, lt2) | 0, i3 = (i3 = i3 + Math.imul(A2, ht) | 0) + Math.imul(E2, lt2) | 0, o2 = o2 + Math.imul(E2, ht) | 0;
          var Pt = (u2 + (n2 = n2 + Math.imul(O2, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(O2, yt) | 0) + Math.imul(j2, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(j2, yt) | 0) + (i3 >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n2 = Math.imul(L, rt), i3 = (i3 = Math.imul(L, nt)) + Math.imul(U, rt) | 0, o2 = Math.imul(U, nt), n2 = n2 + Math.imul(R, ot) | 0, i3 = (i3 = i3 + Math.imul(R, at) | 0) + Math.imul(N, ot) | 0, o2 = o2 + Math.imul(N, at) | 0, n2 = n2 + Math.imul(I, ct) | 0, i3 = (i3 = i3 + Math.imul(I, ut) | 0) + Math.imul(B, ct) | 0, o2 = o2 + Math.imul(B, ut) | 0, n2 = n2 + Math.imul(P, lt2) | 0, i3 = (i3 = i3 + Math.imul(P, ht) | 0) + Math.imul(k, lt2) | 0, o2 = o2 + Math.imul(k, ht) | 0;
          var kt = (u2 + (n2 = n2 + Math.imul(A2, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(A2, yt) | 0) + Math.imul(E2, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(E2, yt) | 0) + (i3 >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n2 = Math.imul(L, ot), i3 = (i3 = Math.imul(L, at)) + Math.imul(U, ot) | 0, o2 = Math.imul(U, at), n2 = n2 + Math.imul(R, ct) | 0, i3 = (i3 = i3 + Math.imul(R, ut) | 0) + Math.imul(N, ct) | 0, o2 = o2 + Math.imul(N, ut) | 0, n2 = n2 + Math.imul(I, lt2) | 0, i3 = (i3 = i3 + Math.imul(I, ht) | 0) + Math.imul(B, lt2) | 0, o2 = o2 + Math.imul(B, ht) | 0;
          var Mt = (u2 + (n2 = n2 + Math.imul(P, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(P, yt) | 0) + Math.imul(k, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(k, yt) | 0) + (i3 >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n2 = Math.imul(L, ct), i3 = (i3 = Math.imul(L, ut)) + Math.imul(U, ct) | 0, o2 = Math.imul(U, ut), n2 = n2 + Math.imul(R, lt2) | 0, i3 = (i3 = i3 + Math.imul(R, ht) | 0) + Math.imul(N, lt2) | 0, o2 = o2 + Math.imul(N, ht) | 0;
          var It = (u2 + (n2 = n2 + Math.imul(I, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(I, yt) | 0) + Math.imul(B, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(B, yt) | 0) + (i3 >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, n2 = Math.imul(L, lt2), i3 = (i3 = Math.imul(L, ht)) + Math.imul(U, lt2) | 0, o2 = Math.imul(U, ht);
          var Bt = (u2 + (n2 = n2 + Math.imul(R, dt) | 0) | 0) + ((8191 & (i3 = (i3 = i3 + Math.imul(R, yt) | 0) + Math.imul(N, dt) | 0)) << 13) | 0;
          u2 = ((o2 = o2 + Math.imul(N, yt) | 0) + (i3 >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863;
          var Tt = (u2 + (n2 = Math.imul(L, dt)) | 0) + ((8191 & (i3 = (i3 = Math.imul(L, yt)) + Math.imul(U, dt) | 0)) << 13) | 0;
          return u2 = ((o2 = Math.imul(U, yt)) + (i3 >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, c2[0] = bt, c2[1] = mt, c2[2] = vt, c2[3] = gt2, c2[4] = _t, c2[5] = wt, c2[6] = St, c2[7] = Ot, c2[8] = jt, c2[9] = $t, c2[10] = At, c2[11] = Et, c2[12] = xt, c2[13] = Pt, c2[14] = kt, c2[15] = Mt, c2[16] = It, c2[17] = Bt, c2[18] = Tt, 0 !== u2 && (c2[19] = u2, r3.length++), r3;
        };
        function v(t5, e4, r3) {
          r3.negative = e4.negative ^ t5.negative, r3.length = t5.length + e4.length;
          for (var n2 = 0, i3 = 0, o2 = 0; o2 < r3.length - 1; o2++) {
            var a2 = i3;
            i3 = 0;
            for (var s3 = 67108863 & n2, c2 = Math.min(o2, e4.length - 1), u2 = Math.max(0, o2 - t5.length + 1); u2 <= c2; u2++) {
              var f2 = o2 - u2, l2 = (0 | t5.words[f2]) * (0 | e4.words[u2]), h3 = 67108863 & l2;
              s3 = 67108863 & (h3 = h3 + s3 | 0), i3 += (a2 = (a2 = a2 + (l2 / 67108864 | 0) | 0) + (h3 >>> 26) | 0) >>> 26, a2 &= 67108863;
            }
            r3.words[o2] = s3, n2 = a2, a2 = i3;
          }
          return 0 !== n2 ? r3.words[o2] = n2 : r3.length--, r3._strip();
        }
        function g(t5, e4, r3) {
          return v(t5, e4, r3);
        }
        Math.imul || (m2 = b), a.prototype.mulTo = function(t5, e4) {
          var r3 = this.length + t5.length;
          return 10 === this.length && 10 === t5.length ? m2(this, t5, e4) : r3 < 63 ? b(this, t5, e4) : r3 < 1024 ? v(this, t5, e4) : g(this, t5, e4);
        }, a.prototype.mul = function(t5) {
          var e4 = new a(null);
          return e4.words = new Array(this.length + t5.length), this.mulTo(t5, e4);
        }, a.prototype.mulf = function(t5) {
          var e4 = new a(null);
          return e4.words = new Array(this.length + t5.length), g(this, t5, e4);
        }, a.prototype.imul = function(t5) {
          return this.clone().mulTo(t5, this);
        }, a.prototype.imuln = function(t5) {
          var e4 = t5 < 0;
          e4 && (t5 = -t5), i2("number" == typeof t5), i2(t5 < 67108864);
          for (var r3 = 0, n2 = 0; n2 < this.length; n2++) {
            var o2 = (0 | this.words[n2]) * t5, a2 = (67108863 & o2) + (67108863 & r3);
            r3 >>= 26, r3 += o2 / 67108864 | 0, r3 += a2 >>> 26, this.words[n2] = 67108863 & a2;
          }
          return 0 !== r3 && (this.words[n2] = r3, this.length++), e4 ? this.ineg() : this;
        }, a.prototype.muln = function(t5) {
          return this.clone().imuln(t5);
        }, a.prototype.sqr = function() {
          return this.mul(this);
        }, a.prototype.isqr = function() {
          return this.imul(this.clone());
        }, a.prototype.pow = function(t5) {
          var e4 = function(t6) {
            for (var e5 = new Array(t6.bitLength()), r4 = 0; r4 < e5.length; r4++) {
              var n3 = r4 / 26 | 0, i4 = r4 % 26;
              e5[r4] = t6.words[n3] >>> i4 & 1;
            }
            return e5;
          }(t5);
          if (0 === e4.length)
            return new a(1);
          for (var r3 = this, n2 = 0; n2 < e4.length && 0 === e4[n2]; n2++, r3 = r3.sqr())
            ;
          if (++n2 < e4.length)
            for (var i3 = r3.sqr(); n2 < e4.length; n2++, i3 = i3.sqr())
              0 !== e4[n2] && (r3 = r3.mul(i3));
          return r3;
        }, a.prototype.iushln = function(t5) {
          i2("number" == typeof t5 && t5 >= 0);
          var e4, r3 = t5 % 26, n2 = (t5 - r3) / 26, o2 = 67108863 >>> 26 - r3 << 26 - r3;
          if (0 !== r3) {
            var a2 = 0;
            for (e4 = 0; e4 < this.length; e4++) {
              var s3 = this.words[e4] & o2, c2 = (0 | this.words[e4]) - s3 << r3;
              this.words[e4] = c2 | a2, a2 = s3 >>> 26 - r3;
            }
            a2 && (this.words[e4] = a2, this.length++);
          }
          if (0 !== n2) {
            for (e4 = this.length - 1; e4 >= 0; e4--)
              this.words[e4 + n2] = this.words[e4];
            for (e4 = 0; e4 < n2; e4++)
              this.words[e4] = 0;
            this.length += n2;
          }
          return this._strip();
        }, a.prototype.ishln = function(t5) {
          return i2(0 === this.negative), this.iushln(t5);
        }, a.prototype.iushrn = function(t5, e4, r3) {
          var n2;
          i2("number" == typeof t5 && t5 >= 0), n2 = e4 ? (e4 - e4 % 26) / 26 : 0;
          var o2 = t5 % 26, a2 = Math.min((t5 - o2) / 26, this.length), s3 = 67108863 ^ 67108863 >>> o2 << o2, c2 = r3;
          if (n2 -= a2, n2 = Math.max(0, n2), c2) {
            for (var u2 = 0; u2 < a2; u2++)
              c2.words[u2] = this.words[u2];
            c2.length = a2;
          }
          if (0 === a2)
            ;
          else if (this.length > a2)
            for (this.length -= a2, u2 = 0; u2 < this.length; u2++)
              this.words[u2] = this.words[u2 + a2];
          else
            this.words[0] = 0, this.length = 1;
          var f2 = 0;
          for (u2 = this.length - 1; u2 >= 0 && (0 !== f2 || u2 >= n2); u2--) {
            var l2 = 0 | this.words[u2];
            this.words[u2] = f2 << 26 - o2 | l2 >>> o2, f2 = l2 & s3;
          }
          return c2 && 0 !== f2 && (c2.words[c2.length++] = f2), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
        }, a.prototype.ishrn = function(t5, e4, r3) {
          return i2(0 === this.negative), this.iushrn(t5, e4, r3);
        }, a.prototype.shln = function(t5) {
          return this.clone().ishln(t5);
        }, a.prototype.ushln = function(t5) {
          return this.clone().iushln(t5);
        }, a.prototype.shrn = function(t5) {
          return this.clone().ishrn(t5);
        }, a.prototype.ushrn = function(t5) {
          return this.clone().iushrn(t5);
        }, a.prototype.testn = function(t5) {
          i2("number" == typeof t5 && t5 >= 0);
          var e4 = t5 % 26, r3 = (t5 - e4) / 26, n2 = 1 << e4;
          return !(this.length <= r3 || !(this.words[r3] & n2));
        }, a.prototype.imaskn = function(t5) {
          i2("number" == typeof t5 && t5 >= 0);
          var e4 = t5 % 26, r3 = (t5 - e4) / 26;
          if (i2(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r3)
            return this;
          if (0 !== e4 && r3++, this.length = Math.min(r3, this.length), 0 !== e4) {
            var n2 = 67108863 ^ 67108863 >>> e4 << e4;
            this.words[this.length - 1] &= n2;
          }
          return this._strip();
        }, a.prototype.maskn = function(t5) {
          return this.clone().imaskn(t5);
        }, a.prototype.iaddn = function(t5) {
          return i2("number" == typeof t5), i2(t5 < 67108864), t5 < 0 ? this.isubn(-t5) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= t5 ? (this.words[0] = t5 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t5), this.negative = 1, this) : this._iaddn(t5);
        }, a.prototype._iaddn = function(t5) {
          this.words[0] += t5;
          for (var e4 = 0; e4 < this.length && this.words[e4] >= 67108864; e4++)
            this.words[e4] -= 67108864, e4 === this.length - 1 ? this.words[e4 + 1] = 1 : this.words[e4 + 1]++;
          return this.length = Math.max(this.length, e4 + 1), this;
        }, a.prototype.isubn = function(t5) {
          if (i2("number" == typeof t5), i2(t5 < 67108864), t5 < 0)
            return this.iaddn(-t5);
          if (0 !== this.negative)
            return this.negative = 0, this.iaddn(t5), this.negative = 1, this;
          if (this.words[0] -= t5, 1 === this.length && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var e4 = 0; e4 < this.length && this.words[e4] < 0; e4++)
              this.words[e4] += 67108864, this.words[e4 + 1] -= 1;
          return this._strip();
        }, a.prototype.addn = function(t5) {
          return this.clone().iaddn(t5);
        }, a.prototype.subn = function(t5) {
          return this.clone().isubn(t5);
        }, a.prototype.iabs = function() {
          return this.negative = 0, this;
        }, a.prototype.abs = function() {
          return this.clone().iabs();
        }, a.prototype._ishlnsubmul = function(t5, e4, r3) {
          var n2, o2, a2 = t5.length + r3;
          this._expand(a2);
          var s3 = 0;
          for (n2 = 0; n2 < t5.length; n2++) {
            o2 = (0 | this.words[n2 + r3]) + s3;
            var c2 = (0 | t5.words[n2]) * e4;
            s3 = ((o2 -= 67108863 & c2) >> 26) - (c2 / 67108864 | 0), this.words[n2 + r3] = 67108863 & o2;
          }
          for (; n2 < this.length - r3; n2++)
            s3 = (o2 = (0 | this.words[n2 + r3]) + s3) >> 26, this.words[n2 + r3] = 67108863 & o2;
          if (0 === s3)
            return this._strip();
          for (i2(-1 === s3), s3 = 0, n2 = 0; n2 < this.length; n2++)
            s3 = (o2 = -(0 | this.words[n2]) + s3) >> 26, this.words[n2] = 67108863 & o2;
          return this.negative = 1, this._strip();
        }, a.prototype._wordDiv = function(t5, e4) {
          var r3 = (this.length, t5.length), n2 = this.clone(), i3 = t5, o2 = 0 | i3.words[i3.length - 1];
          0 != (r3 = 26 - this._countBits(o2)) && (i3 = i3.ushln(r3), n2.iushln(r3), o2 = 0 | i3.words[i3.length - 1]);
          var s3, c2 = n2.length - i3.length;
          if ("mod" !== e4) {
            (s3 = new a(null)).length = c2 + 1, s3.words = new Array(s3.length);
            for (var u2 = 0; u2 < s3.length; u2++)
              s3.words[u2] = 0;
          }
          var f2 = n2.clone()._ishlnsubmul(i3, 1, c2);
          0 === f2.negative && (n2 = f2, s3 && (s3.words[c2] = 1));
          for (var l2 = c2 - 1; l2 >= 0; l2--) {
            var h3 = 67108864 * (0 | n2.words[i3.length + l2]) + (0 | n2.words[i3.length + l2 - 1]);
            for (h3 = Math.min(h3 / o2 | 0, 67108863), n2._ishlnsubmul(i3, h3, l2); 0 !== n2.negative; )
              h3--, n2.negative = 0, n2._ishlnsubmul(i3, 1, l2), n2.isZero() || (n2.negative ^= 1);
            s3 && (s3.words[l2] = h3);
          }
          return s3 && s3._strip(), n2._strip(), "div" !== e4 && 0 !== r3 && n2.iushrn(r3), { div: s3 || null, mod: n2 };
        }, a.prototype.divmod = function(t5, e4, r3) {
          return i2(!t5.isZero()), this.isZero() ? { div: new a(0), mod: new a(0) } : 0 !== this.negative && 0 === t5.negative ? (s3 = this.neg().divmod(t5, e4), "mod" !== e4 && (n2 = s3.div.neg()), "div" !== e4 && (o2 = s3.mod.neg(), r3 && 0 !== o2.negative && o2.iadd(t5)), { div: n2, mod: o2 }) : 0 === this.negative && 0 !== t5.negative ? (s3 = this.divmod(t5.neg(), e4), "mod" !== e4 && (n2 = s3.div.neg()), { div: n2, mod: s3.mod }) : this.negative & t5.negative ? (s3 = this.neg().divmod(t5.neg(), e4), "div" !== e4 && (o2 = s3.mod.neg(), r3 && 0 !== o2.negative && o2.isub(t5)), { div: s3.div, mod: o2 }) : t5.length > this.length || this.cmp(t5) < 0 ? { div: new a(0), mod: this } : 1 === t5.length ? "div" === e4 ? { div: this.divn(t5.words[0]), mod: null } : "mod" === e4 ? { div: null, mod: new a(this.modrn(t5.words[0])) } : { div: this.divn(t5.words[0]), mod: new a(this.modrn(t5.words[0])) } : this._wordDiv(t5, e4);
          var n2, o2, s3;
        }, a.prototype.div = function(t5) {
          return this.divmod(t5, "div", false).div;
        }, a.prototype.mod = function(t5) {
          return this.divmod(t5, "mod", false).mod;
        }, a.prototype.umod = function(t5) {
          return this.divmod(t5, "mod", true).mod;
        }, a.prototype.divRound = function(t5) {
          var e4 = this.divmod(t5);
          if (e4.mod.isZero())
            return e4.div;
          var r3 = 0 !== e4.div.negative ? e4.mod.isub(t5) : e4.mod, n2 = t5.ushrn(1), i3 = t5.andln(1), o2 = r3.cmp(n2);
          return o2 < 0 || 1 === i3 && 0 === o2 ? e4.div : 0 !== e4.div.negative ? e4.div.isubn(1) : e4.div.iaddn(1);
        }, a.prototype.modrn = function(t5) {
          var e4 = t5 < 0;
          e4 && (t5 = -t5), i2(t5 <= 67108863);
          for (var r3 = (1 << 26) % t5, n2 = 0, o2 = this.length - 1; o2 >= 0; o2--)
            n2 = (r3 * n2 + (0 | this.words[o2])) % t5;
          return e4 ? -n2 : n2;
        }, a.prototype.modn = function(t5) {
          return this.modrn(t5);
        }, a.prototype.idivn = function(t5) {
          var e4 = t5 < 0;
          e4 && (t5 = -t5), i2(t5 <= 67108863);
          for (var r3 = 0, n2 = this.length - 1; n2 >= 0; n2--) {
            var o2 = (0 | this.words[n2]) + 67108864 * r3;
            this.words[n2] = o2 / t5 | 0, r3 = o2 % t5;
          }
          return this._strip(), e4 ? this.ineg() : this;
        }, a.prototype.divn = function(t5) {
          return this.clone().idivn(t5);
        }, a.prototype.egcd = function(t5) {
          i2(0 === t5.negative), i2(!t5.isZero());
          var e4 = this, r3 = t5.clone();
          e4 = 0 !== e4.negative ? e4.umod(t5) : e4.clone();
          for (var n2 = new a(1), o2 = new a(0), s3 = new a(0), c2 = new a(1), u2 = 0; e4.isEven() && r3.isEven(); )
            e4.iushrn(1), r3.iushrn(1), ++u2;
          for (var f2 = r3.clone(), l2 = e4.clone(); !e4.isZero(); ) {
            for (var h3 = 0, p2 = 1; !(e4.words[0] & p2) && h3 < 26; ++h3, p2 <<= 1)
              ;
            if (h3 > 0)
              for (e4.iushrn(h3); h3-- > 0; )
                (n2.isOdd() || o2.isOdd()) && (n2.iadd(f2), o2.isub(l2)), n2.iushrn(1), o2.iushrn(1);
            for (var d3 = 0, y3 = 1; !(r3.words[0] & y3) && d3 < 26; ++d3, y3 <<= 1)
              ;
            if (d3 > 0)
              for (r3.iushrn(d3); d3-- > 0; )
                (s3.isOdd() || c2.isOdd()) && (s3.iadd(f2), c2.isub(l2)), s3.iushrn(1), c2.iushrn(1);
            e4.cmp(r3) >= 0 ? (e4.isub(r3), n2.isub(s3), o2.isub(c2)) : (r3.isub(e4), s3.isub(n2), c2.isub(o2));
          }
          return { a: s3, b: c2, gcd: r3.iushln(u2) };
        }, a.prototype._invmp = function(t5) {
          i2(0 === t5.negative), i2(!t5.isZero());
          var e4 = this, r3 = t5.clone();
          e4 = 0 !== e4.negative ? e4.umod(t5) : e4.clone();
          for (var n2, o2 = new a(1), s3 = new a(0), c2 = r3.clone(); e4.cmpn(1) > 0 && r3.cmpn(1) > 0; ) {
            for (var u2 = 0, f2 = 1; !(e4.words[0] & f2) && u2 < 26; ++u2, f2 <<= 1)
              ;
            if (u2 > 0)
              for (e4.iushrn(u2); u2-- > 0; )
                o2.isOdd() && o2.iadd(c2), o2.iushrn(1);
            for (var l2 = 0, h3 = 1; !(r3.words[0] & h3) && l2 < 26; ++l2, h3 <<= 1)
              ;
            if (l2 > 0)
              for (r3.iushrn(l2); l2-- > 0; )
                s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
            e4.cmp(r3) >= 0 ? (e4.isub(r3), o2.isub(s3)) : (r3.isub(e4), s3.isub(o2));
          }
          return (n2 = 0 === e4.cmpn(1) ? o2 : s3).cmpn(0) < 0 && n2.iadd(t5), n2;
        }, a.prototype.gcd = function(t5) {
          if (this.isZero())
            return t5.abs();
          if (t5.isZero())
            return this.abs();
          var e4 = this.clone(), r3 = t5.clone();
          e4.negative = 0, r3.negative = 0;
          for (var n2 = 0; e4.isEven() && r3.isEven(); n2++)
            e4.iushrn(1), r3.iushrn(1);
          for (; ; ) {
            for (; e4.isEven(); )
              e4.iushrn(1);
            for (; r3.isEven(); )
              r3.iushrn(1);
            var i3 = e4.cmp(r3);
            if (i3 < 0) {
              var o2 = e4;
              e4 = r3, r3 = o2;
            } else if (0 === i3 || 0 === r3.cmpn(1))
              break;
            e4.isub(r3);
          }
          return r3.iushln(n2);
        }, a.prototype.invm = function(t5) {
          return this.egcd(t5).a.umod(t5);
        }, a.prototype.isEven = function() {
          return !(1 & this.words[0]);
        }, a.prototype.isOdd = function() {
          return !(1 & ~this.words[0]);
        }, a.prototype.andln = function(t5) {
          return this.words[0] & t5;
        }, a.prototype.bincn = function(t5) {
          i2("number" == typeof t5);
          var e4 = t5 % 26, r3 = (t5 - e4) / 26, n2 = 1 << e4;
          if (this.length <= r3)
            return this._expand(r3 + 1), this.words[r3] |= n2, this;
          for (var o2 = n2, a2 = r3; 0 !== o2 && a2 < this.length; a2++) {
            var s3 = 0 | this.words[a2];
            o2 = (s3 += o2) >>> 26, s3 &= 67108863, this.words[a2] = s3;
          }
          return 0 !== o2 && (this.words[a2] = o2, this.length++), this;
        }, a.prototype.isZero = function() {
          return 1 === this.length && 0 === this.words[0];
        }, a.prototype.cmpn = function(t5) {
          var e4, r3 = t5 < 0;
          if (0 !== this.negative && !r3)
            return -1;
          if (0 === this.negative && r3)
            return 1;
          if (this._strip(), this.length > 1)
            e4 = 1;
          else {
            r3 && (t5 = -t5), i2(t5 <= 67108863, "Number is too big");
            var n2 = 0 | this.words[0];
            e4 = n2 === t5 ? 0 : n2 < t5 ? -1 : 1;
          }
          return 0 !== this.negative ? 0 | -e4 : e4;
        }, a.prototype.cmp = function(t5) {
          if (0 !== this.negative && 0 === t5.negative)
            return -1;
          if (0 === this.negative && 0 !== t5.negative)
            return 1;
          var e4 = this.ucmp(t5);
          return 0 !== this.negative ? 0 | -e4 : e4;
        }, a.prototype.ucmp = function(t5) {
          if (this.length > t5.length)
            return 1;
          if (this.length < t5.length)
            return -1;
          for (var e4 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
            var n2 = 0 | this.words[r3], i3 = 0 | t5.words[r3];
            if (n2 !== i3) {
              n2 < i3 ? e4 = -1 : n2 > i3 && (e4 = 1);
              break;
            }
          }
          return e4;
        }, a.prototype.gtn = function(t5) {
          return 1 === this.cmpn(t5);
        }, a.prototype.gt = function(t5) {
          return 1 === this.cmp(t5);
        }, a.prototype.gten = function(t5) {
          return this.cmpn(t5) >= 0;
        }, a.prototype.gte = function(t5) {
          return this.cmp(t5) >= 0;
        }, a.prototype.ltn = function(t5) {
          return -1 === this.cmpn(t5);
        }, a.prototype.lt = function(t5) {
          return -1 === this.cmp(t5);
        }, a.prototype.lten = function(t5) {
          return this.cmpn(t5) <= 0;
        }, a.prototype.lte = function(t5) {
          return this.cmp(t5) <= 0;
        }, a.prototype.eqn = function(t5) {
          return 0 === this.cmpn(t5);
        }, a.prototype.eq = function(t5) {
          return 0 === this.cmp(t5);
        }, a.red = function(t5) {
          return new E(t5);
        }, a.prototype.toRed = function(t5) {
          return i2(!this.red, "Already a number in reduction context"), i2(0 === this.negative, "red works only with positives"), t5.convertTo(this)._forceRed(t5);
        }, a.prototype.fromRed = function() {
          return i2(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, a.prototype._forceRed = function(t5) {
          return this.red = t5, this;
        }, a.prototype.forceRed = function(t5) {
          return i2(!this.red, "Already a number in reduction context"), this._forceRed(t5);
        }, a.prototype.redAdd = function(t5) {
          return i2(this.red, "redAdd works only with red numbers"), this.red.add(this, t5);
        }, a.prototype.redIAdd = function(t5) {
          return i2(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t5);
        }, a.prototype.redSub = function(t5) {
          return i2(this.red, "redSub works only with red numbers"), this.red.sub(this, t5);
        }, a.prototype.redISub = function(t5) {
          return i2(this.red, "redISub works only with red numbers"), this.red.isub(this, t5);
        }, a.prototype.redShl = function(t5) {
          return i2(this.red, "redShl works only with red numbers"), this.red.shl(this, t5);
        }, a.prototype.redMul = function(t5) {
          return i2(this.red, "redMul works only with red numbers"), this.red._verify2(this, t5), this.red.mul(this, t5);
        }, a.prototype.redIMul = function(t5) {
          return i2(this.red, "redMul works only with red numbers"), this.red._verify2(this, t5), this.red.imul(this, t5);
        }, a.prototype.redSqr = function() {
          return i2(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, a.prototype.redISqr = function() {
          return i2(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, a.prototype.redSqrt = function() {
          return i2(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, a.prototype.redInvm = function() {
          return i2(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, a.prototype.redNeg = function() {
          return i2(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, a.prototype.redPow = function(t5) {
          return i2(this.red && !t5.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t5);
        };
        var w2 = { k256: null, p224: null, p192: null, p25519: null };
        function S(t5, e4) {
          this.name = t5, this.p = new a(e4, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function O() {
          S.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function j() {
          S.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function $() {
          S.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function A() {
          S.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function E(t5) {
          if ("string" == typeof t5) {
            var e4 = a._prime(t5);
            this.m = e4.p, this.prime = e4;
          } else
            i2(t5.gtn(1), "modulus must be greater than 1"), this.m = t5, this.prime = null;
        }
        function x(t5) {
          E.call(this, t5), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        S.prototype._tmp = function() {
          var t5 = new a(null);
          return t5.words = new Array(Math.ceil(this.n / 13)), t5;
        }, S.prototype.ireduce = function(t5) {
          var e4, r3 = t5;
          do {
            this.split(r3, this.tmp), e4 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
          } while (e4 > this.n);
          var n2 = e4 < this.n ? -1 : r3.ucmp(this.p);
          return 0 === n2 ? (r3.words[0] = 0, r3.length = 1) : n2 > 0 ? r3.isub(this.p) : void 0 !== r3.strip ? r3.strip() : r3._strip(), r3;
        }, S.prototype.split = function(t5, e4) {
          t5.iushrn(this.n, 0, e4);
        }, S.prototype.imulK = function(t5) {
          return t5.imul(this.k);
        }, o(O, S), O.prototype.split = function(t5, e4) {
          for (var r3 = 4194303, n2 = Math.min(t5.length, 9), i3 = 0; i3 < n2; i3++)
            e4.words[i3] = t5.words[i3];
          if (e4.length = n2, t5.length <= 9)
            return t5.words[0] = 0, void (t5.length = 1);
          var o2 = t5.words[9];
          for (e4.words[e4.length++] = o2 & r3, i3 = 10; i3 < t5.length; i3++) {
            var a2 = 0 | t5.words[i3];
            t5.words[i3 - 10] = (a2 & r3) << 4 | o2 >>> 22, o2 = a2;
          }
          o2 >>>= 22, t5.words[i3 - 10] = o2, 0 === o2 && t5.length > 10 ? t5.length -= 10 : t5.length -= 9;
        }, O.prototype.imulK = function(t5) {
          t5.words[t5.length] = 0, t5.words[t5.length + 1] = 0, t5.length += 2;
          for (var e4 = 0, r3 = 0; r3 < t5.length; r3++) {
            var n2 = 0 | t5.words[r3];
            e4 += 977 * n2, t5.words[r3] = 67108863 & e4, e4 = 64 * n2 + (e4 / 67108864 | 0);
          }
          return 0 === t5.words[t5.length - 1] && (t5.length--, 0 === t5.words[t5.length - 1] && t5.length--), t5;
        }, o(j, S), o($, S), o(A, S), A.prototype.imulK = function(t5) {
          for (var e4 = 0, r3 = 0; r3 < t5.length; r3++) {
            var n2 = 19 * (0 | t5.words[r3]) + e4, i3 = 67108863 & n2;
            n2 >>>= 26, t5.words[r3] = i3, e4 = n2;
          }
          return 0 !== e4 && (t5.words[t5.length++] = e4), t5;
        }, a._prime = function(t5) {
          if (w2[t5])
            return w2[t5];
          var e4;
          if ("k256" === t5)
            e4 = new O();
          else if ("p224" === t5)
            e4 = new j();
          else if ("p192" === t5)
            e4 = new $();
          else {
            if ("p25519" !== t5)
              throw new Error("Unknown prime " + t5);
            e4 = new A();
          }
          return w2[t5] = e4, e4;
        }, E.prototype._verify1 = function(t5) {
          i2(0 === t5.negative, "red works only with positives"), i2(t5.red, "red works only with red numbers");
        }, E.prototype._verify2 = function(t5, e4) {
          i2(!(t5.negative | e4.negative), "red works only with positives"), i2(t5.red && t5.red === e4.red, "red works only with red numbers");
        }, E.prototype.imod = function(t5) {
          return this.prime ? this.prime.ireduce(t5)._forceRed(this) : (l(t5, t5.umod(this.m)._forceRed(this)), t5);
        }, E.prototype.neg = function(t5) {
          return t5.isZero() ? t5.clone() : this.m.sub(t5)._forceRed(this);
        }, E.prototype.add = function(t5, e4) {
          this._verify2(t5, e4);
          var r3 = t5.add(e4);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
        }, E.prototype.iadd = function(t5, e4) {
          this._verify2(t5, e4);
          var r3 = t5.iadd(e4);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
        }, E.prototype.sub = function(t5, e4) {
          this._verify2(t5, e4);
          var r3 = t5.sub(e4);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
        }, E.prototype.isub = function(t5, e4) {
          this._verify2(t5, e4);
          var r3 = t5.isub(e4);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
        }, E.prototype.shl = function(t5, e4) {
          return this._verify1(t5), this.imod(t5.ushln(e4));
        }, E.prototype.imul = function(t5, e4) {
          return this._verify2(t5, e4), this.imod(t5.imul(e4));
        }, E.prototype.mul = function(t5, e4) {
          return this._verify2(t5, e4), this.imod(t5.mul(e4));
        }, E.prototype.isqr = function(t5) {
          return this.imul(t5, t5.clone());
        }, E.prototype.sqr = function(t5) {
          return this.mul(t5, t5);
        }, E.prototype.sqrt = function(t5) {
          if (t5.isZero())
            return t5.clone();
          var e4 = this.m.andln(3);
          if (i2(e4 % 2 == 1), 3 === e4) {
            var r3 = this.m.add(new a(1)).iushrn(2);
            return this.pow(t5, r3);
          }
          for (var n2 = this.m.subn(1), o2 = 0; !n2.isZero() && 0 === n2.andln(1); )
            o2++, n2.iushrn(1);
          i2(!n2.isZero());
          var s3 = new a(1).toRed(this), c2 = s3.redNeg(), u2 = this.m.subn(1).iushrn(1), f2 = this.m.bitLength();
          for (f2 = new a(2 * f2 * f2).toRed(this); 0 !== this.pow(f2, u2).cmp(c2); )
            f2.redIAdd(c2);
          for (var l2 = this.pow(f2, n2), h3 = this.pow(t5, n2.addn(1).iushrn(1)), p2 = this.pow(t5, n2), d3 = o2; 0 !== p2.cmp(s3); ) {
            for (var y3 = p2, b2 = 0; 0 !== y3.cmp(s3); b2++)
              y3 = y3.redSqr();
            i2(b2 < d3);
            var m3 = this.pow(l2, new a(1).iushln(d3 - b2 - 1));
            h3 = h3.redMul(m3), l2 = m3.redSqr(), p2 = p2.redMul(l2), d3 = b2;
          }
          return h3;
        }, E.prototype.invm = function(t5) {
          var e4 = t5._invmp(this.m);
          return 0 !== e4.negative ? (e4.negative = 0, this.imod(e4).redNeg()) : this.imod(e4);
        }, E.prototype.pow = function(t5, e4) {
          if (e4.isZero())
            return new a(1).toRed(this);
          if (0 === e4.cmpn(1))
            return t5.clone();
          var r3 = new Array(16);
          r3[0] = new a(1).toRed(this), r3[1] = t5;
          for (var n2 = 2; n2 < r3.length; n2++)
            r3[n2] = this.mul(r3[n2 - 1], t5);
          var i3 = r3[0], o2 = 0, s3 = 0, c2 = e4.bitLength() % 26;
          for (0 === c2 && (c2 = 26), n2 = e4.length - 1; n2 >= 0; n2--) {
            for (var u2 = e4.words[n2], f2 = c2 - 1; f2 >= 0; f2--) {
              var l2 = u2 >> f2 & 1;
              i3 !== r3[0] && (i3 = this.sqr(i3)), 0 !== l2 || 0 !== o2 ? (o2 <<= 1, o2 |= l2, (4 == ++s3 || 0 === n2 && 0 === f2) && (i3 = this.mul(i3, r3[o2]), s3 = 0, o2 = 0)) : s3 = 0;
            }
            c2 = 26;
          }
          return i3;
        }, E.prototype.convertTo = function(t5) {
          var e4 = t5.umod(this.m);
          return e4 === t5 ? e4.clone() : e4;
        }, E.prototype.convertFrom = function(t5) {
          var e4 = t5.clone();
          return e4.red = null, e4;
        }, a.mont = function(t5) {
          return new x(t5);
        }, o(x, E), x.prototype.convertTo = function(t5) {
          return this.imod(t5.ushln(this.shift));
        }, x.prototype.convertFrom = function(t5) {
          var e4 = this.imod(t5.mul(this.rinv));
          return e4.red = null, e4;
        }, x.prototype.imul = function(t5, e4) {
          if (t5.isZero() || e4.isZero())
            return t5.words[0] = 0, t5.length = 1, t5;
          var r3 = t5.imul(e4), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i3 = r3.isub(n2).iushrn(this.shift), o2 = i3;
          return i3.cmp(this.m) >= 0 ? o2 = i3.isub(this.m) : i3.cmpn(0) < 0 && (o2 = i3.iadd(this.m)), o2._forceRed(this);
        }, x.prototype.mul = function(t5, e4) {
          if (t5.isZero() || e4.isZero())
            return new a(0)._forceRed(this);
          var r3 = t5.mul(e4), n2 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i3 = r3.isub(n2).iushrn(this.shift), o2 = i3;
          return i3.cmp(this.m) >= 0 ? o2 = i3.isub(this.m) : i3.cmpn(0) < 0 && (o2 = i3.iadd(this.m)), o2._forceRed(this);
        }, x.prototype.invm = function(t5) {
          return this.imod(t5._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(t3 = r2.nmd(t3), this);
    }, 8904: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2;
      function o(t4) {
        this.rand = t4;
      }
      if (t3.exports = function(t4) {
        return i2 || (i2 = new o(null)), i2.generate(t4);
      }, t3.exports.Rand = o, o.prototype.generate = function(t4) {
        return this._rand(t4);
      }, o.prototype._rand = function(t4) {
        if (this.rand.getBytes)
          return this.rand.getBytes(t4);
        for (var e3 = new Uint8Array(t4), r3 = 0; r3 < e3.length; r3++)
          e3[r3] = this.rand.getByte();
        return e3;
      }, "object" === ("undefined" == typeof self ? "undefined" : n(self)))
        self.crypto && self.crypto.getRandomValues ? o.prototype._rand = function(t4) {
          var e3 = new Uint8Array(t4);
          return self.crypto.getRandomValues(e3), e3;
        } : self.msCrypto && self.msCrypto.getRandomValues ? o.prototype._rand = function(t4) {
          var e3 = new Uint8Array(t4);
          return self.msCrypto.getRandomValues(e3), e3;
        } : "object" === ("undefined" == typeof window ? "undefined" : n(window)) && (o.prototype._rand = function() {
          throw new Error("Not implemented yet");
        });
      else
        try {
          var a = r2(3776);
          if ("function" != typeof a.randomBytes)
            throw new Error("Not supported");
          o.prototype._rand = function(t4) {
            return a.randomBytes(t4);
          };
        } catch (t4) {
        }
    }, 5401: (t3, e2, r2) => {
      var n = r2(9732).Buffer;
      function i2(t4) {
        n.isBuffer(t4) || (t4 = n.from(t4));
        for (var e3 = t4.length / 4 | 0, r3 = new Array(e3), i3 = 0; i3 < e3; i3++)
          r3[i3] = t4.readUInt32BE(4 * i3);
        return r3;
      }
      function o(t4) {
        for (; 0 < t4.length; t4++)
          t4[0] = 0;
      }
      function a(t4, e3, r3, n2, i3) {
        for (var o2, a2, s3, c2, u2 = r3[0], f = r3[1], l = r3[2], h2 = r3[3], p = t4[0] ^ e3[0], d2 = t4[1] ^ e3[1], y2 = t4[2] ^ e3[2], b = t4[3] ^ e3[3], m2 = 4, v = 1; v < i3; v++)
          o2 = u2[p >>> 24] ^ f[d2 >>> 16 & 255] ^ l[y2 >>> 8 & 255] ^ h2[255 & b] ^ e3[m2++], a2 = u2[d2 >>> 24] ^ f[y2 >>> 16 & 255] ^ l[b >>> 8 & 255] ^ h2[255 & p] ^ e3[m2++], s3 = u2[y2 >>> 24] ^ f[b >>> 16 & 255] ^ l[p >>> 8 & 255] ^ h2[255 & d2] ^ e3[m2++], c2 = u2[b >>> 24] ^ f[p >>> 16 & 255] ^ l[d2 >>> 8 & 255] ^ h2[255 & y2] ^ e3[m2++], p = o2, d2 = a2, y2 = s3, b = c2;
        return o2 = (n2[p >>> 24] << 24 | n2[d2 >>> 16 & 255] << 16 | n2[y2 >>> 8 & 255] << 8 | n2[255 & b]) ^ e3[m2++], a2 = (n2[d2 >>> 24] << 24 | n2[y2 >>> 16 & 255] << 16 | n2[b >>> 8 & 255] << 8 | n2[255 & p]) ^ e3[m2++], s3 = (n2[y2 >>> 24] << 24 | n2[b >>> 16 & 255] << 16 | n2[p >>> 8 & 255] << 8 | n2[255 & d2]) ^ e3[m2++], c2 = (n2[b >>> 24] << 24 | n2[p >>> 16 & 255] << 16 | n2[d2 >>> 8 & 255] << 8 | n2[255 & y2]) ^ e3[m2++], [o2 >>>= 0, a2 >>>= 0, s3 >>>= 0, c2 >>>= 0];
      }
      var s2 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], c = function() {
        for (var t4 = new Array(256), e3 = 0; e3 < 256; e3++)
          t4[e3] = e3 < 128 ? e3 << 1 : e3 << 1 ^ 283;
        for (var r3 = [], n2 = [], i3 = [[], [], [], []], o2 = [[], [], [], []], a2 = 0, s3 = 0, c2 = 0; c2 < 256; ++c2) {
          var u2 = s3 ^ s3 << 1 ^ s3 << 2 ^ s3 << 3 ^ s3 << 4;
          u2 = u2 >>> 8 ^ 255 & u2 ^ 99, r3[a2] = u2, n2[u2] = a2;
          var f = t4[a2], l = t4[f], h2 = t4[l], p = 257 * t4[u2] ^ 16843008 * u2;
          i3[0][a2] = p << 24 | p >>> 8, i3[1][a2] = p << 16 | p >>> 16, i3[2][a2] = p << 8 | p >>> 24, i3[3][a2] = p, p = 16843009 * h2 ^ 65537 * l ^ 257 * f ^ 16843008 * a2, o2[0][u2] = p << 24 | p >>> 8, o2[1][u2] = p << 16 | p >>> 16, o2[2][u2] = p << 8 | p >>> 24, o2[3][u2] = p, 0 === a2 ? a2 = s3 = 1 : (a2 = f ^ t4[t4[t4[h2 ^ f]]], s3 ^= t4[t4[s3]]);
        }
        return { SBOX: r3, INV_SBOX: n2, SUB_MIX: i3, INV_SUB_MIX: o2 };
      }();
      function u(t4) {
        this._key = i2(t4), this._reset();
      }
      u.blockSize = 16, u.keySize = 32, u.prototype.blockSize = u.blockSize, u.prototype.keySize = u.keySize, u.prototype._reset = function() {
        for (var t4 = this._key, e3 = t4.length, r3 = e3 + 6, n2 = 4 * (r3 + 1), i3 = [], o2 = 0; o2 < e3; o2++)
          i3[o2] = t4[o2];
        for (o2 = e3; o2 < n2; o2++) {
          var a2 = i3[o2 - 1];
          o2 % e3 == 0 ? (a2 = a2 << 8 | a2 >>> 24, a2 = c.SBOX[a2 >>> 24] << 24 | c.SBOX[a2 >>> 16 & 255] << 16 | c.SBOX[a2 >>> 8 & 255] << 8 | c.SBOX[255 & a2], a2 ^= s2[o2 / e3 | 0] << 24) : e3 > 6 && o2 % e3 == 4 && (a2 = c.SBOX[a2 >>> 24] << 24 | c.SBOX[a2 >>> 16 & 255] << 16 | c.SBOX[a2 >>> 8 & 255] << 8 | c.SBOX[255 & a2]), i3[o2] = i3[o2 - e3] ^ a2;
        }
        for (var u2 = [], f = 0; f < n2; f++) {
          var l = n2 - f, h2 = i3[l - (f % 4 ? 0 : 4)];
          u2[f] = f < 4 || l <= 4 ? h2 : c.INV_SUB_MIX[0][c.SBOX[h2 >>> 24]] ^ c.INV_SUB_MIX[1][c.SBOX[h2 >>> 16 & 255]] ^ c.INV_SUB_MIX[2][c.SBOX[h2 >>> 8 & 255]] ^ c.INV_SUB_MIX[3][c.SBOX[255 & h2]];
        }
        this._nRounds = r3, this._keySchedule = i3, this._invKeySchedule = u2;
      }, u.prototype.encryptBlockRaw = function(t4) {
        return a(t4 = i2(t4), this._keySchedule, c.SUB_MIX, c.SBOX, this._nRounds);
      }, u.prototype.encryptBlock = function(t4) {
        var e3 = this.encryptBlockRaw(t4), r3 = n.allocUnsafe(16);
        return r3.writeUInt32BE(e3[0], 0), r3.writeUInt32BE(e3[1], 4), r3.writeUInt32BE(e3[2], 8), r3.writeUInt32BE(e3[3], 12), r3;
      }, u.prototype.decryptBlock = function(t4) {
        var e3 = (t4 = i2(t4))[1];
        t4[1] = t4[3], t4[3] = e3;
        var r3 = a(t4, this._invKeySchedule, c.INV_SUB_MIX, c.INV_SBOX, this._nRounds), o2 = n.allocUnsafe(16);
        return o2.writeUInt32BE(r3[0], 0), o2.writeUInt32BE(r3[3], 4), o2.writeUInt32BE(r3[2], 8), o2.writeUInt32BE(r3[1], 12), o2;
      }, u.prototype.scrub = function() {
        o(this._keySchedule), o(this._invKeySchedule), o(this._key);
      }, t3.exports.AES = u;
    }, 1085: (t3, e2, r2) => {
      var n = r2(5401), i2 = r2(9732).Buffer, o = r2(2533), a = r2(1679), s2 = r2(9363), c = r2(6876), u = r2(9003);
      function f(t4, e3, r3, a2) {
        o.call(this);
        var c2 = i2.alloc(4, 0);
        this._cipher = new n.AES(e3);
        var f2 = this._cipher.encryptBlock(c2);
        this._ghash = new s2(f2), r3 = function(t5, e4, r4) {
          if (12 === e4.length)
            return t5._finID = i2.concat([e4, i2.from([0, 0, 0, 1])]), i2.concat([e4, i2.from([0, 0, 0, 2])]);
          var n2 = new s2(r4), o2 = e4.length, a3 = o2 % 16;
          n2.update(e4), a3 && (a3 = 16 - a3, n2.update(i2.alloc(a3, 0))), n2.update(i2.alloc(8, 0));
          var c3 = 8 * o2, f3 = i2.alloc(8);
          f3.writeUIntBE(c3, 0, 8), n2.update(f3), t5._finID = n2.state;
          var l = i2.from(t5._finID);
          return u(l), l;
        }(this, r3, f2), this._prev = i2.from(r3), this._cache = i2.allocUnsafe(0), this._secCache = i2.allocUnsafe(0), this._decrypt = a2, this._alen = 0, this._len = 0, this._mode = t4, this._authTag = null, this._called = false;
      }
      a(f, o), f.prototype._update = function(t4) {
        if (!this._called && this._alen) {
          var e3 = 16 - this._alen % 16;
          e3 < 16 && (e3 = i2.alloc(e3, 0), this._ghash.update(e3));
        }
        this._called = true;
        var r3 = this._mode.encrypt(this, t4);
        return this._decrypt ? this._ghash.update(t4) : this._ghash.update(r3), this._len += t4.length, r3;
      }, f.prototype._final = function() {
        if (this._decrypt && !this._authTag)
          throw new Error("Unsupported state or unable to authenticate data");
        var t4 = c(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && function(t5, e3) {
          var r3 = 0;
          t5.length !== e3.length && r3++;
          for (var n2 = Math.min(t5.length, e3.length), i3 = 0; i3 < n2; ++i3)
            r3 += t5[i3] ^ e3[i3];
          return r3;
        }(t4, this._authTag))
          throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = t4, this._cipher.scrub();
      }, f.prototype.getAuthTag = function() {
        if (this._decrypt || !i2.isBuffer(this._authTag))
          throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
      }, f.prototype.setAuthTag = function(t4) {
        if (!this._decrypt)
          throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = t4;
      }, f.prototype.setAAD = function(t4) {
        if (this._called)
          throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(t4), this._alen += t4.length;
      }, t3.exports = f;
    }, 2098: (t3, e2, r2) => {
      var n = r2(3604), i2 = r2(1808), o = r2(3219);
      e2.createCipher = e2.Cipher = n.createCipher, e2.createCipheriv = e2.Cipheriv = n.createCipheriv, e2.createDecipher = e2.Decipher = i2.createDecipher, e2.createDecipheriv = e2.Decipheriv = i2.createDecipheriv, e2.listCiphers = e2.getCiphers = function() {
        return Object.keys(o);
      };
    }, 1808: (t3, e2, r2) => {
      var n = r2(1085), i2 = r2(9732).Buffer, o = r2(8629), a = r2(5407), s2 = r2(2533), c = r2(5401), u = r2(1685);
      function f(t4, e3, r3) {
        s2.call(this), this._cache = new l(), this._last = void 0, this._cipher = new c.AES(e3), this._prev = i2.from(r3), this._mode = t4, this._autopadding = true;
      }
      function l() {
        this.cache = i2.allocUnsafe(0);
      }
      function h2(t4, e3, r3) {
        var s3 = o[t4.toLowerCase()];
        if (!s3)
          throw new TypeError("invalid suite type");
        if ("string" == typeof r3 && (r3 = i2.from(r3)), "GCM" !== s3.mode && r3.length !== s3.iv)
          throw new TypeError("invalid iv length " + r3.length);
        if ("string" == typeof e3 && (e3 = i2.from(e3)), e3.length !== s3.key / 8)
          throw new TypeError("invalid key length " + e3.length);
        return "stream" === s3.type ? new a(s3.module, e3, r3, true) : "auth" === s3.type ? new n(s3.module, e3, r3, true) : new f(s3.module, e3, r3);
      }
      r2(1679)(f, s2), f.prototype._update = function(t4) {
        var e3, r3;
        this._cache.add(t4);
        for (var n2 = []; e3 = this._cache.get(this._autopadding); )
          r3 = this._mode.decrypt(this, e3), n2.push(r3);
        return i2.concat(n2);
      }, f.prototype._final = function() {
        var t4 = this._cache.flush();
        if (this._autopadding)
          return function(t5) {
            var e3 = t5[15];
            if (e3 < 1 || e3 > 16)
              throw new Error("unable to decrypt data");
            for (var r3 = -1; ++r3 < e3; )
              if (t5[r3 + (16 - e3)] !== e3)
                throw new Error("unable to decrypt data");
            if (16 !== e3)
              return t5.slice(0, 16 - e3);
          }(this._mode.decrypt(this, t4));
        if (t4)
          throw new Error("data not multiple of block length");
      }, f.prototype.setAutoPadding = function(t4) {
        return this._autopadding = !!t4, this;
      }, l.prototype.add = function(t4) {
        this.cache = i2.concat([this.cache, t4]);
      }, l.prototype.get = function(t4) {
        var e3;
        if (t4) {
          if (this.cache.length > 16)
            return e3 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e3;
        } else if (this.cache.length >= 16)
          return e3 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e3;
        return null;
      }, l.prototype.flush = function() {
        if (this.cache.length)
          return this.cache;
      }, e2.createDecipher = function(t4, e3) {
        var r3 = o[t4.toLowerCase()];
        if (!r3)
          throw new TypeError("invalid suite type");
        var n2 = u(e3, false, r3.key, r3.iv);
        return h2(t4, n2.key, n2.iv);
      }, e2.createDecipheriv = h2;
    }, 3604: (t3, e2, r2) => {
      var n = r2(8629), i2 = r2(1085), o = r2(9732).Buffer, a = r2(5407), s2 = r2(2533), c = r2(5401), u = r2(1685);
      function f(t4, e3, r3) {
        s2.call(this), this._cache = new h2(), this._cipher = new c.AES(e3), this._prev = o.from(r3), this._mode = t4, this._autopadding = true;
      }
      r2(1679)(f, s2), f.prototype._update = function(t4) {
        var e3, r3;
        this._cache.add(t4);
        for (var n2 = []; e3 = this._cache.get(); )
          r3 = this._mode.encrypt(this, e3), n2.push(r3);
        return o.concat(n2);
      };
      var l = o.alloc(16, 16);
      function h2() {
        this.cache = o.allocUnsafe(0);
      }
      function p(t4, e3, r3) {
        var s3 = n[t4.toLowerCase()];
        if (!s3)
          throw new TypeError("invalid suite type");
        if ("string" == typeof e3 && (e3 = o.from(e3)), e3.length !== s3.key / 8)
          throw new TypeError("invalid key length " + e3.length);
        if ("string" == typeof r3 && (r3 = o.from(r3)), "GCM" !== s3.mode && r3.length !== s3.iv)
          throw new TypeError("invalid iv length " + r3.length);
        return "stream" === s3.type ? new a(s3.module, e3, r3) : "auth" === s3.type ? new i2(s3.module, e3, r3) : new f(s3.module, e3, r3);
      }
      f.prototype._final = function() {
        var t4 = this._cache.flush();
        if (this._autopadding)
          return t4 = this._mode.encrypt(this, t4), this._cipher.scrub(), t4;
        if (!t4.equals(l))
          throw this._cipher.scrub(), new Error("data not multiple of block length");
      }, f.prototype.setAutoPadding = function(t4) {
        return this._autopadding = !!t4, this;
      }, h2.prototype.add = function(t4) {
        this.cache = o.concat([this.cache, t4]);
      }, h2.prototype.get = function() {
        if (this.cache.length > 15) {
          var t4 = this.cache.slice(0, 16);
          return this.cache = this.cache.slice(16), t4;
        }
        return null;
      }, h2.prototype.flush = function() {
        for (var t4 = 16 - this.cache.length, e3 = o.allocUnsafe(t4), r3 = -1; ++r3 < t4; )
          e3.writeUInt8(t4, r3);
        return o.concat([this.cache, e3]);
      }, e2.createCipheriv = p, e2.createCipher = function(t4, e3) {
        var r3 = n[t4.toLowerCase()];
        if (!r3)
          throw new TypeError("invalid suite type");
        var i3 = u(e3, false, r3.key, r3.iv);
        return p(t4, i3.key, i3.iv);
      };
    }, 9363: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = n.alloc(16, 0);
      function o(t4) {
        var e3 = n.allocUnsafe(16);
        return e3.writeUInt32BE(t4[0] >>> 0, 0), e3.writeUInt32BE(t4[1] >>> 0, 4), e3.writeUInt32BE(t4[2] >>> 0, 8), e3.writeUInt32BE(t4[3] >>> 0, 12), e3;
      }
      function a(t4) {
        this.h = t4, this.state = n.alloc(16, 0), this.cache = n.allocUnsafe(0);
      }
      a.prototype.ghash = function(t4) {
        for (var e3 = -1; ++e3 < t4.length; )
          this.state[e3] ^= t4[e3];
        this._multiply();
      }, a.prototype._multiply = function() {
        for (var t4, e3, r3, n2 = [(t4 = this.h).readUInt32BE(0), t4.readUInt32BE(4), t4.readUInt32BE(8), t4.readUInt32BE(12)], i3 = [0, 0, 0, 0], a2 = -1; ++a2 < 128; ) {
          for (!!(this.state[~~(a2 / 8)] & 1 << 7 - a2 % 8) && (i3[0] ^= n2[0], i3[1] ^= n2[1], i3[2] ^= n2[2], i3[3] ^= n2[3]), r3 = !!(1 & n2[3]), e3 = 3; e3 > 0; e3--)
            n2[e3] = n2[e3] >>> 1 | (1 & n2[e3 - 1]) << 31;
          n2[0] = n2[0] >>> 1, r3 && (n2[0] = n2[0] ^ 225 << 24);
        }
        this.state = o(i3);
      }, a.prototype.update = function(t4) {
        var e3;
        for (this.cache = n.concat([this.cache, t4]); this.cache.length >= 16; )
          e3 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e3);
      }, a.prototype.final = function(t4, e3) {
        return this.cache.length && this.ghash(n.concat([this.cache, i2], 16)), this.ghash(o([0, t4, 0, e3])), this.state;
      }, t3.exports = a;
    }, 9003: (t3) => {
      t3.exports = function(t4) {
        for (var e2, r2 = t4.length; r2--; ) {
          if (255 !== (e2 = t4.readUInt8(r2))) {
            e2++, t4.writeUInt8(e2, r2);
            break;
          }
          t4.writeUInt8(0, r2);
        }
      };
    }, 5459: (t3, e2, r2) => {
      var n = r2(6876);
      e2.encrypt = function(t4, e3) {
        var r3 = n(e3, t4._prev);
        return t4._prev = t4._cipher.encryptBlock(r3), t4._prev;
      }, e2.decrypt = function(t4, e3) {
        var r3 = t4._prev;
        t4._prev = e3;
        var i2 = t4._cipher.decryptBlock(e3);
        return n(i2, r3);
      };
    }, 4488: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(6876);
      function o(t4, e3, r3) {
        var o2 = e3.length, a = i2(e3, t4._cache);
        return t4._cache = t4._cache.slice(o2), t4._prev = n.concat([t4._prev, r3 ? e3 : a]), a;
      }
      e2.encrypt = function(t4, e3, r3) {
        for (var i3, a = n.allocUnsafe(0); e3.length; ) {
          if (0 === t4._cache.length && (t4._cache = t4._cipher.encryptBlock(t4._prev), t4._prev = n.allocUnsafe(0)), !(t4._cache.length <= e3.length)) {
            a = n.concat([a, o(t4, e3, r3)]);
            break;
          }
          i3 = t4._cache.length, a = n.concat([a, o(t4, e3.slice(0, i3), r3)]), e3 = e3.slice(i3);
        }
        return a;
      };
    }, 4937: (t3, e2, r2) => {
      var n = r2(9732).Buffer;
      function i2(t4, e3, r3) {
        for (var n2, i3, a = -1, s2 = 0; ++a < 8; )
          n2 = e3 & 1 << 7 - a ? 128 : 0, s2 += (128 & (i3 = t4._cipher.encryptBlock(t4._prev)[0] ^ n2)) >> a % 8, t4._prev = o(t4._prev, r3 ? n2 : i3);
        return s2;
      }
      function o(t4, e3) {
        var r3 = t4.length, i3 = -1, o2 = n.allocUnsafe(t4.length);
        for (t4 = n.concat([t4, n.from([e3])]); ++i3 < r3; )
          o2[i3] = t4[i3] << 1 | t4[i3 + 1] >> 7;
        return o2;
      }
      e2.encrypt = function(t4, e3, r3) {
        for (var o2 = e3.length, a = n.allocUnsafe(o2), s2 = -1; ++s2 < o2; )
          a[s2] = i2(t4, e3[s2], r3);
        return a;
      };
    }, 6322: (t3, e2, r2) => {
      var n = r2(9732).Buffer;
      function i2(t4, e3, r3) {
        var i3 = t4._cipher.encryptBlock(t4._prev)[0] ^ e3;
        return t4._prev = n.concat([t4._prev.slice(1), n.from([r3 ? e3 : i3])]), i3;
      }
      e2.encrypt = function(t4, e3, r3) {
        for (var o = e3.length, a = n.allocUnsafe(o), s2 = -1; ++s2 < o; )
          a[s2] = i2(t4, e3[s2], r3);
        return a;
      };
    }, 2538: (t3, e2, r2) => {
      var n = r2(6876), i2 = r2(9732).Buffer, o = r2(9003);
      function a(t4) {
        var e3 = t4._cipher.encryptBlockRaw(t4._prev);
        return o(t4._prev), e3;
      }
      e2.encrypt = function(t4, e3) {
        var r3 = Math.ceil(e3.length / 16), o2 = t4._cache.length;
        t4._cache = i2.concat([t4._cache, i2.allocUnsafe(16 * r3)]);
        for (var s2 = 0; s2 < r3; s2++) {
          var c = a(t4), u = o2 + 16 * s2;
          t4._cache.writeUInt32BE(c[0], u + 0), t4._cache.writeUInt32BE(c[1], u + 4), t4._cache.writeUInt32BE(c[2], u + 8), t4._cache.writeUInt32BE(c[3], u + 12);
        }
        var f = t4._cache.slice(0, e3.length);
        return t4._cache = t4._cache.slice(e3.length), n(e3, f);
      };
    }, 9907: (t3, e2) => {
      e2.encrypt = function(t4, e3) {
        return t4._cipher.encryptBlock(e3);
      }, e2.decrypt = function(t4, e3) {
        return t4._cipher.decryptBlock(e3);
      };
    }, 8629: (t3, e2, r2) => {
      var n = { ECB: r2(9907), CBC: r2(5459), CFB: r2(4488), CFB8: r2(6322), CFB1: r2(4937), OFB: r2(4252), CTR: r2(2538), GCM: r2(2538) }, i2 = r2(3219);
      for (var o in i2)
        i2[o].module = n[i2[o].mode];
      t3.exports = i2;
    }, 4252: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(6876);
      function o(t4) {
        return t4._prev = t4._cipher.encryptBlock(t4._prev), t4._prev;
      }
      e2.encrypt = function(t4, e3) {
        for (; t4._cache.length < e3.length; )
          t4._cache = n.concat([t4._cache, o(t4)]);
        var r3 = t4._cache.slice(0, e3.length);
        return t4._cache = t4._cache.slice(e3.length), i2(e3, r3);
      };
    }, 5407: (t3, e2, r2) => {
      var n = r2(5401), i2 = r2(9732).Buffer, o = r2(2533);
      function a(t4, e3, r3, a2) {
        o.call(this), this._cipher = new n.AES(e3), this._prev = i2.from(r3), this._cache = i2.allocUnsafe(0), this._secCache = i2.allocUnsafe(0), this._decrypt = a2, this._mode = t4;
      }
      r2(1679)(a, o), a.prototype._update = function(t4) {
        return this._mode.encrypt(this, t4, this._decrypt);
      }, a.prototype._final = function() {
        this._cipher.scrub();
      }, t3.exports = a;
    }, 9652: (t3, e2, r2) => {
      var n = r2(8201), i2 = r2(2098), o = r2(8629), a = r2(3849), s2 = r2(1685);
      function c(t4, e3, r3) {
        if (t4 = t4.toLowerCase(), o[t4])
          return i2.createCipheriv(t4, e3, r3);
        if (a[t4])
          return new n({ key: e3, iv: r3, mode: t4 });
        throw new TypeError("invalid suite type");
      }
      function u(t4, e3, r3) {
        if (t4 = t4.toLowerCase(), o[t4])
          return i2.createDecipheriv(t4, e3, r3);
        if (a[t4])
          return new n({ key: e3, iv: r3, mode: t4, decrypt: true });
        throw new TypeError("invalid suite type");
      }
      e2.createCipher = e2.Cipher = function(t4, e3) {
        var r3, n2;
        if (t4 = t4.toLowerCase(), o[t4])
          r3 = o[t4].key, n2 = o[t4].iv;
        else {
          if (!a[t4])
            throw new TypeError("invalid suite type");
          r3 = 8 * a[t4].key, n2 = a[t4].iv;
        }
        var i3 = s2(e3, false, r3, n2);
        return c(t4, i3.key, i3.iv);
      }, e2.createCipheriv = e2.Cipheriv = c, e2.createDecipher = e2.Decipher = function(t4, e3) {
        var r3, n2;
        if (t4 = t4.toLowerCase(), o[t4])
          r3 = o[t4].key, n2 = o[t4].iv;
        else {
          if (!a[t4])
            throw new TypeError("invalid suite type");
          r3 = 8 * a[t4].key, n2 = a[t4].iv;
        }
        var i3 = s2(e3, false, r3, n2);
        return u(t4, i3.key, i3.iv);
      }, e2.createDecipheriv = e2.Decipheriv = u, e2.listCiphers = e2.getCiphers = function() {
        return Object.keys(a).concat(i2.getCiphers());
      };
    }, 8201: (t3, e2, r2) => {
      var n = r2(2533), i2 = r2(1471), o = r2(1679), a = r2(9732).Buffer, s2 = { "des-ede3-cbc": i2.CBC.instantiate(i2.EDE), "des-ede3": i2.EDE, "des-ede-cbc": i2.CBC.instantiate(i2.EDE), "des-ede": i2.EDE, "des-cbc": i2.CBC.instantiate(i2.DES), "des-ecb": i2.DES };
      function c(t4) {
        n.call(this);
        var e3, r3 = t4.mode.toLowerCase(), i3 = s2[r3];
        e3 = t4.decrypt ? "decrypt" : "encrypt";
        var o2 = t4.key;
        a.isBuffer(o2) || (o2 = a.from(o2)), "des-ede" !== r3 && "des-ede-cbc" !== r3 || (o2 = a.concat([o2, o2.slice(0, 8)]));
        var c2 = t4.iv;
        a.isBuffer(c2) || (c2 = a.from(c2)), this._des = i3.create({ key: o2, iv: c2, type: e3 });
      }
      s2.des = s2["des-cbc"], s2.des3 = s2["des-ede3-cbc"], t3.exports = c, o(c, n), c.prototype._update = function(t4) {
        return a.from(this._des.update(t4));
      }, c.prototype._final = function() {
        return a.from(this._des.final());
      };
    }, 3849: (t3, e2) => {
      e2["des-ecb"] = { key: 8, iv: 0 }, e2["des-cbc"] = e2.des = { key: 8, iv: 8 }, e2["des-ede3-cbc"] = e2.des3 = { key: 24, iv: 8 }, e2["des-ede3"] = { key: 24, iv: 0 }, e2["des-ede-cbc"] = { key: 16, iv: 8 }, e2["des-ede"] = { key: 16, iv: 0 };
    }, 1095: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(7799), o = r2(4276);
      function a(t4) {
        var e3, r3 = t4.modulus.byteLength();
        do {
          e3 = new i2(o(r3));
        } while (e3.cmp(t4.modulus) >= 0 || !e3.umod(t4.prime1) || !e3.umod(t4.prime2));
        return e3;
      }
      function s2(t4, e3) {
        var r3 = function(t5) {
          var e4 = a(t5);
          return { blinder: e4.toRed(i2.mont(t5.modulus)).redPow(new i2(t5.publicExponent)).fromRed(), unblinder: e4.invm(t5.modulus) };
        }(e3), o2 = e3.modulus.byteLength(), s3 = new i2(t4).mul(r3.blinder).umod(e3.modulus), c = s3.toRed(i2.mont(e3.prime1)), u = s3.toRed(i2.mont(e3.prime2)), f = e3.coefficient, l = e3.prime1, h2 = e3.prime2, p = c.redPow(e3.exponent1).fromRed(), d2 = u.redPow(e3.exponent2).fromRed(), y2 = p.isub(d2).imul(f).umod(l).imul(h2);
        return d2.iadd(y2).imul(r3.unblinder).umod(e3.modulus).toArrayLike(n, "be", o2);
      }
      s2.getr = a, t3.exports = s2;
    }, 4606: (t3, e2, r2) => {
      t3.exports = r2(2951);
    }, 7937: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(5833), o = r2(3292), a = r2(1679), s2 = r2(6620), c = r2(7032), u = r2(2951);
      function f(t4) {
        o.Writable.call(this);
        var e3 = u[t4];
        if (!e3)
          throw new Error("Unknown message digest");
        this._hashType = e3.hash, this._hash = i2(e3.hash), this._tag = e3.id, this._signType = e3.sign;
      }
      function l(t4) {
        o.Writable.call(this);
        var e3 = u[t4];
        if (!e3)
          throw new Error("Unknown message digest");
        this._hash = i2(e3.hash), this._tag = e3.id, this._signType = e3.sign;
      }
      function h2(t4) {
        return new f(t4);
      }
      function p(t4) {
        return new l(t4);
      }
      Object.keys(u).forEach(function(t4) {
        u[t4].id = n.from(u[t4].id, "hex"), u[t4.toLowerCase()] = u[t4];
      }), a(f, o.Writable), f.prototype._write = function(t4, e3, r3) {
        this._hash.update(t4), r3();
      }, f.prototype.update = function(t4, e3) {
        return this._hash.update("string" == typeof t4 ? n.from(t4, e3) : t4), this;
      }, f.prototype.sign = function(t4, e3) {
        this.end();
        var r3 = this._hash.digest(), n2 = s2(r3, t4, this._hashType, this._signType, this._tag);
        return e3 ? n2.toString(e3) : n2;
      }, a(l, o.Writable), l.prototype._write = function(t4, e3, r3) {
        this._hash.update(t4), r3();
      }, l.prototype.update = function(t4, e3) {
        return this._hash.update("string" == typeof t4 ? n.from(t4, e3) : t4), this;
      }, l.prototype.verify = function(t4, e3, r3) {
        var i3 = "string" == typeof e3 ? n.from(e3, r3) : e3;
        this.end();
        var o2 = this._hash.digest();
        return c(i3, o2, t4, this._signType, this._tag);
      }, t3.exports = { Sign: h2, Verify: p, createSign: h2, createVerify: p };
    }, 6620: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(2046), o = r2(1095), a = r2(7312).ec, s2 = r2(7799), c = r2(5053), u = r2(4589);
      function f(t4, e3, r3, o2) {
        if ((t4 = n.from(t4.toArray())).length < e3.byteLength()) {
          var a2 = n.alloc(e3.byteLength() - t4.length);
          t4 = n.concat([a2, t4]);
        }
        var s3 = r3.length, c2 = function(t5, e4) {
          t5 = (t5 = l(t5, e4)).mod(e4);
          var r4 = n.from(t5.toArray());
          if (r4.length < e4.byteLength()) {
            var i3 = n.alloc(e4.byteLength() - r4.length);
            r4 = n.concat([i3, r4]);
          }
          return r4;
        }(r3, e3), u2 = n.alloc(s3);
        u2.fill(1);
        var f2 = n.alloc(s3);
        return f2 = i2(o2, f2).update(u2).update(n.from([0])).update(t4).update(c2).digest(), u2 = i2(o2, f2).update(u2).digest(), { k: f2 = i2(o2, f2).update(u2).update(n.from([1])).update(t4).update(c2).digest(), v: u2 = i2(o2, f2).update(u2).digest() };
      }
      function l(t4, e3) {
        var r3 = new s2(t4), n2 = (t4.length << 3) - e3.bitLength();
        return n2 > 0 && r3.ishrn(n2), r3;
      }
      function h2(t4, e3, r3) {
        var o2, a2;
        do {
          for (o2 = n.alloc(0); 8 * o2.length < t4.bitLength(); )
            e3.v = i2(r3, e3.k).update(e3.v).digest(), o2 = n.concat([o2, e3.v]);
          a2 = l(o2, t4), e3.k = i2(r3, e3.k).update(e3.v).update(n.from([0])).digest(), e3.v = i2(r3, e3.k).update(e3.v).digest();
        } while (-1 !== a2.cmp(t4));
        return a2;
      }
      function p(t4, e3, r3, n2) {
        return t4.toRed(s2.mont(r3)).redPow(e3).fromRed().mod(n2);
      }
      t3.exports = function(t4, e3, r3, i3, d2) {
        var y2 = c(e3);
        if (y2.curve) {
          if ("ecdsa" !== i3 && "ecdsa/rsa" !== i3)
            throw new Error("wrong private key type");
          return function(t5, e4) {
            var r4 = u[e4.curve.join(".")];
            if (!r4)
              throw new Error("unknown curve " + e4.curve.join("."));
            var i4 = new a(r4).keyFromPrivate(e4.privateKey).sign(t5);
            return n.from(i4.toDER());
          }(t4, y2);
        }
        if ("dsa" === y2.type) {
          if ("dsa" !== i3)
            throw new Error("wrong private key type");
          return function(t5, e4, r4) {
            for (var i4, o2 = e4.params.priv_key, a2 = e4.params.p, c2 = e4.params.q, u2 = e4.params.g, d3 = new s2(0), y3 = l(t5, c2).mod(c2), b2 = false, m3 = f(o2, c2, t5, r4); false === b2; )
              d3 = p(u2, i4 = h2(c2, m3, r4), a2, c2), 0 === (b2 = i4.invm(c2).imul(y3.add(o2.mul(d3))).mod(c2)).cmpn(0) && (b2 = false, d3 = new s2(0));
            return function(t6, e5) {
              t6 = t6.toArray(), e5 = e5.toArray(), 128 & t6[0] && (t6 = [0].concat(t6)), 128 & e5[0] && (e5 = [0].concat(e5));
              var r5 = [48, t6.length + e5.length + 4, 2, t6.length];
              return r5 = r5.concat(t6, [2, e5.length], e5), n.from(r5);
            }(d3, b2);
          }(t4, y2, r3);
        }
        if ("rsa" !== i3 && "ecdsa/rsa" !== i3)
          throw new Error("wrong private key type");
        if (void 0 !== e3.padding && 1 !== e3.padding)
          throw new Error("illegal or unsupported padding mode");
        t4 = n.concat([d2, t4]);
        for (var b = y2.modulus.byteLength(), m2 = [0, 1]; t4.length + m2.length + 1 < b; )
          m2.push(255);
        m2.push(0);
        for (var v = -1; ++v < t4.length; )
          m2.push(t4[v]);
        return o(m2, y2);
      }, t3.exports.getKey = f, t3.exports.makeKey = h2;
    }, 7032: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(7799), o = r2(7312).ec, a = r2(5053), s2 = r2(4589);
      function c(t4, e3) {
        if (t4.cmpn(0) <= 0)
          throw new Error("invalid sig");
        if (t4.cmp(e3) >= 0)
          throw new Error("invalid sig");
      }
      t3.exports = function(t4, e3, r3, u, f) {
        var l = a(r3);
        if ("ec" === l.type) {
          if ("ecdsa" !== u && "ecdsa/rsa" !== u)
            throw new Error("wrong public key type");
          return function(t5, e4, r4) {
            var n2 = s2[r4.data.algorithm.curve.join(".")];
            if (!n2)
              throw new Error("unknown curve " + r4.data.algorithm.curve.join("."));
            var i3 = new o(n2), a2 = r4.data.subjectPrivateKey.data;
            return i3.verify(e4, t5, a2);
          }(t4, e3, l);
        }
        if ("dsa" === l.type) {
          if ("dsa" !== u)
            throw new Error("wrong public key type");
          return function(t5, e4, r4) {
            var n2 = r4.data.p, o2 = r4.data.q, s3 = r4.data.g, u2 = r4.data.pub_key, f2 = a.signature.decode(t5, "der"), l2 = f2.s, h3 = f2.r;
            c(l2, o2), c(h3, o2);
            var p2 = i2.mont(n2), d3 = l2.invm(o2);
            return 0 === s3.toRed(p2).redPow(new i2(e4).mul(d3).mod(o2)).fromRed().mul(u2.toRed(p2).redPow(h3.mul(d3).mod(o2)).fromRed()).mod(n2).mod(o2).cmp(h3);
          }(t4, e3, l);
        }
        if ("rsa" !== u && "ecdsa/rsa" !== u)
          throw new Error("wrong public key type");
        e3 = n.concat([f, e3]);
        for (var h2 = l.modulus.byteLength(), p = [1], d2 = 0; e3.length + p.length + 2 < h2; )
          p.push(255), d2 += 1;
        p.push(0);
        for (var y2 = -1; ++y2 < e3.length; )
          p.push(e3[y2]);
        p = n.from(p);
        var b = i2.mont(l.modulus);
        t4 = (t4 = new i2(t4).toRed(b)).redPow(new i2(l.publicExponent)), t4 = n.from(t4.fromRed().toArray());
        var m2 = d2 < 8 ? 1 : 0;
        for (h2 = Math.min(t4.length, p.length), t4.length !== p.length && (m2 = 1), y2 = -1; ++y2 < h2; )
          m2 |= t4[y2] ^ p[y2];
        return 0 === m2;
      };
    }, 6876: (t3, e2, r2) => {
      var n = r2(5832).Buffer;
      t3.exports = function(t4, e3) {
        for (var r3 = Math.min(t4.length, e3.length), i2 = new n(r3), o = 0; o < r3; ++o)
          i2[o] = t4[o] ^ e3[o];
        return i2;
      };
    }, 5832: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(6775), o = r2(2486), a = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
      e2.Buffer = u, e2.SlowBuffer = function(t4) {
        return +t4 != t4 && (t4 = 0), u.alloc(+t4);
      }, e2.INSPECT_MAX_BYTES = 50;
      var s2 = 2147483647;
      function c(t4) {
        if (t4 > s2)
          throw new RangeError('The value "' + t4 + '" is invalid for option "size"');
        var e3 = new Uint8Array(t4);
        return Object.setPrototypeOf(e3, u.prototype), e3;
      }
      function u(t4, e3, r3) {
        if ("number" == typeof t4) {
          if ("string" == typeof e3)
            throw new TypeError('The "string" argument must be of type string. Received type number');
          return h2(t4);
        }
        return f(t4, e3, r3);
      }
      function f(t4, e3, r3) {
        if ("string" == typeof t4)
          return function(t5, e4) {
            if ("string" == typeof e4 && "" !== e4 || (e4 = "utf8"), !u.isEncoding(e4))
              throw new TypeError("Unknown encoding: " + e4);
            var r4 = 0 | b(t5, e4), n2 = c(r4), i4 = n2.write(t5, e4);
            return i4 !== r4 && (n2 = n2.slice(0, i4)), n2;
          }(t4, e3);
        if (ArrayBuffer.isView(t4))
          return function(t5) {
            if (F(t5, Uint8Array)) {
              var e4 = new Uint8Array(t5);
              return d2(e4.buffer, e4.byteOffset, e4.byteLength);
            }
            return p(t5);
          }(t4);
        if (null == t4)
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t4));
        if (F(t4, ArrayBuffer) || t4 && F(t4.buffer, ArrayBuffer))
          return d2(t4, e3, r3);
        if ("undefined" != typeof SharedArrayBuffer && (F(t4, SharedArrayBuffer) || t4 && F(t4.buffer, SharedArrayBuffer)))
          return d2(t4, e3, r3);
        if ("number" == typeof t4)
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        var i3 = t4.valueOf && t4.valueOf();
        if (null != i3 && i3 !== t4)
          return u.from(i3, e3, r3);
        var o2 = function(t5) {
          if (u.isBuffer(t5)) {
            var e4 = 0 | y2(t5.length), r4 = c(e4);
            return 0 === r4.length || t5.copy(r4, 0, 0, e4), r4;
          }
          return void 0 !== t5.length ? "number" != typeof t5.length || V(t5.length) ? c(0) : p(t5) : "Buffer" === t5.type && Array.isArray(t5.data) ? p(t5.data) : void 0;
        }(t4);
        if (o2)
          return o2;
        if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t4[Symbol.toPrimitive])
          return u.from(t4[Symbol.toPrimitive]("string"), e3, r3);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + n(t4));
      }
      function l(t4) {
        if ("number" != typeof t4)
          throw new TypeError('"size" argument must be of type number');
        if (t4 < 0)
          throw new RangeError('The value "' + t4 + '" is invalid for option "size"');
      }
      function h2(t4) {
        return l(t4), c(t4 < 0 ? 0 : 0 | y2(t4));
      }
      function p(t4) {
        for (var e3 = t4.length < 0 ? 0 : 0 | y2(t4.length), r3 = c(e3), n2 = 0; n2 < e3; n2 += 1)
          r3[n2] = 255 & t4[n2];
        return r3;
      }
      function d2(t4, e3, r3) {
        if (e3 < 0 || t4.byteLength < e3)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (t4.byteLength < e3 + (r3 || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        var n2;
        return n2 = void 0 === e3 && void 0 === r3 ? new Uint8Array(t4) : void 0 === r3 ? new Uint8Array(t4, e3) : new Uint8Array(t4, e3, r3), Object.setPrototypeOf(n2, u.prototype), n2;
      }
      function y2(t4) {
        if (t4 >= s2)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s2.toString(16) + " bytes");
        return 0 | t4;
      }
      function b(t4, e3) {
        if (u.isBuffer(t4))
          return t4.length;
        if (ArrayBuffer.isView(t4) || F(t4, ArrayBuffer))
          return t4.byteLength;
        if ("string" != typeof t4)
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + n(t4));
        var r3 = t4.length, i3 = arguments.length > 2 && true === arguments[2];
        if (!i3 && 0 === r3)
          return 0;
        for (var o2 = false; ; )
          switch (e3) {
            case "ascii":
            case "latin1":
            case "binary":
              return r3;
            case "utf8":
            case "utf-8":
              return U(t4).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r3;
            case "hex":
              return r3 >>> 1;
            case "base64":
              return C(t4).length;
            default:
              if (o2)
                return i3 ? -1 : U(t4).length;
              e3 = ("" + e3).toLowerCase(), o2 = true;
          }
      }
      function m2(t4, e3, r3) {
        var n2 = false;
        if ((void 0 === e3 || e3 < 0) && (e3 = 0), e3 > this.length)
          return "";
        if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0)
          return "";
        if ((r3 >>>= 0) <= (e3 >>>= 0))
          return "";
        for (t4 || (t4 = "utf8"); ; )
          switch (t4) {
            case "hex":
              return M(this, e3, r3);
            case "utf8":
            case "utf-8":
              return E(this, e3, r3);
            case "ascii":
              return P(this, e3, r3);
            case "latin1":
            case "binary":
              return k(this, e3, r3);
            case "base64":
              return A(this, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return I(this, e3, r3);
            default:
              if (n2)
                throw new TypeError("Unknown encoding: " + t4);
              t4 = (t4 + "").toLowerCase(), n2 = true;
          }
      }
      function v(t4, e3, r3) {
        var n2 = t4[e3];
        t4[e3] = t4[r3], t4[r3] = n2;
      }
      function g(t4, e3, r3, n2, i3) {
        if (0 === t4.length)
          return -1;
        if ("string" == typeof r3 ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), V(r3 = +r3) && (r3 = i3 ? 0 : t4.length - 1), r3 < 0 && (r3 = t4.length + r3), r3 >= t4.length) {
          if (i3)
            return -1;
          r3 = t4.length - 1;
        } else if (r3 < 0) {
          if (!i3)
            return -1;
          r3 = 0;
        }
        if ("string" == typeof e3 && (e3 = u.from(e3, n2)), u.isBuffer(e3))
          return 0 === e3.length ? -1 : _(t4, e3, r3, n2, i3);
        if ("number" == typeof e3)
          return e3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i3 ? Uint8Array.prototype.indexOf.call(t4, e3, r3) : Uint8Array.prototype.lastIndexOf.call(t4, e3, r3) : _(t4, [e3], r3, n2, i3);
        throw new TypeError("val must be string, number or Buffer");
      }
      function _(t4, e3, r3, n2, i3) {
        var o2, a2 = 1, s3 = t4.length, c2 = e3.length;
        if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
          if (t4.length < 2 || e3.length < 2)
            return -1;
          a2 = 2, s3 /= 2, c2 /= 2, r3 /= 2;
        }
        function u2(t5, e4) {
          return 1 === a2 ? t5[e4] : t5.readUInt16BE(e4 * a2);
        }
        if (i3) {
          var f2 = -1;
          for (o2 = r3; o2 < s3; o2++)
            if (u2(t4, o2) === u2(e3, -1 === f2 ? 0 : o2 - f2)) {
              if (-1 === f2 && (f2 = o2), o2 - f2 + 1 === c2)
                return f2 * a2;
            } else
              -1 !== f2 && (o2 -= o2 - f2), f2 = -1;
        } else
          for (r3 + c2 > s3 && (r3 = s3 - c2), o2 = r3; o2 >= 0; o2--) {
            for (var l2 = true, h3 = 0; h3 < c2; h3++)
              if (u2(t4, o2 + h3) !== u2(e3, h3)) {
                l2 = false;
                break;
              }
            if (l2)
              return o2;
          }
        return -1;
      }
      function w2(t4, e3, r3, n2) {
        r3 = Number(r3) || 0;
        var i3 = t4.length - r3;
        n2 ? (n2 = Number(n2)) > i3 && (n2 = i3) : n2 = i3;
        var o2 = e3.length;
        n2 > o2 / 2 && (n2 = o2 / 2);
        for (var a2 = 0; a2 < n2; ++a2) {
          var s3 = parseInt(e3.substr(2 * a2, 2), 16);
          if (V(s3))
            return a2;
          t4[r3 + a2] = s3;
        }
        return a2;
      }
      function S(t4, e3, r3, n2) {
        return q(U(e3, t4.length - r3), t4, r3, n2);
      }
      function O(t4, e3, r3, n2) {
        return q(function(t5) {
          for (var e4 = [], r4 = 0; r4 < t5.length; ++r4)
            e4.push(255 & t5.charCodeAt(r4));
          return e4;
        }(e3), t4, r3, n2);
      }
      function j(t4, e3, r3, n2) {
        return q(C(e3), t4, r3, n2);
      }
      function $(t4, e3, r3, n2) {
        return q(function(t5, e4) {
          for (var r4, n3, i3, o2 = [], a2 = 0; a2 < t5.length && !((e4 -= 2) < 0); ++a2)
            n3 = (r4 = t5.charCodeAt(a2)) >> 8, i3 = r4 % 256, o2.push(i3), o2.push(n3);
          return o2;
        }(e3, t4.length - r3), t4, r3, n2);
      }
      function A(t4, e3, r3) {
        return 0 === e3 && r3 === t4.length ? i2.fromByteArray(t4) : i2.fromByteArray(t4.slice(e3, r3));
      }
      function E(t4, e3, r3) {
        r3 = Math.min(t4.length, r3);
        for (var n2 = [], i3 = e3; i3 < r3; ) {
          var o2, a2, s3, c2, u2 = t4[i3], f2 = null, l2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
          if (i3 + l2 <= r3)
            switch (l2) {
              case 1:
                u2 < 128 && (f2 = u2);
                break;
              case 2:
                128 == (192 & (o2 = t4[i3 + 1])) && (c2 = (31 & u2) << 6 | 63 & o2) > 127 && (f2 = c2);
                break;
              case 3:
                o2 = t4[i3 + 1], a2 = t4[i3 + 2], 128 == (192 & o2) && 128 == (192 & a2) && (c2 = (15 & u2) << 12 | (63 & o2) << 6 | 63 & a2) > 2047 && (c2 < 55296 || c2 > 57343) && (f2 = c2);
                break;
              case 4:
                o2 = t4[i3 + 1], a2 = t4[i3 + 2], s3 = t4[i3 + 3], 128 == (192 & o2) && 128 == (192 & a2) && 128 == (192 & s3) && (c2 = (15 & u2) << 18 | (63 & o2) << 12 | (63 & a2) << 6 | 63 & s3) > 65535 && c2 < 1114112 && (f2 = c2);
            }
          null === f2 ? (f2 = 65533, l2 = 1) : f2 > 65535 && (f2 -= 65536, n2.push(f2 >>> 10 & 1023 | 55296), f2 = 56320 | 1023 & f2), n2.push(f2), i3 += l2;
        }
        return function(t5) {
          var e4 = t5.length;
          if (e4 <= x)
            return String.fromCharCode.apply(String, t5);
          for (var r4 = "", n3 = 0; n3 < e4; )
            r4 += String.fromCharCode.apply(String, t5.slice(n3, n3 += x));
          return r4;
        }(n2);
      }
      e2.kMaxLength = s2, u.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t4 = new Uint8Array(1), e3 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(t4, e3), 42 === t4.foo();
        } catch (t5) {
          return false;
        }
      }(), u.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u.prototype, "parent", { enumerable: true, get: function() {
        if (u.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(u.prototype, "offset", { enumerable: true, get: function() {
        if (u.isBuffer(this))
          return this.byteOffset;
      } }), u.poolSize = 8192, u.from = function(t4, e3, r3) {
        return f(t4, e3, r3);
      }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array), u.alloc = function(t4, e3, r3) {
        return function(t5, e4, r4) {
          return l(t5), t5 <= 0 ? c(t5) : void 0 !== e4 ? "string" == typeof r4 ? c(t5).fill(e4, r4) : c(t5).fill(e4) : c(t5);
        }(t4, e3, r3);
      }, u.allocUnsafe = function(t4) {
        return h2(t4);
      }, u.allocUnsafeSlow = function(t4) {
        return h2(t4);
      }, u.isBuffer = function(t4) {
        return null != t4 && true === t4._isBuffer && t4 !== u.prototype;
      }, u.compare = function(t4, e3) {
        if (F(t4, Uint8Array) && (t4 = u.from(t4, t4.offset, t4.byteLength)), F(e3, Uint8Array) && (e3 = u.from(e3, e3.offset, e3.byteLength)), !u.isBuffer(t4) || !u.isBuffer(e3))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t4 === e3)
          return 0;
        for (var r3 = t4.length, n2 = e3.length, i3 = 0, o2 = Math.min(r3, n2); i3 < o2; ++i3)
          if (t4[i3] !== e3[i3]) {
            r3 = t4[i3], n2 = e3[i3];
            break;
          }
        return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
      }, u.isEncoding = function(t4) {
        switch (String(t4).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, u.concat = function(t4, e3) {
        if (!Array.isArray(t4))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t4.length)
          return u.alloc(0);
        var r3;
        if (void 0 === e3)
          for (e3 = 0, r3 = 0; r3 < t4.length; ++r3)
            e3 += t4[r3].length;
        var n2 = u.allocUnsafe(e3), i3 = 0;
        for (r3 = 0; r3 < t4.length; ++r3) {
          var o2 = t4[r3];
          if (F(o2, Uint8Array))
            i3 + o2.length > n2.length ? u.from(o2).copy(n2, i3) : Uint8Array.prototype.set.call(n2, o2, i3);
          else {
            if (!u.isBuffer(o2))
              throw new TypeError('"list" argument must be an Array of Buffers');
            o2.copy(n2, i3);
          }
          i3 += o2.length;
        }
        return n2;
      }, u.byteLength = b, u.prototype._isBuffer = true, u.prototype.swap16 = function() {
        var t4 = this.length;
        if (t4 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var e3 = 0; e3 < t4; e3 += 2)
          v(this, e3, e3 + 1);
        return this;
      }, u.prototype.swap32 = function() {
        var t4 = this.length;
        if (t4 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var e3 = 0; e3 < t4; e3 += 4)
          v(this, e3, e3 + 3), v(this, e3 + 1, e3 + 2);
        return this;
      }, u.prototype.swap64 = function() {
        var t4 = this.length;
        if (t4 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var e3 = 0; e3 < t4; e3 += 8)
          v(this, e3, e3 + 7), v(this, e3 + 1, e3 + 6), v(this, e3 + 2, e3 + 5), v(this, e3 + 3, e3 + 4);
        return this;
      }, u.prototype.toString = function() {
        var t4 = this.length;
        return 0 === t4 ? "" : 0 === arguments.length ? E(this, 0, t4) : m2.apply(this, arguments);
      }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(t4) {
        if (!u.isBuffer(t4))
          throw new TypeError("Argument must be a Buffer");
        return this === t4 || 0 === u.compare(this, t4);
      }, u.prototype.inspect = function() {
        var t4 = "", r3 = e2.INSPECT_MAX_BYTES;
        return t4 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (t4 += " ... "), "<Buffer " + t4 + ">";
      }, a && (u.prototype[a] = u.prototype.inspect), u.prototype.compare = function(t4, e3, r3, i3, o2) {
        if (F(t4, Uint8Array) && (t4 = u.from(t4, t4.offset, t4.byteLength)), !u.isBuffer(t4))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + n(t4));
        if (void 0 === e3 && (e3 = 0), void 0 === r3 && (r3 = t4 ? t4.length : 0), void 0 === i3 && (i3 = 0), void 0 === o2 && (o2 = this.length), e3 < 0 || r3 > t4.length || i3 < 0 || o2 > this.length)
          throw new RangeError("out of range index");
        if (i3 >= o2 && e3 >= r3)
          return 0;
        if (i3 >= o2)
          return -1;
        if (e3 >= r3)
          return 1;
        if (this === t4)
          return 0;
        for (var a2 = (o2 >>>= 0) - (i3 >>>= 0), s3 = (r3 >>>= 0) - (e3 >>>= 0), c2 = Math.min(a2, s3), f2 = this.slice(i3, o2), l2 = t4.slice(e3, r3), h3 = 0; h3 < c2; ++h3)
          if (f2[h3] !== l2[h3]) {
            a2 = f2[h3], s3 = l2[h3];
            break;
          }
        return a2 < s3 ? -1 : s3 < a2 ? 1 : 0;
      }, u.prototype.includes = function(t4, e3, r3) {
        return -1 !== this.indexOf(t4, e3, r3);
      }, u.prototype.indexOf = function(t4, e3, r3) {
        return g(this, t4, e3, r3, true);
      }, u.prototype.lastIndexOf = function(t4, e3, r3) {
        return g(this, t4, e3, r3, false);
      }, u.prototype.write = function(t4, e3, r3, n2) {
        if (void 0 === e3)
          n2 = "utf8", r3 = this.length, e3 = 0;
        else if (void 0 === r3 && "string" == typeof e3)
          n2 = e3, r3 = this.length, e3 = 0;
        else {
          if (!isFinite(e3))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          e3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r3, r3 = void 0);
        }
        var i3 = this.length - e3;
        if ((void 0 === r3 || r3 > i3) && (r3 = i3), t4.length > 0 && (r3 < 0 || e3 < 0) || e3 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n2 || (n2 = "utf8");
        for (var o2 = false; ; )
          switch (n2) {
            case "hex":
              return w2(this, t4, e3, r3);
            case "utf8":
            case "utf-8":
              return S(this, t4, e3, r3);
            case "ascii":
            case "latin1":
            case "binary":
              return O(this, t4, e3, r3);
            case "base64":
              return j(this, t4, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return $(this, t4, e3, r3);
            default:
              if (o2)
                throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), o2 = true;
          }
      }, u.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var x = 4096;
      function P(t4, e3, r3) {
        var n2 = "";
        r3 = Math.min(t4.length, r3);
        for (var i3 = e3; i3 < r3; ++i3)
          n2 += String.fromCharCode(127 & t4[i3]);
        return n2;
      }
      function k(t4, e3, r3) {
        var n2 = "";
        r3 = Math.min(t4.length, r3);
        for (var i3 = e3; i3 < r3; ++i3)
          n2 += String.fromCharCode(t4[i3]);
        return n2;
      }
      function M(t4, e3, r3) {
        var n2 = t4.length;
        (!e3 || e3 < 0) && (e3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
        for (var i3 = "", o2 = e3; o2 < r3; ++o2)
          i3 += z[t4[o2]];
        return i3;
      }
      function I(t4, e3, r3) {
        for (var n2 = t4.slice(e3, r3), i3 = "", o2 = 0; o2 < n2.length - 1; o2 += 2)
          i3 += String.fromCharCode(n2[o2] + 256 * n2[o2 + 1]);
        return i3;
      }
      function B(t4, e3, r3) {
        if (t4 % 1 != 0 || t4 < 0)
          throw new RangeError("offset is not uint");
        if (t4 + e3 > r3)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function T(t4, e3, r3, n2, i3, o2) {
        if (!u.isBuffer(t4))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e3 > i3 || e3 < o2)
          throw new RangeError('"value" argument is out of bounds');
        if (r3 + n2 > t4.length)
          throw new RangeError("Index out of range");
      }
      function R(t4, e3, r3, n2, i3, o2) {
        if (r3 + n2 > t4.length)
          throw new RangeError("Index out of range");
        if (r3 < 0)
          throw new RangeError("Index out of range");
      }
      function N(t4, e3, r3, n2, i3) {
        return e3 = +e3, r3 >>>= 0, i3 || R(t4, 0, r3, 4), o.write(t4, e3, r3, n2, 23, 4), r3 + 4;
      }
      function D(t4, e3, r3, n2, i3) {
        return e3 = +e3, r3 >>>= 0, i3 || R(t4, 0, r3, 8), o.write(t4, e3, r3, n2, 52, 8), r3 + 8;
      }
      u.prototype.slice = function(t4, e3) {
        var r3 = this.length;
        (t4 = ~~t4) < 0 ? (t4 += r3) < 0 && (t4 = 0) : t4 > r3 && (t4 = r3), (e3 = void 0 === e3 ? r3 : ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), e3 < t4 && (e3 = t4);
        var n2 = this.subarray(t4, e3);
        return Object.setPrototypeOf(n2, u.prototype), n2;
      }, u.prototype.readUintLE = u.prototype.readUIntLE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || B(t4, e3, this.length);
        for (var n2 = this[t4], i3 = 1, o2 = 0; ++o2 < e3 && (i3 *= 256); )
          n2 += this[t4 + o2] * i3;
        return n2;
      }, u.prototype.readUintBE = u.prototype.readUIntBE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || B(t4, e3, this.length);
        for (var n2 = this[t4 + --e3], i3 = 1; e3 > 0 && (i3 *= 256); )
          n2 += this[t4 + --e3] * i3;
        return n2;
      }, u.prototype.readUint8 = u.prototype.readUInt8 = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 1, this.length), this[t4];
      }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 2, this.length), this[t4] | this[t4 + 1] << 8;
      }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 2, this.length), this[t4] << 8 | this[t4 + 1];
      }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 4, this.length), (this[t4] | this[t4 + 1] << 8 | this[t4 + 2] << 16) + 16777216 * this[t4 + 3];
      }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 4, this.length), 16777216 * this[t4] + (this[t4 + 1] << 16 | this[t4 + 2] << 8 | this[t4 + 3]);
      }, u.prototype.readIntLE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || B(t4, e3, this.length);
        for (var n2 = this[t4], i3 = 1, o2 = 0; ++o2 < e3 && (i3 *= 256); )
          n2 += this[t4 + o2] * i3;
        return n2 >= (i3 *= 128) && (n2 -= Math.pow(2, 8 * e3)), n2;
      }, u.prototype.readIntBE = function(t4, e3, r3) {
        t4 >>>= 0, e3 >>>= 0, r3 || B(t4, e3, this.length);
        for (var n2 = e3, i3 = 1, o2 = this[t4 + --n2]; n2 > 0 && (i3 *= 256); )
          o2 += this[t4 + --n2] * i3;
        return o2 >= (i3 *= 128) && (o2 -= Math.pow(2, 8 * e3)), o2;
      }, u.prototype.readInt8 = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 1, this.length), 128 & this[t4] ? -1 * (255 - this[t4] + 1) : this[t4];
      }, u.prototype.readInt16LE = function(t4, e3) {
        t4 >>>= 0, e3 || B(t4, 2, this.length);
        var r3 = this[t4] | this[t4 + 1] << 8;
        return 32768 & r3 ? 4294901760 | r3 : r3;
      }, u.prototype.readInt16BE = function(t4, e3) {
        t4 >>>= 0, e3 || B(t4, 2, this.length);
        var r3 = this[t4 + 1] | this[t4] << 8;
        return 32768 & r3 ? 4294901760 | r3 : r3;
      }, u.prototype.readInt32LE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 4, this.length), this[t4] | this[t4 + 1] << 8 | this[t4 + 2] << 16 | this[t4 + 3] << 24;
      }, u.prototype.readInt32BE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 4, this.length), this[t4] << 24 | this[t4 + 1] << 16 | this[t4 + 2] << 8 | this[t4 + 3];
      }, u.prototype.readFloatLE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 4, this.length), o.read(this, t4, true, 23, 4);
      }, u.prototype.readFloatBE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 4, this.length), o.read(this, t4, false, 23, 4);
      }, u.prototype.readDoubleLE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 8, this.length), o.read(this, t4, true, 52, 8);
      }, u.prototype.readDoubleBE = function(t4, e3) {
        return t4 >>>= 0, e3 || B(t4, 8, this.length), o.read(this, t4, false, 52, 8);
      }, u.prototype.writeUintLE = u.prototype.writeUIntLE = function(t4, e3, r3, n2) {
        t4 = +t4, e3 >>>= 0, r3 >>>= 0, n2 || T(this, t4, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
        var i3 = 1, o2 = 0;
        for (this[e3] = 255 & t4; ++o2 < r3 && (i3 *= 256); )
          this[e3 + o2] = t4 / i3 & 255;
        return e3 + r3;
      }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(t4, e3, r3, n2) {
        t4 = +t4, e3 >>>= 0, r3 >>>= 0, n2 || T(this, t4, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
        var i3 = r3 - 1, o2 = 1;
        for (this[e3 + i3] = 255 & t4; --i3 >= 0 && (o2 *= 256); )
          this[e3 + i3] = t4 / o2 & 255;
        return e3 + r3;
      }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 1, 255, 0), this[e3] = 255 & t4, e3 + 1;
      }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 2, 65535, 0), this[e3] = 255 & t4, this[e3 + 1] = t4 >>> 8, e3 + 2;
      }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 2, 65535, 0), this[e3] = t4 >>> 8, this[e3 + 1] = 255 & t4, e3 + 2;
      }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 4, 4294967295, 0), this[e3 + 3] = t4 >>> 24, this[e3 + 2] = t4 >>> 16, this[e3 + 1] = t4 >>> 8, this[e3] = 255 & t4, e3 + 4;
      }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 4, 4294967295, 0), this[e3] = t4 >>> 24, this[e3 + 1] = t4 >>> 16, this[e3 + 2] = t4 >>> 8, this[e3 + 3] = 255 & t4, e3 + 4;
      }, u.prototype.writeIntLE = function(t4, e3, r3, n2) {
        if (t4 = +t4, e3 >>>= 0, !n2) {
          var i3 = Math.pow(2, 8 * r3 - 1);
          T(this, t4, e3, r3, i3 - 1, -i3);
        }
        var o2 = 0, a2 = 1, s3 = 0;
        for (this[e3] = 255 & t4; ++o2 < r3 && (a2 *= 256); )
          t4 < 0 && 0 === s3 && 0 !== this[e3 + o2 - 1] && (s3 = 1), this[e3 + o2] = (t4 / a2 | 0) - s3 & 255;
        return e3 + r3;
      }, u.prototype.writeIntBE = function(t4, e3, r3, n2) {
        if (t4 = +t4, e3 >>>= 0, !n2) {
          var i3 = Math.pow(2, 8 * r3 - 1);
          T(this, t4, e3, r3, i3 - 1, -i3);
        }
        var o2 = r3 - 1, a2 = 1, s3 = 0;
        for (this[e3 + o2] = 255 & t4; --o2 >= 0 && (a2 *= 256); )
          t4 < 0 && 0 === s3 && 0 !== this[e3 + o2 + 1] && (s3 = 1), this[e3 + o2] = (t4 / a2 | 0) - s3 & 255;
        return e3 + r3;
      }, u.prototype.writeInt8 = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 1, 127, -128), t4 < 0 && (t4 = 255 + t4 + 1), this[e3] = 255 & t4, e3 + 1;
      }, u.prototype.writeInt16LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 2, 32767, -32768), this[e3] = 255 & t4, this[e3 + 1] = t4 >>> 8, e3 + 2;
      }, u.prototype.writeInt16BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 2, 32767, -32768), this[e3] = t4 >>> 8, this[e3 + 1] = 255 & t4, e3 + 2;
      }, u.prototype.writeInt32LE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 4, 2147483647, -2147483648), this[e3] = 255 & t4, this[e3 + 1] = t4 >>> 8, this[e3 + 2] = t4 >>> 16, this[e3 + 3] = t4 >>> 24, e3 + 4;
      }, u.prototype.writeInt32BE = function(t4, e3, r3) {
        return t4 = +t4, e3 >>>= 0, r3 || T(this, t4, e3, 4, 2147483647, -2147483648), t4 < 0 && (t4 = 4294967295 + t4 + 1), this[e3] = t4 >>> 24, this[e3 + 1] = t4 >>> 16, this[e3 + 2] = t4 >>> 8, this[e3 + 3] = 255 & t4, e3 + 4;
      }, u.prototype.writeFloatLE = function(t4, e3, r3) {
        return N(this, t4, e3, true, r3);
      }, u.prototype.writeFloatBE = function(t4, e3, r3) {
        return N(this, t4, e3, false, r3);
      }, u.prototype.writeDoubleLE = function(t4, e3, r3) {
        return D(this, t4, e3, true, r3);
      }, u.prototype.writeDoubleBE = function(t4, e3, r3) {
        return D(this, t4, e3, false, r3);
      }, u.prototype.copy = function(t4, e3, r3, n2) {
        if (!u.isBuffer(t4))
          throw new TypeError("argument should be a Buffer");
        if (r3 || (r3 = 0), n2 || 0 === n2 || (n2 = this.length), e3 >= t4.length && (e3 = t4.length), e3 || (e3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3)
          return 0;
        if (0 === t4.length || 0 === this.length)
          return 0;
        if (e3 < 0)
          throw new RangeError("targetStart out of bounds");
        if (r3 < 0 || r3 >= this.length)
          throw new RangeError("Index out of range");
        if (n2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n2 > this.length && (n2 = this.length), t4.length - e3 < n2 - r3 && (n2 = t4.length - e3 + r3);
        var i3 = n2 - r3;
        return this === t4 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e3, r3, n2) : Uint8Array.prototype.set.call(t4, this.subarray(r3, n2), e3), i3;
      }, u.prototype.fill = function(t4, e3, r3, n2) {
        if ("string" == typeof t4) {
          if ("string" == typeof e3 ? (n2 = e3, e3 = 0, r3 = this.length) : "string" == typeof r3 && (n2 = r3, r3 = this.length), void 0 !== n2 && "string" != typeof n2)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n2 && !u.isEncoding(n2))
            throw new TypeError("Unknown encoding: " + n2);
          if (1 === t4.length) {
            var i3 = t4.charCodeAt(0);
            ("utf8" === n2 && i3 < 128 || "latin1" === n2) && (t4 = i3);
          }
        } else
          "number" == typeof t4 ? t4 &= 255 : "boolean" == typeof t4 && (t4 = Number(t4));
        if (e3 < 0 || this.length < e3 || this.length < r3)
          throw new RangeError("Out of range index");
        if (r3 <= e3)
          return this;
        var o2;
        if (e3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, t4 || (t4 = 0), "number" == typeof t4)
          for (o2 = e3; o2 < r3; ++o2)
            this[o2] = t4;
        else {
          var a2 = u.isBuffer(t4) ? t4 : u.from(t4, n2), s3 = a2.length;
          if (0 === s3)
            throw new TypeError('The value "' + t4 + '" is invalid for argument "value"');
          for (o2 = 0; o2 < r3 - e3; ++o2)
            this[o2 + e3] = a2[o2 % s3];
        }
        return this;
      };
      var L = /[^+/0-9A-Za-z-_]/g;
      function U(t4, e3) {
        var r3;
        e3 = e3 || 1 / 0;
        for (var n2 = t4.length, i3 = null, o2 = [], a2 = 0; a2 < n2; ++a2) {
          if ((r3 = t4.charCodeAt(a2)) > 55295 && r3 < 57344) {
            if (!i3) {
              if (r3 > 56319) {
                (e3 -= 3) > -1 && o2.push(239, 191, 189);
                continue;
              }
              if (a2 + 1 === n2) {
                (e3 -= 3) > -1 && o2.push(239, 191, 189);
                continue;
              }
              i3 = r3;
              continue;
            }
            if (r3 < 56320) {
              (e3 -= 3) > -1 && o2.push(239, 191, 189), i3 = r3;
              continue;
            }
            r3 = 65536 + (i3 - 55296 << 10 | r3 - 56320);
          } else
            i3 && (e3 -= 3) > -1 && o2.push(239, 191, 189);
          if (i3 = null, r3 < 128) {
            if ((e3 -= 1) < 0)
              break;
            o2.push(r3);
          } else if (r3 < 2048) {
            if ((e3 -= 2) < 0)
              break;
            o2.push(r3 >> 6 | 192, 63 & r3 | 128);
          } else if (r3 < 65536) {
            if ((e3 -= 3) < 0)
              break;
            o2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
          } else {
            if (!(r3 < 1114112))
              throw new Error("Invalid code point");
            if ((e3 -= 4) < 0)
              break;
            o2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
          }
        }
        return o2;
      }
      function C(t4) {
        return i2.toByteArray(function(t5) {
          if ((t5 = (t5 = t5.split("=")[0]).trim().replace(L, "")).length < 2)
            return "";
          for (; t5.length % 4 != 0; )
            t5 += "=";
          return t5;
        }(t4));
      }
      function q(t4, e3, r3, n2) {
        for (var i3 = 0; i3 < n2 && !(i3 + r3 >= e3.length || i3 >= t4.length); ++i3)
          e3[i3 + r3] = t4[i3];
        return i3;
      }
      function F(t4, e3) {
        return t4 instanceof e3 || null != t4 && null != t4.constructor && null != t4.constructor.name && t4.constructor.name === e3.name;
      }
      function V(t4) {
        return t4 != t4;
      }
      var z = function() {
        for (var t4 = "0123456789abcdef", e3 = new Array(256), r3 = 0; r3 < 16; ++r3)
          for (var n2 = 16 * r3, i3 = 0; i3 < 16; ++i3)
            e3[n2 + i3] = t4[r3] + t4[i3];
        return e3;
      }();
    }, 9466: (t3, e2, r2) => {
      var n = r2(6400), i2 = r2(9122), o = i2(n("String.prototype.indexOf"));
      t3.exports = function(t4, e3) {
        var r3 = n(t4, !!e3);
        return "function" == typeof r3 && o(t4, ".prototype.") > -1 ? i2(r3) : r3;
      };
    }, 9122: (t3, e2, r2) => {
      var n = r2(2354), i2 = r2(6400), o = r2(3900), a = r2(2268), s2 = i2("%Function.prototype.apply%"), c = i2("%Function.prototype.call%"), u = i2("%Reflect.apply%", true) || n.call(c, s2), f = r2(988), l = i2("%Math.max%");
      t3.exports = function(t4) {
        if ("function" != typeof t4)
          throw new a("a function is required");
        var e3 = u(n, c, arguments);
        return o(e3, 1 + l(0, t4.length - (arguments.length - 1)), true);
      };
      var h2 = function() {
        return u(n, s2, arguments);
      };
      f ? f(t3.exports, "apply", { value: h2 }) : t3.exports.apply = h2;
    }, 2533: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(7775).Transform, o = r2(136).I;
      function a(t4) {
        i2.call(this), this.hashMode = "string" == typeof t4, this.hashMode ? this[t4] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
      }
      r2(1679)(a, i2), a.prototype.update = function(t4, e3, r3) {
        "string" == typeof t4 && (t4 = n.from(t4, e3));
        var i3 = this._update(t4);
        return this.hashMode ? this : (r3 && (i3 = this._toString(i3, r3)), i3);
      }, a.prototype.setAutoPadding = function() {
      }, a.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      }, a.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      }, a.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      }, a.prototype._transform = function(t4, e3, r3) {
        var n2;
        try {
          this.hashMode ? this._update(t4) : this.push(this._update(t4));
        } catch (t5) {
          n2 = t5;
        } finally {
          r3(n2);
        }
      }, a.prototype._flush = function(t4) {
        var e3;
        try {
          this.push(this.__final());
        } catch (t5) {
          e3 = t5;
        }
        t4(e3);
      }, a.prototype._finalOrDigest = function(t4) {
        var e3 = this.__final() || n.alloc(0);
        return t4 && (e3 = this._toString(e3, t4, true)), e3;
      }, a.prototype._toString = function(t4, e3, r3) {
        if (this._decoder || (this._decoder = new o(e3), this._encoding = e3), this._encoding !== e3)
          throw new Error("can't switch encodings");
        var n2 = this._decoder.write(t4);
        return r3 && (n2 += this._decoder.end()), n2;
      }, t3.exports = a;
    }, 7919: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4) {
        return Object.prototype.toString.call(t4);
      }
      e2.isArray = function(t4) {
        return Array.isArray ? Array.isArray(t4) : "[object Array]" === i2(t4);
      }, e2.isBoolean = function(t4) {
        return "boolean" == typeof t4;
      }, e2.isNull = function(t4) {
        return null === t4;
      }, e2.isNullOrUndefined = function(t4) {
        return null == t4;
      }, e2.isNumber = function(t4) {
        return "number" == typeof t4;
      }, e2.isString = function(t4) {
        return "string" == typeof t4;
      }, e2.isSymbol = function(t4) {
        return "symbol" === n(t4);
      }, e2.isUndefined = function(t4) {
        return void 0 === t4;
      }, e2.isRegExp = function(t4) {
        return "[object RegExp]" === i2(t4);
      }, e2.isObject = function(t4) {
        return "object" === n(t4) && null !== t4;
      }, e2.isDate = function(t4) {
        return "[object Date]" === i2(t4);
      }, e2.isError = function(t4) {
        return "[object Error]" === i2(t4) || t4 instanceof Error;
      }, e2.isFunction = function(t4) {
        return "function" == typeof t4;
      }, e2.isPrimitive = function(t4) {
        return null === t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || "symbol" === n(t4) || void 0 === t4;
      }, e2.isBuffer = r2(5832).Buffer.isBuffer;
    }, 1005: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(7312), o = r2(7799);
      t3.exports = function(t4) {
        return new s2(t4);
      };
      var a = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
      function s2(t4) {
        this.curveType = a[t4], this.curveType || (this.curveType = { name: t4 }), this.curve = new i2.ec(this.curveType.name), this.keys = void 0;
      }
      function c(t4, e3, r3) {
        Array.isArray(t4) || (t4 = t4.toArray());
        var i3 = new n(t4);
        if (r3 && i3.length < r3) {
          var o2 = new n(r3 - i3.length);
          o2.fill(0), i3 = n.concat([o2, i3]);
        }
        return e3 ? i3.toString(e3) : i3;
      }
      a.p224 = a.secp224r1, a.p256 = a.secp256r1 = a.prime256v1, a.p192 = a.secp192r1 = a.prime192v1, a.p384 = a.secp384r1, a.p521 = a.secp521r1, s2.prototype.generateKeys = function(t4, e3) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(t4, e3);
      }, s2.prototype.computeSecret = function(t4, e3, r3) {
        return e3 = e3 || "utf8", n.isBuffer(t4) || (t4 = new n(t4, e3)), c(this.curve.keyFromPublic(t4).getPublic().mul(this.keys.getPrivate()).getX(), r3, this.curveType.byteLength);
      }, s2.prototype.getPublicKey = function(t4, e3) {
        var r3 = this.keys.getPublic("compressed" === e3, true);
        return "hybrid" === e3 && (r3[r3.length - 1] % 2 ? r3[0] = 7 : r3[0] = 6), c(r3, t4);
      }, s2.prototype.getPrivateKey = function(t4) {
        return c(this.keys.getPrivate(), t4);
      }, s2.prototype.setPublicKey = function(t4, e3) {
        return e3 = e3 || "utf8", n.isBuffer(t4) || (t4 = new n(t4, e3)), this.keys._importPublic(t4), this;
      }, s2.prototype.setPrivateKey = function(t4, e3) {
        e3 = e3 || "utf8", n.isBuffer(t4) || (t4 = new n(t4, e3));
        var r3 = new o(t4);
        return r3 = r3.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r3), this;
      };
    }, 5833: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(2635), o = r2(1058), a = r2(3261), s2 = r2(2533);
      function c(t4) {
        s2.call(this, "digest"), this._hash = t4;
      }
      n(c, s2), c.prototype._update = function(t4) {
        this._hash.update(t4);
      }, c.prototype._final = function() {
        return this._hash.digest();
      }, t3.exports = function(t4) {
        return "md5" === (t4 = t4.toLowerCase()) ? new i2() : "rmd160" === t4 || "ripemd160" === t4 ? new o() : new c(a(t4));
      };
    }, 3989: (t3, e2, r2) => {
      var n = r2(2635);
      t3.exports = function(t4) {
        return new n().update(t4).digest();
      };
    }, 2046: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(6583), o = r2(2533), a = r2(9732).Buffer, s2 = r2(3989), c = r2(1058), u = r2(3261), f = a.alloc(128);
      function l(t4, e3) {
        o.call(this, "digest"), "string" == typeof e3 && (e3 = a.from(e3));
        var r3 = "sha512" === t4 || "sha384" === t4 ? 128 : 64;
        this._alg = t4, this._key = e3, e3.length > r3 ? e3 = ("rmd160" === t4 ? new c() : u(t4)).update(e3).digest() : e3.length < r3 && (e3 = a.concat([e3, f], r3));
        for (var n2 = this._ipad = a.allocUnsafe(r3), i3 = this._opad = a.allocUnsafe(r3), s3 = 0; s3 < r3; s3++)
          n2[s3] = 54 ^ e3[s3], i3[s3] = 92 ^ e3[s3];
        this._hash = "rmd160" === t4 ? new c() : u(t4), this._hash.update(n2);
      }
      n(l, o), l.prototype._update = function(t4) {
        this._hash.update(t4);
      }, l.prototype._final = function() {
        var t4 = this._hash.digest();
        return ("rmd160" === this._alg ? new c() : u(this._alg)).update(this._opad).update(t4).digest();
      }, t3.exports = function(t4, e3) {
        return "rmd160" === (t4 = t4.toLowerCase()) || "ripemd160" === t4 ? new l("rmd160", e3) : "md5" === t4 ? new i2(s2, e3) : new l(t4, e3);
      };
    }, 6583: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(9732).Buffer, o = r2(2533), a = i2.alloc(128), s2 = 64;
      function c(t4, e3) {
        o.call(this, "digest"), "string" == typeof e3 && (e3 = i2.from(e3)), this._alg = t4, this._key = e3, e3.length > s2 ? e3 = t4(e3) : e3.length < s2 && (e3 = i2.concat([e3, a], s2));
        for (var r3 = this._ipad = i2.allocUnsafe(s2), n2 = this._opad = i2.allocUnsafe(s2), c2 = 0; c2 < s2; c2++)
          r3[c2] = 54 ^ e3[c2], n2[c2] = 92 ^ e3[c2];
        this._hash = [r3];
      }
      n(c, o), c.prototype._update = function(t4) {
        this._hash.push(t4);
      }, c.prototype._final = function() {
        var t4 = this._alg(i2.concat(this._hash));
        return this._alg(i2.concat([this._opad, t4]));
      }, t3.exports = c;
    }, 8872: (t3, e2, r2) => {
      e2.po = r2(4276), r2(5833), r2(2046);
      r2(4606);
      var o = r2(8699);
      o.pbkdf2, o.pbkdf2Sync;
      var a = r2(9652);
      a.Cipher, a.createCipher, a.Cipheriv, a.createCipheriv, a.Decipher, a.createDecipher, a.Decipheriv, a.createDecipheriv, a.getCiphers, a.listCiphers;
      var s2 = r2(9803);
      s2.DiffieHellmanGroup, s2.createDiffieHellmanGroup, s2.getDiffieHellman, s2.createDiffieHellman, s2.DiffieHellman;
      var c = r2(7937);
      c.createSign, c.Sign, c.createVerify, c.Verify, r2(1005);
      var u = r2(2327);
      u.publicEncrypt, u.privateEncrypt, u.publicDecrypt, u.privateDecrypt;
      var f = r2(7952);
      f.randomFill, f.randomFillSync;
    }, 6750: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(988), o = r2(2288), a = r2(2268), s2 = r2(1464);
      t3.exports = function(t4, e3, r3) {
        if (!t4 || "object" !== n(t4) && "function" != typeof t4)
          throw new a("`obj` must be an object or a function`");
        if ("string" != typeof e3 && "symbol" !== n(e3))
          throw new a("`property` must be a string or a symbol`");
        if (arguments.length > 3 && "boolean" != typeof arguments[3] && null !== arguments[3])
          throw new a("`nonEnumerable`, if provided, must be a boolean or null");
        if (arguments.length > 4 && "boolean" != typeof arguments[4] && null !== arguments[4])
          throw new a("`nonWritable`, if provided, must be a boolean or null");
        if (arguments.length > 5 && "boolean" != typeof arguments[5] && null !== arguments[5])
          throw new a("`nonConfigurable`, if provided, must be a boolean or null");
        if (arguments.length > 6 && "boolean" != typeof arguments[6])
          throw new a("`loose`, if provided, must be a boolean");
        var c = arguments.length > 3 ? arguments[3] : null, u = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, l = arguments.length > 6 && arguments[6], h2 = !!s2 && s2(t4, e3);
        if (i2)
          i2(t4, e3, { configurable: null === f && h2 ? h2.configurable : !f, enumerable: null === c && h2 ? h2.enumerable : !c, value: r3, writable: null === u && h2 ? h2.writable : !u });
        else {
          if (!l && (c || u || f))
            throw new o("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
          t4[e3] = r3;
        }
      };
    }, 2273: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(668), o = "function" == typeof Symbol && "symbol" === n(Symbol("foo")), a = Object.prototype.toString, s2 = Array.prototype.concat, c = r2(6750), u = r2(3191)(), f = function(t4, e3, r3, n2) {
        if (e3 in t4) {
          if (true === n2) {
            if (t4[e3] === r3)
              return;
          } else if ("function" != typeof (i3 = n2) || "[object Function]" !== a.call(i3) || !n2())
            return;
        }
        var i3;
        u ? c(t4, e3, r3, true) : c(t4, e3, r3);
      }, l = function(t4, e3) {
        var r3 = arguments.length > 2 ? arguments[2] : {}, n2 = i2(e3);
        o && (n2 = s2.call(n2, Object.getOwnPropertySymbols(e3)));
        for (var a2 = 0; a2 < n2.length; a2 += 1)
          f(t4, n2[a2], e3[n2[a2]], r3[n2[a2]]);
      };
      l.supportsDescriptors = !!u, t3.exports = l;
    }, 1471: (t3, e2, r2) => {
      e2.utils = r2(9473), e2.Cipher = r2(365), e2.DES = r2(1048), e2.CBC = r2(6754), e2.EDE = r2(1368);
    }, 6754: (t3, e2, r2) => {
      var n = r2(3528), i2 = r2(1679), o = {};
      function a(t4) {
        n.equal(t4.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for (var e3 = 0; e3 < this.iv.length; e3++)
          this.iv[e3] = t4[e3];
      }
      e2.instantiate = function(t4) {
        function e3(e4) {
          t4.call(this, e4), this._cbcInit();
        }
        i2(e3, t4);
        for (var r3 = Object.keys(o), n2 = 0; n2 < r3.length; n2++) {
          var a2 = r3[n2];
          e3.prototype[a2] = o[a2];
        }
        return e3.create = function(t5) {
          return new e3(t5);
        }, e3;
      }, o._cbcInit = function() {
        var t4 = new a(this.options.iv);
        this._cbcState = t4;
      }, o._update = function(t4, e3, r3, n2) {
        var i3 = this._cbcState, o2 = this.constructor.super_.prototype, a2 = i3.iv;
        if ("encrypt" === this.type) {
          for (var s2 = 0; s2 < this.blockSize; s2++)
            a2[s2] ^= t4[e3 + s2];
          for (o2._update.call(this, a2, 0, r3, n2), s2 = 0; s2 < this.blockSize; s2++)
            a2[s2] = r3[n2 + s2];
        } else {
          for (o2._update.call(this, t4, e3, r3, n2), s2 = 0; s2 < this.blockSize; s2++)
            r3[n2 + s2] ^= a2[s2];
          for (s2 = 0; s2 < this.blockSize; s2++)
            a2[s2] = t4[e3 + s2];
        }
      };
    }, 365: (t3, e2, r2) => {
      var n = r2(3528);
      function i2(t4) {
        this.options = t4, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = false !== t4.padding;
      }
      t3.exports = i2, i2.prototype._init = function() {
      }, i2.prototype.update = function(t4) {
        return 0 === t4.length ? [] : "decrypt" === this.type ? this._updateDecrypt(t4) : this._updateEncrypt(t4);
      }, i2.prototype._buffer = function(t4, e3) {
        for (var r3 = Math.min(this.buffer.length - this.bufferOff, t4.length - e3), n2 = 0; n2 < r3; n2++)
          this.buffer[this.bufferOff + n2] = t4[e3 + n2];
        return this.bufferOff += r3, r3;
      }, i2.prototype._flushBuffer = function(t4, e3) {
        return this._update(this.buffer, 0, t4, e3), this.bufferOff = 0, this.blockSize;
      }, i2.prototype._updateEncrypt = function(t4) {
        var e3 = 0, r3 = 0, n2 = (this.bufferOff + t4.length) / this.blockSize | 0, i3 = new Array(n2 * this.blockSize);
        0 !== this.bufferOff && (e3 += this._buffer(t4, e3), this.bufferOff === this.buffer.length && (r3 += this._flushBuffer(i3, r3)));
        for (var o = t4.length - (t4.length - e3) % this.blockSize; e3 < o; e3 += this.blockSize)
          this._update(t4, e3, i3, r3), r3 += this.blockSize;
        for (; e3 < t4.length; e3++, this.bufferOff++)
          this.buffer[this.bufferOff] = t4[e3];
        return i3;
      }, i2.prototype._updateDecrypt = function(t4) {
        for (var e3 = 0, r3 = 0, n2 = Math.ceil((this.bufferOff + t4.length) / this.blockSize) - 1, i3 = new Array(n2 * this.blockSize); n2 > 0; n2--)
          e3 += this._buffer(t4, e3), r3 += this._flushBuffer(i3, r3);
        return e3 += this._buffer(t4, e3), i3;
      }, i2.prototype.final = function(t4) {
        var e3, r3;
        return t4 && (e3 = this.update(t4)), r3 = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), e3 ? e3.concat(r3) : r3;
      }, i2.prototype._pad = function(t4, e3) {
        if (0 === e3)
          return false;
        for (; e3 < t4.length; )
          t4[e3++] = 0;
        return true;
      }, i2.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff))
          return [];
        var t4 = new Array(this.blockSize);
        return this._update(this.buffer, 0, t4, 0), t4;
      }, i2.prototype._unpad = function(t4) {
        return t4;
      }, i2.prototype._finalDecrypt = function() {
        n.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var t4 = new Array(this.blockSize);
        return this._flushBuffer(t4, 0), this._unpad(t4);
      };
    }, 1048: (t3, e2, r2) => {
      var n = r2(3528), i2 = r2(1679), o = r2(9473), a = r2(365);
      function s2() {
        this.tmp = new Array(2), this.keys = null;
      }
      function c(t4) {
        a.call(this, t4);
        var e3 = new s2();
        this._desState = e3, this.deriveKeys(e3, t4.key);
      }
      i2(c, a), t3.exports = c, c.create = function(t4) {
        return new c(t4);
      };
      var u = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
      c.prototype.deriveKeys = function(t4, e3) {
        t4.keys = new Array(32), n.equal(e3.length, this.blockSize, "Invalid key length");
        var r3 = o.readUInt32BE(e3, 0), i3 = o.readUInt32BE(e3, 4);
        o.pc1(r3, i3, t4.tmp, 0), r3 = t4.tmp[0], i3 = t4.tmp[1];
        for (var a2 = 0; a2 < t4.keys.length; a2 += 2) {
          var s3 = u[a2 >>> 1];
          r3 = o.r28shl(r3, s3), i3 = o.r28shl(i3, s3), o.pc2(r3, i3, t4.keys, a2);
        }
      }, c.prototype._update = function(t4, e3, r3, n2) {
        var i3 = this._desState, a2 = o.readUInt32BE(t4, e3), s3 = o.readUInt32BE(t4, e3 + 4);
        o.ip(a2, s3, i3.tmp, 0), a2 = i3.tmp[0], s3 = i3.tmp[1], "encrypt" === this.type ? this._encrypt(i3, a2, s3, i3.tmp, 0) : this._decrypt(i3, a2, s3, i3.tmp, 0), a2 = i3.tmp[0], s3 = i3.tmp[1], o.writeUInt32BE(r3, a2, n2), o.writeUInt32BE(r3, s3, n2 + 4);
      }, c.prototype._pad = function(t4, e3) {
        if (false === this.padding)
          return false;
        for (var r3 = t4.length - e3, n2 = e3; n2 < t4.length; n2++)
          t4[n2] = r3;
        return true;
      }, c.prototype._unpad = function(t4) {
        if (false === this.padding)
          return t4;
        for (var e3 = t4[t4.length - 1], r3 = t4.length - e3; r3 < t4.length; r3++)
          n.equal(t4[r3], e3);
        return t4.slice(0, t4.length - e3);
      }, c.prototype._encrypt = function(t4, e3, r3, n2, i3) {
        for (var a2 = e3, s3 = r3, c2 = 0; c2 < t4.keys.length; c2 += 2) {
          var u2 = t4.keys[c2], f = t4.keys[c2 + 1];
          o.expand(s3, t4.tmp, 0), u2 ^= t4.tmp[0], f ^= t4.tmp[1];
          var l = o.substitute(u2, f), h2 = s3;
          s3 = (a2 ^ o.permute(l)) >>> 0, a2 = h2;
        }
        o.rip(s3, a2, n2, i3);
      }, c.prototype._decrypt = function(t4, e3, r3, n2, i3) {
        for (var a2 = r3, s3 = e3, c2 = t4.keys.length - 2; c2 >= 0; c2 -= 2) {
          var u2 = t4.keys[c2], f = t4.keys[c2 + 1];
          o.expand(a2, t4.tmp, 0), u2 ^= t4.tmp[0], f ^= t4.tmp[1];
          var l = o.substitute(u2, f), h2 = a2;
          a2 = (s3 ^ o.permute(l)) >>> 0, s3 = h2;
        }
        o.rip(a2, s3, n2, i3);
      };
    }, 1368: (t3, e2, r2) => {
      var n = r2(3528), i2 = r2(1679), o = r2(365), a = r2(1048);
      function s2(t4, e3) {
        n.equal(e3.length, 24, "Invalid key length");
        var r3 = e3.slice(0, 8), i3 = e3.slice(8, 16), o2 = e3.slice(16, 24);
        this.ciphers = "encrypt" === t4 ? [a.create({ type: "encrypt", key: r3 }), a.create({ type: "decrypt", key: i3 }), a.create({ type: "encrypt", key: o2 })] : [a.create({ type: "decrypt", key: o2 }), a.create({ type: "encrypt", key: i3 }), a.create({ type: "decrypt", key: r3 })];
      }
      function c(t4) {
        o.call(this, t4);
        var e3 = new s2(this.type, this.options.key);
        this._edeState = e3;
      }
      i2(c, o), t3.exports = c, c.create = function(t4) {
        return new c(t4);
      }, c.prototype._update = function(t4, e3, r3, n2) {
        var i3 = this._edeState;
        i3.ciphers[0]._update(t4, e3, r3, n2), i3.ciphers[1]._update(r3, n2, r3, n2), i3.ciphers[2]._update(r3, n2, r3, n2);
      }, c.prototype._pad = a.prototype._pad, c.prototype._unpad = a.prototype._unpad;
    }, 9473: (t3, e2) => {
      e2.readUInt32BE = function(t4, e3) {
        return (t4[0 + e3] << 24 | t4[1 + e3] << 16 | t4[2 + e3] << 8 | t4[3 + e3]) >>> 0;
      }, e2.writeUInt32BE = function(t4, e3, r3) {
        t4[0 + r3] = e3 >>> 24, t4[1 + r3] = e3 >>> 16 & 255, t4[2 + r3] = e3 >>> 8 & 255, t4[3 + r3] = 255 & e3;
      }, e2.ip = function(t4, e3, r3, n2) {
        for (var i3 = 0, o = 0, a = 6; a >= 0; a -= 2) {
          for (var s2 = 0; s2 <= 24; s2 += 8)
            i3 <<= 1, i3 |= e3 >>> s2 + a & 1;
          for (s2 = 0; s2 <= 24; s2 += 8)
            i3 <<= 1, i3 |= t4 >>> s2 + a & 1;
        }
        for (a = 6; a >= 0; a -= 2) {
          for (s2 = 1; s2 <= 25; s2 += 8)
            o <<= 1, o |= e3 >>> s2 + a & 1;
          for (s2 = 1; s2 <= 25; s2 += 8)
            o <<= 1, o |= t4 >>> s2 + a & 1;
        }
        r3[n2 + 0] = i3 >>> 0, r3[n2 + 1] = o >>> 0;
      }, e2.rip = function(t4, e3, r3, n2) {
        for (var i3 = 0, o = 0, a = 0; a < 4; a++)
          for (var s2 = 24; s2 >= 0; s2 -= 8)
            i3 <<= 1, i3 |= e3 >>> s2 + a & 1, i3 <<= 1, i3 |= t4 >>> s2 + a & 1;
        for (a = 4; a < 8; a++)
          for (s2 = 24; s2 >= 0; s2 -= 8)
            o <<= 1, o |= e3 >>> s2 + a & 1, o <<= 1, o |= t4 >>> s2 + a & 1;
        r3[n2 + 0] = i3 >>> 0, r3[n2 + 1] = o >>> 0;
      }, e2.pc1 = function(t4, e3, r3, n2) {
        for (var i3 = 0, o = 0, a = 7; a >= 5; a--) {
          for (var s2 = 0; s2 <= 24; s2 += 8)
            i3 <<= 1, i3 |= e3 >> s2 + a & 1;
          for (s2 = 0; s2 <= 24; s2 += 8)
            i3 <<= 1, i3 |= t4 >> s2 + a & 1;
        }
        for (s2 = 0; s2 <= 24; s2 += 8)
          i3 <<= 1, i3 |= e3 >> s2 + a & 1;
        for (a = 1; a <= 3; a++) {
          for (s2 = 0; s2 <= 24; s2 += 8)
            o <<= 1, o |= e3 >> s2 + a & 1;
          for (s2 = 0; s2 <= 24; s2 += 8)
            o <<= 1, o |= t4 >> s2 + a & 1;
        }
        for (s2 = 0; s2 <= 24; s2 += 8)
          o <<= 1, o |= t4 >> s2 + a & 1;
        r3[n2 + 0] = i3 >>> 0, r3[n2 + 1] = o >>> 0;
      }, e2.r28shl = function(t4, e3) {
        return t4 << e3 & 268435455 | t4 >>> 28 - e3;
      };
      var r2 = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
      e2.pc2 = function(t4, e3, n2, i3) {
        for (var o = 0, a = 0, s2 = r2.length >>> 1, c = 0; c < s2; c++)
          o <<= 1, o |= t4 >>> r2[c] & 1;
        for (c = s2; c < r2.length; c++)
          a <<= 1, a |= e3 >>> r2[c] & 1;
        n2[i3 + 0] = o >>> 0, n2[i3 + 1] = a >>> 0;
      }, e2.expand = function(t4, e3, r3) {
        var n2 = 0, i3 = 0;
        n2 = (1 & t4) << 5 | t4 >>> 27;
        for (var o = 23; o >= 15; o -= 4)
          n2 <<= 6, n2 |= t4 >>> o & 63;
        for (o = 11; o >= 3; o -= 4)
          i3 |= t4 >>> o & 63, i3 <<= 6;
        i3 |= (31 & t4) << 1 | t4 >>> 31, e3[r3 + 0] = n2 >>> 0, e3[r3 + 1] = i3 >>> 0;
      };
      var n = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
      e2.substitute = function(t4, e3) {
        for (var r3 = 0, i3 = 0; i3 < 4; i3++)
          r3 <<= 4, r3 |= n[64 * i3 + (t4 >>> 18 - 6 * i3 & 63)];
        for (i3 = 0; i3 < 4; i3++)
          r3 <<= 4, r3 |= n[256 + 64 * i3 + (e3 >>> 18 - 6 * i3 & 63)];
        return r3 >>> 0;
      };
      var i2 = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
      e2.permute = function(t4) {
        for (var e3 = 0, r3 = 0; r3 < i2.length; r3++)
          e3 <<= 1, e3 |= t4 >>> i2[r3] & 1;
        return e3 >>> 0;
      }, e2.padSplit = function(t4, e3, r3) {
        for (var n2 = t4.toString(2); n2.length < e3; )
          n2 = "0" + n2;
        for (var i3 = [], o = 0; o < e3; o += r3)
          i3.push(n2.slice(o, o + r3));
        return i3.join(" ");
      };
    }, 9803: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(1673), o = r2(3241), a = r2(8151), s2 = { binary: true, hex: true, base64: true };
      e2.DiffieHellmanGroup = e2.createDiffieHellmanGroup = e2.getDiffieHellman = function(t4) {
        var e3 = new n(o[t4].prime, "hex"), r3 = new n(o[t4].gen, "hex");
        return new a(e3, r3);
      }, e2.createDiffieHellman = e2.DiffieHellman = function t4(e3, r3, o2, c) {
        return n.isBuffer(r3) || void 0 === s2[r3] ? t4(e3, "binary", r3, o2) : (r3 = r3 || "binary", c = c || "binary", o2 = o2 || new n([2]), n.isBuffer(o2) || (o2 = new n(o2, c)), "number" == typeof e3 ? new a(i2(e3, o2), o2, true) : (n.isBuffer(e3) || (e3 = new n(e3, r3)), new a(e3, o2, true)));
      };
    }, 8151: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(7799), o = new (r2(1257))(), a = new i2(24), s2 = new i2(11), c = new i2(10), u = new i2(3), f = new i2(7), l = r2(1673), h2 = r2(4276);
      function p(t4, e3) {
        return e3 = e3 || "utf8", n.isBuffer(t4) || (t4 = new n(t4, e3)), this._pub = new i2(t4), this;
      }
      function d2(t4, e3) {
        return e3 = e3 || "utf8", n.isBuffer(t4) || (t4 = new n(t4, e3)), this._priv = new i2(t4), this;
      }
      t3.exports = b;
      var y2 = {};
      function b(t4, e3, r3) {
        this.setGenerator(e3), this.__prime = new i2(t4), this._prime = i2.mont(this.__prime), this._primeLen = t4.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r3 ? (this.setPublicKey = p, this.setPrivateKey = d2) : this._primeCode = 8;
      }
      function m2(t4, e3) {
        var r3 = new n(t4.toArray());
        return e3 ? r3.toString(e3) : r3;
      }
      Object.defineProperty(b.prototype, "verifyError", { enumerable: true, get: function() {
        return "number" != typeof this._primeCode && (this._primeCode = function(t4, e3) {
          var r3 = e3.toString("hex"), n2 = [r3, t4.toString(16)].join("_");
          if (n2 in y2)
            return y2[n2];
          var i3, h3 = 0;
          if (t4.isEven() || !l.simpleSieve || !l.fermatTest(t4) || !o.test(t4))
            return h3 += 1, h3 += "02" === r3 || "05" === r3 ? 8 : 4, y2[n2] = h3, h3;
          switch (o.test(t4.shrn(1)) || (h3 += 2), r3) {
            case "02":
              t4.mod(a).cmp(s2) && (h3 += 8);
              break;
            case "05":
              (i3 = t4.mod(c)).cmp(u) && i3.cmp(f) && (h3 += 8);
              break;
            default:
              h3 += 4;
          }
          return y2[n2] = h3, h3;
        }(this.__prime, this.__gen)), this._primeCode;
      } }), b.prototype.generateKeys = function() {
        return this._priv || (this._priv = new i2(h2(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
      }, b.prototype.computeSecret = function(t4) {
        var e3 = (t4 = (t4 = new i2(t4)).toRed(this._prime)).redPow(this._priv).fromRed(), r3 = new n(e3.toArray()), o2 = this.getPrime();
        if (r3.length < o2.length) {
          var a2 = new n(o2.length - r3.length);
          a2.fill(0), r3 = n.concat([a2, r3]);
        }
        return r3;
      }, b.prototype.getPublicKey = function(t4) {
        return m2(this._pub, t4);
      }, b.prototype.getPrivateKey = function(t4) {
        return m2(this._priv, t4);
      }, b.prototype.getPrime = function(t4) {
        return m2(this.__prime, t4);
      }, b.prototype.getGenerator = function(t4) {
        return m2(this._gen, t4);
      }, b.prototype.setGenerator = function(t4, e3) {
        return e3 = e3 || "utf8", n.isBuffer(t4) || (t4 = new n(t4, e3)), this.__gen = t4, this._gen = new i2(t4), this;
      };
    }, 1673: (t3, e2, r2) => {
      var n = r2(4276);
      t3.exports = v, v.simpleSieve = b, v.fermatTest = m2;
      var i2 = r2(7799), o = new i2(24), a = new (r2(1257))(), s2 = new i2(1), c = new i2(2), u = new i2(5), f = (new i2(16), new i2(8), new i2(10)), l = new i2(3), h2 = (new i2(7), new i2(11)), p = new i2(4), d2 = (new i2(12), null);
      function y2() {
        if (null !== d2)
          return d2;
        var t4 = [];
        t4[0] = 2;
        for (var e3 = 1, r3 = 3; r3 < 1048576; r3 += 2) {
          for (var n2 = Math.ceil(Math.sqrt(r3)), i3 = 0; i3 < e3 && t4[i3] <= n2 && r3 % t4[i3] != 0; i3++)
            ;
          e3 !== i3 && t4[i3] <= n2 || (t4[e3++] = r3);
        }
        return d2 = t4, t4;
      }
      function b(t4) {
        for (var e3 = y2(), r3 = 0; r3 < e3.length; r3++)
          if (0 === t4.modn(e3[r3]))
            return 0 === t4.cmpn(e3[r3]);
        return true;
      }
      function m2(t4) {
        var e3 = i2.mont(t4);
        return 0 === c.toRed(e3).redPow(t4.subn(1)).fromRed().cmpn(1);
      }
      function v(t4, e3) {
        if (t4 < 16)
          return new i2(2 === e3 || 5 === e3 ? [140, 123] : [140, 39]);
        var r3, d3;
        for (e3 = new i2(e3); ; ) {
          for (r3 = new i2(n(Math.ceil(t4 / 8))); r3.bitLength() > t4; )
            r3.ishrn(1);
          if (r3.isEven() && r3.iadd(s2), r3.testn(1) || r3.iadd(c), e3.cmp(c)) {
            if (!e3.cmp(u))
              for (; r3.mod(f).cmp(l); )
                r3.iadd(p);
          } else
            for (; r3.mod(o).cmp(h2); )
              r3.iadd(p);
          if (b(d3 = r3.shrn(1)) && b(r3) && m2(d3) && m2(r3) && a.test(d3) && a.test(r3))
            return r3;
        }
      }
    }, 7312: (t3, e2, r2) => {
      var n = e2;
      n.version = r2(1636).rE, n.utils = r2(1970), n.rand = r2(8904), n.curve = r2(5803), n.curves = r2(6379), n.ec = r2(7416), n.eddsa = r2(4919);
    }, 3334: (t3, e2, r2) => {
      var n = r2(7799), i2 = r2(1970), o = i2.getNAF, a = i2.getJSF, s2 = i2.assert;
      function c(t4, e3) {
        this.type = t4, this.p = new n(e3.p, 16), this.red = e3.prime ? n.red(e3.prime) : n.mont(this.p), this.zero = new n(0).toRed(this.red), this.one = new n(1).toRed(this.red), this.two = new n(2).toRed(this.red), this.n = e3.n && new n(e3.n, 16), this.g = e3.g && this.pointFromJSON(e3.g, e3.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var r3 = this.n && this.p.div(this.n);
        !r3 || r3.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
      }
      function u(t4, e3) {
        this.curve = t4, this.type = e3, this.precomputed = null;
      }
      t3.exports = c, c.prototype.point = function() {
        throw new Error("Not implemented");
      }, c.prototype.validate = function() {
        throw new Error("Not implemented");
      }, c.prototype._fixedNafMul = function(t4, e3) {
        s2(t4.precomputed);
        var r3 = t4._getDoubles(), n2 = o(e3, 1, this._bitLength), i3 = (1 << r3.step + 1) - (r3.step % 2 == 0 ? 2 : 1);
        i3 /= 3;
        var a2, c2, u2 = [];
        for (a2 = 0; a2 < n2.length; a2 += r3.step) {
          c2 = 0;
          for (var f = a2 + r3.step - 1; f >= a2; f--)
            c2 = (c2 << 1) + n2[f];
          u2.push(c2);
        }
        for (var l = this.jpoint(null, null, null), h2 = this.jpoint(null, null, null), p = i3; p > 0; p--) {
          for (a2 = 0; a2 < u2.length; a2++)
            (c2 = u2[a2]) === p ? h2 = h2.mixedAdd(r3.points[a2]) : c2 === -p && (h2 = h2.mixedAdd(r3.points[a2].neg()));
          l = l.add(h2);
        }
        return l.toP();
      }, c.prototype._wnafMul = function(t4, e3) {
        var r3 = 4, n2 = t4._getNAFPoints(r3);
        r3 = n2.wnd;
        for (var i3 = n2.points, a2 = o(e3, r3, this._bitLength), c2 = this.jpoint(null, null, null), u2 = a2.length - 1; u2 >= 0; u2--) {
          for (var f = 0; u2 >= 0 && 0 === a2[u2]; u2--)
            f++;
          if (u2 >= 0 && f++, c2 = c2.dblp(f), u2 < 0)
            break;
          var l = a2[u2];
          s2(0 !== l), c2 = "affine" === t4.type ? l > 0 ? c2.mixedAdd(i3[l - 1 >> 1]) : c2.mixedAdd(i3[-l - 1 >> 1].neg()) : l > 0 ? c2.add(i3[l - 1 >> 1]) : c2.add(i3[-l - 1 >> 1].neg());
        }
        return "affine" === t4.type ? c2.toP() : c2;
      }, c.prototype._wnafMulAdd = function(t4, e3, r3, n2, i3) {
        var s3, c2, u2, f = this._wnafT1, l = this._wnafT2, h2 = this._wnafT3, p = 0;
        for (s3 = 0; s3 < n2; s3++) {
          var d2 = (u2 = e3[s3])._getNAFPoints(t4);
          f[s3] = d2.wnd, l[s3] = d2.points;
        }
        for (s3 = n2 - 1; s3 >= 1; s3 -= 2) {
          var y2 = s3 - 1, b = s3;
          if (1 === f[y2] && 1 === f[b]) {
            var m2 = [e3[y2], null, null, e3[b]];
            0 === e3[y2].y.cmp(e3[b].y) ? (m2[1] = e3[y2].add(e3[b]), m2[2] = e3[y2].toJ().mixedAdd(e3[b].neg())) : 0 === e3[y2].y.cmp(e3[b].y.redNeg()) ? (m2[1] = e3[y2].toJ().mixedAdd(e3[b]), m2[2] = e3[y2].add(e3[b].neg())) : (m2[1] = e3[y2].toJ().mixedAdd(e3[b]), m2[2] = e3[y2].toJ().mixedAdd(e3[b].neg()));
            var v = [-3, -1, -5, -7, 0, 7, 5, 1, 3], g = a(r3[y2], r3[b]);
            for (p = Math.max(g[0].length, p), h2[y2] = new Array(p), h2[b] = new Array(p), c2 = 0; c2 < p; c2++) {
              var _ = 0 | g[0][c2], w2 = 0 | g[1][c2];
              h2[y2][c2] = v[3 * (_ + 1) + (w2 + 1)], h2[b][c2] = 0, l[y2] = m2;
            }
          } else
            h2[y2] = o(r3[y2], f[y2], this._bitLength), h2[b] = o(r3[b], f[b], this._bitLength), p = Math.max(h2[y2].length, p), p = Math.max(h2[b].length, p);
        }
        var S = this.jpoint(null, null, null), O = this._wnafT4;
        for (s3 = p; s3 >= 0; s3--) {
          for (var j = 0; s3 >= 0; ) {
            var $ = true;
            for (c2 = 0; c2 < n2; c2++)
              O[c2] = 0 | h2[c2][s3], 0 !== O[c2] && ($ = false);
            if (!$)
              break;
            j++, s3--;
          }
          if (s3 >= 0 && j++, S = S.dblp(j), s3 < 0)
            break;
          for (c2 = 0; c2 < n2; c2++) {
            var A = O[c2];
            0 !== A && (A > 0 ? u2 = l[c2][A - 1 >> 1] : A < 0 && (u2 = l[c2][-A - 1 >> 1].neg()), S = "affine" === u2.type ? S.mixedAdd(u2) : S.add(u2));
          }
        }
        for (s3 = 0; s3 < n2; s3++)
          l[s3] = null;
        return i3 ? S : S.toP();
      }, c.BasePoint = u, u.prototype.eq = function() {
        throw new Error("Not implemented");
      }, u.prototype.validate = function() {
        return this.curve.validate(this);
      }, c.prototype.decodePoint = function(t4, e3) {
        t4 = i2.toArray(t4, e3);
        var r3 = this.p.byteLength();
        if ((4 === t4[0] || 6 === t4[0] || 7 === t4[0]) && t4.length - 1 == 2 * r3)
          return 6 === t4[0] ? s2(t4[t4.length - 1] % 2 == 0) : 7 === t4[0] && s2(t4[t4.length - 1] % 2 == 1), this.point(t4.slice(1, 1 + r3), t4.slice(1 + r3, 1 + 2 * r3));
        if ((2 === t4[0] || 3 === t4[0]) && t4.length - 1 === r3)
          return this.pointFromX(t4.slice(1, 1 + r3), 3 === t4[0]);
        throw new Error("Unknown point format");
      }, u.prototype.encodeCompressed = function(t4) {
        return this.encode(t4, true);
      }, u.prototype._encode = function(t4) {
        var e3 = this.curve.p.byteLength(), r3 = this.getX().toArray("be", e3);
        return t4 ? [this.getY().isEven() ? 2 : 3].concat(r3) : [4].concat(r3, this.getY().toArray("be", e3));
      }, u.prototype.encode = function(t4, e3) {
        return i2.encode(this._encode(e3), t4);
      }, u.prototype.precompute = function(t4) {
        if (this.precomputed)
          return this;
        var e3 = { doubles: null, naf: null, beta: null };
        return e3.naf = this._getNAFPoints(8), e3.doubles = this._getDoubles(4, t4), e3.beta = this._getBeta(), this.precomputed = e3, this;
      }, u.prototype._hasDoubles = function(t4) {
        if (!this.precomputed)
          return false;
        var e3 = this.precomputed.doubles;
        return !!e3 && e3.points.length >= Math.ceil((t4.bitLength() + 1) / e3.step);
      }, u.prototype._getDoubles = function(t4, e3) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        for (var r3 = [this], n2 = this, i3 = 0; i3 < e3; i3 += t4) {
          for (var o2 = 0; o2 < t4; o2++)
            n2 = n2.dbl();
          r3.push(n2);
        }
        return { step: t4, points: r3 };
      }, u.prototype._getNAFPoints = function(t4) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        for (var e3 = [this], r3 = (1 << t4) - 1, n2 = 1 === r3 ? null : this.dbl(), i3 = 1; i3 < r3; i3++)
          e3[i3] = e3[i3 - 1].add(n2);
        return { wnd: t4, points: e3 };
      }, u.prototype._getBeta = function() {
        return null;
      }, u.prototype.dblp = function(t4) {
        for (var e3 = this, r3 = 0; r3 < t4; r3++)
          e3 = e3.dbl();
        return e3;
      };
    }, 9723: (t3, e2, r2) => {
      var n = r2(1970), i2 = r2(7799), o = r2(1679), a = r2(3334), s2 = n.assert;
      function c(t4) {
        this.twisted = 1 != (0 | t4.a), this.mOneA = this.twisted && -1 == (0 | t4.a), this.extended = this.mOneA, a.call(this, "edwards", t4), this.a = new i2(t4.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new i2(t4.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new i2(t4.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), s2(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | t4.c);
      }
      function u(t4, e3, r3, n2, o2) {
        a.BasePoint.call(this, t4, "projective"), null === e3 && null === r3 && null === n2 ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new i2(e3, 16), this.y = new i2(r3, 16), this.z = n2 ? new i2(n2, 16) : this.curve.one, this.t = o2 && new i2(o2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
      }
      o(c, a), t3.exports = c, c.prototype._mulA = function(t4) {
        return this.mOneA ? t4.redNeg() : this.a.redMul(t4);
      }, c.prototype._mulC = function(t4) {
        return this.oneC ? t4 : this.c.redMul(t4);
      }, c.prototype.jpoint = function(t4, e3, r3, n2) {
        return this.point(t4, e3, r3, n2);
      }, c.prototype.pointFromX = function(t4, e3) {
        (t4 = new i2(t4, 16)).red || (t4 = t4.toRed(this.red));
        var r3 = t4.redSqr(), n2 = this.c2.redSub(this.a.redMul(r3)), o2 = this.one.redSub(this.c2.redMul(this.d).redMul(r3)), a2 = n2.redMul(o2.redInvm()), s3 = a2.redSqrt();
        if (0 !== s3.redSqr().redSub(a2).cmp(this.zero))
          throw new Error("invalid point");
        var c2 = s3.fromRed().isOdd();
        return (e3 && !c2 || !e3 && c2) && (s3 = s3.redNeg()), this.point(t4, s3);
      }, c.prototype.pointFromY = function(t4, e3) {
        (t4 = new i2(t4, 16)).red || (t4 = t4.toRed(this.red));
        var r3 = t4.redSqr(), n2 = r3.redSub(this.c2), o2 = r3.redMul(this.d).redMul(this.c2).redSub(this.a), a2 = n2.redMul(o2.redInvm());
        if (0 === a2.cmp(this.zero)) {
          if (e3)
            throw new Error("invalid point");
          return this.point(this.zero, t4);
        }
        var s3 = a2.redSqrt();
        if (0 !== s3.redSqr().redSub(a2).cmp(this.zero))
          throw new Error("invalid point");
        return s3.fromRed().isOdd() !== e3 && (s3 = s3.redNeg()), this.point(s3, t4);
      }, c.prototype.validate = function(t4) {
        if (t4.isInfinity())
          return true;
        t4.normalize();
        var e3 = t4.x.redSqr(), r3 = t4.y.redSqr(), n2 = e3.redMul(this.a).redAdd(r3), i3 = this.c2.redMul(this.one.redAdd(this.d.redMul(e3).redMul(r3)));
        return 0 === n2.cmp(i3);
      }, o(u, a.BasePoint), c.prototype.pointFromJSON = function(t4) {
        return u.fromJSON(this, t4);
      }, c.prototype.point = function(t4, e3, r3, n2) {
        return new u(this, t4, e3, r3, n2);
      }, u.fromJSON = function(t4, e3) {
        return new u(t4, e3[0], e3[1], e3[2]);
      }, u.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      }, u.prototype.isInfinity = function() {
        return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
      }, u.prototype._extDbl = function() {
        var t4 = this.x.redSqr(), e3 = this.y.redSqr(), r3 = this.z.redSqr();
        r3 = r3.redIAdd(r3);
        var n2 = this.curve._mulA(t4), i3 = this.x.redAdd(this.y).redSqr().redISub(t4).redISub(e3), o2 = n2.redAdd(e3), a2 = o2.redSub(r3), s3 = n2.redSub(e3), c2 = i3.redMul(a2), u2 = o2.redMul(s3), f = i3.redMul(s3), l = a2.redMul(o2);
        return this.curve.point(c2, u2, l, f);
      }, u.prototype._projDbl = function() {
        var t4, e3, r3, n2, i3, o2, a2 = this.x.redAdd(this.y).redSqr(), s3 = this.x.redSqr(), c2 = this.y.redSqr();
        if (this.curve.twisted) {
          var u2 = (n2 = this.curve._mulA(s3)).redAdd(c2);
          this.zOne ? (t4 = a2.redSub(s3).redSub(c2).redMul(u2.redSub(this.curve.two)), e3 = u2.redMul(n2.redSub(c2)), r3 = u2.redSqr().redSub(u2).redSub(u2)) : (i3 = this.z.redSqr(), o2 = u2.redSub(i3).redISub(i3), t4 = a2.redSub(s3).redISub(c2).redMul(o2), e3 = u2.redMul(n2.redSub(c2)), r3 = u2.redMul(o2));
        } else
          n2 = s3.redAdd(c2), i3 = this.curve._mulC(this.z).redSqr(), o2 = n2.redSub(i3).redSub(i3), t4 = this.curve._mulC(a2.redISub(n2)).redMul(o2), e3 = this.curve._mulC(n2).redMul(s3.redISub(c2)), r3 = n2.redMul(o2);
        return this.curve.point(t4, e3, r3);
      }, u.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
      }, u.prototype._extAdd = function(t4) {
        var e3 = this.y.redSub(this.x).redMul(t4.y.redSub(t4.x)), r3 = this.y.redAdd(this.x).redMul(t4.y.redAdd(t4.x)), n2 = this.t.redMul(this.curve.dd).redMul(t4.t), i3 = this.z.redMul(t4.z.redAdd(t4.z)), o2 = r3.redSub(e3), a2 = i3.redSub(n2), s3 = i3.redAdd(n2), c2 = r3.redAdd(e3), u2 = o2.redMul(a2), f = s3.redMul(c2), l = o2.redMul(c2), h2 = a2.redMul(s3);
        return this.curve.point(u2, f, h2, l);
      }, u.prototype._projAdd = function(t4) {
        var e3, r3, n2 = this.z.redMul(t4.z), i3 = n2.redSqr(), o2 = this.x.redMul(t4.x), a2 = this.y.redMul(t4.y), s3 = this.curve.d.redMul(o2).redMul(a2), c2 = i3.redSub(s3), u2 = i3.redAdd(s3), f = this.x.redAdd(this.y).redMul(t4.x.redAdd(t4.y)).redISub(o2).redISub(a2), l = n2.redMul(c2).redMul(f);
        return this.curve.twisted ? (e3 = n2.redMul(u2).redMul(a2.redSub(this.curve._mulA(o2))), r3 = c2.redMul(u2)) : (e3 = n2.redMul(u2).redMul(a2.redSub(o2)), r3 = this.curve._mulC(c2).redMul(u2)), this.curve.point(l, e3, r3);
      }, u.prototype.add = function(t4) {
        return this.isInfinity() ? t4 : t4.isInfinity() ? this : this.curve.extended ? this._extAdd(t4) : this._projAdd(t4);
      }, u.prototype.mul = function(t4) {
        return this._hasDoubles(t4) ? this.curve._fixedNafMul(this, t4) : this.curve._wnafMul(this, t4);
      }, u.prototype.mulAdd = function(t4, e3, r3) {
        return this.curve._wnafMulAdd(1, [this, e3], [t4, r3], 2, false);
      }, u.prototype.jmulAdd = function(t4, e3, r3) {
        return this.curve._wnafMulAdd(1, [this, e3], [t4, r3], 2, true);
      }, u.prototype.normalize = function() {
        if (this.zOne)
          return this;
        var t4 = this.z.redInvm();
        return this.x = this.x.redMul(t4), this.y = this.y.redMul(t4), this.t && (this.t = this.t.redMul(t4)), this.z = this.curve.one, this.zOne = true, this;
      }, u.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      }, u.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
      }, u.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
      }, u.prototype.eq = function(t4) {
        return this === t4 || 0 === this.getX().cmp(t4.getX()) && 0 === this.getY().cmp(t4.getY());
      }, u.prototype.eqXToP = function(t4) {
        var e3 = t4.toRed(this.curve.red).redMul(this.z);
        if (0 === this.x.cmp(e3))
          return true;
        for (var r3 = t4.clone(), n2 = this.curve.redN.redMul(this.z); ; ) {
          if (r3.iadd(this.curve.n), r3.cmp(this.curve.p) >= 0)
            return false;
          if (e3.redIAdd(n2), 0 === this.x.cmp(e3))
            return true;
        }
      }, u.prototype.toP = u.prototype.normalize, u.prototype.mixedAdd = u.prototype.add;
    }, 5803: (t3, e2, r2) => {
      var n = e2;
      n.base = r2(3334), n.short = r2(5045), n.mont = r2(3453), n.edwards = r2(9723);
    }, 3453: (t3, e2, r2) => {
      var n = r2(7799), i2 = r2(1679), o = r2(3334), a = r2(1970);
      function s2(t4) {
        o.call(this, "mont", t4), this.a = new n(t4.a, 16).toRed(this.red), this.b = new n(t4.b, 16).toRed(this.red), this.i4 = new n(4).toRed(this.red).redInvm(), this.two = new n(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      function c(t4, e3, r3) {
        o.BasePoint.call(this, t4, "projective"), null === e3 && null === r3 ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new n(e3, 16), this.z = new n(r3, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
      }
      i2(s2, o), t3.exports = s2, s2.prototype.validate = function(t4) {
        var e3 = t4.normalize().x, r3 = e3.redSqr(), n2 = r3.redMul(e3).redAdd(r3.redMul(this.a)).redAdd(e3);
        return 0 === n2.redSqrt().redSqr().cmp(n2);
      }, i2(c, o.BasePoint), s2.prototype.decodePoint = function(t4, e3) {
        return this.point(a.toArray(t4, e3), 1);
      }, s2.prototype.point = function(t4, e3) {
        return new c(this, t4, e3);
      }, s2.prototype.pointFromJSON = function(t4) {
        return c.fromJSON(this, t4);
      }, c.prototype.precompute = function() {
      }, c.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      }, c.fromJSON = function(t4, e3) {
        return new c(t4, e3[0], e3[1] || t4.one);
      }, c.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      }, c.prototype.isInfinity = function() {
        return 0 === this.z.cmpn(0);
      }, c.prototype.dbl = function() {
        var t4 = this.x.redAdd(this.z).redSqr(), e3 = this.x.redSub(this.z).redSqr(), r3 = t4.redSub(e3), n2 = t4.redMul(e3), i3 = r3.redMul(e3.redAdd(this.curve.a24.redMul(r3)));
        return this.curve.point(n2, i3);
      }, c.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
      }, c.prototype.diffAdd = function(t4, e3) {
        var r3 = this.x.redAdd(this.z), n2 = this.x.redSub(this.z), i3 = t4.x.redAdd(t4.z), o2 = t4.x.redSub(t4.z).redMul(r3), a2 = i3.redMul(n2), s3 = e3.z.redMul(o2.redAdd(a2).redSqr()), c2 = e3.x.redMul(o2.redISub(a2).redSqr());
        return this.curve.point(s3, c2);
      }, c.prototype.mul = function(t4) {
        for (var e3 = t4.clone(), r3 = this, n2 = this.curve.point(null, null), i3 = []; 0 !== e3.cmpn(0); e3.iushrn(1))
          i3.push(e3.andln(1));
        for (var o2 = i3.length - 1; o2 >= 0; o2--)
          0 === i3[o2] ? (r3 = r3.diffAdd(n2, this), n2 = n2.dbl()) : (n2 = r3.diffAdd(n2, this), r3 = r3.dbl());
        return n2;
      }, c.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
      }, c.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
      }, c.prototype.eq = function(t4) {
        return 0 === this.getX().cmp(t4.getX());
      }, c.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
      }, c.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
      };
    }, 5045: (t3, e2, r2) => {
      var n = r2(1970), i2 = r2(7799), o = r2(1679), a = r2(3334), s2 = n.assert;
      function c(t4) {
        a.call(this, "short", t4), this.a = new i2(t4.a, 16).toRed(this.red), this.b = new i2(t4.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(t4), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
      }
      function u(t4, e3, r3, n2) {
        a.BasePoint.call(this, t4, "affine"), null === e3 && null === r3 ? (this.x = null, this.y = null, this.inf = true) : (this.x = new i2(e3, 16), this.y = new i2(r3, 16), n2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
      }
      function f(t4, e3, r3, n2) {
        a.BasePoint.call(this, t4, "jacobian"), null === e3 && null === r3 && null === n2 ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new i2(0)) : (this.x = new i2(e3, 16), this.y = new i2(r3, 16), this.z = new i2(n2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
      }
      o(c, a), t3.exports = c, c.prototype._getEndomorphism = function(t4) {
        if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
          var e3, r3;
          if (t4.beta)
            e3 = new i2(t4.beta, 16).toRed(this.red);
          else {
            var n2 = this._getEndoRoots(this.p);
            e3 = (e3 = n2[0].cmp(n2[1]) < 0 ? n2[0] : n2[1]).toRed(this.red);
          }
          if (t4.lambda)
            r3 = new i2(t4.lambda, 16);
          else {
            var o2 = this._getEndoRoots(this.n);
            0 === this.g.mul(o2[0]).x.cmp(this.g.x.redMul(e3)) ? r3 = o2[0] : (r3 = o2[1], s2(0 === this.g.mul(r3).x.cmp(this.g.x.redMul(e3))));
          }
          return { beta: e3, lambda: r3, basis: t4.basis ? t4.basis.map(function(t5) {
            return { a: new i2(t5.a, 16), b: new i2(t5.b, 16) };
          }) : this._getEndoBasis(r3) };
        }
      }, c.prototype._getEndoRoots = function(t4) {
        var e3 = t4 === this.p ? this.red : i2.mont(t4), r3 = new i2(2).toRed(e3).redInvm(), n2 = r3.redNeg(), o2 = new i2(3).toRed(e3).redNeg().redSqrt().redMul(r3);
        return [n2.redAdd(o2).fromRed(), n2.redSub(o2).fromRed()];
      }, c.prototype._getEndoBasis = function(t4) {
        for (var e3, r3, n2, o2, a2, s3, c2, u2, f2, l = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), h2 = t4, p = this.n.clone(), d2 = new i2(1), y2 = new i2(0), b = new i2(0), m2 = new i2(1), v = 0; 0 !== h2.cmpn(0); ) {
          var g = p.div(h2);
          u2 = p.sub(g.mul(h2)), f2 = b.sub(g.mul(d2));
          var _ = m2.sub(g.mul(y2));
          if (!n2 && u2.cmp(l) < 0)
            e3 = c2.neg(), r3 = d2, n2 = u2.neg(), o2 = f2;
          else if (n2 && 2 == ++v)
            break;
          c2 = u2, p = h2, h2 = u2, b = d2, d2 = f2, m2 = y2, y2 = _;
        }
        a2 = u2.neg(), s3 = f2;
        var w2 = n2.sqr().add(o2.sqr());
        return a2.sqr().add(s3.sqr()).cmp(w2) >= 0 && (a2 = e3, s3 = r3), n2.negative && (n2 = n2.neg(), o2 = o2.neg()), a2.negative && (a2 = a2.neg(), s3 = s3.neg()), [{ a: n2, b: o2 }, { a: a2, b: s3 }];
      }, c.prototype._endoSplit = function(t4) {
        var e3 = this.endo.basis, r3 = e3[0], n2 = e3[1], i3 = n2.b.mul(t4).divRound(this.n), o2 = r3.b.neg().mul(t4).divRound(this.n), a2 = i3.mul(r3.a), s3 = o2.mul(n2.a), c2 = i3.mul(r3.b), u2 = o2.mul(n2.b);
        return { k1: t4.sub(a2).sub(s3), k2: c2.add(u2).neg() };
      }, c.prototype.pointFromX = function(t4, e3) {
        (t4 = new i2(t4, 16)).red || (t4 = t4.toRed(this.red));
        var r3 = t4.redSqr().redMul(t4).redIAdd(t4.redMul(this.a)).redIAdd(this.b), n2 = r3.redSqrt();
        if (0 !== n2.redSqr().redSub(r3).cmp(this.zero))
          throw new Error("invalid point");
        var o2 = n2.fromRed().isOdd();
        return (e3 && !o2 || !e3 && o2) && (n2 = n2.redNeg()), this.point(t4, n2);
      }, c.prototype.validate = function(t4) {
        if (t4.inf)
          return true;
        var e3 = t4.x, r3 = t4.y, n2 = this.a.redMul(e3), i3 = e3.redSqr().redMul(e3).redIAdd(n2).redIAdd(this.b);
        return 0 === r3.redSqr().redISub(i3).cmpn(0);
      }, c.prototype._endoWnafMulAdd = function(t4, e3, r3) {
        for (var n2 = this._endoWnafT1, i3 = this._endoWnafT2, o2 = 0; o2 < t4.length; o2++) {
          var a2 = this._endoSplit(e3[o2]), s3 = t4[o2], c2 = s3._getBeta();
          a2.k1.negative && (a2.k1.ineg(), s3 = s3.neg(true)), a2.k2.negative && (a2.k2.ineg(), c2 = c2.neg(true)), n2[2 * o2] = s3, n2[2 * o2 + 1] = c2, i3[2 * o2] = a2.k1, i3[2 * o2 + 1] = a2.k2;
        }
        for (var u2 = this._wnafMulAdd(1, n2, i3, 2 * o2, r3), f2 = 0; f2 < 2 * o2; f2++)
          n2[f2] = null, i3[f2] = null;
        return u2;
      }, o(u, a.BasePoint), c.prototype.point = function(t4, e3, r3) {
        return new u(this, t4, e3, r3);
      }, c.prototype.pointFromJSON = function(t4, e3) {
        return u.fromJSON(this, t4, e3);
      }, u.prototype._getBeta = function() {
        if (this.curve.endo) {
          var t4 = this.precomputed;
          if (t4 && t4.beta)
            return t4.beta;
          var e3 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
          if (t4) {
            var r3 = this.curve, n2 = function(t5) {
              return r3.point(t5.x.redMul(r3.endo.beta), t5.y);
            };
            t4.beta = e3, e3.precomputed = { beta: null, naf: t4.naf && { wnd: t4.naf.wnd, points: t4.naf.points.map(n2) }, doubles: t4.doubles && { step: t4.doubles.step, points: t4.doubles.points.map(n2) } };
          }
          return e3;
        }
      }, u.prototype.toJSON = function() {
        return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
      }, u.fromJSON = function(t4, e3, r3) {
        "string" == typeof e3 && (e3 = JSON.parse(e3));
        var n2 = t4.point(e3[0], e3[1], r3);
        if (!e3[2])
          return n2;
        function i3(e4) {
          return t4.point(e4[0], e4[1], r3);
        }
        var o2 = e3[2];
        return n2.precomputed = { beta: null, doubles: o2.doubles && { step: o2.doubles.step, points: [n2].concat(o2.doubles.points.map(i3)) }, naf: o2.naf && { wnd: o2.naf.wnd, points: [n2].concat(o2.naf.points.map(i3)) } }, n2;
      }, u.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      }, u.prototype.isInfinity = function() {
        return this.inf;
      }, u.prototype.add = function(t4) {
        if (this.inf)
          return t4;
        if (t4.inf)
          return this;
        if (this.eq(t4))
          return this.dbl();
        if (this.neg().eq(t4))
          return this.curve.point(null, null);
        if (0 === this.x.cmp(t4.x))
          return this.curve.point(null, null);
        var e3 = this.y.redSub(t4.y);
        0 !== e3.cmpn(0) && (e3 = e3.redMul(this.x.redSub(t4.x).redInvm()));
        var r3 = e3.redSqr().redISub(this.x).redISub(t4.x), n2 = e3.redMul(this.x.redSub(r3)).redISub(this.y);
        return this.curve.point(r3, n2);
      }, u.prototype.dbl = function() {
        if (this.inf)
          return this;
        var t4 = this.y.redAdd(this.y);
        if (0 === t4.cmpn(0))
          return this.curve.point(null, null);
        var e3 = this.curve.a, r3 = this.x.redSqr(), n2 = t4.redInvm(), i3 = r3.redAdd(r3).redIAdd(r3).redIAdd(e3).redMul(n2), o2 = i3.redSqr().redISub(this.x.redAdd(this.x)), a2 = i3.redMul(this.x.redSub(o2)).redISub(this.y);
        return this.curve.point(o2, a2);
      }, u.prototype.getX = function() {
        return this.x.fromRed();
      }, u.prototype.getY = function() {
        return this.y.fromRed();
      }, u.prototype.mul = function(t4) {
        return t4 = new i2(t4, 16), this.isInfinity() ? this : this._hasDoubles(t4) ? this.curve._fixedNafMul(this, t4) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t4]) : this.curve._wnafMul(this, t4);
      }, u.prototype.mulAdd = function(t4, e3, r3) {
        var n2 = [this, e3], i3 = [t4, r3];
        return this.curve.endo ? this.curve._endoWnafMulAdd(n2, i3) : this.curve._wnafMulAdd(1, n2, i3, 2);
      }, u.prototype.jmulAdd = function(t4, e3, r3) {
        var n2 = [this, e3], i3 = [t4, r3];
        return this.curve.endo ? this.curve._endoWnafMulAdd(n2, i3, true) : this.curve._wnafMulAdd(1, n2, i3, 2, true);
      }, u.prototype.eq = function(t4) {
        return this === t4 || this.inf === t4.inf && (this.inf || 0 === this.x.cmp(t4.x) && 0 === this.y.cmp(t4.y));
      }, u.prototype.neg = function(t4) {
        if (this.inf)
          return this;
        var e3 = this.curve.point(this.x, this.y.redNeg());
        if (t4 && this.precomputed) {
          var r3 = this.precomputed, n2 = function(t5) {
            return t5.neg();
          };
          e3.precomputed = { naf: r3.naf && { wnd: r3.naf.wnd, points: r3.naf.points.map(n2) }, doubles: r3.doubles && { step: r3.doubles.step, points: r3.doubles.points.map(n2) } };
        }
        return e3;
      }, u.prototype.toJ = function() {
        return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
      }, o(f, a.BasePoint), c.prototype.jpoint = function(t4, e3, r3) {
        return new f(this, t4, e3, r3);
      }, f.prototype.toP = function() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var t4 = this.z.redInvm(), e3 = t4.redSqr(), r3 = this.x.redMul(e3), n2 = this.y.redMul(e3).redMul(t4);
        return this.curve.point(r3, n2);
      }, f.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      }, f.prototype.add = function(t4) {
        if (this.isInfinity())
          return t4;
        if (t4.isInfinity())
          return this;
        var e3 = t4.z.redSqr(), r3 = this.z.redSqr(), n2 = this.x.redMul(e3), i3 = t4.x.redMul(r3), o2 = this.y.redMul(e3.redMul(t4.z)), a2 = t4.y.redMul(r3.redMul(this.z)), s3 = n2.redSub(i3), c2 = o2.redSub(a2);
        if (0 === s3.cmpn(0))
          return 0 !== c2.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
        var u2 = s3.redSqr(), f2 = u2.redMul(s3), l = n2.redMul(u2), h2 = c2.redSqr().redIAdd(f2).redISub(l).redISub(l), p = c2.redMul(l.redISub(h2)).redISub(o2.redMul(f2)), d2 = this.z.redMul(t4.z).redMul(s3);
        return this.curve.jpoint(h2, p, d2);
      }, f.prototype.mixedAdd = function(t4) {
        if (this.isInfinity())
          return t4.toJ();
        if (t4.isInfinity())
          return this;
        var e3 = this.z.redSqr(), r3 = this.x, n2 = t4.x.redMul(e3), i3 = this.y, o2 = t4.y.redMul(e3).redMul(this.z), a2 = r3.redSub(n2), s3 = i3.redSub(o2);
        if (0 === a2.cmpn(0))
          return 0 !== s3.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
        var c2 = a2.redSqr(), u2 = c2.redMul(a2), f2 = r3.redMul(c2), l = s3.redSqr().redIAdd(u2).redISub(f2).redISub(f2), h2 = s3.redMul(f2.redISub(l)).redISub(i3.redMul(u2)), p = this.z.redMul(a2);
        return this.curve.jpoint(l, h2, p);
      }, f.prototype.dblp = function(t4) {
        if (0 === t4)
          return this;
        if (this.isInfinity())
          return this;
        if (!t4)
          return this.dbl();
        var e3;
        if (this.curve.zeroA || this.curve.threeA) {
          var r3 = this;
          for (e3 = 0; e3 < t4; e3++)
            r3 = r3.dbl();
          return r3;
        }
        var n2 = this.curve.a, i3 = this.curve.tinv, o2 = this.x, a2 = this.y, s3 = this.z, c2 = s3.redSqr().redSqr(), u2 = a2.redAdd(a2);
        for (e3 = 0; e3 < t4; e3++) {
          var f2 = o2.redSqr(), l = u2.redSqr(), h2 = l.redSqr(), p = f2.redAdd(f2).redIAdd(f2).redIAdd(n2.redMul(c2)), d2 = o2.redMul(l), y2 = p.redSqr().redISub(d2.redAdd(d2)), b = d2.redISub(y2), m2 = p.redMul(b);
          m2 = m2.redIAdd(m2).redISub(h2);
          var v = u2.redMul(s3);
          e3 + 1 < t4 && (c2 = c2.redMul(h2)), o2 = y2, s3 = v, u2 = m2;
        }
        return this.curve.jpoint(o2, u2.redMul(i3), s3);
      }, f.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
      }, f.prototype._zeroDbl = function() {
        var t4, e3, r3;
        if (this.zOne) {
          var n2 = this.x.redSqr(), i3 = this.y.redSqr(), o2 = i3.redSqr(), a2 = this.x.redAdd(i3).redSqr().redISub(n2).redISub(o2);
          a2 = a2.redIAdd(a2);
          var s3 = n2.redAdd(n2).redIAdd(n2), c2 = s3.redSqr().redISub(a2).redISub(a2), u2 = o2.redIAdd(o2);
          u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2), t4 = c2, e3 = s3.redMul(a2.redISub(c2)).redISub(u2), r3 = this.y.redAdd(this.y);
        } else {
          var f2 = this.x.redSqr(), l = this.y.redSqr(), h2 = l.redSqr(), p = this.x.redAdd(l).redSqr().redISub(f2).redISub(h2);
          p = p.redIAdd(p);
          var d2 = f2.redAdd(f2).redIAdd(f2), y2 = d2.redSqr(), b = h2.redIAdd(h2);
          b = (b = b.redIAdd(b)).redIAdd(b), t4 = y2.redISub(p).redISub(p), e3 = d2.redMul(p.redISub(t4)).redISub(b), r3 = (r3 = this.y.redMul(this.z)).redIAdd(r3);
        }
        return this.curve.jpoint(t4, e3, r3);
      }, f.prototype._threeDbl = function() {
        var t4, e3, r3;
        if (this.zOne) {
          var n2 = this.x.redSqr(), i3 = this.y.redSqr(), o2 = i3.redSqr(), a2 = this.x.redAdd(i3).redSqr().redISub(n2).redISub(o2);
          a2 = a2.redIAdd(a2);
          var s3 = n2.redAdd(n2).redIAdd(n2).redIAdd(this.curve.a), c2 = s3.redSqr().redISub(a2).redISub(a2);
          t4 = c2;
          var u2 = o2.redIAdd(o2);
          u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2), e3 = s3.redMul(a2.redISub(c2)).redISub(u2), r3 = this.y.redAdd(this.y);
        } else {
          var f2 = this.z.redSqr(), l = this.y.redSqr(), h2 = this.x.redMul(l), p = this.x.redSub(f2).redMul(this.x.redAdd(f2));
          p = p.redAdd(p).redIAdd(p);
          var d2 = h2.redIAdd(h2), y2 = (d2 = d2.redIAdd(d2)).redAdd(d2);
          t4 = p.redSqr().redISub(y2), r3 = this.y.redAdd(this.z).redSqr().redISub(l).redISub(f2);
          var b = l.redSqr();
          b = (b = (b = b.redIAdd(b)).redIAdd(b)).redIAdd(b), e3 = p.redMul(d2.redISub(t4)).redISub(b);
        }
        return this.curve.jpoint(t4, e3, r3);
      }, f.prototype._dbl = function() {
        var t4 = this.curve.a, e3 = this.x, r3 = this.y, n2 = this.z, i3 = n2.redSqr().redSqr(), o2 = e3.redSqr(), a2 = r3.redSqr(), s3 = o2.redAdd(o2).redIAdd(o2).redIAdd(t4.redMul(i3)), c2 = e3.redAdd(e3), u2 = (c2 = c2.redIAdd(c2)).redMul(a2), f2 = s3.redSqr().redISub(u2.redAdd(u2)), l = u2.redISub(f2), h2 = a2.redSqr();
        h2 = (h2 = (h2 = h2.redIAdd(h2)).redIAdd(h2)).redIAdd(h2);
        var p = s3.redMul(l).redISub(h2), d2 = r3.redAdd(r3).redMul(n2);
        return this.curve.jpoint(f2, p, d2);
      }, f.prototype.trpl = function() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var t4 = this.x.redSqr(), e3 = this.y.redSqr(), r3 = this.z.redSqr(), n2 = e3.redSqr(), i3 = t4.redAdd(t4).redIAdd(t4), o2 = i3.redSqr(), a2 = this.x.redAdd(e3).redSqr().redISub(t4).redISub(n2), s3 = (a2 = (a2 = (a2 = a2.redIAdd(a2)).redAdd(a2).redIAdd(a2)).redISub(o2)).redSqr(), c2 = n2.redIAdd(n2);
        c2 = (c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2)).redIAdd(c2);
        var u2 = i3.redIAdd(a2).redSqr().redISub(o2).redISub(s3).redISub(c2), f2 = e3.redMul(u2);
        f2 = (f2 = f2.redIAdd(f2)).redIAdd(f2);
        var l = this.x.redMul(s3).redISub(f2);
        l = (l = l.redIAdd(l)).redIAdd(l);
        var h2 = this.y.redMul(u2.redMul(c2.redISub(u2)).redISub(a2.redMul(s3)));
        h2 = (h2 = (h2 = h2.redIAdd(h2)).redIAdd(h2)).redIAdd(h2);
        var p = this.z.redAdd(a2).redSqr().redISub(r3).redISub(s3);
        return this.curve.jpoint(l, h2, p);
      }, f.prototype.mul = function(t4, e3) {
        return t4 = new i2(t4, e3), this.curve._wnafMul(this, t4);
      }, f.prototype.eq = function(t4) {
        if ("affine" === t4.type)
          return this.eq(t4.toJ());
        if (this === t4)
          return true;
        var e3 = this.z.redSqr(), r3 = t4.z.redSqr();
        if (0 !== this.x.redMul(r3).redISub(t4.x.redMul(e3)).cmpn(0))
          return false;
        var n2 = e3.redMul(this.z), i3 = r3.redMul(t4.z);
        return 0 === this.y.redMul(i3).redISub(t4.y.redMul(n2)).cmpn(0);
      }, f.prototype.eqXToP = function(t4) {
        var e3 = this.z.redSqr(), r3 = t4.toRed(this.curve.red).redMul(e3);
        if (0 === this.x.cmp(r3))
          return true;
        for (var n2 = t4.clone(), i3 = this.curve.redN.redMul(e3); ; ) {
          if (n2.iadd(this.curve.n), n2.cmp(this.curve.p) >= 0)
            return false;
          if (r3.redIAdd(i3), 0 === this.x.cmp(r3))
            return true;
        }
      }, f.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      }, f.prototype.isInfinity = function() {
        return 0 === this.z.cmpn(0);
      };
    }, 6379: (t3, e2, r2) => {
      var n, i2 = e2, o = r2(2859), a = r2(5803), s2 = r2(1970).assert;
      function c(t4) {
        "short" === t4.type ? this.curve = new a.short(t4) : "edwards" === t4.type ? this.curve = new a.edwards(t4) : this.curve = new a.mont(t4), this.g = this.curve.g, this.n = this.curve.n, this.hash = t4.hash, s2(this.g.validate(), "Invalid curve"), s2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      function u(t4, e3) {
        Object.defineProperty(i2, t4, { configurable: true, enumerable: true, get: function() {
          var r3 = new c(e3);
          return Object.defineProperty(i2, t4, { configurable: true, enumerable: true, value: r3 }), r3;
        } });
      }
      i2.PresetCurve = c, u("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: o.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), u("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: o.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), u("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: o.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), u("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: o.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), u("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: o.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), u("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: o.sha256, gRed: false, g: ["9"] }), u("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: o.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
      try {
        n = r2(5586);
      } catch (t4) {
        n = void 0;
      }
      u("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: o.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n] });
    }, 7416: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(7799), o = r2(6934), a = r2(1970), s2 = r2(6379), c = r2(8904), u = a.assert, f = r2(3643), l = r2(3686);
      function h2(t4) {
        if (!(this instanceof h2))
          return new h2(t4);
        "string" == typeof t4 && (u(Object.prototype.hasOwnProperty.call(s2, t4), "Unknown curve " + t4), t4 = s2[t4]), t4 instanceof s2.PresetCurve && (t4 = { curve: t4 }), this.curve = t4.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t4.curve.g, this.g.precompute(t4.curve.n.bitLength() + 1), this.hash = t4.hash || t4.curve.hash;
      }
      t3.exports = h2, h2.prototype.keyPair = function(t4) {
        return new f(this, t4);
      }, h2.prototype.keyFromPrivate = function(t4, e3) {
        return f.fromPrivate(this, t4, e3);
      }, h2.prototype.keyFromPublic = function(t4, e3) {
        return f.fromPublic(this, t4, e3);
      }, h2.prototype.genKeyPair = function(t4) {
        t4 || (t4 = {});
        for (var e3 = new o({ hash: this.hash, pers: t4.pers, persEnc: t4.persEnc || "utf8", entropy: t4.entropy || c(this.hash.hmacStrength), entropyEnc: t4.entropy && t4.entropyEnc || "utf8", nonce: this.n.toArray() }), r3 = this.n.byteLength(), n2 = this.n.sub(new i2(2)); ; ) {
          var a2 = new i2(e3.generate(r3));
          if (!(a2.cmp(n2) > 0))
            return a2.iaddn(1), this.keyFromPrivate(a2);
        }
      }, h2.prototype._truncateToN = function(t4, e3) {
        var r3 = 8 * t4.byteLength() - this.n.bitLength();
        return r3 > 0 && (t4 = t4.ushrn(r3)), !e3 && t4.cmp(this.n) >= 0 ? t4.sub(this.n) : t4;
      }, h2.prototype.sign = function(t4, e3, r3, a2) {
        "object" === n(r3) && (a2 = r3, r3 = null), a2 || (a2 = {}), e3 = this.keyFromPrivate(e3, r3), t4 = this._truncateToN(new i2(t4, 16));
        for (var s3 = this.n.byteLength(), c2 = e3.getPrivate().toArray("be", s3), u2 = t4.toArray("be", s3), f2 = new o({ hash: this.hash, entropy: c2, nonce: u2, pers: a2.pers, persEnc: a2.persEnc || "utf8" }), h3 = this.n.sub(new i2(1)), p = 0; ; p++) {
          var d2 = a2.k ? a2.k(p) : new i2(f2.generate(this.n.byteLength()));
          if (!((d2 = this._truncateToN(d2, true)).cmpn(1) <= 0 || d2.cmp(h3) >= 0)) {
            var y2 = this.g.mul(d2);
            if (!y2.isInfinity()) {
              var b = y2.getX(), m2 = b.umod(this.n);
              if (0 !== m2.cmpn(0)) {
                var v = d2.invm(this.n).mul(m2.mul(e3.getPrivate()).iadd(t4));
                if (0 !== (v = v.umod(this.n)).cmpn(0)) {
                  var g = (y2.getY().isOdd() ? 1 : 0) | (0 !== b.cmp(m2) ? 2 : 0);
                  return a2.canonical && v.cmp(this.nh) > 0 && (v = this.n.sub(v), g ^= 1), new l({ r: m2, s: v, recoveryParam: g });
                }
              }
            }
          }
        }
      }, h2.prototype.verify = function(t4, e3, r3, n2) {
        t4 = this._truncateToN(new i2(t4, 16)), r3 = this.keyFromPublic(r3, n2);
        var o2 = (e3 = new l(e3, "hex")).r, a2 = e3.s;
        if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0)
          return false;
        if (a2.cmpn(1) < 0 || a2.cmp(this.n) >= 0)
          return false;
        var s3, c2 = a2.invm(this.n), u2 = c2.mul(t4).umod(this.n), f2 = c2.mul(o2).umod(this.n);
        return this.curve._maxwellTrick ? !(s3 = this.g.jmulAdd(u2, r3.getPublic(), f2)).isInfinity() && s3.eqXToP(o2) : !(s3 = this.g.mulAdd(u2, r3.getPublic(), f2)).isInfinity() && 0 === s3.getX().umod(this.n).cmp(o2);
      }, h2.prototype.recoverPubKey = function(t4, e3, r3, n2) {
        u((3 & r3) === r3, "The recovery param is more than two bits"), e3 = new l(e3, n2);
        var o2 = this.n, a2 = new i2(t4), s3 = e3.r, c2 = e3.s, f2 = 1 & r3, h3 = r3 >> 1;
        if (s3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && h3)
          throw new Error("Unable to find sencond key candinate");
        s3 = h3 ? this.curve.pointFromX(s3.add(this.curve.n), f2) : this.curve.pointFromX(s3, f2);
        var p = e3.r.invm(o2), d2 = o2.sub(a2).mul(p).umod(o2), y2 = c2.mul(p).umod(o2);
        return this.g.mulAdd(d2, s3, y2);
      }, h2.prototype.getKeyRecoveryParam = function(t4, e3, r3, n2) {
        if (null !== (e3 = new l(e3, n2)).recoveryParam)
          return e3.recoveryParam;
        for (var i3 = 0; i3 < 4; i3++) {
          var o2;
          try {
            o2 = this.recoverPubKey(t4, e3, i3);
          } catch (t5) {
            continue;
          }
          if (o2.eq(r3))
            return i3;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }, 3643: (t3, e2, r2) => {
      var n = r2(7799), i2 = r2(1970).assert;
      function o(t4, e3) {
        this.ec = t4, this.priv = null, this.pub = null, e3.priv && this._importPrivate(e3.priv, e3.privEnc), e3.pub && this._importPublic(e3.pub, e3.pubEnc);
      }
      t3.exports = o, o.fromPublic = function(t4, e3, r3) {
        return e3 instanceof o ? e3 : new o(t4, { pub: e3, pubEnc: r3 });
      }, o.fromPrivate = function(t4, e3, r3) {
        return e3 instanceof o ? e3 : new o(t4, { priv: e3, privEnc: r3 });
      }, o.prototype.validate = function() {
        var t4 = this.getPublic();
        return t4.isInfinity() ? { result: false, reason: "Invalid public key" } : t4.validate() ? t4.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
      }, o.prototype.getPublic = function(t4, e3) {
        return "string" == typeof t4 && (e3 = t4, t4 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e3 ? this.pub.encode(e3, t4) : this.pub;
      }, o.prototype.getPrivate = function(t4) {
        return "hex" === t4 ? this.priv.toString(16, 2) : this.priv;
      }, o.prototype._importPrivate = function(t4, e3) {
        this.priv = new n(t4, e3 || 16), this.priv = this.priv.umod(this.ec.curve.n);
      }, o.prototype._importPublic = function(t4, e3) {
        if (t4.x || t4.y)
          return "mont" === this.ec.curve.type ? i2(t4.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || i2(t4.x && t4.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(t4.x, t4.y));
        this.pub = this.ec.curve.decodePoint(t4, e3);
      }, o.prototype.derive = function(t4) {
        return t4.validate() || i2(t4.validate(), "public point not validated"), t4.mul(this.priv).getX();
      }, o.prototype.sign = function(t4, e3, r3) {
        return this.ec.sign(t4, this, e3, r3);
      }, o.prototype.verify = function(t4, e3) {
        return this.ec.verify(t4, e3, this);
      }, o.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }, 3686: (t3, e2, r2) => {
      var n = r2(7799), i2 = r2(1970), o = i2.assert;
      function a(t4, e3) {
        if (t4 instanceof a)
          return t4;
        this._importDER(t4, e3) || (o(t4.r && t4.s, "Signature without r or s"), this.r = new n(t4.r, 16), this.s = new n(t4.s, 16), void 0 === t4.recoveryParam ? this.recoveryParam = null : this.recoveryParam = t4.recoveryParam);
      }
      function s2() {
        this.place = 0;
      }
      function c(t4, e3) {
        var r3 = t4[e3.place++];
        if (!(128 & r3))
          return r3;
        var n2 = 15 & r3;
        if (0 === n2 || n2 > 4)
          return false;
        for (var i3 = 0, o2 = 0, a2 = e3.place; o2 < n2; o2++, a2++)
          i3 <<= 8, i3 |= t4[a2], i3 >>>= 0;
        return !(i3 <= 127) && (e3.place = a2, i3);
      }
      function u(t4) {
        for (var e3 = 0, r3 = t4.length - 1; !t4[e3] && !(128 & t4[e3 + 1]) && e3 < r3; )
          e3++;
        return 0 === e3 ? t4 : t4.slice(e3);
      }
      function f(t4, e3) {
        if (e3 < 128)
          t4.push(e3);
        else {
          var r3 = 1 + (Math.log(e3) / Math.LN2 >>> 3);
          for (t4.push(128 | r3); --r3; )
            t4.push(e3 >>> (r3 << 3) & 255);
          t4.push(e3);
        }
      }
      t3.exports = a, a.prototype._importDER = function(t4, e3) {
        t4 = i2.toArray(t4, e3);
        var r3 = new s2();
        if (48 !== t4[r3.place++])
          return false;
        var o2 = c(t4, r3);
        if (false === o2)
          return false;
        if (o2 + r3.place !== t4.length)
          return false;
        if (2 !== t4[r3.place++])
          return false;
        var a2 = c(t4, r3);
        if (false === a2)
          return false;
        var u2 = t4.slice(r3.place, a2 + r3.place);
        if (r3.place += a2, 2 !== t4[r3.place++])
          return false;
        var f2 = c(t4, r3);
        if (false === f2)
          return false;
        if (t4.length !== f2 + r3.place)
          return false;
        var l = t4.slice(r3.place, f2 + r3.place);
        if (0 === u2[0]) {
          if (!(128 & u2[1]))
            return false;
          u2 = u2.slice(1);
        }
        if (0 === l[0]) {
          if (!(128 & l[1]))
            return false;
          l = l.slice(1);
        }
        return this.r = new n(u2), this.s = new n(l), this.recoveryParam = null, true;
      }, a.prototype.toDER = function(t4) {
        var e3 = this.r.toArray(), r3 = this.s.toArray();
        for (128 & e3[0] && (e3 = [0].concat(e3)), 128 & r3[0] && (r3 = [0].concat(r3)), e3 = u(e3), r3 = u(r3); !(r3[0] || 128 & r3[1]); )
          r3 = r3.slice(1);
        var n2 = [2];
        f(n2, e3.length), (n2 = n2.concat(e3)).push(2), f(n2, r3.length);
        var o2 = n2.concat(r3), a2 = [48];
        return f(a2, o2.length), a2 = a2.concat(o2), i2.encode(a2, t4);
      };
    }, 4919: (t3, e2, r2) => {
      var n = r2(2859), i2 = r2(6379), o = r2(1970), a = o.assert, s2 = o.parseBytes, c = r2(208), u = r2(8433);
      function f(t4) {
        if (a("ed25519" === t4, "only tested with ed25519 so far"), !(this instanceof f))
          return new f(t4);
        t4 = i2[t4].curve, this.curve = t4, this.g = t4.g, this.g.precompute(t4.n.bitLength() + 1), this.pointClass = t4.point().constructor, this.encodingLength = Math.ceil(t4.n.bitLength() / 8), this.hash = n.sha512;
      }
      t3.exports = f, f.prototype.sign = function(t4, e3) {
        t4 = s2(t4);
        var r3 = this.keyFromSecret(e3), n2 = this.hashInt(r3.messagePrefix(), t4), i3 = this.g.mul(n2), o2 = this.encodePoint(i3), a2 = this.hashInt(o2, r3.pubBytes(), t4).mul(r3.priv()), c2 = n2.add(a2).umod(this.curve.n);
        return this.makeSignature({ R: i3, S: c2, Rencoded: o2 });
      }, f.prototype.verify = function(t4, e3, r3) {
        t4 = s2(t4), e3 = this.makeSignature(e3);
        var n2 = this.keyFromPublic(r3), i3 = this.hashInt(e3.Rencoded(), n2.pubBytes(), t4), o2 = this.g.mul(e3.S());
        return e3.R().add(n2.pub().mul(i3)).eq(o2);
      }, f.prototype.hashInt = function() {
        for (var t4 = this.hash(), e3 = 0; e3 < arguments.length; e3++)
          t4.update(arguments[e3]);
        return o.intFromLE(t4.digest()).umod(this.curve.n);
      }, f.prototype.keyFromPublic = function(t4) {
        return c.fromPublic(this, t4);
      }, f.prototype.keyFromSecret = function(t4) {
        return c.fromSecret(this, t4);
      }, f.prototype.makeSignature = function(t4) {
        return t4 instanceof u ? t4 : new u(this, t4);
      }, f.prototype.encodePoint = function(t4) {
        var e3 = t4.getY().toArray("le", this.encodingLength);
        return e3[this.encodingLength - 1] |= t4.getX().isOdd() ? 128 : 0, e3;
      }, f.prototype.decodePoint = function(t4) {
        var e3 = (t4 = o.parseBytes(t4)).length - 1, r3 = t4.slice(0, e3).concat(-129 & t4[e3]), n2 = !!(128 & t4[e3]), i3 = o.intFromLE(r3);
        return this.curve.pointFromY(i3, n2);
      }, f.prototype.encodeInt = function(t4) {
        return t4.toArray("le", this.encodingLength);
      }, f.prototype.decodeInt = function(t4) {
        return o.intFromLE(t4);
      }, f.prototype.isPoint = function(t4) {
        return t4 instanceof this.pointClass;
      };
    }, 208: (t3, e2, r2) => {
      var n = r2(1970), i2 = n.assert, o = n.parseBytes, a = n.cachedProperty;
      function s2(t4, e3) {
        this.eddsa = t4, this._secret = o(e3.secret), t4.isPoint(e3.pub) ? this._pub = e3.pub : this._pubBytes = o(e3.pub);
      }
      s2.fromPublic = function(t4, e3) {
        return e3 instanceof s2 ? e3 : new s2(t4, { pub: e3 });
      }, s2.fromSecret = function(t4, e3) {
        return e3 instanceof s2 ? e3 : new s2(t4, { secret: e3 });
      }, s2.prototype.secret = function() {
        return this._secret;
      }, a(s2, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
      }), a(s2, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
      }), a(s2, "privBytes", function() {
        var t4 = this.eddsa, e3 = this.hash(), r3 = t4.encodingLength - 1, n2 = e3.slice(0, t4.encodingLength);
        return n2[0] &= 248, n2[r3] &= 127, n2[r3] |= 64, n2;
      }), a(s2, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
      }), a(s2, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
      }), a(s2, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
      }), s2.prototype.sign = function(t4) {
        return i2(this._secret, "KeyPair can only verify"), this.eddsa.sign(t4, this);
      }, s2.prototype.verify = function(t4, e3) {
        return this.eddsa.verify(t4, e3, this);
      }, s2.prototype.getSecret = function(t4) {
        return i2(this._secret, "KeyPair is public only"), n.encode(this.secret(), t4);
      }, s2.prototype.getPublic = function(t4) {
        return n.encode(this.pubBytes(), t4);
      }, t3.exports = s2;
    }, 8433: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(7799), o = r2(1970), a = o.assert, s2 = o.cachedProperty, c = o.parseBytes;
      function u(t4, e3) {
        this.eddsa = t4, "object" !== n(e3) && (e3 = c(e3)), Array.isArray(e3) && (e3 = { R: e3.slice(0, t4.encodingLength), S: e3.slice(t4.encodingLength) }), a(e3.R && e3.S, "Signature without R or S"), t4.isPoint(e3.R) && (this._R = e3.R), e3.S instanceof i2 && (this._S = e3.S), this._Rencoded = Array.isArray(e3.R) ? e3.R : e3.Rencoded, this._Sencoded = Array.isArray(e3.S) ? e3.S : e3.Sencoded;
      }
      s2(u, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
      }), s2(u, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
      }), s2(u, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
      }), s2(u, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
      }), u.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
      }, u.prototype.toHex = function() {
        return o.encode(this.toBytes(), "hex").toUpperCase();
      }, t3.exports = u;
    }, 5586: (t3) => {
      t3.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    }, 1970: (t3, e2, r2) => {
      var n = e2, i2 = r2(7799), o = r2(3528), a = r2(6706);
      n.assert = o, n.toArray = a.toArray, n.zero2 = a.zero2, n.toHex = a.toHex, n.encode = a.encode, n.getNAF = function(t4, e3, r3) {
        var n2, i3 = new Array(Math.max(t4.bitLength(), r3) + 1);
        for (n2 = 0; n2 < i3.length; n2 += 1)
          i3[n2] = 0;
        var o2 = 1 << e3 + 1, a2 = t4.clone();
        for (n2 = 0; n2 < i3.length; n2++) {
          var s2, c = a2.andln(o2 - 1);
          a2.isOdd() ? (s2 = c > (o2 >> 1) - 1 ? (o2 >> 1) - c : c, a2.isubn(s2)) : s2 = 0, i3[n2] = s2, a2.iushrn(1);
        }
        return i3;
      }, n.getJSF = function(t4, e3) {
        var r3 = [[], []];
        t4 = t4.clone(), e3 = e3.clone();
        for (var n2, i3 = 0, o2 = 0; t4.cmpn(-i3) > 0 || e3.cmpn(-o2) > 0; ) {
          var a2, s2, c = t4.andln(3) + i3 & 3, u = e3.andln(3) + o2 & 3;
          3 === c && (c = -1), 3 === u && (u = -1), a2 = 1 & c ? 3 != (n2 = t4.andln(7) + i3 & 7) && 5 !== n2 || 2 !== u ? c : -c : 0, r3[0].push(a2), s2 = 1 & u ? 3 != (n2 = e3.andln(7) + o2 & 7) && 5 !== n2 || 2 !== c ? u : -u : 0, r3[1].push(s2), 2 * i3 === a2 + 1 && (i3 = 1 - i3), 2 * o2 === s2 + 1 && (o2 = 1 - o2), t4.iushrn(1), e3.iushrn(1);
        }
        return r3;
      }, n.cachedProperty = function(t4, e3, r3) {
        var n2 = "_" + e3;
        t4.prototype[e3] = function() {
          return void 0 !== this[n2] ? this[n2] : this[n2] = r3.call(this);
        };
      }, n.parseBytes = function(t4) {
        return "string" == typeof t4 ? n.toArray(t4, "hex") : t4;
      }, n.intFromLE = function(t4) {
        return new i2(t4, "hex", "le");
      };
    }, 988: (t3, e2, r2) => {
      var n = r2(6400)("%Object.defineProperty%", true) || false;
      if (n)
        try {
          n({}, "a", { value: 1 });
        } catch (t4) {
          n = false;
        }
      t3.exports = n;
    }, 9206: (t3) => {
      t3.exports = EvalError;
    }, 9870: (t3) => {
      t3.exports = Error;
    }, 9939: (t3) => {
      t3.exports = RangeError;
    }, 783: (t3) => {
      t3.exports = ReferenceError;
    }, 2288: (t3) => {
      t3.exports = SyntaxError;
    }, 2268: (t3) => {
      t3.exports = TypeError;
    }, 8188: (t3) => {
      t3.exports = URIError;
    }, 6182: (t3) => {
      function e2(t4, e3) {
        if (null == t4)
          throw new TypeError("Cannot convert first argument to object");
        for (var r2 = Object(t4), n = 1; n < arguments.length; n++) {
          var i2 = arguments[n];
          if (null != i2)
            for (var o = Object.keys(Object(i2)), a = 0, s2 = o.length; a < s2; a++) {
              var c = o[a], u = Object.getOwnPropertyDescriptor(i2, c);
              void 0 !== u && u.enumerable && (r2[c] = i2[c]);
            }
        }
        return r2;
      }
      t3.exports = { assign: e2, polyfill: function() {
        Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e2 });
      } };
    }, 3550: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2, n = "object" === ("undefined" == typeof Reflect ? "undefined" : e2(Reflect)) ? Reflect : null, i2 = n && "function" == typeof n.apply ? n.apply : function(t4, e3, r3) {
        return Function.prototype.apply.call(t4, e3, r3);
      };
      r2 = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(t4) {
        return Object.getOwnPropertyNames(t4).concat(Object.getOwnPropertySymbols(t4));
      } : function(t4) {
        return Object.getOwnPropertyNames(t4);
      };
      var o = Number.isNaN || function(t4) {
        return t4 != t4;
      };
      function a() {
        a.init.call(this);
      }
      t3.exports = a, t3.exports.once = function(t4, e3) {
        return new Promise(function(r3, n2) {
          function i3(r4) {
            t4.removeListener(e3, o2), n2(r4);
          }
          function o2() {
            "function" == typeof t4.removeListener && t4.removeListener("error", i3), r3([].slice.call(arguments));
          }
          b(t4, e3, o2, { once: true }), "error" !== e3 && function(t5, e4, r4) {
            "function" == typeof t5.on && b(t5, "error", e4, { once: true });
          }(t4, i3);
        });
      }, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
      var s2 = 10;
      function c(t4) {
        if ("function" != typeof t4)
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + e2(t4));
      }
      function u(t4) {
        return void 0 === t4._maxListeners ? a.defaultMaxListeners : t4._maxListeners;
      }
      function f(t4, e3, r3, n2) {
        var i3, o2, a2, s3;
        if (c(r3), void 0 === (o2 = t4._events) ? (o2 = t4._events = /* @__PURE__ */ Object.create(null), t4._eventsCount = 0) : (void 0 !== o2.newListener && (t4.emit("newListener", e3, r3.listener ? r3.listener : r3), o2 = t4._events), a2 = o2[e3]), void 0 === a2)
          a2 = o2[e3] = r3, ++t4._eventsCount;
        else if ("function" == typeof a2 ? a2 = o2[e3] = n2 ? [r3, a2] : [a2, r3] : n2 ? a2.unshift(r3) : a2.push(r3), (i3 = u(t4)) > 0 && a2.length > i3 && !a2.warned) {
          a2.warned = true;
          var f2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(e3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          f2.name = "MaxListenersExceededWarning", f2.emitter = t4, f2.type = e3, f2.count = a2.length, s3 = f2, console && console.warn && console.warn(s3);
        }
        return t4;
      }
      function l() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function h2(t4, e3, r3) {
        var n2 = { fired: false, wrapFn: void 0, target: t4, type: e3, listener: r3 }, i3 = l.bind(n2);
        return i3.listener = r3, n2.wrapFn = i3, i3;
      }
      function p(t4, e3, r3) {
        var n2 = t4._events;
        if (void 0 === n2)
          return [];
        var i3 = n2[e3];
        return void 0 === i3 ? [] : "function" == typeof i3 ? r3 ? [i3.listener || i3] : [i3] : r3 ? function(t5) {
          for (var e4 = new Array(t5.length), r4 = 0; r4 < e4.length; ++r4)
            e4[r4] = t5[r4].listener || t5[r4];
          return e4;
        }(i3) : y2(i3, i3.length);
      }
      function d2(t4) {
        var e3 = this._events;
        if (void 0 !== e3) {
          var r3 = e3[t4];
          if ("function" == typeof r3)
            return 1;
          if (void 0 !== r3)
            return r3.length;
        }
        return 0;
      }
      function y2(t4, e3) {
        for (var r3 = new Array(e3), n2 = 0; n2 < e3; ++n2)
          r3[n2] = t4[n2];
        return r3;
      }
      function b(t4, r3, n2, i3) {
        if ("function" == typeof t4.on)
          i3.once ? t4.once(r3, n2) : t4.on(r3, n2);
        else {
          if ("function" != typeof t4.addEventListener)
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + e2(t4));
          t4.addEventListener(r3, function e3(o2) {
            i3.once && t4.removeEventListener(r3, e3), n2(o2);
          });
        }
      }
      Object.defineProperty(a, "defaultMaxListeners", { enumerable: true, get: function() {
        return s2;
      }, set: function(t4) {
        if ("number" != typeof t4 || t4 < 0 || o(t4))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t4 + ".");
        s2 = t4;
      } }), a.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, a.prototype.setMaxListeners = function(t4) {
        if ("number" != typeof t4 || t4 < 0 || o(t4))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t4 + ".");
        return this._maxListeners = t4, this;
      }, a.prototype.getMaxListeners = function() {
        return u(this);
      }, a.prototype.emit = function(t4) {
        for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
          e3.push(arguments[r3]);
        var n2 = "error" === t4, o2 = this._events;
        if (void 0 !== o2)
          n2 = n2 && void 0 === o2.error;
        else if (!n2)
          return false;
        if (n2) {
          var a2;
          if (e3.length > 0 && (a2 = e3[0]), a2 instanceof Error)
            throw a2;
          var s3 = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
          throw s3.context = a2, s3;
        }
        var c2 = o2[t4];
        if (void 0 === c2)
          return false;
        if ("function" == typeof c2)
          i2(c2, this, e3);
        else {
          var u2 = c2.length, f2 = y2(c2, u2);
          for (r3 = 0; r3 < u2; ++r3)
            i2(f2[r3], this, e3);
        }
        return true;
      }, a.prototype.addListener = function(t4, e3) {
        return f(this, t4, e3, false);
      }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(t4, e3) {
        return f(this, t4, e3, true);
      }, a.prototype.once = function(t4, e3) {
        return c(e3), this.on(t4, h2(this, t4, e3)), this;
      }, a.prototype.prependOnceListener = function(t4, e3) {
        return c(e3), this.prependListener(t4, h2(this, t4, e3)), this;
      }, a.prototype.removeListener = function(t4, e3) {
        var r3, n2, i3, o2, a2;
        if (c(e3), void 0 === (n2 = this._events))
          return this;
        if (void 0 === (r3 = n2[t4]))
          return this;
        if (r3 === e3 || r3.listener === e3)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[t4], n2.removeListener && this.emit("removeListener", t4, r3.listener || e3));
        else if ("function" != typeof r3) {
          for (i3 = -1, o2 = r3.length - 1; o2 >= 0; o2--)
            if (r3[o2] === e3 || r3[o2].listener === e3) {
              a2 = r3[o2].listener, i3 = o2;
              break;
            }
          if (i3 < 0)
            return this;
          0 === i3 ? r3.shift() : function(t5, e4) {
            for (; e4 + 1 < t5.length; e4++)
              t5[e4] = t5[e4 + 1];
            t5.pop();
          }(r3, i3), 1 === r3.length && (n2[t4] = r3[0]), void 0 !== n2.removeListener && this.emit("removeListener", t4, a2 || e3);
        }
        return this;
      }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(t4) {
        var e3, r3, n2;
        if (void 0 === (r3 = this._events))
          return this;
        if (void 0 === r3.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r3[t4] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r3[t4]), this;
        if (0 === arguments.length) {
          var i3, o2 = Object.keys(r3);
          for (n2 = 0; n2 < o2.length; ++n2)
            "removeListener" !== (i3 = o2[n2]) && this.removeAllListeners(i3);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (e3 = r3[t4]))
          this.removeListener(t4, e3);
        else if (void 0 !== e3)
          for (n2 = e3.length - 1; n2 >= 0; n2--)
            this.removeListener(t4, e3[n2]);
        return this;
      }, a.prototype.listeners = function(t4) {
        return p(this, t4, true);
      }, a.prototype.rawListeners = function(t4) {
        return p(this, t4, false);
      }, a.listenerCount = function(t4, e3) {
        return "function" == typeof t4.listenerCount ? t4.listenerCount(e3) : d2.call(t4, e3);
      }, a.prototype.listenerCount = d2, a.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r2(this._events) : [];
      };
    }, 1685: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(2635);
      t3.exports = function(t4, e3, r3, o) {
        if (n.isBuffer(t4) || (t4 = n.from(t4, "binary")), e3 && (n.isBuffer(e3) || (e3 = n.from(e3, "binary")), 8 !== e3.length))
          throw new RangeError("salt should be Buffer with 8 byte length");
        for (var a = r3 / 8, s2 = n.alloc(a), c = n.alloc(o || 0), u = n.alloc(0); a > 0 || o > 0; ) {
          var f = new i2();
          f.update(u), f.update(t4), e3 && f.update(e3), u = f.digest();
          var l = 0;
          if (a > 0) {
            var h2 = s2.length - a;
            l = Math.min(a, u.length), u.copy(s2, h2, 0, l), a -= l;
          }
          if (l < u.length && o > 0) {
            var p = c.length - o, d2 = Math.min(o, u.length - l);
            u.copy(c, p, l, l + d2), o -= d2;
          }
        }
        return u.fill(0), { key: s2, iv: c };
      };
    }, 3777: (t3, e2, r2) => {
      var n = r2(9809), i2 = Object.prototype.toString, o = Object.prototype.hasOwnProperty;
      t3.exports = function(t4, e3, r3) {
        if (!n(e3))
          throw new TypeError("iterator must be a function");
        var a;
        arguments.length >= 3 && (a = r3), "[object Array]" === i2.call(t4) ? function(t5, e4, r4) {
          for (var n2 = 0, i3 = t5.length; n2 < i3; n2++)
            o.call(t5, n2) && (null == r4 ? e4(t5[n2], n2, t5) : e4.call(r4, t5[n2], n2, t5));
        }(t4, e3, a) : "string" == typeof t4 ? function(t5, e4, r4) {
          for (var n2 = 0, i3 = t5.length; n2 < i3; n2++)
            null == r4 ? e4(t5.charAt(n2), n2, t5) : e4.call(r4, t5.charAt(n2), n2, t5);
        }(t4, e3, a) : function(t5, e4, r4) {
          for (var n2 in t5)
            o.call(t5, n2) && (null == r4 ? e4(t5[n2], n2, t5) : e4.call(r4, t5[n2], n2, t5));
        }(t4, e3, a);
      };
    }, 6730: (t3) => {
      var e2 = Object.prototype.toString, r2 = Math.max, n = function(t4, e3) {
        for (var r3 = [], n2 = 0; n2 < t4.length; n2 += 1)
          r3[n2] = t4[n2];
        for (var i2 = 0; i2 < e3.length; i2 += 1)
          r3[i2 + t4.length] = e3[i2];
        return r3;
      };
      t3.exports = function(t4) {
        var i2 = this;
        if ("function" != typeof i2 || "[object Function]" !== e2.apply(i2))
          throw new TypeError("Function.prototype.bind called on incompatible " + i2);
        for (var o, a = function(t5, e3) {
          for (var r3 = [], n2 = 1, i3 = 0; n2 < t5.length; n2 += 1, i3 += 1)
            r3[i3] = t5[n2];
          return r3;
        }(arguments), s2 = r2(0, i2.length - a.length), c = [], u = 0; u < s2; u++)
          c[u] = "$" + u;
        if (o = Function("binder", "return function (" + function(t5, e3) {
          for (var r3 = "", n2 = 0; n2 < t5.length; n2 += 1)
            r3 += t5[n2], n2 + 1 < t5.length && (r3 += ",");
          return r3;
        }(c) + "){ return binder.apply(this,arguments); }")(function() {
          if (this instanceof o) {
            var e3 = i2.apply(this, n(a, arguments));
            return Object(e3) === e3 ? e3 : this;
          }
          return i2.apply(t4, n(a, arguments));
        }), i2.prototype) {
          var f = function() {
          };
          f.prototype = i2.prototype, o.prototype = new f(), f.prototype = null;
        }
        return o;
      };
    }, 2354: (t3, e2, r2) => {
      var n = r2(6730);
      t3.exports = Function.prototype.bind || n;
    }, 6400: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2, o = r2(9870), a = r2(9206), s2 = r2(9939), c = r2(783), u = r2(2288), f = r2(2268), l = r2(8188), h2 = Function, p = function(t4) {
        try {
          return h2('"use strict"; return (' + t4 + ").constructor;")();
        } catch (t5) {
        }
      }, d2 = Object.getOwnPropertyDescriptor;
      if (d2)
        try {
          d2({}, "");
        } catch (t4) {
          d2 = null;
        }
      var y2 = function() {
        throw new f();
      }, b = d2 ? function() {
        try {
          return y2;
        } catch (t4) {
          try {
            return d2(arguments, "callee").get;
          } catch (t5) {
            return y2;
          }
        }
      }() : y2, m2 = r2(5510)(), v = r2(309)(), g = Object.getPrototypeOf || (v ? function(t4) {
        return t4.__proto__;
      } : null), _ = {}, w2 = "undefined" != typeof Uint8Array && g ? g(Uint8Array) : i2, S = { __proto__: null, "%AggregateError%": "undefined" == typeof AggregateError ? i2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? i2 : ArrayBuffer, "%ArrayIteratorPrototype%": m2 && g ? g([][Symbol.iterator]()) : i2, "%AsyncFromSyncIteratorPrototype%": i2, "%AsyncFunction%": _, "%AsyncGenerator%": _, "%AsyncGeneratorFunction%": _, "%AsyncIteratorPrototype%": _, "%Atomics%": "undefined" == typeof Atomics ? i2 : Atomics, "%BigInt%": "undefined" == typeof BigInt ? i2 : BigInt, "%BigInt64Array%": "undefined" == typeof BigInt64Array ? i2 : BigInt64Array, "%BigUint64Array%": "undefined" == typeof BigUint64Array ? i2 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? i2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": o, "%eval%": eval, "%EvalError%": a, "%Float32Array%": "undefined" == typeof Float32Array ? i2 : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? i2 : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? i2 : FinalizationRegistry, "%Function%": h2, "%GeneratorFunction%": _, "%Int8Array%": "undefined" == typeof Int8Array ? i2 : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? i2 : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? i2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": m2 && g ? g(g([][Symbol.iterator]())) : i2, "%JSON%": "object" === ("undefined" == typeof JSON ? "undefined" : n(JSON)) ? JSON : i2, "%Map%": "undefined" == typeof Map ? i2 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && m2 && g ? g((/* @__PURE__ */ new Map())[Symbol.iterator]()) : i2, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? i2 : Promise, "%Proxy%": "undefined" == typeof Proxy ? i2 : Proxy, "%RangeError%": s2, "%ReferenceError%": c, "%Reflect%": "undefined" == typeof Reflect ? i2 : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? i2 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && m2 && g ? g((/* @__PURE__ */ new Set())[Symbol.iterator]()) : i2, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? i2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": m2 && g ? g(""[Symbol.iterator]()) : i2, "%Symbol%": m2 ? Symbol : i2, "%SyntaxError%": u, "%ThrowTypeError%": b, "%TypedArray%": w2, "%TypeError%": f, "%Uint8Array%": "undefined" == typeof Uint8Array ? i2 : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? i2 : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? i2 : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? i2 : Uint32Array, "%URIError%": l, "%WeakMap%": "undefined" == typeof WeakMap ? i2 : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? i2 : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? i2 : WeakSet };
      if (g)
        try {
          null.error;
        } catch (t4) {
          var O = g(g(t4));
          S["%Error.prototype%"] = O;
        }
      var j = function t4(e3) {
        var r3;
        if ("%AsyncFunction%" === e3)
          r3 = p("async function () {}");
        else if ("%GeneratorFunction%" === e3)
          r3 = p("function* () {}");
        else if ("%AsyncGeneratorFunction%" === e3)
          r3 = p("async function* () {}");
        else if ("%AsyncGenerator%" === e3) {
          var n2 = t4("%AsyncGeneratorFunction%");
          n2 && (r3 = n2.prototype);
        } else if ("%AsyncIteratorPrototype%" === e3) {
          var i3 = t4("%AsyncGenerator%");
          i3 && g && (r3 = g(i3.prototype));
        }
        return S[e3] = r3, r3;
      }, $ = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, A = r2(2354), E = r2(5994), x = A.call(Function.call, Array.prototype.concat), P = A.call(Function.apply, Array.prototype.splice), k = A.call(Function.call, String.prototype.replace), M = A.call(Function.call, String.prototype.slice), I = A.call(Function.call, RegExp.prototype.exec), B = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, T = /\\(\\)?/g, R = function(t4, e3) {
        var r3, n2 = t4;
        if (E($, n2) && (n2 = "%" + (r3 = $[n2])[0] + "%"), E(S, n2)) {
          var i3 = S[n2];
          if (i3 === _ && (i3 = j(n2)), void 0 === i3 && !e3)
            throw new f("intrinsic " + t4 + " exists, but is not available. Please file an issue!");
          return { alias: r3, name: n2, value: i3 };
        }
        throw new u("intrinsic " + t4 + " does not exist!");
      };
      t3.exports = function(t4, e3) {
        if ("string" != typeof t4 || 0 === t4.length)
          throw new f("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof e3)
          throw new f('"allowMissing" argument must be a boolean');
        if (null === I(/^%?[^%]*%?$/, t4))
          throw new u("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var r3 = function(t5) {
          var e4 = M(t5, 0, 1), r4 = M(t5, -1);
          if ("%" === e4 && "%" !== r4)
            throw new u("invalid intrinsic syntax, expected closing `%`");
          if ("%" === r4 && "%" !== e4)
            throw new u("invalid intrinsic syntax, expected opening `%`");
          var n3 = [];
          return k(t5, B, function(t6, e5, r5, i4) {
            n3[n3.length] = r5 ? k(i4, T, "$1") : e5 || t6;
          }), n3;
        }(t4), n2 = r3.length > 0 ? r3[0] : "", i3 = R("%" + n2 + "%", e3), o2 = i3.name, a2 = i3.value, s3 = false, c2 = i3.alias;
        c2 && (n2 = c2[0], P(r3, x([0, 1], c2)));
        for (var l2 = 1, h3 = true; l2 < r3.length; l2 += 1) {
          var p2 = r3[l2], y3 = M(p2, 0, 1), b2 = M(p2, -1);
          if (('"' === y3 || "'" === y3 || "`" === y3 || '"' === b2 || "'" === b2 || "`" === b2) && y3 !== b2)
            throw new u("property names with quotes must have matching quotes");
          if ("constructor" !== p2 && h3 || (s3 = true), E(S, o2 = "%" + (n2 += "." + p2) + "%"))
            a2 = S[o2];
          else if (null != a2) {
            if (!(p2 in a2)) {
              if (!e3)
                throw new f("base intrinsic for " + t4 + " exists, but the property is not available.");
              return;
            }
            if (d2 && l2 + 1 >= r3.length) {
              var m3 = d2(a2, p2);
              a2 = (h3 = !!m3) && "get" in m3 && !("originalValue" in m3.get) ? m3.get : a2[p2];
            } else
              h3 = E(a2, p2), a2 = a2[p2];
            h3 && !s3 && (S[o2] = a2);
          }
        }
        return a2;
      };
    }, 1464: (t3, e2, r2) => {
      var n = r2(6400)("%Object.getOwnPropertyDescriptor%", true);
      if (n)
        try {
          n([], "length");
        } catch (t4) {
          n = null;
        }
      t3.exports = n;
    }, 3191: (t3, e2, r2) => {
      var n = r2(988), i2 = function() {
        return !!n;
      };
      i2.hasArrayLengthDefineBug = function() {
        if (!n)
          return null;
        try {
          return 1 !== n([], "length", { value: 1 }).length;
        } catch (t4) {
          return true;
        }
      }, t3.exports = i2;
    }, 309: (t3) => {
      var e2 = { __proto__: null, foo: {} }, r2 = Object;
      t3.exports = function() {
        return { __proto__: e2 }.foo === e2.foo && !(e2 instanceof r2);
      };
    }, 5510: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = "undefined" != typeof Symbol && Symbol, o = r2(5484);
      t3.exports = function() {
        return "function" == typeof i2 && "function" == typeof Symbol && "symbol" === n(i2("foo")) && "symbol" === n(Symbol("bar")) && o();
      };
    }, 5484: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
          return false;
        if ("symbol" === e2(Symbol.iterator))
          return true;
        var t4 = {}, r2 = Symbol("test"), n = Object(r2);
        if ("string" == typeof r2)
          return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(r2))
          return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(n))
          return false;
        for (r2 in t4[r2] = 42, t4)
          return false;
        if ("function" == typeof Object.keys && 0 !== Object.keys(t4).length)
          return false;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t4).length)
          return false;
        var i2 = Object.getOwnPropertySymbols(t4);
        if (1 !== i2.length || i2[0] !== r2)
          return false;
        if (!Object.prototype.propertyIsEnumerable.call(t4, r2))
          return false;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
          var o = Object.getOwnPropertyDescriptor(t4, r2);
          if (42 !== o.value || true !== o.enumerable)
            return false;
        }
        return true;
      };
    }, 953: (t3, e2, r2) => {
      var n = r2(5484);
      t3.exports = function() {
        return n() && !!Symbol.toStringTag;
      };
    }, 6936: (t3, e2, r2) => {
      var n = r2(9732).Buffer, i2 = r2(7775).Transform;
      function o(t4) {
        i2.call(this), this._block = n.allocUnsafe(t4), this._blockSize = t4, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
      }
      r2(1679)(o, i2), o.prototype._transform = function(t4, e3, r3) {
        var n2 = null;
        try {
          this.update(t4, e3);
        } catch (t5) {
          n2 = t5;
        }
        r3(n2);
      }, o.prototype._flush = function(t4) {
        var e3 = null;
        try {
          this.push(this.digest());
        } catch (t5) {
          e3 = t5;
        }
        t4(e3);
      }, o.prototype.update = function(t4, e3) {
        if (function(t5, e4) {
          if (!n.isBuffer(t5) && "string" != typeof t5)
            throw new TypeError("Data must be a string or a buffer");
        }(t4), this._finalized)
          throw new Error("Digest already called");
        n.isBuffer(t4) || (t4 = n.from(t4, e3));
        for (var r3 = this._block, i3 = 0; this._blockOffset + t4.length - i3 >= this._blockSize; ) {
          for (var o2 = this._blockOffset; o2 < this._blockSize; )
            r3[o2++] = t4[i3++];
          this._update(), this._blockOffset = 0;
        }
        for (; i3 < t4.length; )
          r3[this._blockOffset++] = t4[i3++];
        for (var a = 0, s2 = 8 * t4.length; s2 > 0; ++a)
          this._length[a] += s2, (s2 = this._length[a] / 4294967296 | 0) > 0 && (this._length[a] -= 4294967296 * s2);
        return this;
      }, o.prototype._update = function() {
        throw new Error("_update is not implemented");
      }, o.prototype.digest = function(t4) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var e3 = this._digest();
        void 0 !== t4 && (e3 = e3.toString(t4)), this._block.fill(0), this._blockOffset = 0;
        for (var r3 = 0; r3 < 4; ++r3)
          this._length[r3] = 0;
        return e3;
      }, o.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      }, t3.exports = o;
    }, 2859: (t3, e2, r2) => {
      var n = e2;
      n.utils = r2(4685), n.common = r2(7695), n.sha = r2(690), n.ripemd = r2(601), n.hmac = r2(9313), n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160;
    }, 7695: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(3528);
      function o() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
      }
      e2.BlockHash = o, o.prototype.update = function(t4, e3) {
        if (t4 = n.toArray(t4, e3), this.pending ? this.pending = this.pending.concat(t4) : this.pending = t4, this.pendingTotal += t4.length, this.pending.length >= this._delta8) {
          var r3 = (t4 = this.pending).length % this._delta8;
          this.pending = t4.slice(t4.length - r3, t4.length), 0 === this.pending.length && (this.pending = null), t4 = n.join32(t4, 0, t4.length - r3, this.endian);
          for (var i3 = 0; i3 < t4.length; i3 += this._delta32)
            this._update(t4, i3, i3 + this._delta32);
        }
        return this;
      }, o.prototype.digest = function(t4) {
        return this.update(this._pad()), i2(null === this.pending), this._digest(t4);
      }, o.prototype._pad = function() {
        var t4 = this.pendingTotal, e3 = this._delta8, r3 = e3 - (t4 + this.padLength) % e3, n2 = new Array(r3 + this.padLength);
        n2[0] = 128;
        for (var i3 = 1; i3 < r3; i3++)
          n2[i3] = 0;
        if (t4 <<= 3, "big" === this.endian) {
          for (var o2 = 8; o2 < this.padLength; o2++)
            n2[i3++] = 0;
          n2[i3++] = 0, n2[i3++] = 0, n2[i3++] = 0, n2[i3++] = 0, n2[i3++] = t4 >>> 24 & 255, n2[i3++] = t4 >>> 16 & 255, n2[i3++] = t4 >>> 8 & 255, n2[i3++] = 255 & t4;
        } else
          for (n2[i3++] = 255 & t4, n2[i3++] = t4 >>> 8 & 255, n2[i3++] = t4 >>> 16 & 255, n2[i3++] = t4 >>> 24 & 255, n2[i3++] = 0, n2[i3++] = 0, n2[i3++] = 0, n2[i3++] = 0, o2 = 8; o2 < this.padLength; o2++)
            n2[i3++] = 0;
        return n2;
      };
    }, 9313: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(3528);
      function o(t4, e3, r3) {
        if (!(this instanceof o))
          return new o(t4, e3, r3);
        this.Hash = t4, this.blockSize = t4.blockSize / 8, this.outSize = t4.outSize / 8, this.inner = null, this.outer = null, this._init(n.toArray(e3, r3));
      }
      t3.exports = o, o.prototype._init = function(t4) {
        t4.length > this.blockSize && (t4 = new this.Hash().update(t4).digest()), i2(t4.length <= this.blockSize);
        for (var e3 = t4.length; e3 < this.blockSize; e3++)
          t4.push(0);
        for (e3 = 0; e3 < t4.length; e3++)
          t4[e3] ^= 54;
        for (this.inner = new this.Hash().update(t4), e3 = 0; e3 < t4.length; e3++)
          t4[e3] ^= 106;
        this.outer = new this.Hash().update(t4);
      }, o.prototype.update = function(t4, e3) {
        return this.inner.update(t4, e3), this;
      }, o.prototype.digest = function(t4) {
        return this.outer.update(this.inner.digest()), this.outer.digest(t4);
      };
    }, 601: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(7695), o = n.rotl32, a = n.sum32, s2 = n.sum32_3, c = n.sum32_4, u = i2.BlockHash;
      function f() {
        if (!(this instanceof f))
          return new f();
        u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
      }
      function l(t4, e3, r3, n2) {
        return t4 <= 15 ? e3 ^ r3 ^ n2 : t4 <= 31 ? e3 & r3 | ~e3 & n2 : t4 <= 47 ? (e3 | ~r3) ^ n2 : t4 <= 63 ? e3 & n2 | r3 & ~n2 : e3 ^ (r3 | ~n2);
      }
      function h2(t4) {
        return t4 <= 15 ? 0 : t4 <= 31 ? 1518500249 : t4 <= 47 ? 1859775393 : t4 <= 63 ? 2400959708 : 2840853838;
      }
      function p(t4) {
        return t4 <= 15 ? 1352829926 : t4 <= 31 ? 1548603684 : t4 <= 47 ? 1836072691 : t4 <= 63 ? 2053994217 : 0;
      }
      n.inherits(f, u), e2.ripemd160 = f, f.blockSize = 512, f.outSize = 160, f.hmacStrength = 192, f.padLength = 64, f.prototype._update = function(t4, e3) {
        for (var r3 = this.h[0], n2 = this.h[1], i3 = this.h[2], u2 = this.h[3], f2 = this.h[4], v = r3, g = n2, _ = i3, w2 = u2, S = f2, O = 0; O < 80; O++) {
          var j = a(o(c(r3, l(O, n2, i3, u2), t4[d2[O] + e3], h2(O)), b[O]), f2);
          r3 = f2, f2 = u2, u2 = o(i3, 10), i3 = n2, n2 = j, j = a(o(c(v, l(79 - O, g, _, w2), t4[y2[O] + e3], p(O)), m2[O]), S), v = S, S = w2, w2 = o(_, 10), _ = g, g = j;
        }
        j = s2(this.h[1], i3, w2), this.h[1] = s2(this.h[2], u2, S), this.h[2] = s2(this.h[3], f2, v), this.h[3] = s2(this.h[4], r3, g), this.h[4] = s2(this.h[0], n2, _), this.h[0] = j;
      }, f.prototype._digest = function(t4) {
        return "hex" === t4 ? n.toHex32(this.h, "little") : n.split32(this.h, "little");
      };
      var d2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], y2 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], b = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], m2 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    }, 690: (t3, e2, r2) => {
      e2.sha1 = r2(4042), e2.sha224 = r2(3329), e2.sha256 = r2(2344), e2.sha384 = r2(3420), e2.sha512 = r2(6749);
    }, 4042: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(7695), o = r2(4104), a = n.rotl32, s2 = n.sum32, c = n.sum32_5, u = o.ft_1, f = i2.BlockHash, l = [1518500249, 1859775393, 2400959708, 3395469782];
      function h2() {
        if (!(this instanceof h2))
          return new h2();
        f.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
      }
      n.inherits(h2, f), t3.exports = h2, h2.blockSize = 512, h2.outSize = 160, h2.hmacStrength = 80, h2.padLength = 64, h2.prototype._update = function(t4, e3) {
        for (var r3 = this.W, n2 = 0; n2 < 16; n2++)
          r3[n2] = t4[e3 + n2];
        for (; n2 < r3.length; n2++)
          r3[n2] = a(r3[n2 - 3] ^ r3[n2 - 8] ^ r3[n2 - 14] ^ r3[n2 - 16], 1);
        var i3 = this.h[0], o2 = this.h[1], f2 = this.h[2], h3 = this.h[3], p = this.h[4];
        for (n2 = 0; n2 < r3.length; n2++) {
          var d2 = ~~(n2 / 20), y2 = c(a(i3, 5), u(d2, o2, f2, h3), p, r3[n2], l[d2]);
          p = h3, h3 = f2, f2 = a(o2, 30), o2 = i3, i3 = y2;
        }
        this.h[0] = s2(this.h[0], i3), this.h[1] = s2(this.h[1], o2), this.h[2] = s2(this.h[2], f2), this.h[3] = s2(this.h[3], h3), this.h[4] = s2(this.h[4], p);
      }, h2.prototype._digest = function(t4) {
        return "hex" === t4 ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
      };
    }, 3329: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(2344);
      function o() {
        if (!(this instanceof o))
          return new o();
        i2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }
      n.inherits(o, i2), t3.exports = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function(t4) {
        return "hex" === t4 ? n.toHex32(this.h.slice(0, 7), "big") : n.split32(this.h.slice(0, 7), "big");
      };
    }, 2344: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(7695), o = r2(4104), a = r2(3528), s2 = n.sum32, c = n.sum32_4, u = n.sum32_5, f = o.ch32, l = o.maj32, h2 = o.s0_256, p = o.s1_256, d2 = o.g0_256, y2 = o.g1_256, b = i2.BlockHash, m2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      function v() {
        if (!(this instanceof v))
          return new v();
        b.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = m2, this.W = new Array(64);
      }
      n.inherits(v, b), t3.exports = v, v.blockSize = 512, v.outSize = 256, v.hmacStrength = 192, v.padLength = 64, v.prototype._update = function(t4, e3) {
        for (var r3 = this.W, n2 = 0; n2 < 16; n2++)
          r3[n2] = t4[e3 + n2];
        for (; n2 < r3.length; n2++)
          r3[n2] = c(y2(r3[n2 - 2]), r3[n2 - 7], d2(r3[n2 - 15]), r3[n2 - 16]);
        var i3 = this.h[0], o2 = this.h[1], b2 = this.h[2], m3 = this.h[3], v2 = this.h[4], g = this.h[5], _ = this.h[6], w2 = this.h[7];
        for (a(this.k.length === r3.length), n2 = 0; n2 < r3.length; n2++) {
          var S = u(w2, p(v2), f(v2, g, _), this.k[n2], r3[n2]), O = s2(h2(i3), l(i3, o2, b2));
          w2 = _, _ = g, g = v2, v2 = s2(m3, S), m3 = b2, b2 = o2, o2 = i3, i3 = s2(S, O);
        }
        this.h[0] = s2(this.h[0], i3), this.h[1] = s2(this.h[1], o2), this.h[2] = s2(this.h[2], b2), this.h[3] = s2(this.h[3], m3), this.h[4] = s2(this.h[4], v2), this.h[5] = s2(this.h[5], g), this.h[6] = s2(this.h[6], _), this.h[7] = s2(this.h[7], w2);
      }, v.prototype._digest = function(t4) {
        return "hex" === t4 ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
      };
    }, 3420: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(6749);
      function o() {
        if (!(this instanceof o))
          return new o();
        i2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }
      n.inherits(o, i2), t3.exports = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function(t4) {
        return "hex" === t4 ? n.toHex32(this.h.slice(0, 12), "big") : n.split32(this.h.slice(0, 12), "big");
      };
    }, 6749: (t3, e2, r2) => {
      var n = r2(4685), i2 = r2(7695), o = r2(3528), a = n.rotr64_hi, s2 = n.rotr64_lo, c = n.shr64_hi, u = n.shr64_lo, f = n.sum64, l = n.sum64_hi, h2 = n.sum64_lo, p = n.sum64_4_hi, d2 = n.sum64_4_lo, y2 = n.sum64_5_hi, b = n.sum64_5_lo, m2 = i2.BlockHash, v = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function g() {
        if (!(this instanceof g))
          return new g();
        m2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = v, this.W = new Array(160);
      }
      function _(t4, e3, r3, n2, i3) {
        var o2 = t4 & r3 ^ ~t4 & i3;
        return o2 < 0 && (o2 += 4294967296), o2;
      }
      function w2(t4, e3, r3, n2, i3, o2) {
        var a2 = e3 & n2 ^ ~e3 & o2;
        return a2 < 0 && (a2 += 4294967296), a2;
      }
      function S(t4, e3, r3, n2, i3) {
        var o2 = t4 & r3 ^ t4 & i3 ^ r3 & i3;
        return o2 < 0 && (o2 += 4294967296), o2;
      }
      function O(t4, e3, r3, n2, i3, o2) {
        var a2 = e3 & n2 ^ e3 & o2 ^ n2 & o2;
        return a2 < 0 && (a2 += 4294967296), a2;
      }
      function j(t4, e3) {
        var r3 = a(t4, e3, 28) ^ a(e3, t4, 2) ^ a(e3, t4, 7);
        return r3 < 0 && (r3 += 4294967296), r3;
      }
      function $(t4, e3) {
        var r3 = s2(t4, e3, 28) ^ s2(e3, t4, 2) ^ s2(e3, t4, 7);
        return r3 < 0 && (r3 += 4294967296), r3;
      }
      function A(t4, e3) {
        var r3 = s2(t4, e3, 14) ^ s2(t4, e3, 18) ^ s2(e3, t4, 9);
        return r3 < 0 && (r3 += 4294967296), r3;
      }
      function E(t4, e3) {
        var r3 = a(t4, e3, 1) ^ a(t4, e3, 8) ^ c(t4, e3, 7);
        return r3 < 0 && (r3 += 4294967296), r3;
      }
      function x(t4, e3) {
        var r3 = s2(t4, e3, 1) ^ s2(t4, e3, 8) ^ u(t4, e3, 7);
        return r3 < 0 && (r3 += 4294967296), r3;
      }
      function P(t4, e3) {
        var r3 = s2(t4, e3, 19) ^ s2(e3, t4, 29) ^ u(t4, e3, 6);
        return r3 < 0 && (r3 += 4294967296), r3;
      }
      n.inherits(g, m2), t3.exports = g, g.blockSize = 1024, g.outSize = 512, g.hmacStrength = 192, g.padLength = 128, g.prototype._prepareBlock = function(t4, e3) {
        for (var r3 = this.W, n2 = 0; n2 < 32; n2++)
          r3[n2] = t4[e3 + n2];
        for (; n2 < r3.length; n2 += 2) {
          var i3 = (b2 = r3[n2 - 4], m3 = r3[n2 - 3], v2 = void 0, (v2 = a(b2, m3, 19) ^ a(m3, b2, 29) ^ c(b2, m3, 6)) < 0 && (v2 += 4294967296), v2), o2 = P(r3[n2 - 4], r3[n2 - 3]), s3 = r3[n2 - 14], u2 = r3[n2 - 13], f2 = E(r3[n2 - 30], r3[n2 - 29]), l2 = x(r3[n2 - 30], r3[n2 - 29]), h3 = r3[n2 - 32], y3 = r3[n2 - 31];
          r3[n2] = p(i3, o2, s3, u2, f2, l2, h3, y3), r3[n2 + 1] = d2(i3, o2, s3, u2, f2, l2, h3, y3);
        }
        var b2, m3, v2;
      }, g.prototype._update = function(t4, e3) {
        this._prepareBlock(t4, e3);
        var r3, n2, i3, s3 = this.W, c2 = this.h[0], u2 = this.h[1], p2 = this.h[2], d3 = this.h[3], m3 = this.h[4], v2 = this.h[5], g2 = this.h[6], E2 = this.h[7], x2 = this.h[8], P2 = this.h[9], k = this.h[10], M = this.h[11], I = this.h[12], B = this.h[13], T = this.h[14], R = this.h[15];
        o(this.k.length === s3.length);
        for (var N = 0; N < s3.length; N += 2) {
          var D = T, L = R, U = (i3 = void 0, (i3 = a(r3 = x2, n2 = P2, 14) ^ a(r3, n2, 18) ^ a(n2, r3, 9)) < 0 && (i3 += 4294967296), i3), C = A(x2, P2), q = _(x2, 0, k, 0, I), F = w2(0, P2, 0, M, 0, B), V = this.k[N], z = this.k[N + 1], K = s3[N], H = s3[N + 1], W = y2(D, L, U, C, q, F, V, z, K, H), J = b(D, L, U, C, q, F, V, z, K, H);
          D = j(c2, u2), L = $(c2, u2), U = S(c2, 0, p2, 0, m3), C = O(0, u2, 0, d3, 0, v2);
          var G = l(D, L, U, C), Y = h2(D, L, U, C);
          T = I, R = B, I = k, B = M, k = x2, M = P2, x2 = l(g2, E2, W, J), P2 = h2(E2, E2, W, J), g2 = m3, E2 = v2, m3 = p2, v2 = d3, p2 = c2, d3 = u2, c2 = l(W, J, G, Y), u2 = h2(W, J, G, Y);
        }
        f(this.h, 0, c2, u2), f(this.h, 2, p2, d3), f(this.h, 4, m3, v2), f(this.h, 6, g2, E2), f(this.h, 8, x2, P2), f(this.h, 10, k, M), f(this.h, 12, I, B), f(this.h, 14, T, R);
      }, g.prototype._digest = function(t4) {
        return "hex" === t4 ? n.toHex32(this.h, "big") : n.split32(this.h, "big");
      };
    }, 4104: (t3, e2, r2) => {
      var n = r2(4685).rotr32;
      function i2(t4, e3, r3) {
        return t4 & e3 ^ ~t4 & r3;
      }
      function o(t4, e3, r3) {
        return t4 & e3 ^ t4 & r3 ^ e3 & r3;
      }
      function a(t4, e3, r3) {
        return t4 ^ e3 ^ r3;
      }
      e2.ft_1 = function(t4, e3, r3, n2) {
        return 0 === t4 ? i2(e3, r3, n2) : 1 === t4 || 3 === t4 ? a(e3, r3, n2) : 2 === t4 ? o(e3, r3, n2) : void 0;
      }, e2.ch32 = i2, e2.maj32 = o, e2.p32 = a, e2.s0_256 = function(t4) {
        return n(t4, 2) ^ n(t4, 13) ^ n(t4, 22);
      }, e2.s1_256 = function(t4) {
        return n(t4, 6) ^ n(t4, 11) ^ n(t4, 25);
      }, e2.g0_256 = function(t4) {
        return n(t4, 7) ^ n(t4, 18) ^ t4 >>> 3;
      }, e2.g1_256 = function(t4) {
        return n(t4, 17) ^ n(t4, 19) ^ t4 >>> 10;
      };
    }, 4685: (t3, e2, r2) => {
      var n = r2(3528), i2 = r2(1679);
      function o(t4, e3) {
        return 55296 == (64512 & t4.charCodeAt(e3)) && !(e3 < 0 || e3 + 1 >= t4.length) && 56320 == (64512 & t4.charCodeAt(e3 + 1));
      }
      function a(t4) {
        return (t4 >>> 24 | t4 >>> 8 & 65280 | t4 << 8 & 16711680 | (255 & t4) << 24) >>> 0;
      }
      function s2(t4) {
        return 1 === t4.length ? "0" + t4 : t4;
      }
      function c(t4) {
        return 7 === t4.length ? "0" + t4 : 6 === t4.length ? "00" + t4 : 5 === t4.length ? "000" + t4 : 4 === t4.length ? "0000" + t4 : 3 === t4.length ? "00000" + t4 : 2 === t4.length ? "000000" + t4 : 1 === t4.length ? "0000000" + t4 : t4;
      }
      e2.inherits = i2, e2.toArray = function(t4, e3) {
        if (Array.isArray(t4))
          return t4.slice();
        if (!t4)
          return [];
        var r3 = [];
        if ("string" == typeof t4)
          if (e3) {
            if ("hex" === e3)
              for ((t4 = t4.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t4 = "0" + t4), i3 = 0; i3 < t4.length; i3 += 2)
                r3.push(parseInt(t4[i3] + t4[i3 + 1], 16));
          } else
            for (var n2 = 0, i3 = 0; i3 < t4.length; i3++) {
              var a2 = t4.charCodeAt(i3);
              a2 < 128 ? r3[n2++] = a2 : a2 < 2048 ? (r3[n2++] = a2 >> 6 | 192, r3[n2++] = 63 & a2 | 128) : o(t4, i3) ? (a2 = 65536 + ((1023 & a2) << 10) + (1023 & t4.charCodeAt(++i3)), r3[n2++] = a2 >> 18 | 240, r3[n2++] = a2 >> 12 & 63 | 128, r3[n2++] = a2 >> 6 & 63 | 128, r3[n2++] = 63 & a2 | 128) : (r3[n2++] = a2 >> 12 | 224, r3[n2++] = a2 >> 6 & 63 | 128, r3[n2++] = 63 & a2 | 128);
            }
        else
          for (i3 = 0; i3 < t4.length; i3++)
            r3[i3] = 0 | t4[i3];
        return r3;
      }, e2.toHex = function(t4) {
        for (var e3 = "", r3 = 0; r3 < t4.length; r3++)
          e3 += s2(t4[r3].toString(16));
        return e3;
      }, e2.htonl = a, e2.toHex32 = function(t4, e3) {
        for (var r3 = "", n2 = 0; n2 < t4.length; n2++) {
          var i3 = t4[n2];
          "little" === e3 && (i3 = a(i3)), r3 += c(i3.toString(16));
        }
        return r3;
      }, e2.zero2 = s2, e2.zero8 = c, e2.join32 = function(t4, e3, r3, i3) {
        var o2 = r3 - e3;
        n(o2 % 4 == 0);
        for (var a2 = new Array(o2 / 4), s3 = 0, c2 = e3; s3 < a2.length; s3++, c2 += 4) {
          var u;
          u = "big" === i3 ? t4[c2] << 24 | t4[c2 + 1] << 16 | t4[c2 + 2] << 8 | t4[c2 + 3] : t4[c2 + 3] << 24 | t4[c2 + 2] << 16 | t4[c2 + 1] << 8 | t4[c2], a2[s3] = u >>> 0;
        }
        return a2;
      }, e2.split32 = function(t4, e3) {
        for (var r3 = new Array(4 * t4.length), n2 = 0, i3 = 0; n2 < t4.length; n2++, i3 += 4) {
          var o2 = t4[n2];
          "big" === e3 ? (r3[i3] = o2 >>> 24, r3[i3 + 1] = o2 >>> 16 & 255, r3[i3 + 2] = o2 >>> 8 & 255, r3[i3 + 3] = 255 & o2) : (r3[i3 + 3] = o2 >>> 24, r3[i3 + 2] = o2 >>> 16 & 255, r3[i3 + 1] = o2 >>> 8 & 255, r3[i3] = 255 & o2);
        }
        return r3;
      }, e2.rotr32 = function(t4, e3) {
        return t4 >>> e3 | t4 << 32 - e3;
      }, e2.rotl32 = function(t4, e3) {
        return t4 << e3 | t4 >>> 32 - e3;
      }, e2.sum32 = function(t4, e3) {
        return t4 + e3 >>> 0;
      }, e2.sum32_3 = function(t4, e3, r3) {
        return t4 + e3 + r3 >>> 0;
      }, e2.sum32_4 = function(t4, e3, r3, n2) {
        return t4 + e3 + r3 + n2 >>> 0;
      }, e2.sum32_5 = function(t4, e3, r3, n2, i3) {
        return t4 + e3 + r3 + n2 + i3 >>> 0;
      }, e2.sum64 = function(t4, e3, r3, n2) {
        var i3 = t4[e3], o2 = n2 + t4[e3 + 1] >>> 0, a2 = (o2 < n2 ? 1 : 0) + r3 + i3;
        t4[e3] = a2 >>> 0, t4[e3 + 1] = o2;
      }, e2.sum64_hi = function(t4, e3, r3, n2) {
        return (e3 + n2 >>> 0 < e3 ? 1 : 0) + t4 + r3 >>> 0;
      }, e2.sum64_lo = function(t4, e3, r3, n2) {
        return e3 + n2 >>> 0;
      }, e2.sum64_4_hi = function(t4, e3, r3, n2, i3, o2, a2, s3) {
        var c2 = 0, u = e3;
        return c2 += (u = u + n2 >>> 0) < e3 ? 1 : 0, c2 += (u = u + o2 >>> 0) < o2 ? 1 : 0, t4 + r3 + i3 + a2 + (c2 += (u = u + s3 >>> 0) < s3 ? 1 : 0) >>> 0;
      }, e2.sum64_4_lo = function(t4, e3, r3, n2, i3, o2, a2, s3) {
        return e3 + n2 + o2 + s3 >>> 0;
      }, e2.sum64_5_hi = function(t4, e3, r3, n2, i3, o2, a2, s3, c2, u) {
        var f = 0, l = e3;
        return f += (l = l + n2 >>> 0) < e3 ? 1 : 0, f += (l = l + o2 >>> 0) < o2 ? 1 : 0, f += (l = l + s3 >>> 0) < s3 ? 1 : 0, t4 + r3 + i3 + a2 + c2 + (f += (l = l + u >>> 0) < u ? 1 : 0) >>> 0;
      }, e2.sum64_5_lo = function(t4, e3, r3, n2, i3, o2, a2, s3, c2, u) {
        return e3 + n2 + o2 + s3 + u >>> 0;
      }, e2.rotr64_hi = function(t4, e3, r3) {
        return (e3 << 32 - r3 | t4 >>> r3) >>> 0;
      }, e2.rotr64_lo = function(t4, e3, r3) {
        return (t4 << 32 - r3 | e3 >>> r3) >>> 0;
      }, e2.shr64_hi = function(t4, e3, r3) {
        return t4 >>> r3;
      }, e2.shr64_lo = function(t4, e3, r3) {
        return (t4 << 32 - r3 | e3 >>> r3) >>> 0;
      };
    }, 5994: (t3, e2, r2) => {
      var n = Function.prototype.call, i2 = Object.prototype.hasOwnProperty, o = r2(2354);
      t3.exports = o.call(n, i2);
    }, 6934: (t3, e2, r2) => {
      var n = r2(2859), i2 = r2(6706), o = r2(3528);
      function a(t4) {
        if (!(this instanceof a))
          return new a(t4);
        this.hash = t4.hash, this.predResist = !!t4.predResist, this.outLen = this.hash.outSize, this.minEntropy = t4.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var e3 = i2.toArray(t4.entropy, t4.entropyEnc || "hex"), r3 = i2.toArray(t4.nonce, t4.nonceEnc || "hex"), n2 = i2.toArray(t4.pers, t4.persEnc || "hex");
        o(e3.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e3, r3, n2);
      }
      t3.exports = a, a.prototype._init = function(t4, e3, r3) {
        var n2 = t4.concat(e3).concat(r3);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for (var i3 = 0; i3 < this.V.length; i3++)
          this.K[i3] = 0, this.V[i3] = 1;
        this._update(n2), this._reseed = 1, this.reseedInterval = 281474976710656;
      }, a.prototype._hmac = function() {
        return new n.hmac(this.hash, this.K);
      }, a.prototype._update = function(t4) {
        var e3 = this._hmac().update(this.V).update([0]);
        t4 && (e3 = e3.update(t4)), this.K = e3.digest(), this.V = this._hmac().update(this.V).digest(), t4 && (this.K = this._hmac().update(this.V).update([1]).update(t4).digest(), this.V = this._hmac().update(this.V).digest());
      }, a.prototype.reseed = function(t4, e3, r3, n2) {
        "string" != typeof e3 && (n2 = r3, r3 = e3, e3 = null), t4 = i2.toArray(t4, e3), r3 = i2.toArray(r3, n2), o(t4.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t4.concat(r3 || [])), this._reseed = 1;
      }, a.prototype.generate = function(t4, e3, r3, n2) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        "string" != typeof e3 && (n2 = r3, r3 = e3, e3 = null), r3 && (r3 = i2.toArray(r3, n2 || "hex"), this._update(r3));
        for (var o2 = []; o2.length < t4; )
          this.V = this._hmac().update(this.V).digest(), o2 = o2.concat(this.V);
        var a2 = o2.slice(0, t4);
        return this._update(r3), this._reseed++, i2.encode(a2, e3);
      };
    }, 2486: (t3, e2) => {
      e2.read = function(t4, e3, r2, n, i2) {
        var o, a, s2 = 8 * i2 - n - 1, c = (1 << s2) - 1, u = c >> 1, f = -7, l = r2 ? i2 - 1 : 0, h2 = r2 ? -1 : 1, p = t4[e3 + l];
        for (l += h2, o = p & (1 << -f) - 1, p >>= -f, f += s2; f > 0; o = 256 * o + t4[e3 + l], l += h2, f -= 8)
          ;
        for (a = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; a = 256 * a + t4[e3 + l], l += h2, f -= 8)
          ;
        if (0 === o)
          o = 1 - u;
        else {
          if (o === c)
            return a ? NaN : 1 / 0 * (p ? -1 : 1);
          a += Math.pow(2, n), o -= u;
        }
        return (p ? -1 : 1) * a * Math.pow(2, o - n);
      }, e2.write = function(t4, e3, r2, n, i2, o) {
        var a, s2, c, u = 8 * o - i2 - 1, f = (1 << u) - 1, l = f >> 1, h2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, d2 = n ? 1 : -1, y2 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
        for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (s2 = isNaN(e3) ? 1 : 0, a = f) : (a = Math.floor(Math.log(e3) / Math.LN2), e3 * (c = Math.pow(2, -a)) < 1 && (a--, c *= 2), (e3 += a + l >= 1 ? h2 / c : h2 * Math.pow(2, 1 - l)) * c >= 2 && (a++, c /= 2), a + l >= f ? (s2 = 0, a = f) : a + l >= 1 ? (s2 = (e3 * c - 1) * Math.pow(2, i2), a += l) : (s2 = e3 * Math.pow(2, l - 1) * Math.pow(2, i2), a = 0)); i2 >= 8; t4[r2 + p] = 255 & s2, p += d2, s2 /= 256, i2 -= 8)
          ;
        for (a = a << i2 | s2, u += i2; u > 0; t4[r2 + p] = 255 & a, p += d2, a /= 256, u -= 8)
          ;
        t4[r2 + p - d2] |= 128 * y2;
      };
    }, 1679: (t3) => {
      "function" == typeof Object.create ? t3.exports = function(t4, e2) {
        e2 && (t4.super_ = e2, t4.prototype = Object.create(e2.prototype, { constructor: { value: t4, enumerable: false, writable: true, configurable: true } }));
      } : t3.exports = function(t4, e2) {
        if (e2) {
          t4.super_ = e2;
          var r2 = function() {
          };
          r2.prototype = e2.prototype, t4.prototype = new r2(), t4.prototype.constructor = t4;
        }
      };
    }, 5899: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(953)(), o = r2(9466)("Object.prototype.toString"), a = function(t4) {
        return !(i2 && t4 && "object" === n(t4) && Symbol.toStringTag in t4) && "[object Arguments]" === o(t4);
      }, s2 = function(t4) {
        return !!a(t4) || null !== t4 && "object" === n(t4) && "number" == typeof t4.length && t4.length >= 0 && "[object Array]" !== o(t4) && "[object Function]" === o(t4.callee);
      }, c = function() {
        return a(arguments);
      }();
      a.isLegacyArguments = s2, t3.exports = c ? a : s2;
    }, 9809: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2, n, i2 = Function.prototype.toString, o = "object" === ("undefined" == typeof Reflect ? "undefined" : e2(Reflect)) && null !== Reflect && Reflect.apply;
      if ("function" == typeof o && "function" == typeof Object.defineProperty)
        try {
          r2 = Object.defineProperty({}, "length", { get: function() {
            throw n;
          } }), n = {}, o(function() {
            throw 42;
          }, null, r2);
        } catch (t4) {
          t4 !== n && (o = null);
        }
      else
        o = null;
      var a = /^\s*class\b/, s2 = function(t4) {
        try {
          var e3 = i2.call(t4);
          return a.test(e3);
        } catch (t5) {
          return false;
        }
      }, c = function(t4) {
        try {
          return !s2(t4) && (i2.call(t4), true);
        } catch (t5) {
          return false;
        }
      }, u = Object.prototype.toString, f = "function" == typeof Symbol && !!Symbol.toStringTag, l = !(0 in [,]), h2 = function() {
        return false;
      };
      if ("object" === ("undefined" == typeof document ? "undefined" : e2(document))) {
        var p = document.all;
        u.call(p) === u.call(document.all) && (h2 = function(t4) {
          if ((l || !t4) && (void 0 === t4 || "object" === e2(t4)))
            try {
              var r3 = u.call(t4);
              return ("[object HTMLAllCollection]" === r3 || "[object HTML document.all class]" === r3 || "[object HTMLCollection]" === r3 || "[object Object]" === r3) && null == t4("");
            } catch (t5) {
            }
          return false;
        });
      }
      t3.exports = o ? function(t4) {
        if (h2(t4))
          return true;
        if (!t4)
          return false;
        if ("function" != typeof t4 && "object" !== e2(t4))
          return false;
        try {
          o(t4, null, r2);
        } catch (t5) {
          if (t5 !== n)
            return false;
        }
        return !s2(t4) && c(t4);
      } : function(t4) {
        if (h2(t4))
          return true;
        if (!t4)
          return false;
        if ("function" != typeof t4 && "object" !== e2(t4))
          return false;
        if (f)
          return c(t4);
        if (s2(t4))
          return false;
        var r3 = u.call(t4);
        return !("[object Function]" !== r3 && "[object GeneratorFunction]" !== r3 && !/^\[object HTML/.test(r3)) && c(t4);
      };
    }, 1905: (t3, e2, r2) => {
      var n, i2 = Object.prototype.toString, o = Function.prototype.toString, a = /^\s*(?:function)?\*/, s2 = r2(953)(), c = Object.getPrototypeOf;
      t3.exports = function(t4) {
        if ("function" != typeof t4)
          return false;
        if (a.test(o.call(t4)))
          return true;
        if (!s2)
          return "[object GeneratorFunction]" === i2.call(t4);
        if (!c)
          return false;
        if (void 0 === n) {
          var e3 = function() {
            if (!s2)
              return false;
            try {
              return Function("return function*() {}")();
            } catch (t5) {
            }
          }();
          n = !!e3 && c(e3);
        }
        return c(t4) === n;
      };
    }, 118: (t3) => {
      t3.exports = function(t4) {
        return t4 != t4;
      };
    }, 6062: (t3, e2, r2) => {
      var n = r2(9122), i2 = r2(2273), o = r2(118), a = r2(4183), s2 = r2(5497), c = n(a(), Number);
      i2(c, { getPolyfill: a, implementation: o, shim: s2 }), t3.exports = c;
    }, 4183: (t3, e2, r2) => {
      var n = r2(118);
      t3.exports = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : n;
      };
    }, 5497: (t3, e2, r2) => {
      var n = r2(2273), i2 = r2(4183);
      t3.exports = function() {
        var t4 = i2();
        return n(Number, { isNaN: t4 }, { isNaN: function() {
          return Number.isNaN !== t4;
        } }), t4;
      };
    }, 7911: (t3, e2, r2) => {
      var n = r2(9834);
      t3.exports = function(t4) {
        return !!n(t4);
      };
    }, 5455: (t3) => {
      var e2 = {}.toString;
      t3.exports = Array.isArray || function(t4) {
        return "[object Array]" == e2.call(t4);
      };
    }, 8297: (t3) => {
      function e2(t4, e3) {
        var r3 = "undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"];
        if (!r3) {
          if (Array.isArray(t4) || (r3 = n(t4)) || e3 && t4 && "number" == typeof t4.length) {
            r3 && (t4 = r3);
            var i3 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return i3 >= t4.length ? { done: true } : { done: false, value: t4[i3++] };
            }, e: function(t5) {
              throw t5;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a2, s3 = true, c2 = false;
        return { s: function() {
          r3 = r3.call(t4);
        }, n: function() {
          var t5 = r3.next();
          return s3 = t5.done, t5;
        }, e: function(t5) {
          c2 = true, a2 = t5;
        }, f: function() {
          try {
            s3 || null == r3.return || r3.return();
          } finally {
            if (c2)
              throw a2;
          }
        } };
      }
      function r2(t4) {
        return r2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, r2(t4);
      }
      function n(t4, e3) {
        if (t4) {
          if ("string" == typeof t4)
            return i2(t4, e3);
          var r3 = Object.prototype.toString.call(t4).slice(8, -1);
          return "Object" === r3 && t4.constructor && (r3 = t4.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t4) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? i2(t4, e3) : void 0;
        }
      }
      function i2(t4, e3) {
        (null == e3 || e3 > t4.length) && (e3 = t4.length);
        for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
          n2[r3] = t4[r3];
        return n2;
      }
      function o(t4, e3, r3) {
        if (a())
          return Reflect.construct.apply(null, arguments);
        var n2 = [null];
        n2.push.apply(n2, e3);
        var i3 = new (t4.bind.apply(t4, n2))();
        return r3 && s2(i3, r3.prototype), i3;
      }
      function a() {
        try {
          var t4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t5) {
        }
        return (a = function() {
          return !!t4;
        })();
      }
      function s2(t4, e3) {
        return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e4) {
          return t5.__proto__ = e4, t5;
        }, s2(t4, e3);
      }
      function c() {
        this._pres = /* @__PURE__ */ new Map(), this._posts = /* @__PURE__ */ new Map();
      }
      function u(t4, e3, r3, n2, i3, o2, a2) {
        return o2.useErrorHandlers ? t4.execPost(r3, n2, i3, { error: e3 }, function(t5) {
          return "function" == typeof a2 && a2(t5);
        }) : "function" == typeof a2 && a2(e3);
      }
      function f(t4, e3, r3, n2) {
        var i3;
        try {
          i3 = t4.apply(e3, r3);
        } catch (t5) {
          return n2(t5);
        }
        l(i3) && i3.then(function() {
          return n2();
        }, function(t5) {
          return n2(t5);
        });
      }
      function l(t4) {
        return "object" === r2(t4) && null !== t4 && "function" == typeof t4.then;
      }
      function h2(t4) {
        var e3 = false, r3 = this;
        return function() {
          var n2 = arguments;
          if (!e3)
            return e3 = true, p(function() {
              return t4.apply(r3, n2);
            });
        };
      }
      c.skipWrappedFunction = function() {
        if (!(this instanceof c.skipWrappedFunction))
          return o(c.skipWrappedFunction, Array.prototype.slice.call(arguments));
        this.args = Array.prototype.slice.call(arguments);
      }, c.overwriteResult = function() {
        if (!(this instanceof c.overwriteResult))
          return o(c.overwriteResult, Array.prototype.slice.call(arguments));
        this.args = Array.prototype.slice.call(arguments);
      }, c.prototype.execPre = function(t4, e3, r3, n2) {
        3 === arguments.length && (n2 = r3, r3 = []);
        var i3 = this._pres.get(t4) || [], o2 = i3.length, a2 = i3.numAsync || 0, s3 = 0, u2 = a2, d3 = false, y2 = r3, b = null;
        if (!o2)
          return p(function() {
            n2(null);
          });
        function m2() {
          if (!(s3 >= o2)) {
            var t5 = i3[s3];
            if (t5.isAsync) {
              var r4 = [h2(v), h2(function(t6) {
                if (t6) {
                  if (d3)
                    return;
                  if (!(t6 instanceof c.skipWrappedFunction))
                    return d3 = true, n2(t6);
                  b = t6;
                }
                if (0 == --u2 && s3 >= o2)
                  return n2(b);
              })];
              f(t5.fn, e3, r4, r4[0]);
            } else if (t5.fn.length > 0) {
              for (var a3 = [h2(v)], g = arguments.length >= 2 ? arguments : [null].concat(y2), _ = 1; _ < g.length; ++_)
                _ === g.length - 1 && "function" == typeof g[_] || a3.push(g[_]);
              f(t5.fn, e3, a3, a3[0]);
            } else {
              var w2 = null;
              try {
                w2 = t5.fn.call(e3);
              } catch (t6) {
                if (null != t6)
                  return n2(t6);
              }
              if (l(w2))
                w2.then(function() {
                  return v();
                }, function(t6) {
                  return v(t6);
                });
              else {
                if (++s3 >= o2)
                  return u2 > 0 ? void 0 : p(function() {
                    n2(b);
                  });
                m2();
              }
            }
          }
        }
        function v(t5) {
          if (t5) {
            if (d3)
              return;
            if (!(t5 instanceof c.skipWrappedFunction))
              return d3 = true, n2(t5);
            b = t5;
          }
          if (++s3 >= o2)
            return u2 > 0 ? void 0 : n2(b);
          m2.apply(e3, arguments);
        }
        m2.apply(null, [null].concat(r3));
      }, c.prototype.execPreSync = function(t4, e3, r3) {
        for (var n2 = this._pres.get(t4) || [], i3 = n2.length, o2 = 0; o2 < i3; ++o2)
          n2[o2].fn.apply(e3, r3 || []);
      }, c.prototype.execPost = function(t4, e3, r3, n2, i3) {
        arguments.length < 5 && (i3 = n2, n2 = null);
        var o2 = this._posts.get(t4) || [], a2 = o2.length, s3 = 0, u2 = null;
        if (n2 && n2.error && (u2 = n2.error), !a2)
          return p(function() {
            i3.apply(null, [u2].concat(r3));
          });
        !function t5() {
          for (var n3 = o2[s3].fn, p2 = 0, y2 = r3.length, b = [], m2 = 0; m2 < y2; ++m2)
            p2 += r3[m2] && r3[m2]._kareemIgnore ? 0 : 1, r3[m2] && r3[m2]._kareemIgnore || b.push(r3[m2]);
          if (u2)
            if (d2(o2[s3], p2)) {
              var v = h2(function(e4) {
                if (e4) {
                  if (e4 instanceof c.overwriteResult)
                    return r3 = e4.args, ++s3 >= a2 ? i3.call(null, u2) : t5();
                  u2 = e4;
                }
                if (++s3 >= a2)
                  return i3.call(null, u2);
                t5();
              });
              f(n3, e3, [u2].concat(b).concat([v]), v);
            } else {
              if (++s3 >= a2)
                return i3.call(null, u2);
              t5();
            }
          else {
            var g = h2(function(e4) {
              return e4 ? e4 instanceof c.overwriteResult ? (r3 = e4.args, ++s3 >= a2 ? i3.apply(null, [null].concat(r3)) : t5()) : (u2 = e4, t5()) : ++s3 >= a2 ? i3.apply(null, [null].concat(r3)) : void t5();
            });
            if (d2(o2[s3], p2))
              return ++s3 >= a2 ? i3.apply(null, [null].concat(r3)) : t5();
            if (n3.length === p2 + 1)
              f(n3, e3, b.concat([g]), g);
            else {
              var _, w2;
              try {
                w2 = n3.apply(e3, b);
              } catch (t6) {
                _ = t6, u2 = t6;
              }
              if (l(w2))
                return w2.then(function(t6) {
                  g(t6 instanceof c.overwriteResult ? t6 : null);
                }, function(t6) {
                  return g(t6);
                });
              if (w2 instanceof c.overwriteResult && (r3 = w2.args), ++s3 >= a2)
                return i3.apply(null, [_].concat(r3));
              t5();
            }
          }
        }();
      }, c.prototype.execPostSync = function(t4, e3, r3) {
        for (var n2 = this._posts.get(t4) || [], i3 = n2.length, o2 = 0; o2 < i3; ++o2) {
          var a2 = n2[o2].fn.apply(e3, r3 || []);
          a2 instanceof c.overwriteResult && (r3 = a2.args);
        }
        return r3;
      }, c.prototype.createWrapperSync = function(t4, e3) {
        var r3 = this;
        return function() {
          r3.execPreSync(t4, this, arguments);
          var n2 = e3.apply(this, arguments);
          return r3.execPostSync(t4, this, [n2])[0];
        };
      }, c.prototype.wrap = function(t4, e3, r3, o2, a2) {
        var s3 = o2.length > 0 ? o2[o2.length - 1] : null, f2 = Array.from(o2);
        "function" == typeof s3 && f2.pop();
        var h3 = this, p2 = (a2 = a2 || {}).checkForPromise;
        this.execPre(t4, r3, o2, function(o3) {
          if (o3 && !(o3 instanceof c.skipWrappedFunction)) {
            for (var d3 = a2.numCallbackParams || 0, y2 = a2.contextParameter ? [r3] : [], b = y2.length; b < d3; ++b)
              y2.push(null);
            return u(h3, o3, t4, r3, y2, a2, s3);
          }
          var m2, v, g = e3.length;
          if (o3 instanceof c.skipWrappedFunction)
            return m2 = o3.args[0], _.apply(void 0, [null].concat(function(t5) {
              if (Array.isArray(t5))
                return i2(t5);
            }(v = o3.args) || function(t5) {
              if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
                return Array.from(t5);
            }(v) || n(v) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }()));
          try {
            m2 = e3.apply(r3, f2.concat(_));
          } catch (t5) {
            return _(t5);
          }
          if (p2) {
            if (l(m2))
              return m2.then(function(t5) {
                return _(null, t5);
              }, function(t5) {
                return _(t5);
              });
            if (g < f2.length + 1)
              return _(null, m2);
          }
          function _() {
            var e4 = Array.from(arguments);
            if (e4.shift(), a2.nullResultByDefault && 0 === e4.length && e4.push(null), arguments[0])
              return u(h3, arguments[0], t4, r3, e4, a2, s3);
            h3.execPost(t4, r3, e4, function() {
              null !== s3 && (arguments[0] ? s3(arguments[0]) : s3.apply(r3, arguments));
            });
          }
        });
      }, c.prototype.filter = function(t4) {
        for (var e3 = this, r3 = this.clone(), n2 = Array.from(r3._pres.keys()), i3 = function() {
          var n3 = a2[o2], i4 = e3._pres.get(n3).map(function(t5) {
            return Object.assign({}, t5, { name: n3 });
          }).filter(t4);
          if (0 === i4.length)
            return r3._pres.delete(n3), 1;
          i4.numAsync = i4.filter(function(t5) {
            return t5.isAsync;
          }).length, r3._pres.set(n3, i4);
        }, o2 = 0, a2 = n2; o2 < a2.length; o2++)
          i3();
        for (var s3 = Array.from(r3._posts.keys()), c2 = function() {
          var n3 = f2[u2], i4 = e3._posts.get(n3).map(function(t5) {
            return Object.assign({}, t5, { name: n3 });
          }).filter(t4);
          if (0 === i4.length)
            return r3._posts.delete(n3), 1;
          r3._posts.set(n3, i4);
        }, u2 = 0, f2 = s3; u2 < f2.length; u2++)
          c2();
        return r3;
      }, c.prototype.hasHooks = function(t4) {
        return this._pres.has(t4) || this._posts.has(t4);
      }, c.prototype.createWrapper = function(t4, e3, r3, n2) {
        var i3 = this;
        return this.hasHooks(t4) ? function() {
          var o2 = r3 || this;
          i3.wrap(t4, e3, o2, Array.from(arguments), n2);
        } : function() {
          var t5 = arguments, r4 = this;
          p(function() {
            return e3.apply(r4, t5);
          });
        };
      }, c.prototype.pre = function(t4, e3, n2, i3, o2) {
        var a2 = {};
        "object" === r2(e3) && null !== e3 ? e3 = (a2 = e3).isAsync : "boolean" != typeof arguments[1] && (n2 = e3, e3 = false);
        var s3 = this._pres.get(t4) || [];
        if (this._pres.set(t4, s3), e3 && (s3.numAsync = s3.numAsync || 0, ++s3.numAsync), "function" != typeof n2)
          throw new Error('pre() requires a function, got "' + r2(n2) + '"');
        return o2 ? s3.unshift(Object.assign({}, a2, { fn: n2, isAsync: e3 })) : s3.push(Object.assign({}, a2, { fn: n2, isAsync: e3 })), this;
      }, c.prototype.post = function(t4, e3, n2, i3) {
        var o2 = this._posts.get(t4) || [];
        if ("function" == typeof e3 && (i3 = !!n2, n2 = e3, e3 = {}), "function" != typeof n2)
          throw new Error('post() requires a function, got "' + r2(n2) + '"');
        return i3 ? o2.unshift(Object.assign({}, e3, { fn: n2 })) : o2.push(Object.assign({}, e3, { fn: n2 })), this._posts.set(t4, o2), this;
      }, c.prototype.clone = function() {
        var t4, r3 = new c(), n2 = e2(this._pres.keys());
        try {
          for (n2.s(); !(t4 = n2.n()).done; ) {
            var i3 = t4.value, o2 = this._pres.get(i3).slice();
            o2.numAsync = this._pres.get(i3).numAsync, r3._pres.set(i3, o2);
          }
        } catch (t5) {
          n2.e(t5);
        } finally {
          n2.f();
        }
        var a2, s3 = e2(this._posts.keys());
        try {
          for (s3.s(); !(a2 = s3.n()).done; ) {
            var u2 = a2.value;
            r3._posts.set(u2, this._posts.get(u2).slice());
          }
        } catch (t5) {
          s3.e(t5);
        } finally {
          s3.f();
        }
        return r3;
      }, c.prototype.merge = function(t4, r3) {
        var n2, i3 = (r3 = 1 === arguments.length || r3) ? this.clone() : this, o2 = e2(t4._pres.keys());
        try {
          var a2 = function() {
            var e3 = n2.value, r4 = i3._pres.get(e3) || [], o3 = t4._pres.get(e3).filter(function(t5) {
              return -1 === r4.map(function(t6) {
                return t6.fn;
              }).indexOf(t5.fn);
            }), a3 = r4.concat(o3);
            a3.numAsync = r4.numAsync || 0, a3.numAsync += o3.filter(function(t5) {
              return t5.isAsync;
            }).length, i3._pres.set(e3, a3);
          };
          for (o2.s(); !(n2 = o2.n()).done; )
            a2();
        } catch (t5) {
          o2.e(t5);
        } finally {
          o2.f();
        }
        var s3, c2 = e2(t4._posts.keys());
        try {
          var u2 = function() {
            var e3 = s3.value, r4 = i3._posts.get(e3) || [], n3 = t4._posts.get(e3).filter(function(t5) {
              return -1 === r4.indexOf(t5);
            });
            i3._posts.set(e3, r4.concat(n3));
          };
          for (c2.s(); !(s3 = c2.n()).done; )
            u2();
        } catch (t5) {
          c2.e(t5);
        } finally {
          c2.f();
        }
        return i3;
      };
      var p = "object" === (void 0 === { env: {} } ? "undefined" : r2({ env: {} })) && null !== { env: {} } && { env: {} }.nextTick || function(t4) {
        setTimeout(t4, 0);
      };
      function d2(t4, e3) {
        return !!t4.errorHandler || t4.fn.length === e3 + 2;
      }
      t3.exports = c;
    }, 2635: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(6936), o = r2(9732).Buffer, a = new Array(16);
      function s2() {
        i2.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
      }
      function c(t4, e3) {
        return t4 << e3 | t4 >>> 32 - e3;
      }
      function u(t4, e3, r3, n2, i3, o2, a2) {
        return c(t4 + (e3 & r3 | ~e3 & n2) + i3 + o2 | 0, a2) + e3 | 0;
      }
      function f(t4, e3, r3, n2, i3, o2, a2) {
        return c(t4 + (e3 & n2 | r3 & ~n2) + i3 + o2 | 0, a2) + e3 | 0;
      }
      function l(t4, e3, r3, n2, i3, o2, a2) {
        return c(t4 + (e3 ^ r3 ^ n2) + i3 + o2 | 0, a2) + e3 | 0;
      }
      function h2(t4, e3, r3, n2, i3, o2, a2) {
        return c(t4 + (r3 ^ (e3 | ~n2)) + i3 + o2 | 0, a2) + e3 | 0;
      }
      n(s2, i2), s2.prototype._update = function() {
        for (var t4 = a, e3 = 0; e3 < 16; ++e3)
          t4[e3] = this._block.readInt32LE(4 * e3);
        var r3 = this._a, n2 = this._b, i3 = this._c, o2 = this._d;
        r3 = u(r3, n2, i3, o2, t4[0], 3614090360, 7), o2 = u(o2, r3, n2, i3, t4[1], 3905402710, 12), i3 = u(i3, o2, r3, n2, t4[2], 606105819, 17), n2 = u(n2, i3, o2, r3, t4[3], 3250441966, 22), r3 = u(r3, n2, i3, o2, t4[4], 4118548399, 7), o2 = u(o2, r3, n2, i3, t4[5], 1200080426, 12), i3 = u(i3, o2, r3, n2, t4[6], 2821735955, 17), n2 = u(n2, i3, o2, r3, t4[7], 4249261313, 22), r3 = u(r3, n2, i3, o2, t4[8], 1770035416, 7), o2 = u(o2, r3, n2, i3, t4[9], 2336552879, 12), i3 = u(i3, o2, r3, n2, t4[10], 4294925233, 17), n2 = u(n2, i3, o2, r3, t4[11], 2304563134, 22), r3 = u(r3, n2, i3, o2, t4[12], 1804603682, 7), o2 = u(o2, r3, n2, i3, t4[13], 4254626195, 12), i3 = u(i3, o2, r3, n2, t4[14], 2792965006, 17), r3 = f(r3, n2 = u(n2, i3, o2, r3, t4[15], 1236535329, 22), i3, o2, t4[1], 4129170786, 5), o2 = f(o2, r3, n2, i3, t4[6], 3225465664, 9), i3 = f(i3, o2, r3, n2, t4[11], 643717713, 14), n2 = f(n2, i3, o2, r3, t4[0], 3921069994, 20), r3 = f(r3, n2, i3, o2, t4[5], 3593408605, 5), o2 = f(o2, r3, n2, i3, t4[10], 38016083, 9), i3 = f(i3, o2, r3, n2, t4[15], 3634488961, 14), n2 = f(n2, i3, o2, r3, t4[4], 3889429448, 20), r3 = f(r3, n2, i3, o2, t4[9], 568446438, 5), o2 = f(o2, r3, n2, i3, t4[14], 3275163606, 9), i3 = f(i3, o2, r3, n2, t4[3], 4107603335, 14), n2 = f(n2, i3, o2, r3, t4[8], 1163531501, 20), r3 = f(r3, n2, i3, o2, t4[13], 2850285829, 5), o2 = f(o2, r3, n2, i3, t4[2], 4243563512, 9), i3 = f(i3, o2, r3, n2, t4[7], 1735328473, 14), r3 = l(r3, n2 = f(n2, i3, o2, r3, t4[12], 2368359562, 20), i3, o2, t4[5], 4294588738, 4), o2 = l(o2, r3, n2, i3, t4[8], 2272392833, 11), i3 = l(i3, o2, r3, n2, t4[11], 1839030562, 16), n2 = l(n2, i3, o2, r3, t4[14], 4259657740, 23), r3 = l(r3, n2, i3, o2, t4[1], 2763975236, 4), o2 = l(o2, r3, n2, i3, t4[4], 1272893353, 11), i3 = l(i3, o2, r3, n2, t4[7], 4139469664, 16), n2 = l(n2, i3, o2, r3, t4[10], 3200236656, 23), r3 = l(r3, n2, i3, o2, t4[13], 681279174, 4), o2 = l(o2, r3, n2, i3, t4[0], 3936430074, 11), i3 = l(i3, o2, r3, n2, t4[3], 3572445317, 16), n2 = l(n2, i3, o2, r3, t4[6], 76029189, 23), r3 = l(r3, n2, i3, o2, t4[9], 3654602809, 4), o2 = l(o2, r3, n2, i3, t4[12], 3873151461, 11), i3 = l(i3, o2, r3, n2, t4[15], 530742520, 16), r3 = h2(r3, n2 = l(n2, i3, o2, r3, t4[2], 3299628645, 23), i3, o2, t4[0], 4096336452, 6), o2 = h2(o2, r3, n2, i3, t4[7], 1126891415, 10), i3 = h2(i3, o2, r3, n2, t4[14], 2878612391, 15), n2 = h2(n2, i3, o2, r3, t4[5], 4237533241, 21), r3 = h2(r3, n2, i3, o2, t4[12], 1700485571, 6), o2 = h2(o2, r3, n2, i3, t4[3], 2399980690, 10), i3 = h2(i3, o2, r3, n2, t4[10], 4293915773, 15), n2 = h2(n2, i3, o2, r3, t4[1], 2240044497, 21), r3 = h2(r3, n2, i3, o2, t4[8], 1873313359, 6), o2 = h2(o2, r3, n2, i3, t4[15], 4264355552, 10), i3 = h2(i3, o2, r3, n2, t4[6], 2734768916, 15), n2 = h2(n2, i3, o2, r3, t4[13], 1309151649, 21), r3 = h2(r3, n2, i3, o2, t4[4], 4149444226, 6), o2 = h2(o2, r3, n2, i3, t4[11], 3174756917, 10), i3 = h2(i3, o2, r3, n2, t4[2], 718787259, 15), n2 = h2(n2, i3, o2, r3, t4[9], 3951481745, 21), this._a = this._a + r3 | 0, this._b = this._b + n2 | 0, this._c = this._c + i3 | 0, this._d = this._d + o2 | 0;
      }, s2.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t4 = o.allocUnsafe(16);
        return t4.writeInt32LE(this._a, 0), t4.writeInt32LE(this._b, 4), t4.writeInt32LE(this._c, 8), t4.writeInt32LE(this._d, 12), t4;
      }, t3.exports = s2;
    }, 1257: (t3, e2, r2) => {
      var n = r2(7799), i2 = r2(8904);
      function o(t4) {
        this.rand = t4 || new i2.Rand();
      }
      t3.exports = o, o.create = function(t4) {
        return new o(t4);
      }, o.prototype._randbelow = function(t4) {
        var e3 = t4.bitLength(), r3 = Math.ceil(e3 / 8);
        do {
          var i3 = new n(this.rand.generate(r3));
        } while (i3.cmp(t4) >= 0);
        return i3;
      }, o.prototype._randrange = function(t4, e3) {
        var r3 = e3.sub(t4);
        return t4.add(this._randbelow(r3));
      }, o.prototype.test = function(t4, e3, r3) {
        var i3 = t4.bitLength(), o2 = n.mont(t4), a = new n(1).toRed(o2);
        e3 || (e3 = Math.max(1, i3 / 48 | 0));
        for (var s2 = t4.subn(1), c = 0; !s2.testn(c); c++)
          ;
        for (var u = t4.shrn(c), f = s2.toRed(o2); e3 > 0; e3--) {
          var l = this._randrange(new n(2), s2);
          r3 && r3(l);
          var h2 = l.toRed(o2).redPow(u);
          if (0 !== h2.cmp(a) && 0 !== h2.cmp(f)) {
            for (var p = 1; p < c; p++) {
              if (0 === (h2 = h2.redSqr()).cmp(a))
                return false;
              if (0 === h2.cmp(f))
                break;
            }
            if (p === c)
              return false;
          }
        }
        return true;
      }, o.prototype.getDivisor = function(t4, e3) {
        var r3 = t4.bitLength(), i3 = n.mont(t4), o2 = new n(1).toRed(i3);
        e3 || (e3 = Math.max(1, r3 / 48 | 0));
        for (var a = t4.subn(1), s2 = 0; !a.testn(s2); s2++)
          ;
        for (var c = t4.shrn(s2), u = a.toRed(i3); e3 > 0; e3--) {
          var f = this._randrange(new n(2), a), l = t4.gcd(f);
          if (0 !== l.cmpn(1))
            return l;
          var h2 = f.toRed(i3).redPow(c);
          if (0 !== h2.cmp(o2) && 0 !== h2.cmp(u)) {
            for (var p = 1; p < s2; p++) {
              if (0 === (h2 = h2.redSqr()).cmp(o2))
                return h2.fromRed().subn(1).gcd(t4);
              if (0 === h2.cmp(u))
                break;
            }
            if (p === s2)
              return (h2 = h2.redSqr()).fromRed().subn(1).gcd(t4);
          }
        }
        return false;
      };
    }, 3528: (t3) => {
      function e2(t4, e3) {
        if (!t4)
          throw new Error(e3 || "Assertion failed");
      }
      t3.exports = e2, e2.equal = function(t4, e3, r2) {
        if (t4 != e3)
          throw new Error(r2 || "Assertion failed: " + t4 + " != " + e3);
      };
    }, 6706: (t3, e2) => {
      var r2 = e2;
      function n(t4) {
        return 1 === t4.length ? "0" + t4 : t4;
      }
      function i2(t4) {
        for (var e3 = "", r3 = 0; r3 < t4.length; r3++)
          e3 += n(t4[r3].toString(16));
        return e3;
      }
      r2.toArray = function(t4, e3) {
        if (Array.isArray(t4))
          return t4.slice();
        if (!t4)
          return [];
        var r3 = [];
        if ("string" != typeof t4) {
          for (var n2 = 0; n2 < t4.length; n2++)
            r3[n2] = 0 | t4[n2];
          return r3;
        }
        if ("hex" === e3)
          for ((t4 = t4.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t4 = "0" + t4), n2 = 0; n2 < t4.length; n2 += 2)
            r3.push(parseInt(t4[n2] + t4[n2 + 1], 16));
        else
          for (n2 = 0; n2 < t4.length; n2++) {
            var i3 = t4.charCodeAt(n2), o = i3 >> 8, a = 255 & i3;
            o ? r3.push(o, a) : r3.push(a);
          }
        return r3;
      }, r2.zero2 = n, r2.toHex = i2, r2.encode = function(t4, e3) {
        return "hex" === e3 ? i2(t4) : t4;
      };
    }, 5678: (t3, e2, r2) => {
      t3.exports = r2(2914);
    }, 2914: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(7860), o = ["__proto__", "constructor", "prototype"];
      function a(t4, e3, r3, n2, i3, o2) {
        for (var s3, c = 0; c < t4.length && c < e3.length; ++c)
          s3 = t4[c], Array.isArray(s3) && Array.isArray(e3[c]) ? a(s3, e3[c], r3, n2, i3, o2) : s3 && (n2 ? n2(s3, r3, o2(e3[c])) : (s3[i3] && (s3 = s3[i3]), s3[r3] = o2(e3[c])));
      }
      function s2(t4) {
        return t4;
      }
      e2.get = function(t4, r3, o2, a2) {
        var c;
        "function" == typeof o2 && (o2.length < 2 ? (a2 = o2, o2 = void 0) : (c = o2, o2 = void 0)), a2 || (a2 = s2);
        var u = "string" == typeof t4 ? i2(t4) : t4;
        if (!Array.isArray(u))
          throw new TypeError("Invalid `path`. Must be either string or array");
        for (var f, l = r3, h2 = 0; h2 < u.length; ++h2) {
          if (f = u[h2], "string" != typeof u[h2] && "number" != typeof u[h2])
            throw new TypeError("Each segment of path to `get()` must be a string or number, got " + n(u[h2]));
          if (Array.isArray(l) && !/^\d+$/.test(f)) {
            var p = u.slice(h2);
            return [].concat(l).map(function(t5) {
              return t5 ? e2.get(p, t5, o2 || c, a2) : a2(void 0);
            });
          }
          if (c)
            l = c(l, f);
          else {
            var d2 = o2 && l[o2] ? l[o2] : l;
            l = d2 instanceof Map ? d2.get(f) : d2[f];
          }
          if (!l)
            return a2(l);
        }
        return a2(l);
      }, e2.has = function(t4, e3) {
        var r3 = "string" == typeof t4 ? i2(t4) : t4;
        if (!Array.isArray(r3))
          throw new TypeError("Invalid `path`. Must be either string or array");
        for (var o2 = r3.length, a2 = e3, s3 = 0; s3 < o2; ++s3) {
          if ("string" != typeof r3[s3] && "number" != typeof r3[s3])
            throw new TypeError("Each segment of path to `has()` must be a string or number, got " + n(r3[s3]));
          if (null == a2 || "object" !== n(a2) || !(r3[s3] in a2))
            return false;
          a2 = a2[r3[s3]];
        }
        return true;
      }, e2.unset = function(t4, e3) {
        var r3 = "string" == typeof t4 ? i2(t4) : t4;
        if (!Array.isArray(r3))
          throw new TypeError("Invalid `path`. Must be either string or array");
        for (var a2 = r3.length, s3 = e3, c = 0; c < a2; ++c) {
          if (null == s3 || "object" !== n(s3) || !(r3[c] in s3))
            return false;
          if ("string" != typeof r3[c] && "number" != typeof r3[c])
            throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + n(r3[c]));
          if (-1 !== o.indexOf(r3[c]))
            return false;
          if (c === a2 - 1)
            return delete s3[r3[c]], true;
          s3 = s3 instanceof Map ? s3.get(r3[c]) : s3[r3[c]];
        }
        return true;
      }, e2.set = function(t4, r3, c, u, f, l) {
        var h2;
        "function" == typeof u && (u.length < 2 ? (f = u, u = void 0) : (h2 = u, u = void 0)), f || (f = s2);
        var p = "string" == typeof t4 ? i2(t4) : t4;
        if (!Array.isArray(p))
          throw new TypeError("Invalid `path`. Must be either string or array");
        if (null != c) {
          for (var d2 = 0; d2 < p.length; ++d2) {
            if ("string" != typeof p[d2] && "number" != typeof p[d2])
              throw new TypeError("Each segment of path to `set()` must be a string or number, got " + n(p[d2]));
            if (-1 !== o.indexOf(p[d2]))
              return;
          }
          for (var y2, b = l || /\$/.test(t4) && false !== l, m2 = c, v = (d2 = 0, p.length - 1); d2 < v; ++d2)
            if ("$" != (y2 = p[d2])) {
              if (Array.isArray(m2) && !/^\d+$/.test(y2)) {
                var g = p.slice(d2);
                if (!b && Array.isArray(r3))
                  for (var _ = 0; _ < m2.length && _ < r3.length; ++_)
                    e2.set(g, r3[_], m2[_], u || h2, f, b);
                else
                  for (_ = 0; _ < m2.length; ++_)
                    e2.set(g, r3, m2[_], u || h2, f, b);
                return;
              }
              if (h2)
                m2 = h2(m2, y2);
              else {
                var w2 = u && m2[u] ? m2[u] : m2;
                m2 = w2 instanceof Map ? w2.get(y2) : w2[y2];
              }
              if (!m2)
                return;
            } else if (d2 == v - 1)
              break;
          if (y2 = p[v], u && m2[u] && (m2 = m2[u]), Array.isArray(m2) && !/^\d+$/.test(y2))
            if (!b && Array.isArray(r3))
              a(m2, r3, y2, h2, u, f);
            else
              for (_ = 0; _ < m2.length; ++_) {
                var S = m2[_];
                S && (h2 ? h2(S, y2, f(r3)) : (S[u] && (S = S[u]), S[y2] = f(r3)));
              }
          else
            h2 ? h2(m2, y2, f(r3)) : m2 instanceof Map ? m2.set(y2, f(r3)) : m2[y2] = f(r3);
        }
      }, e2.stringToParts = i2;
    }, 7860: (t3) => {
      t3.exports = function(t4) {
        for (var e2 = [], r2 = "", n = "DEFAULT", i2 = 0; i2 < t4.length; ++i2)
          "IN_SQUARE_BRACKETS" !== n || /\d/.test(t4[i2]) || "]" === t4[i2] || (n = "DEFAULT", r2 = e2[e2.length - 1] + "[" + r2, e2.splice(e2.length - 1, 1)), "[" === t4[i2] ? ("IMMEDIATELY_AFTER_SQUARE_BRACKETS" !== n && (e2.push(r2), r2 = ""), n = "IN_SQUARE_BRACKETS") : "]" === t4[i2] ? "IN_SQUARE_BRACKETS" === n ? (n = "IMMEDIATELY_AFTER_SQUARE_BRACKETS", e2.push(r2), r2 = "") : (n = "DEFAULT", r2 += t4[i2]) : "." === t4[i2] ? ("IMMEDIATELY_AFTER_SQUARE_BRACKETS" !== n && (e2.push(r2), r2 = ""), n = "DEFAULT") : r2 += t4[i2];
        return "IMMEDIATELY_AFTER_SQUARE_BRACKETS" !== n && e2.push(r2), e2;
      };
    }, 354: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2 = 1e3, n = 60 * r2, i2 = 60 * n, o = 24 * i2, a = 7 * o;
      function s2(t4, e3, r3, n2) {
        var i3 = e3 >= 1.5 * r3;
        return Math.round(t4 / r3) + " " + n2 + (i3 ? "s" : "");
      }
      t3.exports = function(t4, c) {
        c = c || {};
        var u, f, l = e2(t4);
        if ("string" === l && t4.length > 0)
          return function(t5) {
            if (!((t5 = String(t5)).length > 100)) {
              var e3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t5);
              if (e3) {
                var s3 = parseFloat(e3[1]);
                switch ((e3[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * s3;
                  case "weeks":
                  case "week":
                  case "w":
                    return s3 * a;
                  case "days":
                  case "day":
                  case "d":
                    return s3 * o;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return s3 * i2;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return s3 * n;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return s3 * r2;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return s3;
                  default:
                    return;
                }
              }
            }
          }(t4);
        if ("number" === l && isFinite(t4))
          return c.long ? (u = t4, (f = Math.abs(u)) >= o ? s2(u, f, o, "day") : f >= i2 ? s2(u, f, i2, "hour") : f >= n ? s2(u, f, n, "minute") : f >= r2 ? s2(u, f, r2, "second") : u + " ms") : function(t5) {
            var e3 = Math.abs(t5);
            return e3 >= o ? Math.round(t5 / o) + "d" : e3 >= i2 ? Math.round(t5 / i2) + "h" : e3 >= n ? Math.round(t5 / n) + "m" : e3 >= r2 ? Math.round(t5 / r2) + "s" : t5 + "ms";
          }(t4);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t4));
      };
    }, 4756: (t3) => {
      var e2 = function(t4) {
        return t4 != t4;
      };
      t3.exports = function(t4, r2) {
        return 0 === t4 && 0 === r2 ? 1 / t4 == 1 / r2 : t4 === r2 || !(!e2(t4) || !e2(r2));
      };
    }, 2064: (t3, e2, r2) => {
      var n = r2(2273), i2 = r2(9122), o = r2(4756), a = r2(2481), s2 = r2(9247), c = i2(a(), Object);
      n(c, { getPolyfill: a, implementation: o, shim: s2 }), t3.exports = c;
    }, 2481: (t3, e2, r2) => {
      var n = r2(4756);
      t3.exports = function() {
        return "function" == typeof Object.is ? Object.is : n;
      };
    }, 9247: (t3, e2, r2) => {
      var n = r2(2481), i2 = r2(2273);
      t3.exports = function() {
        var t4 = n();
        return i2(Object, { is: t4 }, { is: function() {
          return Object.is !== t4;
        } }), t4;
      };
    }, 6544: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2;
      if (!Object.keys) {
        var o = Object.prototype.hasOwnProperty, a = Object.prototype.toString, s2 = r2(6312), c = Object.prototype.propertyIsEnumerable, u = !c.call({ toString: null }, "toString"), f = c.call(function() {
        }, "prototype"), l = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], h2 = function(t4) {
          var e3 = t4.constructor;
          return e3 && e3.prototype === t4;
        }, p = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, d2 = function() {
          if ("undefined" == typeof window)
            return false;
          for (var t4 in window)
            try {
              if (!p["$" + t4] && o.call(window, t4) && null !== window[t4] && "object" === n(window[t4]))
                try {
                  h2(window[t4]);
                } catch (t5) {
                  return true;
                }
            } catch (t5) {
              return true;
            }
          return false;
        }();
        i2 = function(t4) {
          var e3 = null !== t4 && "object" === n(t4), r3 = "[object Function]" === a.call(t4), i3 = s2(t4), c2 = e3 && "[object String]" === a.call(t4), p2 = [];
          if (!e3 && !r3 && !i3)
            throw new TypeError("Object.keys called on a non-object");
          var y2 = f && r3;
          if (c2 && t4.length > 0 && !o.call(t4, 0))
            for (var b = 0; b < t4.length; ++b)
              p2.push(String(b));
          if (i3 && t4.length > 0)
            for (var m2 = 0; m2 < t4.length; ++m2)
              p2.push(String(m2));
          else
            for (var v in t4)
              y2 && "prototype" === v || !o.call(t4, v) || p2.push(String(v));
          if (u)
            for (var g = function(t5) {
              if ("undefined" == typeof window || !d2)
                return h2(t5);
              try {
                return h2(t5);
              } catch (t6) {
                return false;
              }
            }(t4), _ = 0; _ < l.length; ++_)
              g && "constructor" === l[_] || !o.call(t4, l[_]) || p2.push(l[_]);
          return p2;
        };
      }
      t3.exports = i2;
    }, 668: (t3, e2, r2) => {
      var n = Array.prototype.slice, i2 = r2(6312), o = Object.keys, a = o ? function(t4) {
        return o(t4);
      } : r2(6544), s2 = Object.keys;
      a.shim = function() {
        if (Object.keys) {
          var t4 = function() {
            var t5 = Object.keys(arguments);
            return t5 && t5.length === arguments.length;
          }(1, 2);
          t4 || (Object.keys = function(t5) {
            return i2(t5) ? s2(n.call(t5)) : s2(t5);
          });
        } else
          Object.keys = a;
        return Object.keys || a;
      }, t3.exports = a;
    }, 6312: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2 = Object.prototype.toString;
      t3.exports = function(t4) {
        var n = r2.call(t4), i2 = "[object Arguments]" === n;
        return i2 || (i2 = "[object Array]" !== n && null !== t4 && "object" === e2(t4) && "number" == typeof t4.length && t4.length >= 0 && "[object Function]" === r2.call(t4.callee)), i2;
      };
    }, 6292: (t3, e2, r2) => {
      var n = r2(1419);
      e2.certificate = r2(6170);
      var i2 = n.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      e2.RSAPrivateKey = i2;
      var o = n.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      e2.RSAPublicKey = o;
      var a = n.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      }), s2 = n.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(a), this.key("subjectPublicKey").bitstr());
      });
      e2.PublicKey = s2;
      var c = n.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(a), this.key("subjectPrivateKey").octstr());
      });
      e2.PrivateKey = c;
      var u = n.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      e2.EncryptedPrivateKey = u;
      var f = n.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      e2.DSAPrivateKey = f, e2.DSAparam = n.define("DSAparam", function() {
        this.int();
      });
      var l = n.define("ECParameters", function() {
        this.choice({ namedCurve: this.objid() });
      }), h2 = n.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(l), this.key("publicKey").optional().explicit(1).bitstr());
      });
      e2.ECPrivateKey = h2, e2.signature = n.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
    }, 6170: (t3, e2, r2) => {
      var n = r2(1419), i2 = n.define("Time", function() {
        this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
      }), o = n.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      }), a = n.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      }), s2 = n.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(a), this.key("subjectPublicKey").bitstr());
      }), c = n.define("RelativeDistinguishedName", function() {
        this.setof(o);
      }), u = n.define("RDNSequence", function() {
        this.seqof(c);
      }), f = n.define("Name", function() {
        this.choice({ rdnSequence: this.use(u) });
      }), l = n.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(i2), this.key("notAfter").use(i2));
      }), h2 = n.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      }), p = n.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(a), this.key("issuer").use(f), this.key("validity").use(l), this.key("subject").use(f), this.key("subjectPublicKeyInfo").use(s2), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(h2).optional());
      }), d2 = n.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(p), this.key("signatureAlgorithm").use(a), this.key("signatureValue").bitstr());
      });
      t3.exports = d2;
    }, 3446: (t3, e2, r2) => {
      var n = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, i2 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, a = r2(1685), s2 = r2(2098), c = r2(9732).Buffer;
      t3.exports = function(t4, e3) {
        var r3, u = t4.toString(), f = u.match(n);
        if (f) {
          var l = "aes" + f[1], h2 = c.from(f[2], "hex"), p = c.from(f[3].replace(/[\r\n]/g, ""), "base64"), d2 = a(e3, h2.slice(0, 8), parseInt(f[1], 10)).key, y2 = [], b = s2.createDecipheriv(l, d2, h2);
          y2.push(b.update(p)), y2.push(b.final()), r3 = c.concat(y2);
        } else {
          var m2 = u.match(o);
          r3 = c.from(m2[2].replace(/[\r\n]/g, ""), "base64");
        }
        return { tag: u.match(i2)[1], data: r3 };
      };
    }, 5053: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(6292), o = r2(5579), a = r2(3446), s2 = r2(2098), c = r2(8699), u = r2(9732).Buffer;
      function f(t4) {
        var e3;
        "object" !== n(t4) || u.isBuffer(t4) || (e3 = t4.passphrase, t4 = t4.key), "string" == typeof t4 && (t4 = u.from(t4));
        var r3, f2, l = a(t4, e3), h2 = l.tag, p = l.data;
        switch (h2) {
          case "CERTIFICATE":
            f2 = i2.certificate.decode(p, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            switch (f2 || (f2 = i2.PublicKey.decode(p, "der")), r3 = f2.algorithm.algorithm.join(".")) {
              case "1.2.840.113549.1.1.1":
                return i2.RSAPublicKey.decode(f2.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                return f2.subjectPrivateKey = f2.subjectPublicKey, { type: "ec", data: f2 };
              case "1.2.840.10040.4.1":
                return f2.algorithm.params.pub_key = i2.DSAparam.decode(f2.subjectPublicKey.data, "der"), { type: "dsa", data: f2.algorithm.params };
              default:
                throw new Error("unknown key id " + r3);
            }
          case "ENCRYPTED PRIVATE KEY":
            p = function(t5, e4) {
              var r4 = t5.algorithm.decrypt.kde.kdeparams.salt, n2 = parseInt(t5.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), i3 = o[t5.algorithm.decrypt.cipher.algo.join(".")], a2 = t5.algorithm.decrypt.cipher.iv, f3 = t5.subjectPrivateKey, l2 = parseInt(i3.split("-")[1], 10) / 8, h3 = c.pbkdf2Sync(e4, r4, n2, l2, "sha1"), p2 = s2.createDecipheriv(i3, h3, a2), d2 = [];
              return d2.push(p2.update(f3)), d2.push(p2.final()), u.concat(d2);
            }(p = i2.EncryptedPrivateKey.decode(p, "der"), e3);
          case "PRIVATE KEY":
            switch (r3 = (f2 = i2.PrivateKey.decode(p, "der")).algorithm.algorithm.join(".")) {
              case "1.2.840.113549.1.1.1":
                return i2.RSAPrivateKey.decode(f2.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return { curve: f2.algorithm.curve, privateKey: i2.ECPrivateKey.decode(f2.subjectPrivateKey, "der").privateKey };
              case "1.2.840.10040.4.1":
                return f2.algorithm.params.priv_key = i2.DSAparam.decode(f2.subjectPrivateKey, "der"), { type: "dsa", params: f2.algorithm.params };
              default:
                throw new Error("unknown key id " + r3);
            }
          case "RSA PUBLIC KEY":
            return i2.RSAPublicKey.decode(p, "der");
          case "RSA PRIVATE KEY":
            return i2.RSAPrivateKey.decode(p, "der");
          case "DSA PRIVATE KEY":
            return { type: "dsa", params: i2.DSAPrivateKey.decode(p, "der") };
          case "EC PRIVATE KEY":
            return { curve: (p = i2.ECPrivateKey.decode(p, "der")).parameters.value, privateKey: p.privateKey };
          default:
            throw new Error("unknown key type " + h2);
        }
      }
      f.signature = i2.signature, t3.exports = f;
    }, 8699: (t3, e2, r2) => {
      e2.pbkdf2 = r2(2367), e2.pbkdf2Sync = r2(245);
    }, 2367: (t3, e2, r2) => {
      var n, i2, o = r2(9732).Buffer, a = r2(9217), s2 = r2(594), c = r2(245), u = r2(6661), f = r2.g.crypto && r2.g.crypto.subtle, l = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, h2 = [];
      function p() {
        return i2 || (i2 = r2.g.process && r2.g.process.nextTick ? r2.g.process.nextTick : r2.g.queueMicrotask ? r2.g.queueMicrotask : r2.g.setImmediate ? r2.g.setImmediate : r2.g.setTimeout);
      }
      function d2(t4, e3, r3, n2, i3) {
        return f.importKey("raw", t4, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(t5) {
          return f.deriveBits({ name: "PBKDF2", salt: e3, iterations: r3, hash: { name: i3 } }, t5, n2 << 3);
        }).then(function(t5) {
          return o.from(t5);
        });
      }
      t3.exports = function(t4, e3, i3, y2, b, m2) {
        "function" == typeof b && (m2 = b, b = void 0);
        var v = l[(b = b || "sha1").toLowerCase()];
        if (v && "function" == typeof r2.g.Promise) {
          if (a(i3, y2), t4 = u(t4, s2, "Password"), e3 = u(e3, s2, "Salt"), "function" != typeof m2)
            throw new Error("No callback provided to pbkdf2");
          !function(t5, e4) {
            t5.then(function(t6) {
              p()(function() {
                e4(null, t6);
              });
            }, function(t6) {
              p()(function() {
                e4(t6);
              });
            });
          }(function(t5) {
            if (r2.g.process && !r2.g.process.browser)
              return Promise.resolve(false);
            if (!f || !f.importKey || !f.deriveBits)
              return Promise.resolve(false);
            if (void 0 !== h2[t5])
              return h2[t5];
            var e4 = d2(n = n || o.alloc(8), n, 10, 128, t5).then(function() {
              return true;
            }).catch(function() {
              return false;
            });
            return h2[t5] = e4, e4;
          }(v).then(function(r3) {
            return r3 ? d2(t4, e3, i3, y2, v) : c(t4, e3, i3, y2, b);
          }), m2);
        } else
          p()(function() {
            var r3;
            try {
              r3 = c(t4, e3, i3, y2, b);
            } catch (t5) {
              return m2(t5);
            }
            m2(null, r3);
          });
      };
    }, 594: (t3, e2, r2) => {
      var n;
      n = r2.g.process && r2.g.process.browser ? "utf-8" : r2.g.process && r2.g.process.version ? parseInt({ env: {} }.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary" : "utf-8", t3.exports = n;
    }, 9217: (t3) => {
      var e2 = Math.pow(2, 30) - 1;
      t3.exports = function(t4, r2) {
        if ("number" != typeof t4)
          throw new TypeError("Iterations not a number");
        if (t4 < 0)
          throw new TypeError("Bad iterations");
        if ("number" != typeof r2)
          throw new TypeError("Key length not a number");
        if (r2 < 0 || r2 > e2 || r2 != r2)
          throw new TypeError("Bad key length");
      };
    }, 245: (t3, e2, r2) => {
      var n = r2(3989), i2 = r2(1058), o = r2(3261), a = r2(9732).Buffer, s2 = r2(9217), c = r2(594), u = r2(6661), f = a.alloc(128), l = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
      function h2(t4, e3, r3) {
        var s3 = /* @__PURE__ */ function(t5) {
          return "rmd160" === t5 || "ripemd160" === t5 ? function(t6) {
            return new i2().update(t6).digest();
          } : "md5" === t5 ? n : function(e4) {
            return o(t5).update(e4).digest();
          };
        }(t4), c2 = "sha512" === t4 || "sha384" === t4 ? 128 : 64;
        e3.length > c2 ? e3 = s3(e3) : e3.length < c2 && (e3 = a.concat([e3, f], c2));
        for (var u2 = a.allocUnsafe(c2 + l[t4]), h3 = a.allocUnsafe(c2 + l[t4]), p = 0; p < c2; p++)
          u2[p] = 54 ^ e3[p], h3[p] = 92 ^ e3[p];
        var d2 = a.allocUnsafe(c2 + r3 + 4);
        u2.copy(d2, 0, 0, c2), this.ipad1 = d2, this.ipad2 = u2, this.opad = h3, this.alg = t4, this.blocksize = c2, this.hash = s3, this.size = l[t4];
      }
      h2.prototype.run = function(t4, e3) {
        return t4.copy(e3, this.blocksize), this.hash(e3).copy(this.opad, this.blocksize), this.hash(this.opad);
      }, t3.exports = function(t4, e3, r3, n2, i3) {
        s2(r3, n2);
        var o2 = new h2(i3 = i3 || "sha1", t4 = u(t4, c, "Password"), (e3 = u(e3, c, "Salt")).length), f2 = a.allocUnsafe(n2), p = a.allocUnsafe(e3.length + 4);
        e3.copy(p, 0, 0, e3.length);
        for (var d2 = 0, y2 = l[i3], b = Math.ceil(n2 / y2), m2 = 1; m2 <= b; m2++) {
          p.writeUInt32BE(m2, e3.length);
          for (var v = o2.run(p, o2.ipad1), g = v, _ = 1; _ < r3; _++) {
            g = o2.run(g, o2.ipad2);
            for (var w2 = 0; w2 < y2; w2++)
              v[w2] ^= g[w2];
          }
          v.copy(f2, d2), d2 += y2;
        }
        return f2;
      };
    }, 6661: (t3, e2, r2) => {
      var n = r2(9732).Buffer;
      t3.exports = function(t4, e3, r3) {
        if (n.isBuffer(t4))
          return t4;
        if ("string" == typeof t4)
          return n.from(t4, e3);
        if (ArrayBuffer.isView(t4))
          return n.from(t4.buffer);
        throw new TypeError(r3 + " must be a string, a Buffer, a typed array or a DataView");
      };
    }, 2653: (t3) => {
      t3.exports = ["Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
    }, 4758: (t3) => {
      void 0 === { env: {} } || !{ env: {} }.version || 0 === { env: {} }.version.indexOf("v0.") || 0 === { env: {} }.version.indexOf("v1.") && 0 !== { env: {} }.version.indexOf("v1.8.") ? t3.exports = { nextTick: function(t4, e2, r2, n) {
        if ("function" != typeof t4)
          throw new TypeError('"callback" argument must be a function');
        var i2, o, a = arguments.length;
        switch (a) {
          case 0:
          case 1:
            return { env: {} }.nextTick(t4);
          case 2:
            return { env: {} }.nextTick(function() {
              t4.call(null, e2);
            });
          case 3:
            return { env: {} }.nextTick(function() {
              t4.call(null, e2, r2);
            });
          case 4:
            return { env: {} }.nextTick(function() {
              t4.call(null, e2, r2, n);
            });
          default:
            for (i2 = new Array(a - 1), o = 0; o < i2.length; )
              i2[o++] = arguments[o];
            return { env: {} }.nextTick(function() {
              t4.apply(null, i2);
            });
        }
      } } : t3.exports = { env: {} };
    }, 2327: (t3, e2, r2) => {
      e2.publicEncrypt = r2(2937), e2.privateDecrypt = r2(5443), e2.privateEncrypt = function(t4, r3) {
        return e2.publicEncrypt(t4, r3, true);
      }, e2.publicDecrypt = function(t4, r3) {
        return e2.privateDecrypt(t4, r3, true);
      };
    }, 7797: (t3, e2, r2) => {
      var n = r2(5833), i2 = r2(9732).Buffer;
      function o(t4) {
        var e3 = i2.allocUnsafe(4);
        return e3.writeUInt32BE(t4, 0), e3;
      }
      t3.exports = function(t4, e3) {
        for (var r3, a = i2.alloc(0), s2 = 0; a.length < e3; )
          r3 = o(s2++), a = i2.concat([a, n("sha1").update(t4).update(r3).digest()]);
        return a.slice(0, e3);
      };
    }, 5443: (t3, e2, r2) => {
      var n = r2(5053), i2 = r2(7797), o = r2(1190), a = r2(7799), s2 = r2(1095), c = r2(5833), u = r2(5218), f = r2(9732).Buffer;
      t3.exports = function(t4, e3, r3) {
        var l;
        l = t4.padding ? t4.padding : r3 ? 1 : 4;
        var h2, p = n(t4), d2 = p.modulus.byteLength();
        if (e3.length > d2 || new a(e3).cmp(p.modulus) >= 0)
          throw new Error("decryption error");
        h2 = r3 ? u(new a(e3), p) : s2(e3, p);
        var y2 = f.alloc(d2 - h2.length);
        if (h2 = f.concat([y2, h2], d2), 4 === l)
          return function(t5, e4) {
            var r4 = t5.modulus.byteLength(), n2 = c("sha1").update(f.alloc(0)).digest(), a2 = n2.length;
            if (0 !== e4[0])
              throw new Error("decryption error");
            var s3 = e4.slice(1, a2 + 1), u2 = e4.slice(a2 + 1), l2 = o(s3, i2(u2, a2)), h3 = o(u2, i2(l2, r4 - a2 - 1));
            if (function(t6, e5) {
              t6 = f.from(t6), e5 = f.from(e5);
              var r5 = 0, n3 = t6.length;
              t6.length !== e5.length && (r5++, n3 = Math.min(t6.length, e5.length));
              for (var i3 = -1; ++i3 < n3; )
                r5 += t6[i3] ^ e5[i3];
              return r5;
            }(n2, h3.slice(0, a2)))
              throw new Error("decryption error");
            for (var p2 = a2; 0 === h3[p2]; )
              p2++;
            if (1 !== h3[p2++])
              throw new Error("decryption error");
            return h3.slice(p2);
          }(p, h2);
        if (1 === l)
          return function(t5, e4, r4) {
            for (var n2 = e4.slice(0, 2), i3 = 2, o2 = 0; 0 !== e4[i3++]; )
              if (i3 >= e4.length) {
                o2++;
                break;
              }
            var a2 = e4.slice(2, i3 - 1);
            if (("0002" !== n2.toString("hex") && !r4 || "0001" !== n2.toString("hex") && r4) && o2++, a2.length < 8 && o2++, o2)
              throw new Error("decryption error");
            return e4.slice(i3);
          }(0, h2, r3);
        if (3 === l)
          return h2;
        throw new Error("unknown padding");
      };
    }, 2937: (t3, e2, r2) => {
      var n = r2(5053), i2 = r2(4276), o = r2(5833), a = r2(7797), s2 = r2(1190), c = r2(7799), u = r2(5218), f = r2(1095), l = r2(9732).Buffer;
      t3.exports = function(t4, e3, r3) {
        var h2;
        h2 = t4.padding ? t4.padding : r3 ? 1 : 4;
        var p, d2 = n(t4);
        if (4 === h2)
          p = function(t5, e4) {
            var r4 = t5.modulus.byteLength(), n2 = e4.length, u2 = o("sha1").update(l.alloc(0)).digest(), f2 = u2.length, h3 = 2 * f2;
            if (n2 > r4 - h3 - 2)
              throw new Error("message too long");
            var p2 = l.alloc(r4 - n2 - h3 - 2), d3 = r4 - f2 - 1, y2 = i2(f2), b = s2(l.concat([u2, p2, l.alloc(1, 1), e4], d3), a(y2, d3)), m2 = s2(y2, a(b, f2));
            return new c(l.concat([l.alloc(1), m2, b], r4));
          }(d2, e3);
        else if (1 === h2)
          p = function(t5, e4, r4) {
            var n2, o2 = e4.length, a2 = t5.modulus.byteLength();
            if (o2 > a2 - 11)
              throw new Error("message too long");
            return n2 = r4 ? l.alloc(a2 - o2 - 3, 255) : function(t6) {
              for (var e5, r5 = l.allocUnsafe(t6), n3 = 0, o3 = i2(2 * t6), a3 = 0; n3 < t6; )
                a3 === o3.length && (o3 = i2(2 * t6), a3 = 0), (e5 = o3[a3++]) && (r5[n3++] = e5);
              return r5;
            }(a2 - o2 - 3), new c(l.concat([l.from([0, r4 ? 1 : 2]), n2, l.alloc(1), e4], a2));
          }(d2, e3, r3);
        else {
          if (3 !== h2)
            throw new Error("unknown padding");
          if ((p = new c(e3)).cmp(d2.modulus) >= 0)
            throw new Error("data too long for modulus");
        }
        return r3 ? f(p, d2) : u(p, d2);
      };
    }, 5218: (t3, e2, r2) => {
      var n = r2(7799), i2 = r2(9732).Buffer;
      t3.exports = function(t4, e3) {
        return i2.from(t4.toRed(n.mont(e3.modulus)).redPow(new n(e3.publicExponent)).fromRed().toArray());
      };
    }, 1190: (t3) => {
      t3.exports = function(t4, e2) {
        for (var r2 = t4.length, n = -1; ++n < r2; )
          t4[n] ^= e2[n];
        return t4;
      };
    }, 4276: (t3, e2, r2) => {
      var n = 65536, i2 = r2(9732).Buffer, o = r2.g.crypto || r2.g.msCrypto;
      o && o.getRandomValues ? t3.exports = function(t4, e3) {
        if (t4 > 4294967295)
          throw new RangeError("requested too many random bytes");
        var r3 = i2.allocUnsafe(t4);
        if (t4 > 0)
          if (t4 > n)
            for (var a = 0; a < t4; a += n)
              o.getRandomValues(r3.slice(a, a + n));
          else
            o.getRandomValues(r3);
        return "function" == typeof e3 ? { env: {} }.nextTick(function() {
          e3(null, r3);
        }) : r3;
      } : t3.exports = function() {
        throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
      };
    }, 7952: (t3, e2, r2) => {
      function n() {
        throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
      }
      var i2 = r2(9732), o = r2(4276), a = i2.Buffer, s2 = i2.kMaxLength, c = r2.g.crypto || r2.g.msCrypto, u = Math.pow(2, 32) - 1;
      function f(t4, e3) {
        if ("number" != typeof t4 || t4 != t4)
          throw new TypeError("offset must be a number");
        if (t4 > u || t4 < 0)
          throw new TypeError("offset must be a uint32");
        if (t4 > s2 || t4 > e3)
          throw new RangeError("offset out of range");
      }
      function l(t4, e3, r3) {
        if ("number" != typeof t4 || t4 != t4)
          throw new TypeError("size must be a number");
        if (t4 > u || t4 < 0)
          throw new TypeError("size must be a uint32");
        if (t4 + e3 > r3 || t4 > s2)
          throw new RangeError("buffer too small");
      }
      function h2(t4, e3, r3, n2) {
        if ({ env: {} }.browser) {
          var i3 = t4.buffer, a2 = new Uint8Array(i3, e3, r3);
          return c.getRandomValues(a2), n2 ? void { env: {} }.nextTick(function() {
            n2(null, t4);
          }) : t4;
        }
        if (!n2)
          return o(r3).copy(t4, e3), t4;
        o(r3, function(r4, i4) {
          if (r4)
            return n2(r4);
          i4.copy(t4, e3), n2(null, t4);
        });
      }
      c && c.getRandomValues || !{ env: {} }.browser ? (e2.randomFill = function(t4, e3, n2, i3) {
        if (!(a.isBuffer(t4) || t4 instanceof r2.g.Uint8Array))
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if ("function" == typeof e3)
          i3 = e3, e3 = 0, n2 = t4.length;
        else if ("function" == typeof n2)
          i3 = n2, n2 = t4.length - e3;
        else if ("function" != typeof i3)
          throw new TypeError('"cb" argument must be a function');
        return f(e3, t4.length), l(n2, e3, t4.length), h2(t4, e3, n2, i3);
      }, e2.randomFillSync = function(t4, e3, n2) {
        if (void 0 === e3 && (e3 = 0), !(a.isBuffer(t4) || t4 instanceof r2.g.Uint8Array))
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return f(e3, t4.length), void 0 === n2 && (n2 = t4.length - e3), l(n2, e3, t4.length), h2(t4, e3, n2);
      }) : (e2.randomFill = n, e2.randomFillSync = n);
    }, 1313: (t3, e2, r2) => {
      var n = r2(4758), i2 = Object.keys || function(t4) {
        var e3 = [];
        for (var r3 in t4)
          e3.push(r3);
        return e3;
      };
      t3.exports = l;
      var o = Object.create(r2(7919));
      o.inherits = r2(1679);
      var a = r2(7991), s2 = r2(9147);
      o.inherits(l, a);
      for (var c = i2(s2.prototype), u = 0; u < c.length; u++) {
        var f = c[u];
        l.prototype[f] || (l.prototype[f] = s2.prototype[f]);
      }
      function l(t4) {
        if (!(this instanceof l))
          return new l(t4);
        a.call(this, t4), s2.call(this, t4), t4 && false === t4.readable && (this.readable = false), t4 && false === t4.writable && (this.writable = false), this.allowHalfOpen = true, t4 && false === t4.allowHalfOpen && (this.allowHalfOpen = false), this.once("end", h2);
      }
      function h2() {
        this.allowHalfOpen || this._writableState.ended || n.nextTick(p, this);
      }
      function p(t4) {
        t4.end();
      }
      Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty(l.prototype, "destroyed", { get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
      }, set: function(t4) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t4, this._writableState.destroyed = t4);
      } }), l.prototype._destroy = function(t4, e3) {
        this.push(null), this.end(), n.nextTick(e3, t4);
      };
    }, 9125: (t3, e2, r2) => {
      t3.exports = o;
      var n = r2(1191), i2 = Object.create(r2(7919));
      function o(t4) {
        if (!(this instanceof o))
          return new o(t4);
        n.call(this, t4);
      }
      i2.inherits = r2(1679), i2.inherits(o, n), o.prototype._transform = function(t4, e3, r3) {
        r3(null, t4);
      };
    }, 7991: (t3, e2, r2) => {
      var n = r2(4758);
      t3.exports = v;
      var i2, o = r2(5455);
      v.ReadableState = m2, r2(3550).EventEmitter;
      var a = function(t4, e3) {
        return t4.listeners(e3).length;
      }, s2 = r2(5864), c = r2(8317).Buffer, u = (void 0 !== r2.g ? r2.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
      }, f = Object.create(r2(7919));
      f.inherits = r2(1679);
      var l = r2(9838), h2 = void 0;
      h2 = l && l.debuglog ? l.debuglog("stream") : function() {
      };
      var p, d2 = r2(6567), y2 = r2(8639);
      f.inherits(v, s2);
      var b = ["error", "close", "destroy", "pause", "resume"];
      function m2(t4, e3) {
        t4 = t4 || {};
        var n2 = e3 instanceof (i2 = i2 || r2(1313));
        this.objectMode = !!t4.objectMode, n2 && (this.objectMode = this.objectMode || !!t4.readableObjectMode);
        var o2 = t4.highWaterMark, a2 = t4.readableHighWaterMark, s3 = this.objectMode ? 16 : 16384;
        this.highWaterMark = o2 || 0 === o2 ? o2 : n2 && (a2 || 0 === a2) ? a2 : s3, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new d2(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (p || (p = r2(136).I), this.decoder = new p(t4.encoding), this.encoding = t4.encoding);
      }
      function v(t4) {
        if (i2 = i2 || r2(1313), !(this instanceof v))
          return new v(t4);
        this._readableState = new m2(t4, this), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), s2.call(this);
      }
      function g(t4, e3, r3, n2, i3) {
        var o2, a2 = t4._readableState;
        return null === e3 ? (a2.reading = false, function(t5, e4) {
          if (!e4.ended) {
            if (e4.decoder) {
              var r4 = e4.decoder.end();
              r4 && r4.length && (e4.buffer.push(r4), e4.length += e4.objectMode ? 1 : r4.length);
            }
            e4.ended = true, O(t5);
          }
        }(t4, a2)) : (i3 || (o2 = function(t5, e4) {
          var r4, n3;
          return n3 = e4, c.isBuffer(n3) || n3 instanceof u || "string" == typeof e4 || void 0 === e4 || t5.objectMode || (r4 = new TypeError("Invalid non-string/buffer chunk")), r4;
        }(a2, e3)), o2 ? t4.emit("error", o2) : a2.objectMode || e3 && e3.length > 0 ? ("string" == typeof e3 || a2.objectMode || Object.getPrototypeOf(e3) === c.prototype || (e3 = function(t5) {
          return c.from(t5);
        }(e3)), n2 ? a2.endEmitted ? t4.emit("error", new Error("stream.unshift() after end event")) : _(t4, a2, e3, true) : a2.ended ? t4.emit("error", new Error("stream.push() after EOF")) : (a2.reading = false, a2.decoder && !r3 ? (e3 = a2.decoder.write(e3), a2.objectMode || 0 !== e3.length ? _(t4, a2, e3, false) : $(t4, a2)) : _(t4, a2, e3, false))) : n2 || (a2.reading = false)), function(t5) {
          return !t5.ended && (t5.needReadable || t5.length < t5.highWaterMark || 0 === t5.length);
        }(a2);
      }
      function _(t4, e3, r3, n2) {
        e3.flowing && 0 === e3.length && !e3.sync ? (t4.emit("data", r3), t4.read(0)) : (e3.length += e3.objectMode ? 1 : r3.length, n2 ? e3.buffer.unshift(r3) : e3.buffer.push(r3), e3.needReadable && O(t4)), $(t4, e3);
      }
      Object.defineProperty(v.prototype, "destroyed", { get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed;
      }, set: function(t4) {
        this._readableState && (this._readableState.destroyed = t4);
      } }), v.prototype.destroy = y2.destroy, v.prototype._undestroy = y2.undestroy, v.prototype._destroy = function(t4, e3) {
        this.push(null), e3(t4);
      }, v.prototype.push = function(t4, e3) {
        var r3, n2 = this._readableState;
        return n2.objectMode ? r3 = true : "string" == typeof t4 && ((e3 = e3 || n2.defaultEncoding) !== n2.encoding && (t4 = c.from(t4, e3), e3 = ""), r3 = true), g(this, t4, e3, false, r3);
      }, v.prototype.unshift = function(t4) {
        return g(this, t4, null, true, false);
      }, v.prototype.isPaused = function() {
        return false === this._readableState.flowing;
      }, v.prototype.setEncoding = function(t4) {
        return p || (p = r2(136).I), this._readableState.decoder = new p(t4), this._readableState.encoding = t4, this;
      };
      var w2 = 8388608;
      function S(t4, e3) {
        return t4 <= 0 || 0 === e3.length && e3.ended ? 0 : e3.objectMode ? 1 : t4 != t4 ? e3.flowing && e3.length ? e3.buffer.head.data.length : e3.length : (t4 > e3.highWaterMark && (e3.highWaterMark = function(t5) {
          return t5 >= w2 ? t5 = w2 : (t5--, t5 |= t5 >>> 1, t5 |= t5 >>> 2, t5 |= t5 >>> 4, t5 |= t5 >>> 8, t5 |= t5 >>> 16, t5++), t5;
        }(t4)), t4 <= e3.length ? t4 : e3.ended ? e3.length : (e3.needReadable = true, 0));
      }
      function O(t4) {
        var e3 = t4._readableState;
        e3.needReadable = false, e3.emittedReadable || (h2("emitReadable", e3.flowing), e3.emittedReadable = true, e3.sync ? n.nextTick(j, t4) : j(t4));
      }
      function j(t4) {
        h2("emit readable"), t4.emit("readable"), P(t4);
      }
      function $(t4, e3) {
        e3.readingMore || (e3.readingMore = true, n.nextTick(A, t4, e3));
      }
      function A(t4, e3) {
        for (var r3 = e3.length; !e3.reading && !e3.flowing && !e3.ended && e3.length < e3.highWaterMark && (h2("maybeReadMore read 0"), t4.read(0), r3 !== e3.length); )
          r3 = e3.length;
        e3.readingMore = false;
      }
      function E(t4) {
        h2("readable nexttick read 0"), t4.read(0);
      }
      function x(t4, e3) {
        e3.reading || (h2("resume read 0"), t4.read(0)), e3.resumeScheduled = false, e3.awaitDrain = 0, t4.emit("resume"), P(t4), e3.flowing && !e3.reading && t4.read(0);
      }
      function P(t4) {
        var e3 = t4._readableState;
        for (h2("flow", e3.flowing); e3.flowing && null !== t4.read(); )
          ;
      }
      function k(t4, e3) {
        return 0 === e3.length ? null : (e3.objectMode ? r3 = e3.buffer.shift() : !t4 || t4 >= e3.length ? (r3 = e3.decoder ? e3.buffer.join("") : 1 === e3.buffer.length ? e3.buffer.head.data : e3.buffer.concat(e3.length), e3.buffer.clear()) : r3 = function(t5, e4, r4) {
          var n2;
          return t5 < e4.head.data.length ? (n2 = e4.head.data.slice(0, t5), e4.head.data = e4.head.data.slice(t5)) : n2 = t5 === e4.head.data.length ? e4.shift() : r4 ? function(t6, e5) {
            var r5 = e5.head, n3 = 1, i3 = r5.data;
            for (t6 -= i3.length; r5 = r5.next; ) {
              var o2 = r5.data, a2 = t6 > o2.length ? o2.length : t6;
              if (a2 === o2.length ? i3 += o2 : i3 += o2.slice(0, t6), 0 == (t6 -= a2)) {
                a2 === o2.length ? (++n3, r5.next ? e5.head = r5.next : e5.head = e5.tail = null) : (e5.head = r5, r5.data = o2.slice(a2));
                break;
              }
              ++n3;
            }
            return e5.length -= n3, i3;
          }(t5, e4) : function(t6, e5) {
            var r5 = c.allocUnsafe(t6), n3 = e5.head, i3 = 1;
            for (n3.data.copy(r5), t6 -= n3.data.length; n3 = n3.next; ) {
              var o2 = n3.data, a2 = t6 > o2.length ? o2.length : t6;
              if (o2.copy(r5, r5.length - t6, 0, a2), 0 == (t6 -= a2)) {
                a2 === o2.length ? (++i3, n3.next ? e5.head = n3.next : e5.head = e5.tail = null) : (e5.head = n3, n3.data = o2.slice(a2));
                break;
              }
              ++i3;
            }
            return e5.length -= i3, r5;
          }(t5, e4), n2;
        }(t4, e3.buffer, e3.decoder), r3);
        var r3;
      }
      function M(t4) {
        var e3 = t4._readableState;
        if (e3.length > 0)
          throw new Error('"endReadable()" called on non-empty stream');
        e3.endEmitted || (e3.ended = true, n.nextTick(I, e3, t4));
      }
      function I(t4, e3) {
        t4.endEmitted || 0 !== t4.length || (t4.endEmitted = true, e3.readable = false, e3.emit("end"));
      }
      function B(t4, e3) {
        for (var r3 = 0, n2 = t4.length; r3 < n2; r3++)
          if (t4[r3] === e3)
            return r3;
        return -1;
      }
      v.prototype.read = function(t4) {
        h2("read", t4), t4 = parseInt(t4, 10);
        var e3 = this._readableState, r3 = t4;
        if (0 !== t4 && (e3.emittedReadable = false), 0 === t4 && e3.needReadable && (e3.length >= e3.highWaterMark || e3.ended))
          return h2("read: emitReadable", e3.length, e3.ended), 0 === e3.length && e3.ended ? M(this) : O(this), null;
        if (0 === (t4 = S(t4, e3)) && e3.ended)
          return 0 === e3.length && M(this), null;
        var n2, i3 = e3.needReadable;
        return h2("need readable", i3), (0 === e3.length || e3.length - t4 < e3.highWaterMark) && h2("length less than watermark", i3 = true), e3.ended || e3.reading ? h2("reading or ended", i3 = false) : i3 && (h2("do read"), e3.reading = true, e3.sync = true, 0 === e3.length && (e3.needReadable = true), this._read(e3.highWaterMark), e3.sync = false, e3.reading || (t4 = S(r3, e3))), null === (n2 = t4 > 0 ? k(t4, e3) : null) ? (e3.needReadable = true, t4 = 0) : e3.length -= t4, 0 === e3.length && (e3.ended || (e3.needReadable = true), r3 !== t4 && e3.ended && M(this)), null !== n2 && this.emit("data", n2), n2;
      }, v.prototype._read = function(t4) {
        this.emit("error", new Error("_read() is not implemented"));
      }, v.prototype.pipe = function(t4, e3) {
        var r3 = this, i3 = this._readableState;
        switch (i3.pipesCount) {
          case 0:
            i3.pipes = t4;
            break;
          case 1:
            i3.pipes = [i3.pipes, t4];
            break;
          default:
            i3.pipes.push(t4);
        }
        i3.pipesCount += 1, h2("pipe count=%d opts=%j", i3.pipesCount, e3);
        var s3 = e3 && false === e3.end || t4 === { env: {} }.stdout || t4 === { env: {} }.stderr ? m3 : c2;
        function c2() {
          h2("onend"), t4.end();
        }
        i3.endEmitted ? n.nextTick(s3) : r3.once("end", s3), t4.on("unpipe", function e4(n2, o2) {
          h2("onunpipe"), n2 === r3 && o2 && false === o2.hasUnpiped && (o2.hasUnpiped = true, h2("cleanup"), t4.removeListener("close", y3), t4.removeListener("finish", b2), t4.removeListener("drain", u2), t4.removeListener("error", d3), t4.removeListener("unpipe", e4), r3.removeListener("end", c2), r3.removeListener("end", m3), r3.removeListener("data", p2), f2 = true, !i3.awaitDrain || t4._writableState && !t4._writableState.needDrain || u2());
        });
        var u2 = /* @__PURE__ */ function(t5) {
          return function() {
            var e4 = t5._readableState;
            h2("pipeOnDrain", e4.awaitDrain), e4.awaitDrain && e4.awaitDrain--, 0 === e4.awaitDrain && a(t5, "data") && (e4.flowing = true, P(t5));
          };
        }(r3);
        t4.on("drain", u2);
        var f2 = false, l2 = false;
        function p2(e4) {
          h2("ondata"), l2 = false, false !== t4.write(e4) || l2 || ((1 === i3.pipesCount && i3.pipes === t4 || i3.pipesCount > 1 && -1 !== B(i3.pipes, t4)) && !f2 && (h2("false write response, pause", i3.awaitDrain), i3.awaitDrain++, l2 = true), r3.pause());
        }
        function d3(e4) {
          h2("onerror", e4), m3(), t4.removeListener("error", d3), 0 === a(t4, "error") && t4.emit("error", e4);
        }
        function y3() {
          t4.removeListener("finish", b2), m3();
        }
        function b2() {
          h2("onfinish"), t4.removeListener("close", y3), m3();
        }
        function m3() {
          h2("unpipe"), r3.unpipe(t4);
        }
        return r3.on("data", p2), function(t5, e4, r4) {
          if ("function" == typeof t5.prependListener)
            return t5.prependListener(e4, r4);
          t5._events && t5._events[e4] ? o(t5._events[e4]) ? t5._events[e4].unshift(r4) : t5._events[e4] = [r4, t5._events[e4]] : t5.on(e4, r4);
        }(t4, "error", d3), t4.once("close", y3), t4.once("finish", b2), t4.emit("pipe", r3), i3.flowing || (h2("pipe resume"), r3.resume()), t4;
      }, v.prototype.unpipe = function(t4) {
        var e3 = this._readableState, r3 = { hasUnpiped: false };
        if (0 === e3.pipesCount)
          return this;
        if (1 === e3.pipesCount)
          return t4 && t4 !== e3.pipes || (t4 || (t4 = e3.pipes), e3.pipes = null, e3.pipesCount = 0, e3.flowing = false, t4 && t4.emit("unpipe", this, r3)), this;
        if (!t4) {
          var n2 = e3.pipes, i3 = e3.pipesCount;
          e3.pipes = null, e3.pipesCount = 0, e3.flowing = false;
          for (var o2 = 0; o2 < i3; o2++)
            n2[o2].emit("unpipe", this, { hasUnpiped: false });
          return this;
        }
        var a2 = B(e3.pipes, t4);
        return -1 === a2 || (e3.pipes.splice(a2, 1), e3.pipesCount -= 1, 1 === e3.pipesCount && (e3.pipes = e3.pipes[0]), t4.emit("unpipe", this, r3)), this;
      }, v.prototype.on = function(t4, e3) {
        var r3 = s2.prototype.on.call(this, t4, e3);
        if ("data" === t4)
          false !== this._readableState.flowing && this.resume();
        else if ("readable" === t4) {
          var i3 = this._readableState;
          i3.endEmitted || i3.readableListening || (i3.readableListening = i3.needReadable = true, i3.emittedReadable = false, i3.reading ? i3.length && O(this) : n.nextTick(E, this));
        }
        return r3;
      }, v.prototype.addListener = v.prototype.on, v.prototype.resume = function() {
        var t4 = this._readableState;
        return t4.flowing || (h2("resume"), t4.flowing = true, function(t5, e3) {
          e3.resumeScheduled || (e3.resumeScheduled = true, n.nextTick(x, t5, e3));
        }(this, t4)), this;
      }, v.prototype.pause = function() {
        return h2("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (h2("pause"), this._readableState.flowing = false, this.emit("pause")), this;
      }, v.prototype.wrap = function(t4) {
        var e3 = this, r3 = this._readableState, n2 = false;
        for (var i3 in t4.on("end", function() {
          if (h2("wrapped end"), r3.decoder && !r3.ended) {
            var t5 = r3.decoder.end();
            t5 && t5.length && e3.push(t5);
          }
          e3.push(null);
        }), t4.on("data", function(i4) {
          h2("wrapped data"), r3.decoder && (i4 = r3.decoder.write(i4)), r3.objectMode && null == i4 || (r3.objectMode || i4 && i4.length) && (e3.push(i4) || (n2 = true, t4.pause()));
        }), t4)
          void 0 === this[i3] && "function" == typeof t4[i3] && (this[i3] = /* @__PURE__ */ function(e4) {
            return function() {
              return t4[e4].apply(t4, arguments);
            };
          }(i3));
        for (var o2 = 0; o2 < b.length; o2++)
          t4.on(b[o2], this.emit.bind(this, b[o2]));
        return this._read = function(e4) {
          h2("wrapped _read", e4), n2 && (n2 = false, t4.resume());
        }, this;
      }, Object.defineProperty(v.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
        return this._readableState.highWaterMark;
      } }), v._fromList = k;
    }, 1191: (t3, e2, r2) => {
      t3.exports = a;
      var n = r2(1313), i2 = Object.create(r2(7919));
      function o(t4, e3) {
        var r3 = this._transformState;
        r3.transforming = false;
        var n2 = r3.writecb;
        if (!n2)
          return this.emit("error", new Error("write callback called multiple times"));
        r3.writechunk = null, r3.writecb = null, null != e3 && this.push(e3), n2(t4);
        var i3 = this._readableState;
        i3.reading = false, (i3.needReadable || i3.length < i3.highWaterMark) && this._read(i3.highWaterMark);
      }
      function a(t4) {
        if (!(this instanceof a))
          return new a(t4);
        n.call(this, t4), this._transformState = { afterTransform: o.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t4 && ("function" == typeof t4.transform && (this._transform = t4.transform), "function" == typeof t4.flush && (this._flush = t4.flush)), this.on("prefinish", s2);
      }
      function s2() {
        var t4 = this;
        "function" == typeof this._flush ? this._flush(function(e3, r3) {
          c(t4, e3, r3);
        }) : c(this, null, null);
      }
      function c(t4, e3, r3) {
        if (e3)
          return t4.emit("error", e3);
        if (null != r3 && t4.push(r3), t4._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (t4._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return t4.push(null);
      }
      i2.inherits = r2(1679), i2.inherits(a, n), a.prototype.push = function(t4, e3) {
        return this._transformState.needTransform = false, n.prototype.push.call(this, t4, e3);
      }, a.prototype._transform = function(t4, e3, r3) {
        throw new Error("_transform() is not implemented");
      }, a.prototype._write = function(t4, e3, r3) {
        var n2 = this._transformState;
        if (n2.writecb = r3, n2.writechunk = t4, n2.writeencoding = e3, !n2.transforming) {
          var i3 = this._readableState;
          (n2.needTransform || i3.needReadable || i3.length < i3.highWaterMark) && this._read(i3.highWaterMark);
        }
      }, a.prototype._read = function(t4) {
        var e3 = this._transformState;
        null !== e3.writechunk && e3.writecb && !e3.transforming ? (e3.transforming = true, this._transform(e3.writechunk, e3.writeencoding, e3.afterTransform)) : e3.needTransform = true;
      }, a.prototype._destroy = function(t4, e3) {
        var r3 = this;
        n.prototype._destroy.call(this, t4, function(t5) {
          e3(t5), r3.emit("close");
        });
      };
    }, 9147: (t3, e2, r2) => {
      var n = r2(4758);
      function i2(t4) {
        var e3 = this;
        this.next = null, this.entry = null, this.finish = function() {
          !function(t5, e4, r3) {
            var n2 = t5.entry;
            for (t5.entry = null; n2; ) {
              var i3 = n2.callback;
              e4.pendingcb--, i3(void 0), n2 = n2.next;
            }
            e4.corkedRequestsFree.next = t5;
          }(e3, t4);
        };
      }
      t3.exports = b;
      var o, a = !{ env: {} }.browser && ["v0.10", "v0.9."].indexOf({ env: {} }.version.slice(0, 5)) > -1 ? setImmediate : n.nextTick;
      b.WritableState = y2;
      var s2 = Object.create(r2(7919));
      s2.inherits = r2(1679);
      var c, u = { deprecate: r2(3340) }, f = r2(5864), l = r2(8317).Buffer, h2 = (void 0 !== r2.g ? r2.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
      }, p = r2(8639);
      function d2() {
      }
      function y2(t4, e3) {
        o = o || r2(1313), t4 = t4 || {};
        var s3 = e3 instanceof o;
        this.objectMode = !!t4.objectMode, s3 && (this.objectMode = this.objectMode || !!t4.writableObjectMode);
        var c2 = t4.highWaterMark, u2 = t4.writableHighWaterMark, f2 = this.objectMode ? 16 : 16384;
        this.highWaterMark = c2 || 0 === c2 ? c2 : s3 && (u2 || 0 === u2) ? u2 : f2, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
        var l2 = false === t4.decodeStrings;
        this.decodeStrings = !l2, this.defaultEncoding = t4.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(t5) {
          !function(t6, e4) {
            var r3 = t6._writableState, i3 = r3.sync, o2 = r3.writecb;
            if (function(t7) {
              t7.writing = false, t7.writecb = null, t7.length -= t7.writelen, t7.writelen = 0;
            }(r3), e4)
              !function(t7, e5, r4, i4, o3) {
                --e5.pendingcb, r4 ? (n.nextTick(o3, i4), n.nextTick(S, t7, e5), t7._writableState.errorEmitted = true, t7.emit("error", i4)) : (o3(i4), t7._writableState.errorEmitted = true, t7.emit("error", i4), S(t7, e5));
              }(t6, r3, i3, e4, o2);
            else {
              var s4 = _(r3);
              s4 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || g(t6, r3), i3 ? a(v, t6, r3, s4, o2) : v(t6, r3, s4, o2);
            }
          }(e3, t5);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i2(this);
      }
      function b(t4) {
        if (o = o || r2(1313), !(c.call(b, this) || this instanceof o))
          return new b(t4);
        this._writableState = new y2(t4, this), this.writable = true, t4 && ("function" == typeof t4.write && (this._write = t4.write), "function" == typeof t4.writev && (this._writev = t4.writev), "function" == typeof t4.destroy && (this._destroy = t4.destroy), "function" == typeof t4.final && (this._final = t4.final)), f.call(this);
      }
      function m2(t4, e3, r3, n2, i3, o2, a2) {
        e3.writelen = n2, e3.writecb = a2, e3.writing = true, e3.sync = true, r3 ? t4._writev(i3, e3.onwrite) : t4._write(i3, o2, e3.onwrite), e3.sync = false;
      }
      function v(t4, e3, r3, n2) {
        r3 || function(t5, e4) {
          0 === e4.length && e4.needDrain && (e4.needDrain = false, t5.emit("drain"));
        }(t4, e3), e3.pendingcb--, n2(), S(t4, e3);
      }
      function g(t4, e3) {
        e3.bufferProcessing = true;
        var r3 = e3.bufferedRequest;
        if (t4._writev && r3 && r3.next) {
          var n2 = e3.bufferedRequestCount, o2 = new Array(n2), a2 = e3.corkedRequestsFree;
          a2.entry = r3;
          for (var s3 = 0, c2 = true; r3; )
            o2[s3] = r3, r3.isBuf || (c2 = false), r3 = r3.next, s3 += 1;
          o2.allBuffers = c2, m2(t4, e3, true, e3.length, o2, "", a2.finish), e3.pendingcb++, e3.lastBufferedRequest = null, a2.next ? (e3.corkedRequestsFree = a2.next, a2.next = null) : e3.corkedRequestsFree = new i2(e3), e3.bufferedRequestCount = 0;
        } else {
          for (; r3; ) {
            var u2 = r3.chunk, f2 = r3.encoding, l2 = r3.callback;
            if (m2(t4, e3, false, e3.objectMode ? 1 : u2.length, u2, f2, l2), r3 = r3.next, e3.bufferedRequestCount--, e3.writing)
              break;
          }
          null === r3 && (e3.lastBufferedRequest = null);
        }
        e3.bufferedRequest = r3, e3.bufferProcessing = false;
      }
      function _(t4) {
        return t4.ending && 0 === t4.length && null === t4.bufferedRequest && !t4.finished && !t4.writing;
      }
      function w2(t4, e3) {
        t4._final(function(r3) {
          e3.pendingcb--, r3 && t4.emit("error", r3), e3.prefinished = true, t4.emit("prefinish"), S(t4, e3);
        });
      }
      function S(t4, e3) {
        var r3 = _(e3);
        return r3 && (function(t5, e4) {
          e4.prefinished || e4.finalCalled || ("function" == typeof t5._final ? (e4.pendingcb++, e4.finalCalled = true, n.nextTick(w2, t5, e4)) : (e4.prefinished = true, t5.emit("prefinish")));
        }(t4, e3), 0 === e3.pendingcb && (e3.finished = true, t4.emit("finish"))), r3;
      }
      s2.inherits(b, f), y2.prototype.getBuffer = function() {
        for (var t4 = this.bufferedRequest, e3 = []; t4; )
          e3.push(t4), t4 = t4.next;
        return e3;
      }, function() {
        try {
          Object.defineProperty(y2.prototype, "buffer", { get: u.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
        } catch (t4) {
        }
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(b, Symbol.hasInstance, { value: function(t4) {
        return !!c.call(this, t4) || this === b && t4 && t4._writableState instanceof y2;
      } })) : c = function(t4) {
        return t4 instanceof this;
      }, b.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      }, b.prototype.write = function(t4, e3, r3) {
        var i3, o2 = this._writableState, a2 = false, s3 = !o2.objectMode && (i3 = t4, l.isBuffer(i3) || i3 instanceof h2);
        return s3 && !l.isBuffer(t4) && (t4 = function(t5) {
          return l.from(t5);
        }(t4)), "function" == typeof e3 && (r3 = e3, e3 = null), s3 ? e3 = "buffer" : e3 || (e3 = o2.defaultEncoding), "function" != typeof r3 && (r3 = d2), o2.ended ? function(t5, e4) {
          var r4 = new Error("write after end");
          t5.emit("error", r4), n.nextTick(e4, r4);
        }(this, r3) : (s3 || function(t5, e4, r4, i4) {
          var o3 = true, a3 = false;
          return null === r4 ? a3 = new TypeError("May not write null values to stream") : "string" == typeof r4 || void 0 === r4 || e4.objectMode || (a3 = new TypeError("Invalid non-string/buffer chunk")), a3 && (t5.emit("error", a3), n.nextTick(i4, a3), o3 = false), o3;
        }(this, o2, t4, r3)) && (o2.pendingcb++, a2 = function(t5, e4, r4, n2, i4, o3) {
          if (!r4) {
            var a3 = function(t6, e5, r5) {
              return t6.objectMode || false === t6.decodeStrings || "string" != typeof e5 || (e5 = l.from(e5, r5)), e5;
            }(e4, n2, i4);
            n2 !== a3 && (r4 = true, i4 = "buffer", n2 = a3);
          }
          var s4 = e4.objectMode ? 1 : n2.length;
          e4.length += s4;
          var c2 = e4.length < e4.highWaterMark;
          if (c2 || (e4.needDrain = true), e4.writing || e4.corked) {
            var u2 = e4.lastBufferedRequest;
            e4.lastBufferedRequest = { chunk: n2, encoding: i4, isBuf: r4, callback: o3, next: null }, u2 ? u2.next = e4.lastBufferedRequest : e4.bufferedRequest = e4.lastBufferedRequest, e4.bufferedRequestCount += 1;
          } else
            m2(t5, e4, false, s4, n2, i4, o3);
          return c2;
        }(this, o2, s3, t4, e3, r3)), a2;
      }, b.prototype.cork = function() {
        this._writableState.corked++;
      }, b.prototype.uncork = function() {
        var t4 = this._writableState;
        t4.corked && (t4.corked--, t4.writing || t4.corked || t4.bufferProcessing || !t4.bufferedRequest || g(this, t4));
      }, b.prototype.setDefaultEncoding = function(t4) {
        if ("string" == typeof t4 && (t4 = t4.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t4 + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + t4);
        return this._writableState.defaultEncoding = t4, this;
      }, Object.defineProperty(b.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), b.prototype._write = function(t4, e3, r3) {
        r3(new Error("_write() is not implemented"));
      }, b.prototype._writev = null, b.prototype.end = function(t4, e3, r3) {
        var i3 = this._writableState;
        "function" == typeof t4 ? (r3 = t4, t4 = null, e3 = null) : "function" == typeof e3 && (r3 = e3, e3 = null), null != t4 && this.write(t4, e3), i3.corked && (i3.corked = 1, this.uncork()), i3.ending || function(t5, e4, r4) {
          e4.ending = true, S(t5, e4), r4 && (e4.finished ? n.nextTick(r4) : t5.once("finish", r4)), e4.ended = true, t5.writable = false;
        }(this, i3, r3);
      }, Object.defineProperty(b.prototype, "destroyed", { get: function() {
        return void 0 !== this._writableState && this._writableState.destroyed;
      }, set: function(t4) {
        this._writableState && (this._writableState.destroyed = t4);
      } }), b.prototype.destroy = p.destroy, b.prototype._undestroy = p.undestroy, b.prototype._destroy = function(t4, e3) {
        this.end(), e3(t4);
      };
    }, 6567: (t3, e2, r2) => {
      var n = r2(8317).Buffer, i2 = r2(5340);
      t3.exports = function() {
        function t4() {
          !function(t5, e3) {
            if (!(t5 instanceof e3))
              throw new TypeError("Cannot call a class as a function");
          }(this, t4), this.head = null, this.tail = null, this.length = 0;
        }
        return t4.prototype.push = function(t5) {
          var e3 = { data: t5, next: null };
          this.length > 0 ? this.tail.next = e3 : this.head = e3, this.tail = e3, ++this.length;
        }, t4.prototype.unshift = function(t5) {
          var e3 = { data: t5, next: this.head };
          0 === this.length && (this.tail = e3), this.head = e3, ++this.length;
        }, t4.prototype.shift = function() {
          if (0 !== this.length) {
            var t5 = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t5;
          }
        }, t4.prototype.clear = function() {
          this.head = this.tail = null, this.length = 0;
        }, t4.prototype.join = function(t5) {
          if (0 === this.length)
            return "";
          for (var e3 = this.head, r3 = "" + e3.data; e3 = e3.next; )
            r3 += t5 + e3.data;
          return r3;
        }, t4.prototype.concat = function(t5) {
          if (0 === this.length)
            return n.alloc(0);
          for (var e3, r3, i3 = n.allocUnsafe(t5 >>> 0), o = this.head, a = 0; o; )
            e3 = i3, r3 = a, o.data.copy(e3, r3), a += o.data.length, o = o.next;
          return i3;
        }, t4;
      }(), i2 && i2.inspect && i2.inspect.custom && (t3.exports.prototype[i2.inspect.custom] = function() {
        var t4 = i2.inspect({ length: this.length });
        return this.constructor.name + " " + t4;
      });
    }, 8639: (t3, e2, r2) => {
      var n = r2(4758);
      function i2(t4, e3) {
        t4.emit("error", e3);
      }
      t3.exports = { destroy: function(t4, e3) {
        var r3 = this, o = this._readableState && this._readableState.destroyed, a = this._writableState && this._writableState.destroyed;
        return o || a ? (e3 ? e3(t4) : t4 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, n.nextTick(i2, this, t4)) : n.nextTick(i2, this, t4)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t4 || null, function(t5) {
          !e3 && t5 ? r3._writableState ? r3._writableState.errorEmitted || (r3._writableState.errorEmitted = true, n.nextTick(i2, r3, t5)) : n.nextTick(i2, r3, t5) : e3 && e3(t5);
        }), this);
      }, undestroy: function() {
        this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
      } };
    }, 5864: (t3, e2, r2) => {
      t3.exports = r2(3550).EventEmitter;
    }, 8317: (t3, e2, r2) => {
      var n = r2(5832), i2 = n.Buffer;
      function o(t4, e3) {
        for (var r3 in t4)
          e3[r3] = t4[r3];
      }
      function a(t4, e3, r3) {
        return i2(t4, e3, r3);
      }
      i2.from && i2.alloc && i2.allocUnsafe && i2.allocUnsafeSlow ? t3.exports = n : (o(n, e2), e2.Buffer = a), o(i2, a), a.from = function(t4, e3, r3) {
        if ("number" == typeof t4)
          throw new TypeError("Argument must not be a number");
        return i2(t4, e3, r3);
      }, a.alloc = function(t4, e3, r3) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        var n2 = i2(t4);
        return void 0 !== e3 ? "string" == typeof r3 ? n2.fill(e3, r3) : n2.fill(e3) : n2.fill(0), n2;
      }, a.allocUnsafe = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return i2(t4);
      }, a.allocUnsafeSlow = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return n.SlowBuffer(t4);
      };
    }, 3292: (t3, e2, r2) => {
      (e2 = t3.exports = r2(7991)).Stream = e2, e2.Readable = e2, e2.Writable = r2(9147), e2.Duplex = r2(1313), e2.Transform = r2(1191), e2.PassThrough = r2(9125);
    }, 1058: (t3, e2, r2) => {
      var n = r2(5832).Buffer, i2 = r2(1679), o = r2(6936), a = new Array(16), s2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], c = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], u = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], f = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], l = [0, 1518500249, 1859775393, 2400959708, 2840853838], h2 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function p() {
        o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
      }
      function d2(t4, e3) {
        return t4 << e3 | t4 >>> 32 - e3;
      }
      function y2(t4, e3, r3, n2, i3, o2, a2, s3) {
        return d2(t4 + (e3 ^ r3 ^ n2) + o2 + a2 | 0, s3) + i3 | 0;
      }
      function b(t4, e3, r3, n2, i3, o2, a2, s3) {
        return d2(t4 + (e3 & r3 | ~e3 & n2) + o2 + a2 | 0, s3) + i3 | 0;
      }
      function m2(t4, e3, r3, n2, i3, o2, a2, s3) {
        return d2(t4 + ((e3 | ~r3) ^ n2) + o2 + a2 | 0, s3) + i3 | 0;
      }
      function v(t4, e3, r3, n2, i3, o2, a2, s3) {
        return d2(t4 + (e3 & n2 | r3 & ~n2) + o2 + a2 | 0, s3) + i3 | 0;
      }
      function g(t4, e3, r3, n2, i3, o2, a2, s3) {
        return d2(t4 + (e3 ^ (r3 | ~n2)) + o2 + a2 | 0, s3) + i3 | 0;
      }
      i2(p, o), p.prototype._update = function() {
        for (var t4 = a, e3 = 0; e3 < 16; ++e3)
          t4[e3] = this._block.readInt32LE(4 * e3);
        for (var r3 = 0 | this._a, n2 = 0 | this._b, i3 = 0 | this._c, o2 = 0 | this._d, p2 = 0 | this._e, _ = 0 | this._a, w2 = 0 | this._b, S = 0 | this._c, O = 0 | this._d, j = 0 | this._e, $ = 0; $ < 80; $ += 1) {
          var A, E;
          $ < 16 ? (A = y2(r3, n2, i3, o2, p2, t4[s2[$]], l[0], u[$]), E = g(_, w2, S, O, j, t4[c[$]], h2[0], f[$])) : $ < 32 ? (A = b(r3, n2, i3, o2, p2, t4[s2[$]], l[1], u[$]), E = v(_, w2, S, O, j, t4[c[$]], h2[1], f[$])) : $ < 48 ? (A = m2(r3, n2, i3, o2, p2, t4[s2[$]], l[2], u[$]), E = m2(_, w2, S, O, j, t4[c[$]], h2[2], f[$])) : $ < 64 ? (A = v(r3, n2, i3, o2, p2, t4[s2[$]], l[3], u[$]), E = b(_, w2, S, O, j, t4[c[$]], h2[3], f[$])) : (A = g(r3, n2, i3, o2, p2, t4[s2[$]], l[4], u[$]), E = y2(_, w2, S, O, j, t4[c[$]], h2[4], f[$])), r3 = p2, p2 = o2, o2 = d2(i3, 10), i3 = n2, n2 = A, _ = j, j = O, O = d2(S, 10), S = w2, w2 = E;
        }
        var x = this._b + i3 + O | 0;
        this._b = this._c + o2 + j | 0, this._c = this._d + p2 + _ | 0, this._d = this._e + r3 + w2 | 0, this._e = this._a + n2 + S | 0, this._a = x;
      }, p.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t4 = n.alloc ? n.alloc(20) : new n(20);
        return t4.writeInt32LE(this._a, 0), t4.writeInt32LE(this._b, 4), t4.writeInt32LE(this._c, 8), t4.writeInt32LE(this._d, 12), t4.writeInt32LE(this._e, 16), t4;
      }, t3.exports = p;
    }, 9732: (t3, e2, r2) => {
      var n = r2(5832), i2 = n.Buffer;
      function o(t4, e3) {
        for (var r3 in t4)
          e3[r3] = t4[r3];
      }
      function a(t4, e3, r3) {
        return i2(t4, e3, r3);
      }
      i2.from && i2.alloc && i2.allocUnsafe && i2.allocUnsafeSlow ? t3.exports = n : (o(n, e2), e2.Buffer = a), a.prototype = Object.create(i2.prototype), o(i2, a), a.from = function(t4, e3, r3) {
        if ("number" == typeof t4)
          throw new TypeError("Argument must not be a number");
        return i2(t4, e3, r3);
      }, a.alloc = function(t4, e3, r3) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        var n2 = i2(t4);
        return void 0 !== e3 ? "string" == typeof r3 ? n2.fill(e3, r3) : n2.fill(e3) : n2.fill(0), n2;
      }, a.allocUnsafe = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return i2(t4);
      }, a.allocUnsafeSlow = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return n.SlowBuffer(t4);
      };
    }, 3900: (t3, e2, r2) => {
      var n = r2(6400), i2 = r2(6750), o = r2(3191)(), a = r2(1464), s2 = r2(2268), c = n("%Math.floor%");
      t3.exports = function(t4, e3) {
        if ("function" != typeof t4)
          throw new s2("`fn` is not a function");
        if ("number" != typeof e3 || e3 < 0 || e3 > 4294967295 || c(e3) !== e3)
          throw new s2("`length` must be a positive 32-bit integer");
        var r3 = arguments.length > 2 && !!arguments[2], n2 = true, u = true;
        if ("length" in t4 && a) {
          var f = a(t4, "length");
          f && !f.configurable && (n2 = false), f && !f.writable && (u = false);
        }
        return (n2 || u || !r3) && (o ? i2(t4, "length", e3, true, true) : i2(t4, "length", e3)), t4;
      };
    }, 1485: (t3, e2, r2) => {
      var n = r2(9732).Buffer;
      function i2(t4, e3) {
        this._block = n.alloc(t4), this._finalSize = e3, this._blockSize = t4, this._len = 0;
      }
      i2.prototype.update = function(t4, e3) {
        "string" == typeof t4 && (e3 = e3 || "utf8", t4 = n.from(t4, e3));
        for (var r3 = this._block, i3 = this._blockSize, o = t4.length, a = this._len, s2 = 0; s2 < o; ) {
          for (var c = a % i3, u = Math.min(o - s2, i3 - c), f = 0; f < u; f++)
            r3[c + f] = t4[s2 + f];
          s2 += u, (a += u) % i3 == 0 && this._update(r3);
        }
        return this._len += o, this;
      }, i2.prototype.digest = function(t4) {
        var e3 = this._len % this._blockSize;
        this._block[e3] = 128, this._block.fill(0, e3 + 1), e3 >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var r3 = 8 * this._len;
        if (r3 <= 4294967295)
          this._block.writeUInt32BE(r3, this._blockSize - 4);
        else {
          var n2 = (4294967295 & r3) >>> 0, i3 = (r3 - n2) / 4294967296;
          this._block.writeUInt32BE(i3, this._blockSize - 8), this._block.writeUInt32BE(n2, this._blockSize - 4);
        }
        this._update(this._block);
        var o = this._hash();
        return t4 ? o.toString(t4) : o;
      }, i2.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      }, t3.exports = i2;
    }, 3261: (t3, e2, r2) => {
      var n = t3.exports = function(t4) {
        t4 = t4.toLowerCase();
        var e3 = n[t4];
        if (!e3)
          throw new Error(t4 + " is not supported (we accept pull requests)");
        return new e3();
      };
      n.sha = r2(2219), n.sha1 = r2(68), n.sha224 = r2(3027), n.sha256 = r2(8890), n.sha384 = r2(5938), n.sha512 = r2(6467);
    }, 2219: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(1485), o = r2(9732).Buffer, a = [1518500249, 1859775393, -1894007588, -899497514], s2 = new Array(80);
      function c() {
        this.init(), this._w = s2, i2.call(this, 64, 56);
      }
      function u(t4) {
        return t4 << 30 | t4 >>> 2;
      }
      function f(t4, e3, r3, n2) {
        return 0 === t4 ? e3 & r3 | ~e3 & n2 : 2 === t4 ? e3 & r3 | e3 & n2 | r3 & n2 : e3 ^ r3 ^ n2;
      }
      n(c, i2), c.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
      }, c.prototype._update = function(t4) {
        for (var e3, r3 = this._w, n2 = 0 | this._a, i3 = 0 | this._b, o2 = 0 | this._c, s3 = 0 | this._d, c2 = 0 | this._e, l = 0; l < 16; ++l)
          r3[l] = t4.readInt32BE(4 * l);
        for (; l < 80; ++l)
          r3[l] = r3[l - 3] ^ r3[l - 8] ^ r3[l - 14] ^ r3[l - 16];
        for (var h2 = 0; h2 < 80; ++h2) {
          var p = ~~(h2 / 20), d2 = 0 | ((e3 = n2) << 5 | e3 >>> 27) + f(p, i3, o2, s3) + c2 + r3[h2] + a[p];
          c2 = s3, s3 = o2, o2 = u(i3), i3 = n2, n2 = d2;
        }
        this._a = n2 + this._a | 0, this._b = i3 + this._b | 0, this._c = o2 + this._c | 0, this._d = s3 + this._d | 0, this._e = c2 + this._e | 0;
      }, c.prototype._hash = function() {
        var t4 = o.allocUnsafe(20);
        return t4.writeInt32BE(0 | this._a, 0), t4.writeInt32BE(0 | this._b, 4), t4.writeInt32BE(0 | this._c, 8), t4.writeInt32BE(0 | this._d, 12), t4.writeInt32BE(0 | this._e, 16), t4;
      }, t3.exports = c;
    }, 68: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(1485), o = r2(9732).Buffer, a = [1518500249, 1859775393, -1894007588, -899497514], s2 = new Array(80);
      function c() {
        this.init(), this._w = s2, i2.call(this, 64, 56);
      }
      function u(t4) {
        return t4 << 5 | t4 >>> 27;
      }
      function f(t4) {
        return t4 << 30 | t4 >>> 2;
      }
      function l(t4, e3, r3, n2) {
        return 0 === t4 ? e3 & r3 | ~e3 & n2 : 2 === t4 ? e3 & r3 | e3 & n2 | r3 & n2 : e3 ^ r3 ^ n2;
      }
      n(c, i2), c.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
      }, c.prototype._update = function(t4) {
        for (var e3, r3 = this._w, n2 = 0 | this._a, i3 = 0 | this._b, o2 = 0 | this._c, s3 = 0 | this._d, c2 = 0 | this._e, h2 = 0; h2 < 16; ++h2)
          r3[h2] = t4.readInt32BE(4 * h2);
        for (; h2 < 80; ++h2)
          r3[h2] = (e3 = r3[h2 - 3] ^ r3[h2 - 8] ^ r3[h2 - 14] ^ r3[h2 - 16]) << 1 | e3 >>> 31;
        for (var p = 0; p < 80; ++p) {
          var d2 = ~~(p / 20), y2 = u(n2) + l(d2, i3, o2, s3) + c2 + r3[p] + a[d2] | 0;
          c2 = s3, s3 = o2, o2 = f(i3), i3 = n2, n2 = y2;
        }
        this._a = n2 + this._a | 0, this._b = i3 + this._b | 0, this._c = o2 + this._c | 0, this._d = s3 + this._d | 0, this._e = c2 + this._e | 0;
      }, c.prototype._hash = function() {
        var t4 = o.allocUnsafe(20);
        return t4.writeInt32BE(0 | this._a, 0), t4.writeInt32BE(0 | this._b, 4), t4.writeInt32BE(0 | this._c, 8), t4.writeInt32BE(0 | this._d, 12), t4.writeInt32BE(0 | this._e, 16), t4;
      }, t3.exports = c;
    }, 3027: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(8890), o = r2(1485), a = r2(9732).Buffer, s2 = new Array(64);
      function c() {
        this.init(), this._w = s2, o.call(this, 64, 56);
      }
      n(c, i2), c.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
      }, c.prototype._hash = function() {
        var t4 = a.allocUnsafe(28);
        return t4.writeInt32BE(this._a, 0), t4.writeInt32BE(this._b, 4), t4.writeInt32BE(this._c, 8), t4.writeInt32BE(this._d, 12), t4.writeInt32BE(this._e, 16), t4.writeInt32BE(this._f, 20), t4.writeInt32BE(this._g, 24), t4;
      }, t3.exports = c;
    }, 8890: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(1485), o = r2(9732).Buffer, a = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], s2 = new Array(64);
      function c() {
        this.init(), this._w = s2, i2.call(this, 64, 56);
      }
      function u(t4, e3, r3) {
        return r3 ^ t4 & (e3 ^ r3);
      }
      function f(t4, e3, r3) {
        return t4 & e3 | r3 & (t4 | e3);
      }
      function l(t4) {
        return (t4 >>> 2 | t4 << 30) ^ (t4 >>> 13 | t4 << 19) ^ (t4 >>> 22 | t4 << 10);
      }
      function h2(t4) {
        return (t4 >>> 6 | t4 << 26) ^ (t4 >>> 11 | t4 << 21) ^ (t4 >>> 25 | t4 << 7);
      }
      function p(t4) {
        return (t4 >>> 7 | t4 << 25) ^ (t4 >>> 18 | t4 << 14) ^ t4 >>> 3;
      }
      n(c, i2), c.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
      }, c.prototype._update = function(t4) {
        for (var e3, r3 = this._w, n2 = 0 | this._a, i3 = 0 | this._b, o2 = 0 | this._c, s3 = 0 | this._d, c2 = 0 | this._e, d2 = 0 | this._f, y2 = 0 | this._g, b = 0 | this._h, m2 = 0; m2 < 16; ++m2)
          r3[m2] = t4.readInt32BE(4 * m2);
        for (; m2 < 64; ++m2)
          r3[m2] = 0 | (((e3 = r3[m2 - 2]) >>> 17 | e3 << 15) ^ (e3 >>> 19 | e3 << 13) ^ e3 >>> 10) + r3[m2 - 7] + p(r3[m2 - 15]) + r3[m2 - 16];
        for (var v = 0; v < 64; ++v) {
          var g = b + h2(c2) + u(c2, d2, y2) + a[v] + r3[v] | 0, _ = l(n2) + f(n2, i3, o2) | 0;
          b = y2, y2 = d2, d2 = c2, c2 = s3 + g | 0, s3 = o2, o2 = i3, i3 = n2, n2 = g + _ | 0;
        }
        this._a = n2 + this._a | 0, this._b = i3 + this._b | 0, this._c = o2 + this._c | 0, this._d = s3 + this._d | 0, this._e = c2 + this._e | 0, this._f = d2 + this._f | 0, this._g = y2 + this._g | 0, this._h = b + this._h | 0;
      }, c.prototype._hash = function() {
        var t4 = o.allocUnsafe(32);
        return t4.writeInt32BE(this._a, 0), t4.writeInt32BE(this._b, 4), t4.writeInt32BE(this._c, 8), t4.writeInt32BE(this._d, 12), t4.writeInt32BE(this._e, 16), t4.writeInt32BE(this._f, 20), t4.writeInt32BE(this._g, 24), t4.writeInt32BE(this._h, 28), t4;
      }, t3.exports = c;
    }, 5938: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(6467), o = r2(1485), a = r2(9732).Buffer, s2 = new Array(160);
      function c() {
        this.init(), this._w = s2, o.call(this, 128, 112);
      }
      n(c, i2), c.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
      }, c.prototype._hash = function() {
        var t4 = a.allocUnsafe(48);
        function e3(e4, r3, n2) {
          t4.writeInt32BE(e4, n2), t4.writeInt32BE(r3, n2 + 4);
        }
        return e3(this._ah, this._al, 0), e3(this._bh, this._bl, 8), e3(this._ch, this._cl, 16), e3(this._dh, this._dl, 24), e3(this._eh, this._el, 32), e3(this._fh, this._fl, 40), t4;
      }, t3.exports = c;
    }, 6467: (t3, e2, r2) => {
      var n = r2(1679), i2 = r2(1485), o = r2(9732).Buffer, a = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], s2 = new Array(160);
      function c() {
        this.init(), this._w = s2, i2.call(this, 128, 112);
      }
      function u(t4, e3, r3) {
        return r3 ^ t4 & (e3 ^ r3);
      }
      function f(t4, e3, r3) {
        return t4 & e3 | r3 & (t4 | e3);
      }
      function l(t4, e3) {
        return (t4 >>> 28 | e3 << 4) ^ (e3 >>> 2 | t4 << 30) ^ (e3 >>> 7 | t4 << 25);
      }
      function h2(t4, e3) {
        return (t4 >>> 14 | e3 << 18) ^ (t4 >>> 18 | e3 << 14) ^ (e3 >>> 9 | t4 << 23);
      }
      function p(t4, e3) {
        return (t4 >>> 1 | e3 << 31) ^ (t4 >>> 8 | e3 << 24) ^ t4 >>> 7;
      }
      function d2(t4, e3) {
        return (t4 >>> 1 | e3 << 31) ^ (t4 >>> 8 | e3 << 24) ^ (t4 >>> 7 | e3 << 25);
      }
      function y2(t4, e3) {
        return (t4 >>> 19 | e3 << 13) ^ (e3 >>> 29 | t4 << 3) ^ t4 >>> 6;
      }
      function b(t4, e3) {
        return (t4 >>> 19 | e3 << 13) ^ (e3 >>> 29 | t4 << 3) ^ (t4 >>> 6 | e3 << 26);
      }
      function m2(t4, e3) {
        return t4 >>> 0 < e3 >>> 0 ? 1 : 0;
      }
      n(c, i2), c.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
      }, c.prototype._update = function(t4) {
        for (var e3 = this._w, r3 = 0 | this._ah, n2 = 0 | this._bh, i3 = 0 | this._ch, o2 = 0 | this._dh, s3 = 0 | this._eh, c2 = 0 | this._fh, v = 0 | this._gh, g = 0 | this._hh, _ = 0 | this._al, w2 = 0 | this._bl, S = 0 | this._cl, O = 0 | this._dl, j = 0 | this._el, $ = 0 | this._fl, A = 0 | this._gl, E = 0 | this._hl, x = 0; x < 32; x += 2)
          e3[x] = t4.readInt32BE(4 * x), e3[x + 1] = t4.readInt32BE(4 * x + 4);
        for (; x < 160; x += 2) {
          var P = e3[x - 30], k = e3[x - 30 + 1], M = p(P, k), I = d2(k, P), B = y2(P = e3[x - 4], k = e3[x - 4 + 1]), T = b(k, P), R = e3[x - 14], N = e3[x - 14 + 1], D = e3[x - 32], L = e3[x - 32 + 1], U = I + N | 0, C = M + R + m2(U, I) | 0;
          C = (C = C + B + m2(U = U + T | 0, T) | 0) + D + m2(U = U + L | 0, L) | 0, e3[x] = C, e3[x + 1] = U;
        }
        for (var q = 0; q < 160; q += 2) {
          C = e3[q], U = e3[q + 1];
          var F = f(r3, n2, i3), V = f(_, w2, S), z = l(r3, _), K = l(_, r3), H = h2(s3, j), W = h2(j, s3), J = a[q], G = a[q + 1], Y = u(s3, c2, v), Q = u(j, $, A), X = E + W | 0, Z = g + H + m2(X, E) | 0;
          Z = (Z = (Z = Z + Y + m2(X = X + Q | 0, Q) | 0) + J + m2(X = X + G | 0, G) | 0) + C + m2(X = X + U | 0, U) | 0;
          var tt = K + V | 0, et = z + F + m2(tt, K) | 0;
          g = v, E = A, v = c2, A = $, c2 = s3, $ = j, s3 = o2 + Z + m2(j = O + X | 0, O) | 0, o2 = i3, O = S, i3 = n2, S = w2, n2 = r3, w2 = _, r3 = Z + et + m2(_ = X + tt | 0, X) | 0;
        }
        this._al = this._al + _ | 0, this._bl = this._bl + w2 | 0, this._cl = this._cl + S | 0, this._dl = this._dl + O | 0, this._el = this._el + j | 0, this._fl = this._fl + $ | 0, this._gl = this._gl + A | 0, this._hl = this._hl + E | 0, this._ah = this._ah + r3 + m2(this._al, _) | 0, this._bh = this._bh + n2 + m2(this._bl, w2) | 0, this._ch = this._ch + i3 + m2(this._cl, S) | 0, this._dh = this._dh + o2 + m2(this._dl, O) | 0, this._eh = this._eh + s3 + m2(this._el, j) | 0, this._fh = this._fh + c2 + m2(this._fl, $) | 0, this._gh = this._gh + v + m2(this._gl, A) | 0, this._hh = this._hh + g + m2(this._hl, E) | 0;
      }, c.prototype._hash = function() {
        var t4 = o.allocUnsafe(64);
        function e3(e4, r3, n2) {
          t4.writeInt32BE(e4, n2), t4.writeInt32BE(r3, n2 + 4);
        }
        return e3(this._ah, this._al, 0), e3(this._bh, this._bl, 8), e3(this._ch, this._cl, 16), e3(this._dh, this._dl, 24), e3(this._eh, this._el, 32), e3(this._fh, this._fl, 40), e3(this._gh, this._gl, 48), e3(this._hh, this._hl, 56), t4;
      }, t3.exports = c;
    }, 7775: (t3, e2, r2) => {
      t3.exports = i2;
      var n = r2(3550).EventEmitter;
      function i2() {
        n.call(this);
      }
      r2(1679)(i2, n), i2.Readable = r2(8134), i2.Writable = r2(4186), i2.Duplex = r2(4560), i2.Transform = r2(8784), i2.PassThrough = r2(1026), i2.finished = r2(8500), i2.pipeline = r2(1144), i2.Stream = i2, i2.prototype.pipe = function(t4, e3) {
        var r3 = this;
        function i3(e4) {
          t4.writable && false === t4.write(e4) && r3.pause && r3.pause();
        }
        function o() {
          r3.readable && r3.resume && r3.resume();
        }
        r3.on("data", i3), t4.on("drain", o), t4._isStdio || e3 && false === e3.end || (r3.on("end", s2), r3.on("close", c));
        var a = false;
        function s2() {
          a || (a = true, t4.end());
        }
        function c() {
          a || (a = true, "function" == typeof t4.destroy && t4.destroy());
        }
        function u(t5) {
          if (f(), 0 === n.listenerCount(this, "error"))
            throw t5;
        }
        function f() {
          r3.removeListener("data", i3), t4.removeListener("drain", o), r3.removeListener("end", s2), r3.removeListener("close", c), r3.removeListener("error", u), t4.removeListener("error", u), r3.removeListener("end", f), r3.removeListener("close", f), t4.removeListener("close", f);
        }
        return r3.on("error", u), t4.on("error", u), r3.on("end", f), r3.on("close", f), t4.on("close", f), t4.emit("pipe", r3), t4;
      };
    }, 198: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      var r2 = {};
      function n(t4, e3, n2) {
        n2 || (n2 = Error);
        var i3 = function(t5) {
          var r3, n3;
          function i4(r4, n4, i5) {
            return t5.call(this, function(t6, r5, n5) {
              return "string" == typeof e3 ? e3 : e3(t6, r5, n5);
            }(r4, n4, i5)) || this;
          }
          return n3 = t5, (r3 = i4).prototype = Object.create(n3.prototype), r3.prototype.constructor = r3, r3.__proto__ = n3, i4;
        }(n2);
        i3.prototype.name = n2.name, i3.prototype.code = t4, r2[t4] = i3;
      }
      function i2(t4, e3) {
        if (Array.isArray(t4)) {
          var r3 = t4.length;
          return t4 = t4.map(function(t5) {
            return String(t5);
          }), r3 > 2 ? "one of ".concat(e3, " ").concat(t4.slice(0, r3 - 1).join(", "), ", or ") + t4[r3 - 1] : 2 === r3 ? "one of ".concat(e3, " ").concat(t4[0], " or ").concat(t4[1]) : "of ".concat(e3, " ").concat(t4[0]);
        }
        return "of ".concat(e3, " ").concat(String(t4));
      }
      n("ERR_INVALID_OPT_VALUE", function(t4, e3) {
        return 'The value "' + e3 + '" is invalid for option "' + t4 + '"';
      }, TypeError), n("ERR_INVALID_ARG_TYPE", function(t4, r3, n2) {
        var o, a, s2, c, u;
        if ("string" == typeof r3 && (a = "not ", r3.substr(0, 4) === a) ? (o = "must not be", r3 = r3.replace(/^not /, "")) : o = "must be", function(t5, e3, r4) {
          return (void 0 === r4 || r4 > t5.length) && (r4 = t5.length), t5.substring(r4 - 9, r4) === e3;
        }(t4, " argument"))
          s2 = "The ".concat(t4, " ").concat(o, " ").concat(i2(r3, "type"));
        else {
          var f = ("number" != typeof u && (u = 0), u + 1 > (c = t4).length || -1 === c.indexOf(".", u) ? "argument" : "property");
          s2 = 'The "'.concat(t4, '" ').concat(f, " ").concat(o, " ").concat(i2(r3, "type"));
        }
        return s2 + ". Received type ".concat(e2(n2));
      }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(t4) {
        return "The " + t4 + " method is not implemented";
      }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(t4) {
        return "Cannot call " + t4 + " after a stream was destroyed";
      }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(t4) {
        return "Unknown encoding: " + t4;
      }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t3.exports.F = r2;
    }, 4560: (t3, e2, r2) => {
      var n = Object.keys || function(t4) {
        var e3 = [];
        for (var r3 in t4)
          e3.push(r3);
        return e3;
      };
      t3.exports = u;
      var i2 = r2(8134), o = r2(4186);
      r2(1679)(u, i2);
      for (var a = n(o.prototype), s2 = 0; s2 < a.length; s2++) {
        var c = a[s2];
        u.prototype[c] || (u.prototype[c] = o.prototype[c]);
      }
      function u(t4) {
        if (!(this instanceof u))
          return new u(t4);
        i2.call(this, t4), o.call(this, t4), this.allowHalfOpen = true, t4 && (false === t4.readable && (this.readable = false), false === t4.writable && (this.writable = false), false === t4.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", f)));
      }
      function f() {
        this._writableState.ended || { env: {} }.nextTick(l, this);
      }
      function l(t4) {
        t4.end();
      }
      Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: false, get: function() {
        return this._writableState && this._writableState.getBuffer();
      } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: false, get: function() {
        return this._writableState.length;
      } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: false, get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
      }, set: function(t4) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = t4, this._writableState.destroyed = t4);
      } });
    }, 1026: (t3, e2, r2) => {
      t3.exports = i2;
      var n = r2(8784);
      function i2(t4) {
        if (!(this instanceof i2))
          return new i2(t4);
        n.call(this, t4);
      }
      r2(1679)(i2, n), i2.prototype._transform = function(t4, e3, r3) {
        r3(null, t4);
      };
    }, 8134: (t3, e2, r2) => {
      var n;
      t3.exports = j, j.ReadableState = O, r2(3550).EventEmitter;
      var i2, o = function(t4, e3) {
        return t4.listeners(e3).length;
      }, a = r2(6871), s2 = r2(5832).Buffer, c = (void 0 !== r2.g ? r2.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
      }, u = r2(7199);
      i2 = u && u.debuglog ? u.debuglog("stream") : function() {
      };
      var f, l, h2, p = r2(6811), d2 = r2(6222), y2 = r2(9681).getHighWaterMark, b = r2(198).F, m2 = b.ERR_INVALID_ARG_TYPE, v = b.ERR_STREAM_PUSH_AFTER_EOF, g = b.ERR_METHOD_NOT_IMPLEMENTED, _ = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      r2(1679)(j, a);
      var w2 = d2.errorOrDestroy, S = ["error", "close", "destroy", "pause", "resume"];
      function O(t4, e3, i3) {
        n = n || r2(4560), t4 = t4 || {}, "boolean" != typeof i3 && (i3 = e3 instanceof n), this.objectMode = !!t4.objectMode, i3 && (this.objectMode = this.objectMode || !!t4.readableObjectMode), this.highWaterMark = y2(this, t4, "readableHighWaterMark", i3), this.buffer = new p(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (f || (f = r2(136).I), this.decoder = new f(t4.encoding), this.encoding = t4.encoding);
      }
      function j(t4) {
        if (n = n || r2(4560), !(this instanceof j))
          return new j(t4);
        var e3 = this instanceof n;
        this._readableState = new O(t4, this, e3), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), a.call(this);
      }
      function $(t4, e3, r3, n2, o2) {
        i2("readableAddChunk", e3);
        var a2, u2 = t4._readableState;
        if (null === e3)
          u2.reading = false, function(t5, e4) {
            if (i2("onEofChunk"), !e4.ended) {
              if (e4.decoder) {
                var r4 = e4.decoder.end();
                r4 && r4.length && (e4.buffer.push(r4), e4.length += e4.objectMode ? 1 : r4.length);
              }
              e4.ended = true, e4.sync ? P(t5) : (e4.needReadable = false, e4.emittedReadable || (e4.emittedReadable = true, k(t5)));
            }
          }(t4, u2);
        else if (o2 || (a2 = function(t5, e4) {
          var r4, n3;
          return n3 = e4, s2.isBuffer(n3) || n3 instanceof c || "string" == typeof e4 || void 0 === e4 || t5.objectMode || (r4 = new m2("chunk", ["string", "Buffer", "Uint8Array"], e4)), r4;
        }(u2, e3)), a2)
          w2(t4, a2);
        else if (u2.objectMode || e3 && e3.length > 0)
          if ("string" == typeof e3 || u2.objectMode || Object.getPrototypeOf(e3) === s2.prototype || (e3 = function(t5) {
            return s2.from(t5);
          }(e3)), n2)
            u2.endEmitted ? w2(t4, new _()) : A(t4, u2, e3, true);
          else if (u2.ended)
            w2(t4, new v());
          else {
            if (u2.destroyed)
              return false;
            u2.reading = false, u2.decoder && !r3 ? (e3 = u2.decoder.write(e3), u2.objectMode || 0 !== e3.length ? A(t4, u2, e3, false) : M(t4, u2)) : A(t4, u2, e3, false);
          }
        else
          n2 || (u2.reading = false, M(t4, u2));
        return !u2.ended && (u2.length < u2.highWaterMark || 0 === u2.length);
      }
      function A(t4, e3, r3, n2) {
        e3.flowing && 0 === e3.length && !e3.sync ? (e3.awaitDrain = 0, t4.emit("data", r3)) : (e3.length += e3.objectMode ? 1 : r3.length, n2 ? e3.buffer.unshift(r3) : e3.buffer.push(r3), e3.needReadable && P(t4)), M(t4, e3);
      }
      Object.defineProperty(j.prototype, "destroyed", { enumerable: false, get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed;
      }, set: function(t4) {
        this._readableState && (this._readableState.destroyed = t4);
      } }), j.prototype.destroy = d2.destroy, j.prototype._undestroy = d2.undestroy, j.prototype._destroy = function(t4, e3) {
        e3(t4);
      }, j.prototype.push = function(t4, e3) {
        var r3, n2 = this._readableState;
        return n2.objectMode ? r3 = true : "string" == typeof t4 && ((e3 = e3 || n2.defaultEncoding) !== n2.encoding && (t4 = s2.from(t4, e3), e3 = ""), r3 = true), $(this, t4, e3, false, r3);
      }, j.prototype.unshift = function(t4) {
        return $(this, t4, null, true, false);
      }, j.prototype.isPaused = function() {
        return false === this._readableState.flowing;
      }, j.prototype.setEncoding = function(t4) {
        f || (f = r2(136).I);
        var e3 = new f(t4);
        this._readableState.decoder = e3, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var n2 = this._readableState.buffer.head, i3 = ""; null !== n2; )
          i3 += e3.write(n2.data), n2 = n2.next;
        return this._readableState.buffer.clear(), "" !== i3 && this._readableState.buffer.push(i3), this._readableState.length = i3.length, this;
      };
      var E = 1073741824;
      function x(t4, e3) {
        return t4 <= 0 || 0 === e3.length && e3.ended ? 0 : e3.objectMode ? 1 : t4 != t4 ? e3.flowing && e3.length ? e3.buffer.head.data.length : e3.length : (t4 > e3.highWaterMark && (e3.highWaterMark = function(t5) {
          return t5 >= E ? t5 = E : (t5--, t5 |= t5 >>> 1, t5 |= t5 >>> 2, t5 |= t5 >>> 4, t5 |= t5 >>> 8, t5 |= t5 >>> 16, t5++), t5;
        }(t4)), t4 <= e3.length ? t4 : e3.ended ? e3.length : (e3.needReadable = true, 0));
      }
      function P(t4) {
        var e3 = t4._readableState;
        i2("emitReadable", e3.needReadable, e3.emittedReadable), e3.needReadable = false, e3.emittedReadable || (i2("emitReadable", e3.flowing), e3.emittedReadable = true, { env: {} }.nextTick(k, t4));
      }
      function k(t4) {
        var e3 = t4._readableState;
        i2("emitReadable_", e3.destroyed, e3.length, e3.ended), e3.destroyed || !e3.length && !e3.ended || (t4.emit("readable"), e3.emittedReadable = false), e3.needReadable = !e3.flowing && !e3.ended && e3.length <= e3.highWaterMark, N(t4);
      }
      function M(t4, e3) {
        e3.readingMore || (e3.readingMore = true, { env: {} }.nextTick(I, t4, e3));
      }
      function I(t4, e3) {
        for (; !e3.reading && !e3.ended && (e3.length < e3.highWaterMark || e3.flowing && 0 === e3.length); ) {
          var r3 = e3.length;
          if (i2("maybeReadMore read 0"), t4.read(0), r3 === e3.length)
            break;
        }
        e3.readingMore = false;
      }
      function B(t4) {
        var e3 = t4._readableState;
        e3.readableListening = t4.listenerCount("readable") > 0, e3.resumeScheduled && !e3.paused ? e3.flowing = true : t4.listenerCount("data") > 0 && t4.resume();
      }
      function T(t4) {
        i2("readable nexttick read 0"), t4.read(0);
      }
      function R(t4, e3) {
        i2("resume", e3.reading), e3.reading || t4.read(0), e3.resumeScheduled = false, t4.emit("resume"), N(t4), e3.flowing && !e3.reading && t4.read(0);
      }
      function N(t4) {
        var e3 = t4._readableState;
        for (i2("flow", e3.flowing); e3.flowing && null !== t4.read(); )
          ;
      }
      function D(t4, e3) {
        return 0 === e3.length ? null : (e3.objectMode ? r3 = e3.buffer.shift() : !t4 || t4 >= e3.length ? (r3 = e3.decoder ? e3.buffer.join("") : 1 === e3.buffer.length ? e3.buffer.first() : e3.buffer.concat(e3.length), e3.buffer.clear()) : r3 = e3.buffer.consume(t4, e3.decoder), r3);
        var r3;
      }
      function L(t4) {
        var e3 = t4._readableState;
        i2("endReadable", e3.endEmitted), e3.endEmitted || (e3.ended = true, { env: {} }.nextTick(U, e3, t4));
      }
      function U(t4, e3) {
        if (i2("endReadableNT", t4.endEmitted, t4.length), !t4.endEmitted && 0 === t4.length && (t4.endEmitted = true, e3.readable = false, e3.emit("end"), t4.autoDestroy)) {
          var r3 = e3._writableState;
          (!r3 || r3.autoDestroy && r3.finished) && e3.destroy();
        }
      }
      function C(t4, e3) {
        for (var r3 = 0, n2 = t4.length; r3 < n2; r3++)
          if (t4[r3] === e3)
            return r3;
        return -1;
      }
      j.prototype.read = function(t4) {
        i2("read", t4), t4 = parseInt(t4, 10);
        var e3 = this._readableState, r3 = t4;
        if (0 !== t4 && (e3.emittedReadable = false), 0 === t4 && e3.needReadable && ((0 !== e3.highWaterMark ? e3.length >= e3.highWaterMark : e3.length > 0) || e3.ended))
          return i2("read: emitReadable", e3.length, e3.ended), 0 === e3.length && e3.ended ? L(this) : P(this), null;
        if (0 === (t4 = x(t4, e3)) && e3.ended)
          return 0 === e3.length && L(this), null;
        var n2, o2 = e3.needReadable;
        return i2("need readable", o2), (0 === e3.length || e3.length - t4 < e3.highWaterMark) && i2("length less than watermark", o2 = true), e3.ended || e3.reading ? i2("reading or ended", o2 = false) : o2 && (i2("do read"), e3.reading = true, e3.sync = true, 0 === e3.length && (e3.needReadable = true), this._read(e3.highWaterMark), e3.sync = false, e3.reading || (t4 = x(r3, e3))), null === (n2 = t4 > 0 ? D(t4, e3) : null) ? (e3.needReadable = e3.length <= e3.highWaterMark, t4 = 0) : (e3.length -= t4, e3.awaitDrain = 0), 0 === e3.length && (e3.ended || (e3.needReadable = true), r3 !== t4 && e3.ended && L(this)), null !== n2 && this.emit("data", n2), n2;
      }, j.prototype._read = function(t4) {
        w2(this, new g("_read()"));
      }, j.prototype.pipe = function(t4, e3) {
        var r3 = this, n2 = this._readableState;
        switch (n2.pipesCount) {
          case 0:
            n2.pipes = t4;
            break;
          case 1:
            n2.pipes = [n2.pipes, t4];
            break;
          default:
            n2.pipes.push(t4);
        }
        n2.pipesCount += 1, i2("pipe count=%d opts=%j", n2.pipesCount, e3);
        var a2 = e3 && false === e3.end || t4 === { env: {} }.stdout || t4 === { env: {} }.stderr ? d3 : s3;
        function s3() {
          i2("onend"), t4.end();
        }
        n2.endEmitted ? { env: {} }.nextTick(a2) : r3.once("end", a2), t4.on("unpipe", function e4(o2, a3) {
          i2("onunpipe"), o2 === r3 && a3 && false === a3.hasUnpiped && (a3.hasUnpiped = true, i2("cleanup"), t4.removeListener("close", h3), t4.removeListener("finish", p2), t4.removeListener("drain", c2), t4.removeListener("error", l2), t4.removeListener("unpipe", e4), r3.removeListener("end", s3), r3.removeListener("end", d3), r3.removeListener("data", f2), u2 = true, !n2.awaitDrain || t4._writableState && !t4._writableState.needDrain || c2());
        });
        var c2 = /* @__PURE__ */ function(t5) {
          return function() {
            var e4 = t5._readableState;
            i2("pipeOnDrain", e4.awaitDrain), e4.awaitDrain && e4.awaitDrain--, 0 === e4.awaitDrain && o(t5, "data") && (e4.flowing = true, N(t5));
          };
        }(r3);
        t4.on("drain", c2);
        var u2 = false;
        function f2(e4) {
          i2("ondata");
          var o2 = t4.write(e4);
          i2("dest.write", o2), false === o2 && ((1 === n2.pipesCount && n2.pipes === t4 || n2.pipesCount > 1 && -1 !== C(n2.pipes, t4)) && !u2 && (i2("false write response, pause", n2.awaitDrain), n2.awaitDrain++), r3.pause());
        }
        function l2(e4) {
          i2("onerror", e4), d3(), t4.removeListener("error", l2), 0 === o(t4, "error") && w2(t4, e4);
        }
        function h3() {
          t4.removeListener("finish", p2), d3();
        }
        function p2() {
          i2("onfinish"), t4.removeListener("close", h3), d3();
        }
        function d3() {
          i2("unpipe"), r3.unpipe(t4);
        }
        return r3.on("data", f2), function(t5, e4, r4) {
          if ("function" == typeof t5.prependListener)
            return t5.prependListener(e4, r4);
          t5._events && t5._events[e4] ? Array.isArray(t5._events[e4]) ? t5._events[e4].unshift(r4) : t5._events[e4] = [r4, t5._events[e4]] : t5.on(e4, r4);
        }(t4, "error", l2), t4.once("close", h3), t4.once("finish", p2), t4.emit("pipe", r3), n2.flowing || (i2("pipe resume"), r3.resume()), t4;
      }, j.prototype.unpipe = function(t4) {
        var e3 = this._readableState, r3 = { hasUnpiped: false };
        if (0 === e3.pipesCount)
          return this;
        if (1 === e3.pipesCount)
          return t4 && t4 !== e3.pipes || (t4 || (t4 = e3.pipes), e3.pipes = null, e3.pipesCount = 0, e3.flowing = false, t4 && t4.emit("unpipe", this, r3)), this;
        if (!t4) {
          var n2 = e3.pipes, i3 = e3.pipesCount;
          e3.pipes = null, e3.pipesCount = 0, e3.flowing = false;
          for (var o2 = 0; o2 < i3; o2++)
            n2[o2].emit("unpipe", this, { hasUnpiped: false });
          return this;
        }
        var a2 = C(e3.pipes, t4);
        return -1 === a2 || (e3.pipes.splice(a2, 1), e3.pipesCount -= 1, 1 === e3.pipesCount && (e3.pipes = e3.pipes[0]), t4.emit("unpipe", this, r3)), this;
      }, j.prototype.on = function(t4, e3) {
        var r3 = a.prototype.on.call(this, t4, e3), n2 = this._readableState;
        return "data" === t4 ? (n2.readableListening = this.listenerCount("readable") > 0, false !== n2.flowing && this.resume()) : "readable" === t4 && (n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.flowing = false, n2.emittedReadable = false, i2("on readable", n2.length, n2.reading), n2.length ? P(this) : n2.reading || { env: {} }.nextTick(T, this))), r3;
      }, j.prototype.addListener = j.prototype.on, j.prototype.removeListener = function(t4, e3) {
        var r3 = a.prototype.removeListener.call(this, t4, e3);
        return "readable" === t4 && { env: {} }.nextTick(B, this), r3;
      }, j.prototype.removeAllListeners = function(t4) {
        var e3 = a.prototype.removeAllListeners.apply(this, arguments);
        return "readable" !== t4 && void 0 !== t4 || { env: {} }.nextTick(B, this), e3;
      }, j.prototype.resume = function() {
        var t4 = this._readableState;
        return t4.flowing || (i2("resume"), t4.flowing = !t4.readableListening, function(t5, e3) {
          e3.resumeScheduled || (e3.resumeScheduled = true, { env: {} }.nextTick(R, t5, e3));
        }(this, t4)), t4.paused = false, this;
      }, j.prototype.pause = function() {
        return i2("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (i2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
      }, j.prototype.wrap = function(t4) {
        var e3 = this, r3 = this._readableState, n2 = false;
        for (var o2 in t4.on("end", function() {
          if (i2("wrapped end"), r3.decoder && !r3.ended) {
            var t5 = r3.decoder.end();
            t5 && t5.length && e3.push(t5);
          }
          e3.push(null);
        }), t4.on("data", function(o3) {
          i2("wrapped data"), r3.decoder && (o3 = r3.decoder.write(o3)), r3.objectMode && null == o3 || (r3.objectMode || o3 && o3.length) && (e3.push(o3) || (n2 = true, t4.pause()));
        }), t4)
          void 0 === this[o2] && "function" == typeof t4[o2] && (this[o2] = /* @__PURE__ */ function(e4) {
            return function() {
              return t4[e4].apply(t4, arguments);
            };
          }(o2));
        for (var a2 = 0; a2 < S.length; a2++)
          t4.on(S[a2], this.emit.bind(this, S[a2]));
        return this._read = function(e4) {
          i2("wrapped _read", e4), n2 && (n2 = false, t4.resume());
        }, this;
      }, "function" == typeof Symbol && (j.prototype[Symbol.asyncIterator] = function() {
        return void 0 === l && (l = r2(8493)), l(this);
      }), Object.defineProperty(j.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
        return this._readableState.highWaterMark;
      } }), Object.defineProperty(j.prototype, "readableBuffer", { enumerable: false, get: function() {
        return this._readableState && this._readableState.buffer;
      } }), Object.defineProperty(j.prototype, "readableFlowing", { enumerable: false, get: function() {
        return this._readableState.flowing;
      }, set: function(t4) {
        this._readableState && (this._readableState.flowing = t4);
      } }), j._fromList = D, Object.defineProperty(j.prototype, "readableLength", { enumerable: false, get: function() {
        return this._readableState.length;
      } }), "function" == typeof Symbol && (j.from = function(t4, e3) {
        return void 0 === h2 && (h2 = r2(9271)), h2(j, t4, e3);
      });
    }, 8784: (t3, e2, r2) => {
      t3.exports = f;
      var n = r2(198).F, i2 = n.ERR_METHOD_NOT_IMPLEMENTED, o = n.ERR_MULTIPLE_CALLBACK, a = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, s2 = n.ERR_TRANSFORM_WITH_LENGTH_0, c = r2(4560);
      function u(t4, e3) {
        var r3 = this._transformState;
        r3.transforming = false;
        var n2 = r3.writecb;
        if (null === n2)
          return this.emit("error", new o());
        r3.writechunk = null, r3.writecb = null, null != e3 && this.push(e3), n2(t4);
        var i3 = this._readableState;
        i3.reading = false, (i3.needReadable || i3.length < i3.highWaterMark) && this._read(i3.highWaterMark);
      }
      function f(t4) {
        if (!(this instanceof f))
          return new f(t4);
        c.call(this, t4), this._transformState = { afterTransform: u.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t4 && ("function" == typeof t4.transform && (this._transform = t4.transform), "function" == typeof t4.flush && (this._flush = t4.flush)), this.on("prefinish", l);
      }
      function l() {
        var t4 = this;
        "function" != typeof this._flush || this._readableState.destroyed ? h2(this, null, null) : this._flush(function(e3, r3) {
          h2(t4, e3, r3);
        });
      }
      function h2(t4, e3, r3) {
        if (e3)
          return t4.emit("error", e3);
        if (null != r3 && t4.push(r3), t4._writableState.length)
          throw new s2();
        if (t4._transformState.transforming)
          throw new a();
        return t4.push(null);
      }
      r2(1679)(f, c), f.prototype.push = function(t4, e3) {
        return this._transformState.needTransform = false, c.prototype.push.call(this, t4, e3);
      }, f.prototype._transform = function(t4, e3, r3) {
        r3(new i2("_transform()"));
      }, f.prototype._write = function(t4, e3, r3) {
        var n2 = this._transformState;
        if (n2.writecb = r3, n2.writechunk = t4, n2.writeencoding = e3, !n2.transforming) {
          var i3 = this._readableState;
          (n2.needTransform || i3.needReadable || i3.length < i3.highWaterMark) && this._read(i3.highWaterMark);
        }
      }, f.prototype._read = function(t4) {
        var e3 = this._transformState;
        null === e3.writechunk || e3.transforming ? e3.needTransform = true : (e3.transforming = true, this._transform(e3.writechunk, e3.writeencoding, e3.afterTransform));
      }, f.prototype._destroy = function(t4, e3) {
        c.prototype._destroy.call(this, t4, function(t5) {
          e3(t5);
        });
      };
    }, 4186: (t3, e2, r2) => {
      function n(t4) {
        var e3 = this;
        this.next = null, this.entry = null, this.finish = function() {
          !function(t5, e4, r3) {
            var n2 = t5.entry;
            for (t5.entry = null; n2; ) {
              var i3 = n2.callback;
              e4.pendingcb--, i3(void 0), n2 = n2.next;
            }
            e4.corkedRequestsFree.next = t5;
          }(e3, t4);
        };
      }
      var i2;
      t3.exports = j, j.WritableState = O;
      var o, a = { deprecate: r2(3340) }, s2 = r2(6871), c = r2(5832).Buffer, u = (void 0 !== r2.g ? r2.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
      }, f = r2(6222), l = r2(9681).getHighWaterMark, h2 = r2(198).F, p = h2.ERR_INVALID_ARG_TYPE, d2 = h2.ERR_METHOD_NOT_IMPLEMENTED, y2 = h2.ERR_MULTIPLE_CALLBACK, b = h2.ERR_STREAM_CANNOT_PIPE, m2 = h2.ERR_STREAM_DESTROYED, v = h2.ERR_STREAM_NULL_VALUES, g = h2.ERR_STREAM_WRITE_AFTER_END, _ = h2.ERR_UNKNOWN_ENCODING, w2 = f.errorOrDestroy;
      function S() {
      }
      function O(t4, e3, o2) {
        i2 = i2 || r2(4560), t4 = t4 || {}, "boolean" != typeof o2 && (o2 = e3 instanceof i2), this.objectMode = !!t4.objectMode, o2 && (this.objectMode = this.objectMode || !!t4.writableObjectMode), this.highWaterMark = l(this, t4, "writableHighWaterMark", o2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
        var a2 = false === t4.decodeStrings;
        this.decodeStrings = !a2, this.defaultEncoding = t4.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(t5) {
          !function(t6, e4) {
            var r3 = t6._writableState, n2 = r3.sync, i3 = r3.writecb;
            if ("function" != typeof i3)
              throw new y2();
            if (function(t7) {
              t7.writing = false, t7.writecb = null, t7.length -= t7.writelen, t7.writelen = 0;
            }(r3), e4)
              !function(t7, e5, r4, n3, i4) {
                --e5.pendingcb, r4 ? ({ env: {} }.nextTick(i4, n3), { env: {} }.nextTick(k, t7, e5), t7._writableState.errorEmitted = true, w2(t7, n3)) : (i4(n3), t7._writableState.errorEmitted = true, w2(t7, n3), k(t7, e5));
              }(t6, r3, n2, e4, i3);
            else {
              var o3 = x(r3) || t6.destroyed;
              o3 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || E(t6, r3), n2 ? { env: {} }.nextTick(A, t6, r3, o3, i3) : A(t6, r3, o3, i3);
            }
          }(e3, t5);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
      }
      function j(t4) {
        var e3 = this instanceof (i2 = i2 || r2(4560));
        if (!e3 && !o.call(j, this))
          return new j(t4);
        this._writableState = new O(t4, this, e3), this.writable = true, t4 && ("function" == typeof t4.write && (this._write = t4.write), "function" == typeof t4.writev && (this._writev = t4.writev), "function" == typeof t4.destroy && (this._destroy = t4.destroy), "function" == typeof t4.final && (this._final = t4.final)), s2.call(this);
      }
      function $(t4, e3, r3, n2, i3, o2, a2) {
        e3.writelen = n2, e3.writecb = a2, e3.writing = true, e3.sync = true, e3.destroyed ? e3.onwrite(new m2("write")) : r3 ? t4._writev(i3, e3.onwrite) : t4._write(i3, o2, e3.onwrite), e3.sync = false;
      }
      function A(t4, e3, r3, n2) {
        r3 || function(t5, e4) {
          0 === e4.length && e4.needDrain && (e4.needDrain = false, t5.emit("drain"));
        }(t4, e3), e3.pendingcb--, n2(), k(t4, e3);
      }
      function E(t4, e3) {
        e3.bufferProcessing = true;
        var r3 = e3.bufferedRequest;
        if (t4._writev && r3 && r3.next) {
          var i3 = e3.bufferedRequestCount, o2 = new Array(i3), a2 = e3.corkedRequestsFree;
          a2.entry = r3;
          for (var s3 = 0, c2 = true; r3; )
            o2[s3] = r3, r3.isBuf || (c2 = false), r3 = r3.next, s3 += 1;
          o2.allBuffers = c2, $(t4, e3, true, e3.length, o2, "", a2.finish), e3.pendingcb++, e3.lastBufferedRequest = null, a2.next ? (e3.corkedRequestsFree = a2.next, a2.next = null) : e3.corkedRequestsFree = new n(e3), e3.bufferedRequestCount = 0;
        } else {
          for (; r3; ) {
            var u2 = r3.chunk, f2 = r3.encoding, l2 = r3.callback;
            if ($(t4, e3, false, e3.objectMode ? 1 : u2.length, u2, f2, l2), r3 = r3.next, e3.bufferedRequestCount--, e3.writing)
              break;
          }
          null === r3 && (e3.lastBufferedRequest = null);
        }
        e3.bufferedRequest = r3, e3.bufferProcessing = false;
      }
      function x(t4) {
        return t4.ending && 0 === t4.length && null === t4.bufferedRequest && !t4.finished && !t4.writing;
      }
      function P(t4, e3) {
        t4._final(function(r3) {
          e3.pendingcb--, r3 && w2(t4, r3), e3.prefinished = true, t4.emit("prefinish"), k(t4, e3);
        });
      }
      function k(t4, e3) {
        var r3 = x(e3);
        if (r3 && (function(t5, e4) {
          e4.prefinished || e4.finalCalled || ("function" != typeof t5._final || e4.destroyed ? (e4.prefinished = true, t5.emit("prefinish")) : (e4.pendingcb++, e4.finalCalled = true, { env: {} }.nextTick(P, t5, e4)));
        }(t4, e3), 0 === e3.pendingcb && (e3.finished = true, t4.emit("finish"), e3.autoDestroy))) {
          var n2 = t4._readableState;
          (!n2 || n2.autoDestroy && n2.endEmitted) && t4.destroy();
        }
        return r3;
      }
      r2(1679)(j, s2), O.prototype.getBuffer = function() {
        for (var t4 = this.bufferedRequest, e3 = []; t4; )
          e3.push(t4), t4 = t4.next;
        return e3;
      }, function() {
        try {
          Object.defineProperty(O.prototype, "buffer", { get: a.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
        } catch (t4) {
        }
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (o = Function.prototype[Symbol.hasInstance], Object.defineProperty(j, Symbol.hasInstance, { value: function(t4) {
        return !!o.call(this, t4) || this === j && t4 && t4._writableState instanceof O;
      } })) : o = function(t4) {
        return t4 instanceof this;
      }, j.prototype.pipe = function() {
        w2(this, new b());
      }, j.prototype.write = function(t4, e3, r3) {
        var n2, i3 = this._writableState, o2 = false, a2 = !i3.objectMode && (n2 = t4, c.isBuffer(n2) || n2 instanceof u);
        return a2 && !c.isBuffer(t4) && (t4 = function(t5) {
          return c.from(t5);
        }(t4)), "function" == typeof e3 && (r3 = e3, e3 = null), a2 ? e3 = "buffer" : e3 || (e3 = i3.defaultEncoding), "function" != typeof r3 && (r3 = S), i3.ending ? function(t5, e4) {
          var r4 = new g();
          w2(t5, r4), { env: {} }.nextTick(e4, r4);
        }(this, r3) : (a2 || function(t5, e4, r4, n3) {
          var i4;
          return null === r4 ? i4 = new v() : "string" == typeof r4 || e4.objectMode || (i4 = new p("chunk", ["string", "Buffer"], r4)), !i4 || (w2(t5, i4), { env: {} }.nextTick(n3, i4), false);
        }(this, i3, t4, r3)) && (i3.pendingcb++, o2 = function(t5, e4, r4, n3, i4, o3) {
          if (!r4) {
            var a3 = function(t6, e5, r5) {
              return t6.objectMode || false === t6.decodeStrings || "string" != typeof e5 || (e5 = c.from(e5, r5)), e5;
            }(e4, n3, i4);
            n3 !== a3 && (r4 = true, i4 = "buffer", n3 = a3);
          }
          var s3 = e4.objectMode ? 1 : n3.length;
          e4.length += s3;
          var u2 = e4.length < e4.highWaterMark;
          if (u2 || (e4.needDrain = true), e4.writing || e4.corked) {
            var f2 = e4.lastBufferedRequest;
            e4.lastBufferedRequest = { chunk: n3, encoding: i4, isBuf: r4, callback: o3, next: null }, f2 ? f2.next = e4.lastBufferedRequest : e4.bufferedRequest = e4.lastBufferedRequest, e4.bufferedRequestCount += 1;
          } else
            $(t5, e4, false, s3, n3, i4, o3);
          return u2;
        }(this, i3, a2, t4, e3, r3)), o2;
      }, j.prototype.cork = function() {
        this._writableState.corked++;
      }, j.prototype.uncork = function() {
        var t4 = this._writableState;
        t4.corked && (t4.corked--, t4.writing || t4.corked || t4.bufferProcessing || !t4.bufferedRequest || E(this, t4));
      }, j.prototype.setDefaultEncoding = function(t4) {
        if ("string" == typeof t4 && (t4 = t4.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t4 + "").toLowerCase()) > -1))
          throw new _(t4);
        return this._writableState.defaultEncoding = t4, this;
      }, Object.defineProperty(j.prototype, "writableBuffer", { enumerable: false, get: function() {
        return this._writableState && this._writableState.getBuffer();
      } }), Object.defineProperty(j.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), j.prototype._write = function(t4, e3, r3) {
        r3(new d2("_write()"));
      }, j.prototype._writev = null, j.prototype.end = function(t4, e3, r3) {
        var n2 = this._writableState;
        return "function" == typeof t4 ? (r3 = t4, t4 = null, e3 = null) : "function" == typeof e3 && (r3 = e3, e3 = null), null != t4 && this.write(t4, e3), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || function(t5, e4, r4) {
          e4.ending = true, k(t5, e4), r4 && (e4.finished ? { env: {} }.nextTick(r4) : t5.once("finish", r4)), e4.ended = true, t5.writable = false;
        }(this, n2, r3), this;
      }, Object.defineProperty(j.prototype, "writableLength", { enumerable: false, get: function() {
        return this._writableState.length;
      } }), Object.defineProperty(j.prototype, "destroyed", { enumerable: false, get: function() {
        return void 0 !== this._writableState && this._writableState.destroyed;
      }, set: function(t4) {
        this._writableState && (this._writableState.destroyed = t4);
      } }), j.prototype.destroy = f.destroy, j.prototype._undestroy = f.undestroy, j.prototype._destroy = function(t4, e3) {
        e3(t4);
      };
    }, 8493: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2;
      function o(t4, e3, r3) {
        return (e3 = function(t5) {
          var e4 = function(t6, e5) {
            if ("object" !== n(t6) || null === t6)
              return t6;
            var r4 = t6[Symbol.toPrimitive];
            if (void 0 !== r4) {
              var i3 = r4.call(t6, "string");
              if ("object" !== n(i3))
                return i3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(t6);
          }(t5);
          return "symbol" === n(e4) ? e4 : String(e4);
        }(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      var a = r2(8500), s2 = Symbol("lastResolve"), c = Symbol("lastReject"), u = Symbol("error"), f = Symbol("ended"), l = Symbol("lastPromise"), h2 = Symbol("handlePromise"), p = Symbol("stream");
      function d2(t4, e3) {
        return { value: t4, done: e3 };
      }
      function y2(t4) {
        var e3 = t4[s2];
        if (null !== e3) {
          var r3 = t4[p].read();
          null !== r3 && (t4[l] = null, t4[s2] = null, t4[c] = null, e3(d2(r3, false)));
        }
      }
      function b(t4) {
        ({ env: {} }).nextTick(y2, t4);
      }
      var m2 = Object.getPrototypeOf(function() {
      }), v = Object.setPrototypeOf((o(i2 = { get stream() {
        return this[p];
      }, next: function() {
        var t4 = this, e3 = this[u];
        if (null !== e3)
          return Promise.reject(e3);
        if (this[f])
          return Promise.resolve(d2(void 0, true));
        if (this[p].destroyed)
          return new Promise(function(e4, r4) {
            ({ env: {} }).nextTick(function() {
              t4[u] ? r4(t4[u]) : e4(d2(void 0, true));
            });
          });
        var r3, n2 = this[l];
        if (n2)
          r3 = new Promise(/* @__PURE__ */ function(t5, e4) {
            return function(r4, n3) {
              t5.then(function() {
                e4[f] ? r4(d2(void 0, true)) : e4[h2](r4, n3);
              }, n3);
            };
          }(n2, this));
        else {
          var i3 = this[p].read();
          if (null !== i3)
            return Promise.resolve(d2(i3, false));
          r3 = new Promise(this[h2]);
        }
        return this[l] = r3, r3;
      } }, Symbol.asyncIterator, function() {
        return this;
      }), o(i2, "return", function() {
        var t4 = this;
        return new Promise(function(e3, r3) {
          t4[p].destroy(null, function(t5) {
            t5 ? r3(t5) : e3(d2(void 0, true));
          });
        });
      }), i2), m2);
      t3.exports = function(t4) {
        var e3, r3 = Object.create(v, (o(e3 = {}, p, { value: t4, writable: true }), o(e3, s2, { value: null, writable: true }), o(e3, c, { value: null, writable: true }), o(e3, u, { value: null, writable: true }), o(e3, f, { value: t4._readableState.endEmitted, writable: true }), o(e3, h2, { value: function(t5, e4) {
          var n2 = r3[p].read();
          n2 ? (r3[l] = null, r3[s2] = null, r3[c] = null, t5(d2(n2, false))) : (r3[s2] = t5, r3[c] = e4);
        }, writable: true }), e3));
        return r3[l] = null, a(t4, function(t5) {
          if (t5 && "ERR_STREAM_PREMATURE_CLOSE" !== t5.code) {
            var e4 = r3[c];
            return null !== e4 && (r3[l] = null, r3[s2] = null, r3[c] = null, e4(t5)), void (r3[u] = t5);
          }
          var n2 = r3[s2];
          null !== n2 && (r3[l] = null, r3[s2] = null, r3[c] = null, n2(d2(void 0, true))), r3[f] = true;
        }), t4.on("readable", b.bind(null, r3)), r3;
      };
    }, 6811: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      function i2(t4, e3) {
        var r3 = Object.keys(t4);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(t4);
          e3 && (n2 = n2.filter(function(e4) {
            return Object.getOwnPropertyDescriptor(t4, e4).enumerable;
          })), r3.push.apply(r3, n2);
        }
        return r3;
      }
      function o(t4) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var r3 = null != arguments[e3] ? arguments[e3] : {};
          e3 % 2 ? i2(Object(r3), true).forEach(function(e4) {
            a(t4, e4, r3[e4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(r3)) : i2(Object(r3)).forEach(function(e4) {
            Object.defineProperty(t4, e4, Object.getOwnPropertyDescriptor(r3, e4));
          });
        }
        return t4;
      }
      function a(t4, e3, r3) {
        return (e3 = c(e3)) in t4 ? Object.defineProperty(t4, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t4[e3] = r3, t4;
      }
      function s2(t4, e3) {
        for (var r3 = 0; r3 < e3.length; r3++) {
          var n2 = e3[r3];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t4, c(n2.key), n2);
        }
      }
      function c(t4) {
        var e3 = function(t5, e4) {
          if ("object" !== n(t5) || null === t5)
            return t5;
          var r3 = t5[Symbol.toPrimitive];
          if (void 0 !== r3) {
            var i3 = r3.call(t5, "string");
            if ("object" !== n(i3))
              return i3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" === n(e3) ? e3 : String(e3);
      }
      var u = r2(5832).Buffer, f = r2(3779).inspect, l = f && f.custom || "inspect";
      t3.exports = function() {
        function t4() {
          !function(t5, e4) {
            if (!(t5 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t4), this.head = null, this.tail = null, this.length = 0;
        }
        var e3, r3;
        return e3 = t4, (r3 = [{ key: "push", value: function(t5) {
          var e4 = { data: t5, next: null };
          this.length > 0 ? this.tail.next = e4 : this.head = e4, this.tail = e4, ++this.length;
        } }, { key: "unshift", value: function(t5) {
          var e4 = { data: t5, next: this.head };
          0 === this.length && (this.tail = e4), this.head = e4, ++this.length;
        } }, { key: "shift", value: function() {
          if (0 !== this.length) {
            var t5 = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t5;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(t5) {
          if (0 === this.length)
            return "";
          for (var e4 = this.head, r4 = "" + e4.data; e4 = e4.next; )
            r4 += t5 + e4.data;
          return r4;
        } }, { key: "concat", value: function(t5) {
          if (0 === this.length)
            return u.alloc(0);
          for (var e4, r4, n2, i3 = u.allocUnsafe(t5 >>> 0), o2 = this.head, a2 = 0; o2; )
            e4 = o2.data, r4 = i3, n2 = a2, u.prototype.copy.call(e4, r4, n2), a2 += o2.data.length, o2 = o2.next;
          return i3;
        } }, { key: "consume", value: function(t5, e4) {
          var r4;
          return t5 < this.head.data.length ? (r4 = this.head.data.slice(0, t5), this.head.data = this.head.data.slice(t5)) : r4 = t5 === this.head.data.length ? this.shift() : e4 ? this._getString(t5) : this._getBuffer(t5), r4;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(t5) {
          var e4 = this.head, r4 = 1, n2 = e4.data;
          for (t5 -= n2.length; e4 = e4.next; ) {
            var i3 = e4.data, o2 = t5 > i3.length ? i3.length : t5;
            if (o2 === i3.length ? n2 += i3 : n2 += i3.slice(0, t5), 0 == (t5 -= o2)) {
              o2 === i3.length ? (++r4, e4.next ? this.head = e4.next : this.head = this.tail = null) : (this.head = e4, e4.data = i3.slice(o2));
              break;
            }
            ++r4;
          }
          return this.length -= r4, n2;
        } }, { key: "_getBuffer", value: function(t5) {
          var e4 = u.allocUnsafe(t5), r4 = this.head, n2 = 1;
          for (r4.data.copy(e4), t5 -= r4.data.length; r4 = r4.next; ) {
            var i3 = r4.data, o2 = t5 > i3.length ? i3.length : t5;
            if (i3.copy(e4, e4.length - t5, 0, o2), 0 == (t5 -= o2)) {
              o2 === i3.length ? (++n2, r4.next ? this.head = r4.next : this.head = this.tail = null) : (this.head = r4, r4.data = i3.slice(o2));
              break;
            }
            ++n2;
          }
          return this.length -= n2, e4;
        } }, { key: l, value: function(t5, e4) {
          return f(this, o(o({}, e4), {}, { depth: 0, customInspect: false }));
        } }]) && s2(e3.prototype, r3), Object.defineProperty(e3, "prototype", { writable: false }), t4;
      }();
    }, 6222: (t3) => {
      function e2(t4, e3) {
        n(t4, e3), r2(t4);
      }
      function r2(t4) {
        t4._writableState && !t4._writableState.emitClose || t4._readableState && !t4._readableState.emitClose || t4.emit("close");
      }
      function n(t4, e3) {
        t4.emit("error", e3);
      }
      t3.exports = { destroy: function(t4, i2) {
        var o = this, a = this._readableState && this._readableState.destroyed, s2 = this._writableState && this._writableState.destroyed;
        return a || s2 ? (i2 ? i2(t4) : t4 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, { env: {} }.nextTick(n, this, t4)) : { env: {} }.nextTick(n, this, t4)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t4 || null, function(t5) {
          !i2 && t5 ? o._writableState ? o._writableState.errorEmitted ? { env: {} }.nextTick(r2, o) : (o._writableState.errorEmitted = true, { env: {} }.nextTick(e2, o, t5)) : { env: {} }.nextTick(e2, o, t5) : i2 ? ({ env: {} }.nextTick(r2, o), i2(t5)) : { env: {} }.nextTick(r2, o);
        }), this);
      }, undestroy: function() {
        this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
      }, errorOrDestroy: function(t4, e3) {
        var r3 = t4._readableState, n2 = t4._writableState;
        r3 && r3.autoDestroy || n2 && n2.autoDestroy ? t4.destroy(e3) : t4.emit("error", e3);
      } };
    }, 8500: (t3, e2, r2) => {
      var n = r2(198).F.ERR_STREAM_PREMATURE_CLOSE;
      function i2() {
      }
      t3.exports = function t4(e3, r3, o) {
        if ("function" == typeof r3)
          return t4(e3, null, r3);
        r3 || (r3 = {}), o = /* @__PURE__ */ function(t5) {
          var e4 = false;
          return function() {
            if (!e4) {
              e4 = true;
              for (var r4 = arguments.length, n2 = new Array(r4), i3 = 0; i3 < r4; i3++)
                n2[i3] = arguments[i3];
              t5.apply(this, n2);
            }
          };
        }(o || i2);
        var a = r3.readable || false !== r3.readable && e3.readable, s2 = r3.writable || false !== r3.writable && e3.writable, c = function() {
          e3.writable || f();
        }, u = e3._writableState && e3._writableState.finished, f = function() {
          s2 = false, u = true, a || o.call(e3);
        }, l = e3._readableState && e3._readableState.endEmitted, h2 = function() {
          a = false, l = true, s2 || o.call(e3);
        }, p = function(t5) {
          o.call(e3, t5);
        }, d2 = function() {
          var t5;
          return a && !l ? (e3._readableState && e3._readableState.ended || (t5 = new n()), o.call(e3, t5)) : s2 && !u ? (e3._writableState && e3._writableState.ended || (t5 = new n()), o.call(e3, t5)) : void 0;
        }, y2 = function() {
          e3.req.on("finish", f);
        };
        return function(t5) {
          return t5.setHeader && "function" == typeof t5.abort;
        }(e3) ? (e3.on("complete", f), e3.on("abort", d2), e3.req ? y2() : e3.on("request", y2)) : s2 && !e3._writableState && (e3.on("end", c), e3.on("close", c)), e3.on("end", h2), e3.on("finish", f), false !== r3.error && e3.on("error", p), e3.on("close", d2), function() {
          e3.removeListener("complete", f), e3.removeListener("abort", d2), e3.removeListener("request", y2), e3.req && e3.req.removeListener("finish", f), e3.removeListener("end", c), e3.removeListener("close", c), e3.removeListener("finish", f), e3.removeListener("end", h2), e3.removeListener("error", p), e3.removeListener("close", d2);
        };
      };
    }, 9271: (t3) => {
      t3.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, 1144: (t3, e2, r2) => {
      var n, i2 = r2(198).F, o = i2.ERR_MISSING_ARGS, a = i2.ERR_STREAM_DESTROYED;
      function s2(t4) {
        if (t4)
          throw t4;
      }
      function c(t4) {
        t4();
      }
      function u(t4, e3) {
        return t4.pipe(e3);
      }
      t3.exports = function() {
        for (var t4 = arguments.length, e3 = new Array(t4), i3 = 0; i3 < t4; i3++)
          e3[i3] = arguments[i3];
        var f, l = function(t5) {
          return t5.length ? "function" != typeof t5[t5.length - 1] ? s2 : t5.pop() : s2;
        }(e3);
        if (Array.isArray(e3[0]) && (e3 = e3[0]), e3.length < 2)
          throw new o("streams");
        var h2 = e3.map(function(t5, i4) {
          var o2 = i4 < e3.length - 1;
          return function(t6, e4, i5, o3) {
            o3 = /* @__PURE__ */ function(t7) {
              var e5 = false;
              return function() {
                e5 || (e5 = true, t7.apply(void 0, arguments));
              };
            }(o3);
            var s3 = false;
            t6.on("close", function() {
              s3 = true;
            }), void 0 === n && (n = r2(8500)), n(t6, { readable: e4, writable: i5 }, function(t7) {
              if (t7)
                return o3(t7);
              s3 = true, o3();
            });
            var c2 = false;
            return function(e5) {
              if (!s3 && !c2)
                return c2 = true, function(t7) {
                  return t7.setHeader && "function" == typeof t7.abort;
                }(t6) ? t6.abort() : "function" == typeof t6.destroy ? t6.destroy() : void o3(e5 || new a("pipe"));
            };
          }(t5, o2, i4 > 0, function(t6) {
            f || (f = t6), t6 && h2.forEach(c), o2 || (h2.forEach(c), l(f));
          });
        });
        return e3.reduce(u);
      };
    }, 9681: (t3, e2, r2) => {
      var n = r2(198).F.ERR_INVALID_OPT_VALUE;
      t3.exports = { getHighWaterMark: function(t4, e3, r3, i2) {
        var o = function(t5, e4, r4) {
          return null != t5.highWaterMark ? t5.highWaterMark : e4 ? t5[r4] : null;
        }(e3, i2, r3);
        if (null != o) {
          if (!isFinite(o) || Math.floor(o) !== o || o < 0)
            throw new n(i2 ? r3 : "highWaterMark", o);
          return Math.floor(o);
        }
        return t4.objectMode ? 16 : 16384;
      } };
    }, 6871: (t3, e2, r2) => {
      t3.exports = r2(3550).EventEmitter;
    }, 136: (t3, e2, r2) => {
      var n = r2(2).Buffer, i2 = n.isEncoding || function(t4) {
        switch ((t4 = "" + t4) && t4.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function o(t4) {
        var e3;
        switch (this.encoding = function(t5) {
          var e4 = function(t6) {
            if (!t6)
              return "utf8";
            for (var e5; ; )
              switch (t6) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return t6;
                default:
                  if (e5)
                    return;
                  t6 = ("" + t6).toLowerCase(), e5 = true;
              }
          }(t5);
          if ("string" != typeof e4 && (n.isEncoding === i2 || !i2(t5)))
            throw new Error("Unknown encoding: " + t5);
          return e4 || t5;
        }(t4), this.encoding) {
          case "utf16le":
            this.text = c, this.end = u, e3 = 4;
            break;
          case "utf8":
            this.fillLast = s2, e3 = 4;
            break;
          case "base64":
            this.text = f, this.end = l, e3 = 3;
            break;
          default:
            return this.write = h2, void (this.end = p);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(e3);
      }
      function a(t4) {
        return t4 <= 127 ? 0 : t4 >> 5 == 6 ? 2 : t4 >> 4 == 14 ? 3 : t4 >> 3 == 30 ? 4 : t4 >> 6 == 2 ? -1 : -2;
      }
      function s2(t4) {
        var e3 = this.lastTotal - this.lastNeed, r3 = function(t5, e4, r4) {
          if (128 != (192 & e4[0]))
            return t5.lastNeed = 0, "";
          if (t5.lastNeed > 1 && e4.length > 1) {
            if (128 != (192 & e4[1]))
              return t5.lastNeed = 1, "";
            if (t5.lastNeed > 2 && e4.length > 2 && 128 != (192 & e4[2]))
              return t5.lastNeed = 2, "";
          }
        }(this, t4);
        return void 0 !== r3 ? r3 : this.lastNeed <= t4.length ? (t4.copy(this.lastChar, e3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t4.copy(this.lastChar, e3, 0, t4.length), void (this.lastNeed -= t4.length));
      }
      function c(t4, e3) {
        if ((t4.length - e3) % 2 == 0) {
          var r3 = t4.toString("utf16le", e3);
          if (r3) {
            var n2 = r3.charCodeAt(r3.length - 1);
            if (n2 >= 55296 && n2 <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t4[t4.length - 2], this.lastChar[1] = t4[t4.length - 1], r3.slice(0, -1);
          }
          return r3;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t4[t4.length - 1], t4.toString("utf16le", e3, t4.length - 1);
      }
      function u(t4) {
        var e3 = t4 && t4.length ? this.write(t4) : "";
        if (this.lastNeed) {
          var r3 = this.lastTotal - this.lastNeed;
          return e3 + this.lastChar.toString("utf16le", 0, r3);
        }
        return e3;
      }
      function f(t4, e3) {
        var r3 = (t4.length - e3) % 3;
        return 0 === r3 ? t4.toString("base64", e3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 === r3 ? this.lastChar[0] = t4[t4.length - 1] : (this.lastChar[0] = t4[t4.length - 2], this.lastChar[1] = t4[t4.length - 1]), t4.toString("base64", e3, t4.length - r3));
      }
      function l(t4) {
        var e3 = t4 && t4.length ? this.write(t4) : "";
        return this.lastNeed ? e3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e3;
      }
      function h2(t4) {
        return t4.toString(this.encoding);
      }
      function p(t4) {
        return t4 && t4.length ? this.write(t4) : "";
      }
      e2.I = o, o.prototype.write = function(t4) {
        if (0 === t4.length)
          return "";
        var e3, r3;
        if (this.lastNeed) {
          if (void 0 === (e3 = this.fillLast(t4)))
            return "";
          r3 = this.lastNeed, this.lastNeed = 0;
        } else
          r3 = 0;
        return r3 < t4.length ? e3 ? e3 + this.text(t4, r3) : this.text(t4, r3) : e3 || "";
      }, o.prototype.end = function(t4) {
        var e3 = t4 && t4.length ? this.write(t4) : "";
        return this.lastNeed ? e3 + "" : e3;
      }, o.prototype.text = function(t4, e3) {
        var r3 = function(t5, e4, r4) {
          var n3 = e4.length - 1;
          if (n3 < r4)
            return 0;
          var i3 = a(e4[n3]);
          return i3 >= 0 ? (i3 > 0 && (t5.lastNeed = i3 - 1), i3) : --n3 < r4 || -2 === i3 ? 0 : (i3 = a(e4[n3])) >= 0 ? (i3 > 0 && (t5.lastNeed = i3 - 2), i3) : --n3 < r4 || -2 === i3 ? 0 : (i3 = a(e4[n3])) >= 0 ? (i3 > 0 && (2 === i3 ? i3 = 0 : t5.lastNeed = i3 - 3), i3) : 0;
        }(this, t4, e3);
        if (!this.lastNeed)
          return t4.toString("utf8", e3);
        this.lastTotal = r3;
        var n2 = t4.length - (r3 - this.lastNeed);
        return t4.copy(this.lastChar, 0, n2), t4.toString("utf8", e3, n2);
      }, o.prototype.fillLast = function(t4) {
        if (this.lastNeed <= t4.length)
          return t4.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t4.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t4.length), this.lastNeed -= t4.length;
      };
    }, 2: (t3, e2, r2) => {
      var n = r2(5832), i2 = n.Buffer;
      function o(t4, e3) {
        for (var r3 in t4)
          e3[r3] = t4[r3];
      }
      function a(t4, e3, r3) {
        return i2(t4, e3, r3);
      }
      i2.from && i2.alloc && i2.allocUnsafe && i2.allocUnsafeSlow ? t3.exports = n : (o(n, e2), e2.Buffer = a), o(i2, a), a.from = function(t4, e3, r3) {
        if ("number" == typeof t4)
          throw new TypeError("Argument must not be a number");
        return i2(t4, e3, r3);
      }, a.alloc = function(t4, e3, r3) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        var n2 = i2(t4);
        return void 0 !== e3 ? "string" == typeof r3 ? n2.fill(e3, r3) : n2.fill(e3) : n2.fill(0), n2;
      }, a.allocUnsafe = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return i2(t4);
      }, a.allocUnsafeSlow = function(t4) {
        if ("number" != typeof t4)
          throw new TypeError("Argument must be a number");
        return n.SlowBuffer(t4);
      };
    }, 3340: (t3, e2, r2) => {
      function n(t4) {
        try {
          if (!r2.g.localStorage)
            return false;
        } catch (t5) {
          return false;
        }
        var e3 = r2.g.localStorage[t4];
        return null != e3 && "true" === String(e3).toLowerCase();
      }
      t3.exports = function(t4, e3) {
        if (n("noDeprecation"))
          return t4;
        var r3 = false;
        return function() {
          if (!r3) {
            if (n("throwDeprecation"))
              throw new Error(e3);
            n("traceDeprecation") ? console.trace(e3) : console.warn(e3), r3 = true;
          }
          return t4.apply(this, arguments);
        };
      };
    }, 7944: (t3) => {
      function e2(t4) {
        return e2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, e2(t4);
      }
      t3.exports = function(t4) {
        return t4 && "object" === e2(t4) && "function" == typeof t4.copy && "function" == typeof t4.fill && "function" == typeof t4.readUInt8;
      };
    }, 7595: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(5899), o = r2(1905), a = r2(9834), s2 = r2(7911);
      function c(t4) {
        return t4.call.bind(t4);
      }
      var u = "undefined" != typeof BigInt, f = "undefined" != typeof Symbol, l = c(Object.prototype.toString), h2 = c(Number.prototype.valueOf), p = c(String.prototype.valueOf), d2 = c(Boolean.prototype.valueOf);
      if (u)
        var y2 = c(BigInt.prototype.valueOf);
      if (f)
        var b = c(Symbol.prototype.valueOf);
      function m2(t4, e3) {
        if ("object" !== n(t4))
          return false;
        try {
          return e3(t4), true;
        } catch (t5) {
          return false;
        }
      }
      function v(t4) {
        return "[object Map]" === l(t4);
      }
      function g(t4) {
        return "[object Set]" === l(t4);
      }
      function _(t4) {
        return "[object WeakMap]" === l(t4);
      }
      function w2(t4) {
        return "[object WeakSet]" === l(t4);
      }
      function S(t4) {
        return "[object ArrayBuffer]" === l(t4);
      }
      function O(t4) {
        return "undefined" != typeof ArrayBuffer && (S.working ? S(t4) : t4 instanceof ArrayBuffer);
      }
      function j(t4) {
        return "[object DataView]" === l(t4);
      }
      function $(t4) {
        return "undefined" != typeof DataView && (j.working ? j(t4) : t4 instanceof DataView);
      }
      e2.isArgumentsObject = i2, e2.isGeneratorFunction = o, e2.isTypedArray = s2, e2.isPromise = function(t4) {
        return "undefined" != typeof Promise && t4 instanceof Promise || null !== t4 && "object" === n(t4) && "function" == typeof t4.then && "function" == typeof t4.catch;
      }, e2.isArrayBufferView = function(t4) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t4) : s2(t4) || $(t4);
      }, e2.isUint8Array = function(t4) {
        return "Uint8Array" === a(t4);
      }, e2.isUint8ClampedArray = function(t4) {
        return "Uint8ClampedArray" === a(t4);
      }, e2.isUint16Array = function(t4) {
        return "Uint16Array" === a(t4);
      }, e2.isUint32Array = function(t4) {
        return "Uint32Array" === a(t4);
      }, e2.isInt8Array = function(t4) {
        return "Int8Array" === a(t4);
      }, e2.isInt16Array = function(t4) {
        return "Int16Array" === a(t4);
      }, e2.isInt32Array = function(t4) {
        return "Int32Array" === a(t4);
      }, e2.isFloat32Array = function(t4) {
        return "Float32Array" === a(t4);
      }, e2.isFloat64Array = function(t4) {
        return "Float64Array" === a(t4);
      }, e2.isBigInt64Array = function(t4) {
        return "BigInt64Array" === a(t4);
      }, e2.isBigUint64Array = function(t4) {
        return "BigUint64Array" === a(t4);
      }, v.working = "undefined" != typeof Map && v(/* @__PURE__ */ new Map()), e2.isMap = function(t4) {
        return "undefined" != typeof Map && (v.working ? v(t4) : t4 instanceof Map);
      }, g.working = "undefined" != typeof Set && g(/* @__PURE__ */ new Set()), e2.isSet = function(t4) {
        return "undefined" != typeof Set && (g.working ? g(t4) : t4 instanceof Set);
      }, _.working = "undefined" != typeof WeakMap && _(/* @__PURE__ */ new WeakMap()), e2.isWeakMap = function(t4) {
        return "undefined" != typeof WeakMap && (_.working ? _(t4) : t4 instanceof WeakMap);
      }, w2.working = "undefined" != typeof WeakSet && w2(/* @__PURE__ */ new WeakSet()), e2.isWeakSet = function(t4) {
        return w2(t4);
      }, S.working = "undefined" != typeof ArrayBuffer && S(new ArrayBuffer()), e2.isArrayBuffer = O, j.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && j(new DataView(new ArrayBuffer(1), 0, 1)), e2.isDataView = $;
      var A = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
      function E(t4) {
        return "[object SharedArrayBuffer]" === l(t4);
      }
      function x(t4) {
        return void 0 !== A && (void 0 === E.working && (E.working = E(new A())), E.working ? E(t4) : t4 instanceof A);
      }
      function P(t4) {
        return m2(t4, h2);
      }
      function k(t4) {
        return m2(t4, p);
      }
      function M(t4) {
        return m2(t4, d2);
      }
      function I(t4) {
        return u && m2(t4, y2);
      }
      function B(t4) {
        return f && m2(t4, b);
      }
      e2.isSharedArrayBuffer = x, e2.isAsyncFunction = function(t4) {
        return "[object AsyncFunction]" === l(t4);
      }, e2.isMapIterator = function(t4) {
        return "[object Map Iterator]" === l(t4);
      }, e2.isSetIterator = function(t4) {
        return "[object Set Iterator]" === l(t4);
      }, e2.isGeneratorObject = function(t4) {
        return "[object Generator]" === l(t4);
      }, e2.isWebAssemblyCompiledModule = function(t4) {
        return "[object WebAssembly.Module]" === l(t4);
      }, e2.isNumberObject = P, e2.isStringObject = k, e2.isBooleanObject = M, e2.isBigIntObject = I, e2.isSymbolObject = B, e2.isBoxedPrimitive = function(t4) {
        return P(t4) || k(t4) || M(t4) || I(t4) || B(t4);
      }, e2.isAnyArrayBuffer = function(t4) {
        return "undefined" != typeof Uint8Array && (O(t4) || x(t4));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(t4) {
        Object.defineProperty(e2, t4, { enumerable: false, value: function() {
          throw new Error(t4 + " is not supported in userland");
        } });
      });
    }, 7352: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = Object.getOwnPropertyDescriptors || function(t4) {
        for (var e3 = Object.keys(t4), r3 = {}, n2 = 0; n2 < e3.length; n2++)
          r3[e3[n2]] = Object.getOwnPropertyDescriptor(t4, e3[n2]);
        return r3;
      }, o = /%[sdj%]/g;
      e2.format = function(t4) {
        if (!g(t4)) {
          for (var e3 = [], r3 = 0; r3 < arguments.length; r3++)
            e3.push(u(arguments[r3]));
          return e3.join(" ");
        }
        r3 = 1;
        for (var n2 = arguments, i3 = n2.length, a2 = String(t4).replace(o, function(t5) {
          if ("%%" === t5)
            return "%";
          if (r3 >= i3)
            return t5;
          switch (t5) {
            case "%s":
              return String(n2[r3++]);
            case "%d":
              return Number(n2[r3++]);
            case "%j":
              try {
                return JSON.stringify(n2[r3++]);
              } catch (t6) {
                return "[Circular]";
              }
            default:
              return t5;
          }
        }), s3 = n2[r3]; r3 < i3; s3 = n2[++r3])
          m2(s3) || !S(s3) ? a2 += " " + s3 : a2 += " " + u(s3);
        return a2;
      }, e2.deprecate = function(t4, r3) {
        if (void 0 !== { env: {} } && true === { env: {} }.noDeprecation)
          return t4;
        if (void 0 === { env: {} })
          return function() {
            return e2.deprecate(t4, r3).apply(this, arguments);
          };
        var n2 = false;
        return function() {
          if (!n2) {
            if ({ env: {} }.throwDeprecation)
              throw new Error(r3);
            !{ env: {} }.traceDeprecation ? console.error(r3) : console.trace(r3), n2 = true;
          }
          return t4.apply(this, arguments);
        };
      };
      var a = {}, s2 = /^$/;
      if ({}.NODE_DEBUG) {
        var c = {}.NODE_DEBUG;
        c = c.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), s2 = new RegExp("^" + c + "$", "i");
      }
      function u(t4, r3) {
        var n2 = { seen: [], stylize: l };
        return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), b(r3) ? n2.showHidden = r3 : r3 && e2._extend(n2, r3), _(n2.showHidden) && (n2.showHidden = false), _(n2.depth) && (n2.depth = 2), _(n2.colors) && (n2.colors = false), _(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = f), h2(n2, t4, n2.depth);
      }
      function f(t4, e3) {
        var r3 = u.styles[e3];
        return r3 ? "\x1B[" + u.colors[r3][0] + "m" + t4 + "\x1B[" + u.colors[r3][1] + "m" : t4;
      }
      function l(t4, e3) {
        return t4;
      }
      function h2(t4, r3, n2) {
        if (t4.customInspect && r3 && $(r3.inspect) && r3.inspect !== e2.inspect && (!r3.constructor || r3.constructor.prototype !== r3)) {
          var i3 = r3.inspect(n2, t4);
          return g(i3) || (i3 = h2(t4, i3, n2)), i3;
        }
        var o2 = function(t5, e3) {
          if (_(e3))
            return t5.stylize("undefined", "undefined");
          if (g(e3)) {
            var r4 = "'" + JSON.stringify(e3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return t5.stylize(r4, "string");
          }
          return v(e3) ? t5.stylize("" + e3, "number") : b(e3) ? t5.stylize("" + e3, "boolean") : m2(e3) ? t5.stylize("null", "null") : void 0;
        }(t4, r3);
        if (o2)
          return o2;
        var a2 = Object.keys(r3), s3 = function(t5) {
          var e3 = {};
          return t5.forEach(function(t6, r4) {
            e3[t6] = true;
          }), e3;
        }(a2);
        if (t4.showHidden && (a2 = Object.getOwnPropertyNames(r3)), j(r3) && (a2.indexOf("message") >= 0 || a2.indexOf("description") >= 0))
          return p(r3);
        if (0 === a2.length) {
          if ($(r3)) {
            var c2 = r3.name ? ": " + r3.name : "";
            return t4.stylize("[Function" + c2 + "]", "special");
          }
          if (w2(r3))
            return t4.stylize(RegExp.prototype.toString.call(r3), "regexp");
          if (O(r3))
            return t4.stylize(Date.prototype.toString.call(r3), "date");
          if (j(r3))
            return p(r3);
        }
        var u2, f2 = "", l2 = false, S2 = ["{", "}"];
        return y2(r3) && (l2 = true, S2 = ["[", "]"]), $(r3) && (f2 = " [Function" + (r3.name ? ": " + r3.name : "") + "]"), w2(r3) && (f2 = " " + RegExp.prototype.toString.call(r3)), O(r3) && (f2 = " " + Date.prototype.toUTCString.call(r3)), j(r3) && (f2 = " " + p(r3)), 0 !== a2.length || l2 && 0 != r3.length ? n2 < 0 ? w2(r3) ? t4.stylize(RegExp.prototype.toString.call(r3), "regexp") : t4.stylize("[Object]", "special") : (t4.seen.push(r3), u2 = l2 ? function(t5, e3, r4, n3, i4) {
          for (var o3 = [], a3 = 0, s4 = e3.length; a3 < s4; ++a3)
            P(e3, String(a3)) ? o3.push(d2(t5, e3, r4, n3, String(a3), true)) : o3.push("");
          return i4.forEach(function(i5) {
            i5.match(/^\d+$/) || o3.push(d2(t5, e3, r4, n3, i5, true));
          }), o3;
        }(t4, r3, n2, s3, a2) : a2.map(function(e3) {
          return d2(t4, r3, n2, s3, e3, l2);
        }), t4.seen.pop(), function(t5, e3, r4) {
          return t5.reduce(function(t6, e4) {
            return e4.indexOf("\n"), t6 + e4.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0) > 60 ? r4[0] + ("" === e3 ? "" : e3 + "\n ") + " " + t5.join(",\n  ") + " " + r4[1] : r4[0] + e3 + " " + t5.join(", ") + " " + r4[1];
        }(u2, f2, S2)) : S2[0] + f2 + S2[1];
      }
      function p(t4) {
        return "[" + Error.prototype.toString.call(t4) + "]";
      }
      function d2(t4, e3, r3, n2, i3, o2) {
        var a2, s3, c2;
        if ((c2 = Object.getOwnPropertyDescriptor(e3, i3) || { value: e3[i3] }).get ? s3 = c2.set ? t4.stylize("[Getter/Setter]", "special") : t4.stylize("[Getter]", "special") : c2.set && (s3 = t4.stylize("[Setter]", "special")), P(n2, i3) || (a2 = "[" + i3 + "]"), s3 || (t4.seen.indexOf(c2.value) < 0 ? (s3 = m2(r3) ? h2(t4, c2.value, null) : h2(t4, c2.value, r3 - 1)).indexOf("\n") > -1 && (s3 = o2 ? s3.split("\n").map(function(t5) {
          return "  " + t5;
        }).join("\n").slice(2) : "\n" + s3.split("\n").map(function(t5) {
          return "   " + t5;
        }).join("\n")) : s3 = t4.stylize("[Circular]", "special")), _(a2)) {
          if (o2 && i3.match(/^\d+$/))
            return s3;
          (a2 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a2 = a2.slice(1, -1), a2 = t4.stylize(a2, "name")) : (a2 = a2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a2 = t4.stylize(a2, "string"));
        }
        return a2 + ": " + s3;
      }
      function y2(t4) {
        return Array.isArray(t4);
      }
      function b(t4) {
        return "boolean" == typeof t4;
      }
      function m2(t4) {
        return null === t4;
      }
      function v(t4) {
        return "number" == typeof t4;
      }
      function g(t4) {
        return "string" == typeof t4;
      }
      function _(t4) {
        return void 0 === t4;
      }
      function w2(t4) {
        return S(t4) && "[object RegExp]" === A(t4);
      }
      function S(t4) {
        return "object" === n(t4) && null !== t4;
      }
      function O(t4) {
        return S(t4) && "[object Date]" === A(t4);
      }
      function j(t4) {
        return S(t4) && ("[object Error]" === A(t4) || t4 instanceof Error);
      }
      function $(t4) {
        return "function" == typeof t4;
      }
      function A(t4) {
        return Object.prototype.toString.call(t4);
      }
      function E(t4) {
        return t4 < 10 ? "0" + t4.toString(10) : t4.toString(10);
      }
      e2.debuglog = function(t4) {
        if (t4 = t4.toUpperCase(), !a[t4])
          if (s2.test(t4)) {
            var r3 = { env: {} }.pid;
            a[t4] = function() {
              var n2 = e2.format.apply(e2, arguments);
              console.error("%s %d: %s", t4, r3, n2);
            };
          } else
            a[t4] = function() {
            };
        return a[t4];
      }, e2.inspect = u, u.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, u.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, e2.types = r2(7595), e2.isArray = y2, e2.isBoolean = b, e2.isNull = m2, e2.isNullOrUndefined = function(t4) {
        return null == t4;
      }, e2.isNumber = v, e2.isString = g, e2.isSymbol = function(t4) {
        return "symbol" === n(t4);
      }, e2.isUndefined = _, e2.isRegExp = w2, e2.types.isRegExp = w2, e2.isObject = S, e2.isDate = O, e2.types.isDate = O, e2.isError = j, e2.types.isNativeError = j, e2.isFunction = $, e2.isPrimitive = function(t4) {
        return null === t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || "symbol" === n(t4) || void 0 === t4;
      }, e2.isBuffer = r2(7944);
      var x = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function P(t4, e3) {
        return Object.prototype.hasOwnProperty.call(t4, e3);
      }
      e2.log = function() {
        var t4, r3;
        console.log("%s - %s", (r3 = [E((t4 = /* @__PURE__ */ new Date()).getHours()), E(t4.getMinutes()), E(t4.getSeconds())].join(":"), [t4.getDate(), x[t4.getMonth()], r3].join(" ")), e2.format.apply(e2, arguments));
      }, e2.inherits = r2(1679), e2._extend = function(t4, e3) {
        if (!e3 || !S(e3))
          return t4;
        for (var r3 = Object.keys(e3), n2 = r3.length; n2--; )
          t4[r3[n2]] = e3[r3[n2]];
        return t4;
      };
      var k = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
      function M(t4, e3) {
        if (!t4) {
          var r3 = new Error("Promise was rejected with a falsy value");
          r3.reason = t4, t4 = r3;
        }
        return e3(t4);
      }
      e2.promisify = function(t4) {
        if ("function" != typeof t4)
          throw new TypeError('The "original" argument must be of type Function');
        if (k && t4[k]) {
          var e3;
          if ("function" != typeof (e3 = t4[k]))
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(e3, k, { value: e3, enumerable: false, writable: false, configurable: true }), e3;
        }
        function e3() {
          for (var e4, r3, n2 = new Promise(function(t5, n3) {
            e4 = t5, r3 = n3;
          }), i3 = [], o2 = 0; o2 < arguments.length; o2++)
            i3.push(arguments[o2]);
          i3.push(function(t5, n3) {
            t5 ? r3(t5) : e4(n3);
          });
          try {
            t4.apply(this, i3);
          } catch (t5) {
            r3(t5);
          }
          return n2;
        }
        return Object.setPrototypeOf(e3, Object.getPrototypeOf(t4)), k && Object.defineProperty(e3, k, { value: e3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(e3, i2(t4));
      }, e2.promisify.custom = k, e2.callbackify = function(t4) {
        if ("function" != typeof t4)
          throw new TypeError('The "original" argument must be of type Function');
        function e3() {
          for (var e4 = [], r3 = 0; r3 < arguments.length; r3++)
            e4.push(arguments[r3]);
          var n2 = e4.pop();
          if ("function" != typeof n2)
            throw new TypeError("The last argument must be of type Function");
          var i3 = this, o2 = function() {
            return n2.apply(i3, arguments);
          };
          t4.apply(this, e4).then(function(t5) {
            ({ env: {} }).nextTick(o2.bind(null, null, t5));
          }, function(t5) {
            ({ env: {} }).nextTick(M.bind(null, t5, o2));
          });
        }
        return Object.setPrototypeOf(e3, Object.getPrototypeOf(t4)), Object.defineProperties(e3, i2(t4)), e3;
      };
    }, 9834: (t3, e2, r2) => {
      function n(t4) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, n(t4);
      }
      var i2 = r2(3777), o = r2(3426), a = r2(9122), s2 = r2(9466), c = r2(1464), u = s2("Object.prototype.toString"), f = r2(953)(), l = "undefined" == typeof globalThis ? r2.g : globalThis, h2 = o(), p = s2("String.prototype.slice"), d2 = Object.getPrototypeOf, y2 = s2("Array.prototype.indexOf", true) || function(t4, e3) {
        for (var r3 = 0; r3 < t4.length; r3 += 1)
          if (t4[r3] === e3)
            return r3;
        return -1;
      }, b = { __proto__: null };
      i2(h2, f && c && d2 ? function(t4) {
        var e3 = new l[t4]();
        if (Symbol.toStringTag in e3) {
          var r3 = d2(e3), n2 = c(r3, Symbol.toStringTag);
          if (!n2) {
            var i3 = d2(r3);
            n2 = c(i3, Symbol.toStringTag);
          }
          b["$" + t4] = a(n2.get);
        }
      } : function(t4) {
        var e3 = new l[t4](), r3 = e3.slice || e3.set;
        r3 && (b["$" + t4] = a(r3));
      }), t3.exports = function(t4) {
        if (!t4 || "object" !== n(t4))
          return false;
        if (!f) {
          var e3 = p(u(t4), 8, -1);
          return y2(h2, e3) > -1 ? e3 : "Object" === e3 && function(t5) {
            var e4 = false;
            return i2(b, function(r3, n2) {
              if (!e4)
                try {
                  r3(t5), e4 = p(n2, 1);
                } catch (t6) {
                }
            }), e4;
          }(t4);
        }
        return c ? function(t5) {
          var e4 = false;
          return i2(b, function(r3, n2) {
            if (!e4)
              try {
                "$" + r3(t5) === n2 && (e4 = p(n2, 1));
              } catch (t6) {
              }
          }), e4;
        }(t4) : null;
      };
    }, 7790: () => {
    }, 3776: () => {
    }, 5340: () => {
    }, 9838: () => {
    }, 3779: () => {
    }, 7199: () => {
    }, 3426: (t3, e2, r2) => {
      var n = r2(2653), i2 = "undefined" == typeof globalThis ? r2.g : globalThis;
      t3.exports = function() {
        for (var t4 = [], e3 = 0; e3 < n.length; e3++)
          "function" == typeof i2[n[e3]] && (t4[t4.length] = n[e3]);
        return t4;
      };
    }, 3633: (t3, e2, r2) => {
      var _a2;
      var n = r2(5832).Buffer;
      function i2(t4) {
        return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(t4));
      }
      function o(t4) {
        return "[object Uint8Array]" === Object.prototype.toString.call(t4);
      }
      function a(t4) {
        return "[object RegExp]" === Object.prototype.toString.call(t4);
      }
      function s2(t4) {
        return "[object Map]" === Object.prototype.toString.call(t4);
      }
      function c(t4) {
        return "[object Date]" === Object.prototype.toString.call(t4);
      }
      function u(t4, e3) {
        return JSON.stringify(t4, (t5, e4) => "bigint" == typeof e4 ? { $numberLong: `${e4}` } : s2(e4) ? Object.fromEntries(e4) : e4);
      }
      const f = 6, l = 2147483647, h2 = -2147483648, p = Math.pow(2, 63) - 1, d2 = -Math.pow(2, 63), y2 = Math.pow(2, 53), b = -Math.pow(2, 53), m2 = 1, v = 2, g = 3, _ = 4, w2 = 5, S = 6, O = 7, j = 8, $ = 9, A = 10, E = 11, x = 12, P = 13, k = 14, M = 15, I = 16, B = 17, T = 18, R = 19, N = 255, D = 127, L = 0, U = 4, C = Object.freeze({ double: 1, string: 2, object: 3, array: 4, binData: 5, undefined: 6, objectId: 7, bool: 8, date: 9, null: 10, regex: 11, dbPointer: 12, javascript: 13, symbol: 14, javascriptWithScope: 15, int: 16, timestamp: 17, long: 18, decimal: 19, minKey: -1, maxKey: 127 });
      class q extends Error {
        get bsonError() {
          return true;
        }
        get name() {
          return "BSONError";
        }
        constructor(t4, e3) {
          super(t4, e3);
        }
        static isBSONError(t4) {
          return null != t4 && "object" == typeof t4 && "bsonError" in t4 && true === t4.bsonError && "name" in t4 && "message" in t4 && "stack" in t4;
        }
      }
      class F extends q {
        get name() {
          return "BSONVersionError";
        }
        constructor() {
          super(`Unsupported BSON version, bson types must be from bson ${f}.x.x`);
        }
      }
      class V extends q {
        get name() {
          return "BSONRuntimeError";
        }
        constructor(t4) {
          super(t4);
        }
      }
      class z extends q {
        get name() {
          return "BSONOffsetError";
        }
        constructor(t4, e3, r3) {
          super(`${t4}. offset: ${e3}`, r3), this.offset = e3;
        }
      }
      const K = 128, H = 192, W = 224, J = 240, G = 248, Y = 192, Q = 224, X = 240, Z = 128;
      function tt(t4, e3, r3) {
        let n2 = 0;
        for (let i3 = e3; i3 < r3; i3 += 1) {
          const e4 = t4[i3];
          if (n2) {
            if ((e4 & H) !== Z)
              return false;
            n2 -= 1;
          } else if (e4 & K)
            if ((e4 & W) === Y)
              n2 = 1;
            else if ((e4 & J) === Q)
              n2 = 2;
            else {
              if ((e4 & G) !== X)
                return false;
              n2 = 3;
            }
        }
        return !n2;
      }
      function et(t4, e3, r3) {
        if (0 === t4.length)
          return "";
        const n2 = r3 - e3;
        if (0 === n2)
          return "";
        if (n2 > 20)
          return null;
        if (1 === n2 && t4[e3] < 128)
          return String.fromCharCode(t4[e3]);
        if (2 === n2 && t4[e3] < 128 && t4[e3 + 1] < 128)
          return String.fromCharCode(t4[e3]) + String.fromCharCode(t4[e3 + 1]);
        if (3 === n2 && t4[e3] < 128 && t4[e3 + 1] < 128 && t4[e3 + 2] < 128)
          return String.fromCharCode(t4[e3]) + String.fromCharCode(t4[e3 + 1]) + String.fromCharCode(t4[e3 + 2]);
        const i3 = [];
        for (let n3 = e3; n3 < r3; n3++) {
          const e4 = t4[n3];
          if (e4 > 127)
            return null;
          i3.push(e4);
        }
        return String.fromCharCode(...i3);
      }
      function rt(t4) {
        return it.fromNumberArray(Array.from({ length: t4 }, () => Math.floor(256 * Math.random())));
      }
      const nt = (() => {
        try {
          return r2(8872).po;
        } catch {
          return rt;
        }
      })(), it = { toLocalBufferType(t4) {
        if (n.isBuffer(t4))
          return t4;
        if (ArrayBuffer.isView(t4))
          return n.from(t4.buffer, t4.byteOffset, t4.byteLength);
        const e3 = (t4 == null ? void 0 : t4[Symbol.toStringTag]) ?? Object.prototype.toString.call(t4);
        if ("ArrayBuffer" === e3 || "SharedArrayBuffer" === e3 || "[object ArrayBuffer]" === e3 || "[object SharedArrayBuffer]" === e3)
          return n.from(t4);
        throw new q(`Cannot create Buffer from ${String(t4)}`);
      }, allocate: (t4) => n.alloc(t4), allocateUnsafe: (t4) => n.allocUnsafe(t4), equals: (t4, e3) => it.toLocalBufferType(t4).equals(e3), fromNumberArray: (t4) => n.from(t4), fromBase64: (t4) => n.from(t4, "base64"), toBase64: (t4) => it.toLocalBufferType(t4).toString("base64"), fromISO88591: (t4) => n.from(t4, "binary"), toISO88591: (t4) => it.toLocalBufferType(t4).toString("binary"), fromHex: (t4) => n.from(t4, "hex"), toHex: (t4) => it.toLocalBufferType(t4).toString("hex"), toUTF8(t4, e3, r3, n2) {
        const i3 = r3 - e3 <= 20 ? et(t4, e3, r3) : null;
        if (null != i3)
          return i3;
        const o2 = it.toLocalBufferType(t4).toString("utf8", e3, r3);
        if (n2) {
          for (let n3 = 0; n3 < o2.length; n3++)
            if (65533 === o2.charCodeAt(n3)) {
              if (!tt(t4, e3, r3))
                throw new q("Invalid UTF-8 string in BSON document");
              break;
            }
        }
        return o2;
      }, utf8ByteLength: (t4) => n.byteLength(t4, "utf8"), encodeUTF8Into(t4, e3, r3) {
        const n2 = function(t5, e4, r4) {
          if (0 === e4.length)
            return 0;
          if (e4.length > 25)
            return null;
          if (t5.length - r4 < e4.length)
            return null;
          for (let n3 = 0, i3 = r4; n3 < e4.length; n3++, i3++) {
            const r5 = e4.charCodeAt(n3);
            if (r5 > 127)
              return null;
            t5[i3] = r5;
          }
          return e4.length;
        }(t4, e3, r3);
        return null != n2 ? n2 : it.toLocalBufferType(t4).write(e3, r3, void 0, "utf8");
      }, randomBytes: nt };
      function ot(t4) {
        if (t4 < 0)
          throw new RangeError(`The argument 'byteLength' is invalid. Received ${t4}`);
        return ct.fromNumberArray(Array.from({ length: t4 }, () => Math.floor(256 * Math.random())));
      }
      const at = (() => {
        var _a3;
        const { crypto: t4 } = globalThis;
        if (null != t4 && "function" == typeof t4.getRandomValues)
          return (e3) => t4.getRandomValues(ct.allocate(e3));
        if (function() {
          const { navigator: t5 } = globalThis;
          return "object" == typeof t5 && "ReactNative" === t5.product;
        }()) {
          const { console: t5 } = globalThis;
          (_a3 = t5 == null ? void 0 : t5.warn) == null ? void 0 : _a3.call(t5, "BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
        }
        return ot;
      })(), st = /(\d|[a-f])/i, ct = { toLocalBufferType(t4) {
        const e3 = (t4 == null ? void 0 : t4[Symbol.toStringTag]) ?? Object.prototype.toString.call(t4);
        if ("Uint8Array" === e3)
          return t4;
        if (ArrayBuffer.isView(t4))
          return new Uint8Array(t4.buffer.slice(t4.byteOffset, t4.byteOffset + t4.byteLength));
        if ("ArrayBuffer" === e3 || "SharedArrayBuffer" === e3 || "[object ArrayBuffer]" === e3 || "[object SharedArrayBuffer]" === e3)
          return new Uint8Array(t4);
        throw new q(`Cannot make a Uint8Array from ${String(t4)}`);
      }, allocate(t4) {
        if ("number" != typeof t4)
          throw new TypeError(`The "size" argument must be of type number. Received ${String(t4)}`);
        return new Uint8Array(t4);
      }, allocateUnsafe: (t4) => ct.allocate(t4), equals(t4, e3) {
        if (t4.byteLength !== e3.byteLength)
          return false;
        for (let r3 = 0; r3 < t4.byteLength; r3++)
          if (t4[r3] !== e3[r3])
            return false;
        return true;
      }, fromNumberArray: (t4) => Uint8Array.from(t4), fromBase64: (t4) => Uint8Array.from(atob(t4), (t5) => t5.charCodeAt(0)), toBase64: (t4) => btoa(ct.toISO88591(t4)), fromISO88591: (t4) => Uint8Array.from(t4, (t5) => 255 & t5.charCodeAt(0)), toISO88591: (t4) => Array.from(Uint16Array.from(t4), (t5) => String.fromCharCode(t5)).join(""), fromHex(t4) {
        const e3 = t4.length % 2 == 0 ? t4 : t4.slice(0, t4.length - 1), r3 = [];
        for (let t5 = 0; t5 < e3.length; t5 += 2) {
          const n2 = e3[t5], i3 = e3[t5 + 1];
          if (!st.test(n2))
            break;
          if (!st.test(i3))
            break;
          const o2 = Number.parseInt(`${n2}${i3}`, 16);
          r3.push(o2);
        }
        return Uint8Array.from(r3);
      }, toHex: (t4) => Array.from(t4, (t5) => t5.toString(16).padStart(2, "0")).join(""), toUTF8(t4, e3, r3, n2) {
        const i3 = r3 - e3 <= 20 ? et(t4, e3, r3) : null;
        if (null != i3)
          return i3;
        if (n2)
          try {
            return new TextDecoder("utf8", { fatal: n2 }).decode(t4.slice(e3, r3));
          } catch (t5) {
            throw new q("Invalid UTF-8 string in BSON document", { cause: t5 });
          }
        return new TextDecoder("utf8", { fatal: n2 }).decode(t4.slice(e3, r3));
      }, utf8ByteLength: (t4) => new TextEncoder().encode(t4).byteLength, encodeUTF8Into(t4, e3, r3) {
        const n2 = new TextEncoder().encode(e3);
        return t4.set(n2, r3), n2.byteLength;
      }, randomBytes: at }, ut = "function" == typeof n && true !== ((_a2 = n.prototype) == null ? void 0 : _a2._isBuffer) ? it : ct;
      class ft {
        get [Symbol.for("@@mdb.bson.version")]() {
          return f;
        }
        [Symbol.for("nodejs.util.inspect.custom")](t4, e3, r3) {
          return this.inspect(t4, e3, r3);
        }
      }
      class lt2 extends ft {
        get _bsontype() {
          return "Binary";
        }
        constructor(t4, e3) {
          if (super(), null != t4 && "string" == typeof t4 && !ArrayBuffer.isView(t4) && !i2(t4) && !Array.isArray(t4))
            throw new q("Binary can only be constructed from Uint8Array or number[]");
          this.sub_type = e3 ?? lt2.BSON_BINARY_SUBTYPE_DEFAULT, null == t4 ? (this.buffer = ut.allocate(lt2.BUFFER_SIZE), this.position = 0) : (this.buffer = Array.isArray(t4) ? ut.fromNumberArray(t4) : ut.toLocalBufferType(t4), this.position = this.buffer.byteLength);
        }
        put(t4) {
          if ("string" == typeof t4 && 1 !== t4.length)
            throw new q("only accepts single character String");
          if ("number" != typeof t4 && 1 !== t4.length)
            throw new q("only accepts single character Uint8Array or Array");
          let e3;
          if (e3 = "string" == typeof t4 ? t4.charCodeAt(0) : "number" == typeof t4 ? t4 : t4[0], e3 < 0 || e3 > 255)
            throw new q("only accepts number in a valid unsigned byte range 0-255");
          if (this.buffer.byteLength > this.position)
            this.buffer[this.position++] = e3;
          else {
            const t5 = ut.allocate(lt2.BUFFER_SIZE + this.buffer.length);
            t5.set(this.buffer, 0), this.buffer = t5, this.buffer[this.position++] = e3;
          }
        }
        write(t4, e3) {
          if (e3 = "number" == typeof e3 ? e3 : this.position, this.buffer.byteLength < e3 + t4.length) {
            const e4 = ut.allocate(this.buffer.byteLength + t4.length);
            e4.set(this.buffer, 0), this.buffer = e4;
          }
          if (ArrayBuffer.isView(t4))
            this.buffer.set(ut.toLocalBufferType(t4), e3), this.position = e3 + t4.byteLength > this.position ? e3 + t4.length : this.position;
          else if ("string" == typeof t4)
            throw new q("input cannot be string");
        }
        read(t4, e3) {
          return e3 = e3 && e3 > 0 ? e3 : this.position, this.buffer.slice(t4, t4 + e3);
        }
        value() {
          return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
        }
        length() {
          return this.position;
        }
        toJSON() {
          return ut.toBase64(this.buffer.subarray(0, this.position));
        }
        toString(t4) {
          return "hex" === t4 ? ut.toHex(this.buffer.subarray(0, this.position)) : "base64" === t4 ? ut.toBase64(this.buffer.subarray(0, this.position)) : ut.toUTF8(this.buffer, 0, this.position, false);
        }
        toExtendedJSON(t4) {
          t4 = t4 || {};
          const e3 = ut.toBase64(this.buffer), r3 = Number(this.sub_type).toString(16);
          return t4.legacy ? { $binary: e3, $type: 1 === r3.length ? "0" + r3 : r3 } : { $binary: { base64: e3, subType: 1 === r3.length ? "0" + r3 : r3 } };
        }
        toUUID() {
          if (this.sub_type === lt2.SUBTYPE_UUID)
            return new dt(this.buffer.slice(0, this.position));
          throw new q(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${lt2.SUBTYPE_UUID}" is currently supported.`);
        }
        static createFromHexString(t4, e3) {
          return new lt2(ut.fromHex(t4), e3);
        }
        static createFromBase64(t4, e3) {
          return new lt2(ut.fromBase64(t4), e3);
        }
        static fromExtendedJSON(t4, e3) {
          let r3, n2;
          if (e3 = e3 || {}, "$binary" in t4 ? e3.legacy && "string" == typeof t4.$binary && "$type" in t4 ? (n2 = t4.$type ? parseInt(t4.$type, 16) : 0, r3 = ut.fromBase64(t4.$binary)) : "string" != typeof t4.$binary && (n2 = t4.$binary.subType ? parseInt(t4.$binary.subType, 16) : 0, r3 = ut.fromBase64(t4.$binary.base64)) : "$uuid" in t4 && (n2 = 4, r3 = dt.bytesFromString(t4.$uuid)), !r3)
            throw new q(`Unexpected Binary Extended JSON format ${JSON.stringify(t4)}`);
          return n2 === U ? new dt(r3) : new lt2(r3, n2);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `Binary.createFromBase64(${r3(ut.toBase64(this.buffer.subarray(0, this.position)), e3)}, ${r3(this.sub_type, e3)})`;
        }
      }
      lt2.BSON_BINARY_SUBTYPE_DEFAULT = 0, lt2.BUFFER_SIZE = 256, lt2.SUBTYPE_DEFAULT = 0, lt2.SUBTYPE_FUNCTION = 1, lt2.SUBTYPE_BYTE_ARRAY = 2, lt2.SUBTYPE_UUID_OLD = 3, lt2.SUBTYPE_UUID = 4, lt2.SUBTYPE_MD5 = 5, lt2.SUBTYPE_ENCRYPTED = 6, lt2.SUBTYPE_COLUMN = 7, lt2.SUBTYPE_SENSITIVE = 8, lt2.SUBTYPE_USER_DEFINED = 128;
      const ht = /^[0-9A-F]{32}$/i, pt = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
      class dt extends lt2 {
        constructor(t4) {
          let e3;
          if (null == t4)
            e3 = dt.generate();
          else if (t4 instanceof dt)
            e3 = ut.toLocalBufferType(new Uint8Array(t4.buffer));
          else if (ArrayBuffer.isView(t4) && 16 === t4.byteLength)
            e3 = ut.toLocalBufferType(t4);
          else {
            if ("string" != typeof t4)
              throw new q("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
            e3 = dt.bytesFromString(t4);
          }
          super(e3, U);
        }
        get id() {
          return this.buffer;
        }
        set id(t4) {
          this.buffer = t4;
        }
        toHexString(t4 = true) {
          return t4 ? [ut.toHex(this.buffer.subarray(0, 4)), ut.toHex(this.buffer.subarray(4, 6)), ut.toHex(this.buffer.subarray(6, 8)), ut.toHex(this.buffer.subarray(8, 10)), ut.toHex(this.buffer.subarray(10, 16))].join("-") : ut.toHex(this.buffer);
        }
        toString(t4) {
          return "hex" === t4 ? ut.toHex(this.id) : "base64" === t4 ? ut.toBase64(this.id) : this.toHexString();
        }
        toJSON() {
          return this.toHexString();
        }
        equals(t4) {
          if (!t4)
            return false;
          if (t4 instanceof dt)
            return ut.equals(t4.id, this.id);
          try {
            return ut.equals(new dt(t4).id, this.id);
          } catch {
            return false;
          }
        }
        toBinary() {
          return new lt2(this.id, lt2.SUBTYPE_UUID);
        }
        static generate() {
          const t4 = ut.randomBytes(16);
          return t4[6] = 15 & t4[6] | 64, t4[8] = 63 & t4[8] | 128, t4;
        }
        static isValid(t4) {
          return !!t4 && ("string" == typeof t4 ? dt.isValidUUIDString(t4) : o(t4) ? 16 === t4.byteLength : "Binary" === t4._bsontype && t4.sub_type === this.SUBTYPE_UUID && 16 === t4.buffer.byteLength);
        }
        static createFromHexString(t4) {
          const e3 = dt.bytesFromString(t4);
          return new dt(e3);
        }
        static createFromBase64(t4) {
          return new dt(ut.fromBase64(t4));
        }
        static bytesFromString(t4) {
          if (!dt.isValidUUIDString(t4))
            throw new q("UUID string representation must be 32 hex digits or canonical hyphenated representation");
          return ut.fromHex(t4.replace(/-/g, ""));
        }
        static isValidUUIDString(t4) {
          return ht.test(t4) || pt.test(t4);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new UUID(${r3(this.toHexString(), e3)})`;
        }
      }
      class yt extends ft {
        get _bsontype() {
          return "Code";
        }
        constructor(t4, e3) {
          super(), this.code = t4.toString(), this.scope = e3 ?? null;
        }
        toJSON() {
          return null != this.scope ? { code: this.code, scope: this.scope } : { code: this.code };
        }
        toExtendedJSON() {
          return this.scope ? { $code: this.code, $scope: this.scope } : { $code: this.code };
        }
        static fromExtendedJSON(t4) {
          return new yt(t4.$code, t4.$scope);
        }
        inspect(t4, e3, r3) {
          r3 ?? (r3 = u);
          let n2 = r3(this.code, e3);
          const i3 = n2.includes("\n");
          return null != this.scope && (n2 += `,${i3 ? "\n" : " "}${r3(this.scope, e3)}`), `new Code(${i3 ? "\n" : ""}${n2}${i3 && null === this.scope ? "\n" : ""})`;
        }
      }
      function bt(t4) {
        return null != t4 && "object" == typeof t4 && "$id" in t4 && null != t4.$id && "$ref" in t4 && "string" == typeof t4.$ref && (!("$db" in t4) || "$db" in t4 && "string" == typeof t4.$db);
      }
      class mt extends ft {
        get _bsontype() {
          return "DBRef";
        }
        constructor(t4, e3, r3, n2) {
          super();
          const i3 = t4.split(".");
          2 === i3.length && (r3 = i3.shift(), t4 = i3.shift()), this.collection = t4, this.oid = e3, this.db = r3, this.fields = n2 || {};
        }
        get namespace() {
          return this.collection;
        }
        set namespace(t4) {
          this.collection = t4;
        }
        toJSON() {
          const t4 = Object.assign({ $ref: this.collection, $id: this.oid }, this.fields);
          return null != this.db && (t4.$db = this.db), t4;
        }
        toExtendedJSON(t4) {
          t4 = t4 || {};
          let e3 = { $ref: this.collection, $id: this.oid };
          return t4.legacy || (this.db && (e3.$db = this.db), e3 = Object.assign(e3, this.fields)), e3;
        }
        static fromExtendedJSON(t4) {
          const e3 = Object.assign({}, t4);
          return delete e3.$ref, delete e3.$id, delete e3.$db, new mt(t4.$ref, t4.$id, t4.$db, e3);
        }
        inspect(t4, e3, r3) {
          r3 ?? (r3 = u);
          const n2 = [r3(this.namespace, e3), r3(this.oid, e3), ...this.db ? [r3(this.db, e3)] : [], ...Object.keys(this.fields).length > 0 ? [r3(this.fields, e3)] : []];
          return n2[1] = r3 === u ? `new ObjectId(${n2[1]})` : n2[1], `new DBRef(${n2.join(", ")})`;
        }
      }
      let vt;
      try {
        vt = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch {
      }
      const gt2 = 4294967296, _t = 18446744073709552e3, wt = _t / 2, St = {}, Ot = {}, jt = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
      class $t extends ft {
        get _bsontype() {
          return "Long";
        }
        get __isLong__() {
          return true;
        }
        constructor(t4 = 0, e3, r3) {
          super(), "bigint" == typeof t4 ? Object.assign(this, $t.fromBigInt(t4, !!e3)) : "string" == typeof t4 ? Object.assign(this, $t.fromString(t4, !!e3)) : (this.low = 0 | t4, this.high = 0 | e3, this.unsigned = !!r3);
        }
        static fromBits(t4, e3, r3) {
          return new $t(t4, e3, r3);
        }
        static fromInt(t4, e3) {
          let r3, n2, i3;
          return e3 ? (i3 = 0 <= (t4 >>>= 0) && t4 < 256) && (n2 = Ot[t4], n2) ? n2 : (r3 = $t.fromBits(t4, (0 | t4) < 0 ? -1 : 0, true), i3 && (Ot[t4] = r3), r3) : (i3 = -128 <= (t4 |= 0) && t4 < 128) && (n2 = St[t4], n2) ? n2 : (r3 = $t.fromBits(t4, t4 < 0 ? -1 : 0, false), i3 && (St[t4] = r3), r3);
        }
        static fromNumber(t4, e3) {
          if (isNaN(t4))
            return e3 ? $t.UZERO : $t.ZERO;
          if (e3) {
            if (t4 < 0)
              return $t.UZERO;
            if (t4 >= _t)
              return $t.MAX_UNSIGNED_VALUE;
          } else {
            if (t4 <= -wt)
              return $t.MIN_VALUE;
            if (t4 + 1 >= wt)
              return $t.MAX_VALUE;
          }
          return t4 < 0 ? $t.fromNumber(-t4, e3).neg() : $t.fromBits(t4 % gt2 | 0, t4 / gt2 | 0, e3);
        }
        static fromBigInt(t4, e3) {
          return $t.fromString(t4.toString(), e3);
        }
        static fromString(t4, e3, r3) {
          if (0 === t4.length)
            throw new q("empty string");
          if ("NaN" === t4 || "Infinity" === t4 || "+Infinity" === t4 || "-Infinity" === t4)
            return $t.ZERO;
          if ("number" == typeof e3 ? (r3 = e3, e3 = false) : e3 = !!e3, (r3 = r3 || 10) < 2 || 36 < r3)
            throw new q("radix");
          let n2;
          if ((n2 = t4.indexOf("-")) > 0)
            throw new q("interior hyphen");
          if (0 === n2)
            return $t.fromString(t4.substring(1), e3, r3).neg();
          const i3 = $t.fromNumber(Math.pow(r3, 8));
          let o2 = $t.ZERO;
          for (let e4 = 0; e4 < t4.length; e4 += 8) {
            const n3 = Math.min(8, t4.length - e4), a2 = parseInt(t4.substring(e4, e4 + n3), r3);
            if (n3 < 8) {
              const t5 = $t.fromNumber(Math.pow(r3, n3));
              o2 = o2.mul(t5).add($t.fromNumber(a2));
            } else
              o2 = o2.mul(i3), o2 = o2.add($t.fromNumber(a2));
          }
          return o2.unsigned = e3, o2;
        }
        static fromBytes(t4, e3, r3) {
          return r3 ? $t.fromBytesLE(t4, e3) : $t.fromBytesBE(t4, e3);
        }
        static fromBytesLE(t4, e3) {
          return new $t(t4[0] | t4[1] << 8 | t4[2] << 16 | t4[3] << 24, t4[4] | t4[5] << 8 | t4[6] << 16 | t4[7] << 24, e3);
        }
        static fromBytesBE(t4, e3) {
          return new $t(t4[4] << 24 | t4[5] << 16 | t4[6] << 8 | t4[7], t4[0] << 24 | t4[1] << 16 | t4[2] << 8 | t4[3], e3);
        }
        static isLong(t4) {
          return null != t4 && "object" == typeof t4 && "__isLong__" in t4 && true === t4.__isLong__;
        }
        static fromValue(t4, e3) {
          return "number" == typeof t4 ? $t.fromNumber(t4, e3) : "string" == typeof t4 ? $t.fromString(t4, e3) : $t.fromBits(t4.low, t4.high, "boolean" == typeof e3 ? e3 : t4.unsigned);
        }
        add(t4) {
          $t.isLong(t4) || (t4 = $t.fromValue(t4));
          const e3 = this.high >>> 16, r3 = 65535 & this.high, n2 = this.low >>> 16, i3 = 65535 & this.low, o2 = t4.high >>> 16, a2 = 65535 & t4.high, s3 = t4.low >>> 16;
          let c2 = 0, u2 = 0, f2 = 0, l2 = 0;
          return l2 += i3 + (65535 & t4.low), f2 += l2 >>> 16, l2 &= 65535, f2 += n2 + s3, u2 += f2 >>> 16, f2 &= 65535, u2 += r3 + a2, c2 += u2 >>> 16, u2 &= 65535, c2 += e3 + o2, c2 &= 65535, $t.fromBits(f2 << 16 | l2, c2 << 16 | u2, this.unsigned);
        }
        and(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), $t.fromBits(this.low & t4.low, this.high & t4.high, this.unsigned);
        }
        compare(t4) {
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), this.eq(t4))
            return 0;
          const e3 = this.isNegative(), r3 = t4.isNegative();
          return e3 && !r3 ? -1 : !e3 && r3 ? 1 : this.unsigned ? t4.high >>> 0 > this.high >>> 0 || t4.high === this.high && t4.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t4).isNegative() ? -1 : 1;
        }
        comp(t4) {
          return this.compare(t4);
        }
        divide(t4) {
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), t4.isZero())
            throw new q("division by zero");
          if (vt) {
            if (!this.unsigned && -2147483648 === this.high && -1 === t4.low && -1 === t4.high)
              return this;
            const e4 = (this.unsigned ? vt.div_u : vt.div_s)(this.low, this.high, t4.low, t4.high);
            return $t.fromBits(e4, vt.get_high(), this.unsigned);
          }
          if (this.isZero())
            return this.unsigned ? $t.UZERO : $t.ZERO;
          let e3, r3, n2;
          if (this.unsigned) {
            if (t4.unsigned || (t4 = t4.toUnsigned()), t4.gt(this))
              return $t.UZERO;
            if (t4.gt(this.shru(1)))
              return $t.UONE;
            n2 = $t.UZERO;
          } else {
            if (this.eq($t.MIN_VALUE))
              return t4.eq($t.ONE) || t4.eq($t.NEG_ONE) ? $t.MIN_VALUE : t4.eq($t.MIN_VALUE) ? $t.ONE : (e3 = this.shr(1).div(t4).shl(1), e3.eq($t.ZERO) ? t4.isNegative() ? $t.ONE : $t.NEG_ONE : (r3 = this.sub(t4.mul(e3)), n2 = e3.add(r3.div(t4)), n2));
            if (t4.eq($t.MIN_VALUE))
              return this.unsigned ? $t.UZERO : $t.ZERO;
            if (this.isNegative())
              return t4.isNegative() ? this.neg().div(t4.neg()) : this.neg().div(t4).neg();
            if (t4.isNegative())
              return this.div(t4.neg()).neg();
            n2 = $t.ZERO;
          }
          for (r3 = this; r3.gte(t4); ) {
            e3 = Math.max(1, Math.floor(r3.toNumber() / t4.toNumber()));
            const i3 = Math.ceil(Math.log(e3) / Math.LN2), o2 = i3 <= 48 ? 1 : Math.pow(2, i3 - 48);
            let a2 = $t.fromNumber(e3), s3 = a2.mul(t4);
            for (; s3.isNegative() || s3.gt(r3); )
              e3 -= o2, a2 = $t.fromNumber(e3, this.unsigned), s3 = a2.mul(t4);
            a2.isZero() && (a2 = $t.ONE), n2 = n2.add(a2), r3 = r3.sub(s3);
          }
          return n2;
        }
        div(t4) {
          return this.divide(t4);
        }
        equals(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), (this.unsigned === t4.unsigned || this.high >>> 31 != 1 || t4.high >>> 31 != 1) && this.high === t4.high && this.low === t4.low;
        }
        eq(t4) {
          return this.equals(t4);
        }
        getHighBits() {
          return this.high;
        }
        getHighBitsUnsigned() {
          return this.high >>> 0;
        }
        getLowBits() {
          return this.low;
        }
        getLowBitsUnsigned() {
          return this.low >>> 0;
        }
        getNumBitsAbs() {
          if (this.isNegative())
            return this.eq($t.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
          const t4 = 0 !== this.high ? this.high : this.low;
          let e3;
          for (e3 = 31; e3 > 0 && !(t4 & 1 << e3); e3--)
            ;
          return 0 !== this.high ? e3 + 33 : e3 + 1;
        }
        greaterThan(t4) {
          return this.comp(t4) > 0;
        }
        gt(t4) {
          return this.greaterThan(t4);
        }
        greaterThanOrEqual(t4) {
          return this.comp(t4) >= 0;
        }
        gte(t4) {
          return this.greaterThanOrEqual(t4);
        }
        ge(t4) {
          return this.greaterThanOrEqual(t4);
        }
        isEven() {
          return !(1 & this.low);
        }
        isNegative() {
          return !this.unsigned && this.high < 0;
        }
        isOdd() {
          return !(1 & ~this.low);
        }
        isPositive() {
          return this.unsigned || this.high >= 0;
        }
        isZero() {
          return 0 === this.high && 0 === this.low;
        }
        lessThan(t4) {
          return this.comp(t4) < 0;
        }
        lt(t4) {
          return this.lessThan(t4);
        }
        lessThanOrEqual(t4) {
          return this.comp(t4) <= 0;
        }
        lte(t4) {
          return this.lessThanOrEqual(t4);
        }
        modulo(t4) {
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), vt) {
            const e3 = (this.unsigned ? vt.rem_u : vt.rem_s)(this.low, this.high, t4.low, t4.high);
            return $t.fromBits(e3, vt.get_high(), this.unsigned);
          }
          return this.sub(this.div(t4).mul(t4));
        }
        mod(t4) {
          return this.modulo(t4);
        }
        rem(t4) {
          return this.modulo(t4);
        }
        multiply(t4) {
          if (this.isZero())
            return $t.ZERO;
          if ($t.isLong(t4) || (t4 = $t.fromValue(t4)), vt) {
            const e4 = vt.mul(this.low, this.high, t4.low, t4.high);
            return $t.fromBits(e4, vt.get_high(), this.unsigned);
          }
          if (t4.isZero())
            return $t.ZERO;
          if (this.eq($t.MIN_VALUE))
            return t4.isOdd() ? $t.MIN_VALUE : $t.ZERO;
          if (t4.eq($t.MIN_VALUE))
            return this.isOdd() ? $t.MIN_VALUE : $t.ZERO;
          if (this.isNegative())
            return t4.isNegative() ? this.neg().mul(t4.neg()) : this.neg().mul(t4).neg();
          if (t4.isNegative())
            return this.mul(t4.neg()).neg();
          if (this.lt($t.TWO_PWR_24) && t4.lt($t.TWO_PWR_24))
            return $t.fromNumber(this.toNumber() * t4.toNumber(), this.unsigned);
          const e3 = this.high >>> 16, r3 = 65535 & this.high, n2 = this.low >>> 16, i3 = 65535 & this.low, o2 = t4.high >>> 16, a2 = 65535 & t4.high, s3 = t4.low >>> 16, c2 = 65535 & t4.low;
          let u2 = 0, f2 = 0, l2 = 0, h3 = 0;
          return h3 += i3 * c2, l2 += h3 >>> 16, h3 &= 65535, l2 += n2 * c2, f2 += l2 >>> 16, l2 &= 65535, l2 += i3 * s3, f2 += l2 >>> 16, l2 &= 65535, f2 += r3 * c2, u2 += f2 >>> 16, f2 &= 65535, f2 += n2 * s3, u2 += f2 >>> 16, f2 &= 65535, f2 += i3 * a2, u2 += f2 >>> 16, f2 &= 65535, u2 += e3 * c2 + r3 * s3 + n2 * a2 + i3 * o2, u2 &= 65535, $t.fromBits(l2 << 16 | h3, u2 << 16 | f2, this.unsigned);
        }
        mul(t4) {
          return this.multiply(t4);
        }
        negate() {
          return !this.unsigned && this.eq($t.MIN_VALUE) ? $t.MIN_VALUE : this.not().add($t.ONE);
        }
        neg() {
          return this.negate();
        }
        not() {
          return $t.fromBits(~this.low, ~this.high, this.unsigned);
        }
        notEquals(t4) {
          return !this.equals(t4);
        }
        neq(t4) {
          return this.notEquals(t4);
        }
        ne(t4) {
          return this.notEquals(t4);
        }
        or(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), $t.fromBits(this.low | t4.low, this.high | t4.high, this.unsigned);
        }
        shiftLeft(t4) {
          return $t.isLong(t4) && (t4 = t4.toInt()), 0 == (t4 &= 63) ? this : t4 < 32 ? $t.fromBits(this.low << t4, this.high << t4 | this.low >>> 32 - t4, this.unsigned) : $t.fromBits(0, this.low << t4 - 32, this.unsigned);
        }
        shl(t4) {
          return this.shiftLeft(t4);
        }
        shiftRight(t4) {
          return $t.isLong(t4) && (t4 = t4.toInt()), 0 == (t4 &= 63) ? this : t4 < 32 ? $t.fromBits(this.low >>> t4 | this.high << 32 - t4, this.high >> t4, this.unsigned) : $t.fromBits(this.high >> t4 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        }
        shr(t4) {
          return this.shiftRight(t4);
        }
        shiftRightUnsigned(t4) {
          if ($t.isLong(t4) && (t4 = t4.toInt()), 0 == (t4 &= 63))
            return this;
          {
            const e3 = this.high;
            if (t4 < 32) {
              const r3 = this.low;
              return $t.fromBits(r3 >>> t4 | e3 << 32 - t4, e3 >>> t4, this.unsigned);
            }
            return 32 === t4 ? $t.fromBits(e3, 0, this.unsigned) : $t.fromBits(e3 >>> t4 - 32, 0, this.unsigned);
          }
        }
        shr_u(t4) {
          return this.shiftRightUnsigned(t4);
        }
        shru(t4) {
          return this.shiftRightUnsigned(t4);
        }
        subtract(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), this.add(t4.neg());
        }
        sub(t4) {
          return this.subtract(t4);
        }
        toInt() {
          return this.unsigned ? this.low >>> 0 : this.low;
        }
        toNumber() {
          return this.unsigned ? (this.high >>> 0) * gt2 + (this.low >>> 0) : this.high * gt2 + (this.low >>> 0);
        }
        toBigInt() {
          return BigInt(this.toString());
        }
        toBytes(t4) {
          return t4 ? this.toBytesLE() : this.toBytesBE();
        }
        toBytesLE() {
          const t4 = this.high, e3 = this.low;
          return [255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24, 255 & t4, t4 >>> 8 & 255, t4 >>> 16 & 255, t4 >>> 24];
        }
        toBytesBE() {
          const t4 = this.high, e3 = this.low;
          return [t4 >>> 24, t4 >>> 16 & 255, t4 >>> 8 & 255, 255 & t4, e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
        }
        toSigned() {
          return this.unsigned ? $t.fromBits(this.low, this.high, false) : this;
        }
        toString(t4) {
          if ((t4 = t4 || 10) < 2 || 36 < t4)
            throw new q("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq($t.MIN_VALUE)) {
              const e4 = $t.fromNumber(t4), r4 = this.div(e4), n3 = r4.mul(e4).sub(this);
              return r4.toString(t4) + n3.toInt().toString(t4);
            }
            return "-" + this.neg().toString(t4);
          }
          const e3 = $t.fromNumber(Math.pow(t4, 6), this.unsigned);
          let r3 = this, n2 = "";
          for (; ; ) {
            const i3 = r3.div(e3);
            let o2 = (r3.sub(i3.mul(e3)).toInt() >>> 0).toString(t4);
            if (r3 = i3, r3.isZero())
              return o2 + n2;
            for (; o2.length < 6; )
              o2 = "0" + o2;
            n2 = "" + o2 + n2;
          }
        }
        toUnsigned() {
          return this.unsigned ? this : $t.fromBits(this.low, this.high, true);
        }
        xor(t4) {
          return $t.isLong(t4) || (t4 = $t.fromValue(t4)), $t.fromBits(this.low ^ t4.low, this.high ^ t4.high, this.unsigned);
        }
        eqz() {
          return this.isZero();
        }
        le(t4) {
          return this.lessThanOrEqual(t4);
        }
        toExtendedJSON(t4) {
          return t4 && t4.relaxed ? this.toNumber() : { $numberLong: this.toString() };
        }
        static fromExtendedJSON(t4, e3) {
          const { useBigInt64: r3 = false, relaxed: n2 = true } = { ...e3 };
          if (t4.$numberLong.length > 20)
            throw new q("$numberLong string is too long");
          if (!jt.test(t4.$numberLong))
            throw new q(`$numberLong string "${t4.$numberLong}" is in an invalid format`);
          if (r3) {
            const e4 = BigInt(t4.$numberLong);
            return BigInt.asIntN(64, e4);
          }
          const i3 = $t.fromString(t4.$numberLong);
          return n2 ? i3.toNumber() : i3;
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new Long(${r3(this.toString(), e3)}${this.unsigned ? `, ${r3(this.unsigned, e3)}` : ""})`;
        }
      }
      $t.TWO_PWR_24 = $t.fromInt(1 << 24), $t.MAX_UNSIGNED_VALUE = $t.fromBits(-1, -1, true), $t.ZERO = $t.fromInt(0), $t.UZERO = $t.fromInt(0, true), $t.ONE = $t.fromInt(1), $t.UONE = $t.fromInt(1, true), $t.NEG_ONE = $t.fromInt(-1), $t.MAX_VALUE = $t.fromBits(-1, 2147483647, false), $t.MIN_VALUE = $t.fromBits(0, -2147483648, false);
      const At = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/, Et = /^(\+|-)?(Infinity|inf)$/i, xt = /^(\+|-)?NaN$/i, Pt = 6111, kt = -6176, Mt = ut.fromNumberArray([124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), It = ut.fromNumberArray([248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), Bt = ut.fromNumberArray([120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse()), Tt = /^([-+])?(\d+)?$/;
      function Rt(t4) {
        return !isNaN(parseInt(t4, 10));
      }
      function Nt(t4) {
        const e3 = $t.fromNumber(1e9);
        let r3 = $t.fromNumber(0);
        if (!(t4.parts[0] || t4.parts[1] || t4.parts[2] || t4.parts[3]))
          return { quotient: t4, rem: r3 };
        for (let n2 = 0; n2 <= 3; n2++)
          r3 = r3.shiftLeft(32), r3 = r3.add(new $t(t4.parts[n2], 0)), t4.parts[n2] = r3.div(e3).low, r3 = r3.modulo(e3);
        return { quotient: t4, rem: r3 };
      }
      function Dt(t4, e3) {
        throw new q(`"${t4}" is not a valid Decimal128 string - ${e3}`);
      }
      class Lt extends ft {
        get _bsontype() {
          return "Decimal128";
        }
        constructor(t4) {
          if (super(), "string" == typeof t4)
            this.bytes = Lt.fromString(t4).bytes;
          else {
            if (!o(t4))
              throw new q("Decimal128 must take a Buffer or string");
            if (16 !== t4.byteLength)
              throw new q("Decimal128 must take a Buffer of 16 bytes");
            this.bytes = t4;
          }
        }
        static fromString(t4) {
          return Lt._fromString(t4, { allowRounding: false });
        }
        static fromStringWithRounding(t4) {
          return Lt._fromString(t4, { allowRounding: true });
        }
        static _fromString(t4, e3) {
          let r3 = false, n2 = false, i3 = false, o2 = false, a2 = 0, s3 = 0, c2 = 0, u2 = 0, f2 = 0;
          const l2 = [0];
          let h3 = 0, p2 = 0, d3 = 0, y3 = 0, b2 = new $t(0, 0), m3 = new $t(0, 0), v2 = 0, g2 = 0;
          if (t4.length >= 7e3)
            throw new q(t4 + " not a valid Decimal128 string");
          const _2 = t4.match(At), w3 = t4.match(Et), S2 = t4.match(xt);
          if (!_2 && !w3 && !S2 || 0 === t4.length)
            throw new q(t4 + " not a valid Decimal128 string");
          if (_2) {
            const e4 = _2[2], r4 = _2[4], n3 = _2[5], i4 = _2[6];
            r4 && void 0 === i4 && Dt(t4, "missing exponent power"), r4 && void 0 === e4 && Dt(t4, "missing exponent base"), void 0 === r4 && (n3 || i4) && Dt(t4, "missing e before exponent");
          }
          if ("+" !== t4[g2] && "-" !== t4[g2] || (n2 = true, r3 = "-" === t4[g2++]), !Rt(t4[g2]) && "." !== t4[g2]) {
            if ("i" === t4[g2] || "I" === t4[g2])
              return new Lt(r3 ? It : Bt);
            if ("N" === t4[g2])
              return new Lt(Mt);
          }
          for (; Rt(t4[g2]) || "." === t4[g2]; )
            "." !== t4[g2] ? (h3 < 34 && ("0" !== t4[g2] || o2) && (o2 || (f2 = s3), o2 = true, l2[p2++] = parseInt(t4[g2], 10), h3 += 1), o2 && (c2 += 1), i3 && (u2 += 1), s3 += 1, g2 += 1) : (i3 && Dt(t4, "contains multiple periods"), i3 = true, g2 += 1);
          if (i3 && !s3)
            throw new q(t4 + " not a valid Decimal128 string");
          if ("e" === t4[g2] || "E" === t4[g2]) {
            const e4 = t4.substr(++g2).match(Tt);
            if (!e4 || !e4[2])
              return new Lt(Mt);
            y3 = parseInt(e4[0], 10), g2 += e4[0].length;
          }
          if (t4[g2])
            return new Lt(Mt);
          if (h3) {
            if (d3 = h3 - 1, a2 = c2, 1 !== a2)
              for (; "0" === t4[f2 + a2 - 1 + Number(n2) + Number(i3)]; )
                a2 -= 1;
          } else
            l2[0] = 0, c2 = 1, h3 = 1, a2 = 0;
          for (y3 <= u2 && u2 > y3 + 16384 ? y3 = kt : y3 -= u2; y3 > Pt; ) {
            if (d3 += 1, d3 >= 34) {
              if (0 === a2) {
                y3 = Pt;
                break;
              }
              Dt(t4, "overflow");
            }
            y3 -= 1;
          }
          if (e3.allowRounding) {
            for (; y3 < kt || h3 < c2; ) {
              if (0 === d3 && a2 < h3) {
                y3 = kt, a2 = 0;
                break;
              }
              if (h3 < c2 ? c2 -= 1 : d3 -= 1, y3 < Pt)
                y3 += 1;
              else {
                if (l2.join("").match(/^0+$/)) {
                  y3 = Pt;
                  break;
                }
                Dt(t4, "overflow");
              }
            }
            if (d3 + 1 < a2) {
              let e4 = s3;
              i3 && (f2 += 1, e4 += 1), n2 && (f2 += 1, e4 += 1);
              const o3 = parseInt(t4[f2 + d3 + 1], 10);
              let a3 = 0;
              if (o3 >= 5 && (a3 = 1, 5 === o3)) {
                a3 = l2[d3] % 2 == 1 ? 1 : 0;
                for (let r4 = f2 + d3 + 2; r4 < e4; r4++)
                  if (parseInt(t4[r4], 10)) {
                    a3 = 1;
                    break;
                  }
              }
              if (a3) {
                let t5 = d3;
                for (; t5 >= 0 && ++l2[t5] > 9; t5--)
                  if (l2[t5] = 0, 0 === t5) {
                    if (!(y3 < Pt))
                      return new Lt(r3 ? It : Bt);
                    y3 += 1, l2[t5] = 1;
                  }
              }
            }
          } else {
            for (; y3 < kt || h3 < c2; ) {
              if (0 === d3) {
                if (0 === a2) {
                  y3 = kt;
                  break;
                }
                Dt(t4, "exponent underflow");
              }
              h3 < c2 ? ("0" !== t4[c2 - 1 + Number(n2) + Number(i3)] && 0 !== a2 && Dt(t4, "inexact rounding"), c2 -= 1) : (0 !== l2[d3] && Dt(t4, "inexact rounding"), d3 -= 1), y3 < Pt ? y3 += 1 : Dt(t4, "overflow");
            }
            d3 + 1 < a2 && (i3 && (f2 += 1), n2 && (f2 += 1), 0 !== parseInt(t4[f2 + d3 + 1], 10) && Dt(t4, "inexact rounding"));
          }
          if (b2 = $t.fromNumber(0), m3 = $t.fromNumber(0), 0 === a2)
            b2 = $t.fromNumber(0), m3 = $t.fromNumber(0);
          else if (d3 < 17) {
            let t5 = 0;
            for (m3 = $t.fromNumber(l2[t5++]), b2 = new $t(0, 0); t5 <= d3; t5++)
              m3 = m3.multiply($t.fromNumber(10)), m3 = m3.add($t.fromNumber(l2[t5]));
          } else {
            let t5 = 0;
            for (b2 = $t.fromNumber(l2[t5++]); t5 <= d3 - 17; t5++)
              b2 = b2.multiply($t.fromNumber(10)), b2 = b2.add($t.fromNumber(l2[t5]));
            for (m3 = $t.fromNumber(l2[t5++]); t5 <= d3; t5++)
              m3 = m3.multiply($t.fromNumber(10)), m3 = m3.add($t.fromNumber(l2[t5]));
          }
          const O2 = function(t5, e4) {
            if (!t5 && !e4)
              return { high: $t.fromNumber(0), low: $t.fromNumber(0) };
            const r4 = t5.shiftRightUnsigned(32), n3 = new $t(t5.getLowBits(), 0), i4 = e4.shiftRightUnsigned(32), o3 = new $t(e4.getLowBits(), 0);
            let a3 = r4.multiply(i4), s4 = r4.multiply(o3);
            const c3 = n3.multiply(i4);
            let u3 = n3.multiply(o3);
            return a3 = a3.add(s4.shiftRightUnsigned(32)), s4 = new $t(s4.getLowBits(), 0).add(c3).add(u3.shiftRightUnsigned(32)), a3 = a3.add(s4.shiftRightUnsigned(32)), u3 = s4.shiftLeft(32).add(new $t(u3.getLowBits(), 0)), { high: a3, low: u3 };
          }(b2, $t.fromString("100000000000000000"));
          O2.low = O2.low.add(m3), function(t5, e4) {
            const r4 = t5.high >>> 0, n3 = e4.high >>> 0;
            return r4 < n3 || r4 === n3 && t5.low >>> 0 < e4.low >>> 0;
          }(O2.low, m3) && (O2.high = O2.high.add($t.fromNumber(1))), v2 = y3 + 6176;
          const j2 = { low: $t.fromNumber(0), high: $t.fromNumber(0) };
          O2.high.shiftRightUnsigned(49).and($t.fromNumber(1)).equals($t.fromNumber(1)) ? (j2.high = j2.high.or($t.fromNumber(3).shiftLeft(61)), j2.high = j2.high.or($t.fromNumber(v2).and($t.fromNumber(16383).shiftLeft(47))), j2.high = j2.high.or(O2.high.and($t.fromNumber(140737488355327)))) : (j2.high = j2.high.or($t.fromNumber(16383 & v2).shiftLeft(49)), j2.high = j2.high.or(O2.high.and($t.fromNumber(562949953421311)))), j2.low = O2.low, r3 && (j2.high = j2.high.or($t.fromString("9223372036854775808")));
          const $2 = ut.allocateUnsafe(16);
          return g2 = 0, $2[g2++] = 255 & j2.low.low, $2[g2++] = j2.low.low >> 8 & 255, $2[g2++] = j2.low.low >> 16 & 255, $2[g2++] = j2.low.low >> 24 & 255, $2[g2++] = 255 & j2.low.high, $2[g2++] = j2.low.high >> 8 & 255, $2[g2++] = j2.low.high >> 16 & 255, $2[g2++] = j2.low.high >> 24 & 255, $2[g2++] = 255 & j2.high.low, $2[g2++] = j2.high.low >> 8 & 255, $2[g2++] = j2.high.low >> 16 & 255, $2[g2++] = j2.high.low >> 24 & 255, $2[g2++] = 255 & j2.high.high, $2[g2++] = j2.high.high >> 8 & 255, $2[g2++] = j2.high.high >> 16 & 255, $2[g2++] = j2.high.high >> 24 & 255, new Lt($2);
        }
        toString() {
          let t4, e3 = 0;
          const r3 = new Array(36);
          for (let t5 = 0; t5 < r3.length; t5++)
            r3[t5] = 0;
          let n2, i3, o2, a2 = 0, s3 = false, c2 = { parts: [0, 0, 0, 0] };
          const u2 = [];
          a2 = 0;
          const f2 = this.bytes, l2 = f2[a2++] | f2[a2++] << 8 | f2[a2++] << 16 | f2[a2++] << 24, h3 = f2[a2++] | f2[a2++] << 8 | f2[a2++] << 16 | f2[a2++] << 24, p2 = f2[a2++] | f2[a2++] << 8 | f2[a2++] << 16 | f2[a2++] << 24, d3 = f2[a2++] | f2[a2++] << 8 | f2[a2++] << 16 | f2[a2++] << 24;
          a2 = 0, (new $t(l2, h3), new $t(p2, d3)).lessThan($t.ZERO) && u2.push("-");
          const y3 = d3 >> 26 & 31;
          if (y3 >> 3 == 3) {
            if (30 === y3)
              return u2.join("") + "Infinity";
            if (31 === y3)
              return "NaN";
            t4 = d3 >> 15 & 16383, n2 = 8 + (d3 >> 14 & 1);
          } else
            n2 = d3 >> 14 & 7, t4 = d3 >> 17 & 16383;
          const b2 = t4 - 6176;
          if (c2.parts[0] = (16383 & d3) + ((15 & n2) << 14), c2.parts[1] = p2, c2.parts[2] = h3, c2.parts[3] = l2, 0 === c2.parts[0] && 0 === c2.parts[1] && 0 === c2.parts[2] && 0 === c2.parts[3])
            s3 = true;
          else
            for (o2 = 3; o2 >= 0; o2--) {
              let t5 = 0;
              const e4 = Nt(c2);
              if (c2 = e4.quotient, t5 = e4.rem.low, t5)
                for (i3 = 8; i3 >= 0; i3--)
                  r3[9 * o2 + i3] = t5 % 10, t5 = Math.floor(t5 / 10);
            }
          if (s3)
            e3 = 1, r3[a2] = 0;
          else
            for (e3 = 36; !r3[a2]; )
              e3 -= 1, a2 += 1;
          const m3 = e3 - 1 + b2;
          if (m3 >= 34 || m3 <= -7 || b2 > 0) {
            if (e3 > 34)
              return u2.push("0"), b2 > 0 ? u2.push(`E+${b2}`) : b2 < 0 && u2.push(`E${b2}`), u2.join("");
            u2.push(`${r3[a2++]}`), e3 -= 1, e3 && u2.push(".");
            for (let t5 = 0; t5 < e3; t5++)
              u2.push(`${r3[a2++]}`);
            u2.push("E"), m3 > 0 ? u2.push(`+${m3}`) : u2.push(`${m3}`);
          } else if (b2 >= 0)
            for (let t5 = 0; t5 < e3; t5++)
              u2.push(`${r3[a2++]}`);
          else {
            let t5 = e3 + b2;
            if (t5 > 0)
              for (let e4 = 0; e4 < t5; e4++)
                u2.push(`${r3[a2++]}`);
            else
              u2.push("0");
            for (u2.push("."); t5++ < 0; )
              u2.push("0");
            for (let n3 = 0; n3 < e3 - Math.max(t5 - 1, 0); n3++)
              u2.push(`${r3[a2++]}`);
          }
          return u2.join("");
        }
        toJSON() {
          return { $numberDecimal: this.toString() };
        }
        toExtendedJSON() {
          return { $numberDecimal: this.toString() };
        }
        static fromExtendedJSON(t4) {
          return Lt.fromString(t4.$numberDecimal);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new Decimal128(${r3(this.toString(), e3)})`;
        }
      }
      class Ut extends ft {
        get _bsontype() {
          return "Double";
        }
        constructor(t4) {
          super(), t4 instanceof Number && (t4 = t4.valueOf()), this.value = +t4;
        }
        valueOf() {
          return this.value;
        }
        toJSON() {
          return this.value;
        }
        toString(t4) {
          return this.value.toString(t4);
        }
        toExtendedJSON(t4) {
          return t4 && (t4.legacy || t4.relaxed && isFinite(this.value)) ? this.value : Object.is(Math.sign(this.value), -0) ? { $numberDouble: "-0.0" } : { $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString() };
        }
        static fromExtendedJSON(t4, e3) {
          const r3 = parseFloat(t4.$numberDouble);
          return e3 && e3.relaxed ? r3 : new Ut(r3);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new Double(${r3(this.value, e3)})`;
        }
      }
      class Ct extends ft {
        get _bsontype() {
          return "Int32";
        }
        constructor(t4) {
          super(), t4 instanceof Number && (t4 = t4.valueOf()), this.value = 0 | +t4;
        }
        valueOf() {
          return this.value;
        }
        toString(t4) {
          return this.value.toString(t4);
        }
        toJSON() {
          return this.value;
        }
        toExtendedJSON(t4) {
          return t4 && (t4.relaxed || t4.legacy) ? this.value : { $numberInt: this.value.toString() };
        }
        static fromExtendedJSON(t4, e3) {
          return e3 && e3.relaxed ? parseInt(t4.$numberInt, 10) : new Ct(t4.$numberInt);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new Int32(${r3(this.value, e3)})`;
        }
      }
      class qt extends ft {
        get _bsontype() {
          return "MaxKey";
        }
        toExtendedJSON() {
          return { $maxKey: 1 };
        }
        static fromExtendedJSON() {
          return new qt();
        }
        inspect() {
          return "new MaxKey()";
        }
      }
      class Ft extends ft {
        get _bsontype() {
          return "MinKey";
        }
        toExtendedJSON() {
          return { $minKey: 1 };
        }
        static fromExtendedJSON() {
          return new Ft();
        }
        inspect() {
          return "new MinKey()";
        }
      }
      const Vt = new Float64Array(1), zt = new Uint8Array(Vt.buffer, 0, 8);
      Vt[0] = -1;
      const Kt = 0 === zt[7], Ht = { getNonnegativeInt32LE(t4, e3) {
        if (t4[e3 + 3] > 127)
          throw new RangeError(`Size cannot be negative at offset: ${e3}`);
        return t4[e3] | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24;
      }, getInt32LE: (t4, e3) => t4[e3] | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24, getUint32LE: (t4, e3) => t4[e3] + 256 * t4[e3 + 1] + 65536 * t4[e3 + 2] + 16777216 * t4[e3 + 3], getUint32BE: (t4, e3) => t4[e3 + 3] + 256 * t4[e3 + 2] + 65536 * t4[e3 + 1] + 16777216 * t4[e3], getBigInt64LE(t4, e3) {
        const r3 = Ht.getUint32LE(t4, e3), n2 = Ht.getUint32LE(t4, e3 + 4);
        return (BigInt(n2) << BigInt(32)) + BigInt(r3);
      }, getFloat64LE: Kt ? (t4, e3) => (zt[7] = t4[e3], zt[6] = t4[e3 + 1], zt[5] = t4[e3 + 2], zt[4] = t4[e3 + 3], zt[3] = t4[e3 + 4], zt[2] = t4[e3 + 5], zt[1] = t4[e3 + 6], zt[0] = t4[e3 + 7], Vt[0]) : (t4, e3) => (zt[0] = t4[e3], zt[1] = t4[e3 + 1], zt[2] = t4[e3 + 2], zt[3] = t4[e3 + 3], zt[4] = t4[e3 + 4], zt[5] = t4[e3 + 5], zt[6] = t4[e3 + 6], zt[7] = t4[e3 + 7], Vt[0]), setInt32BE: (t4, e3, r3) => (t4[e3 + 3] = r3, r3 >>>= 8, t4[e3 + 2] = r3, r3 >>>= 8, t4[e3 + 1] = r3, r3 >>>= 8, t4[e3] = r3, 4), setInt32LE: (t4, e3, r3) => (t4[e3] = r3, r3 >>>= 8, t4[e3 + 1] = r3, r3 >>>= 8, t4[e3 + 2] = r3, r3 >>>= 8, t4[e3 + 3] = r3, 4), setBigInt64LE(t4, e3, r3) {
        const n2 = BigInt(4294967295);
        let i3 = Number(r3 & n2);
        t4[e3] = i3, i3 >>= 8, t4[e3 + 1] = i3, i3 >>= 8, t4[e3 + 2] = i3, i3 >>= 8, t4[e3 + 3] = i3;
        let o2 = Number(r3 >> BigInt(32) & n2);
        return t4[e3 + 4] = o2, o2 >>= 8, t4[e3 + 5] = o2, o2 >>= 8, t4[e3 + 6] = o2, o2 >>= 8, t4[e3 + 7] = o2, 8;
      }, setFloat64LE: Kt ? (t4, e3, r3) => (Vt[0] = r3, t4[e3] = zt[7], t4[e3 + 1] = zt[6], t4[e3 + 2] = zt[5], t4[e3 + 3] = zt[4], t4[e3 + 4] = zt[3], t4[e3 + 5] = zt[2], t4[e3 + 6] = zt[1], t4[e3 + 7] = zt[0], 8) : (t4, e3, r3) => (Vt[0] = r3, t4[e3] = zt[0], t4[e3 + 1] = zt[1], t4[e3 + 2] = zt[2], t4[e3 + 3] = zt[3], t4[e3 + 4] = zt[4], t4[e3 + 5] = zt[5], t4[e3 + 6] = zt[6], t4[e3 + 7] = zt[7], 8) }, Wt = new RegExp("^[0-9a-fA-F]{24}$");
      let Jt = null;
      class Gt extends ft {
        get _bsontype() {
          return "ObjectId";
        }
        constructor(t4) {
          let e3;
          if (super(), "object" == typeof t4 && t4 && "id" in t4) {
            if ("string" != typeof t4.id && !ArrayBuffer.isView(t4.id))
              throw new q("Argument passed in must have an id that is of type string or Buffer");
            e3 = "toHexString" in t4 && "function" == typeof t4.toHexString ? ut.fromHex(t4.toHexString()) : t4.id;
          } else
            e3 = t4;
          if (null == e3 || "number" == typeof e3)
            this.buffer = Gt.generate("number" == typeof e3 ? e3 : void 0);
          else if (ArrayBuffer.isView(e3) && 12 === e3.byteLength)
            this.buffer = ut.toLocalBufferType(e3);
          else {
            if ("string" != typeof e3)
              throw new q("Argument passed in does not match the accepted types");
            if (24 !== e3.length || !Wt.test(e3))
              throw new q("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
            this.buffer = ut.fromHex(e3);
          }
          Gt.cacheHexString && (this.__id = ut.toHex(this.id));
        }
        get id() {
          return this.buffer;
        }
        set id(t4) {
          this.buffer = t4, Gt.cacheHexString && (this.__id = ut.toHex(t4));
        }
        toHexString() {
          if (Gt.cacheHexString && this.__id)
            return this.__id;
          const t4 = ut.toHex(this.id);
          return Gt.cacheHexString && !this.__id && (this.__id = t4), t4;
        }
        static getInc() {
          return Gt.index = (Gt.index + 1) % 16777215;
        }
        static generate(t4) {
          "number" != typeof t4 && (t4 = Math.floor(Date.now() / 1e3));
          const e3 = Gt.getInc(), r3 = ut.allocateUnsafe(12);
          return Ht.setInt32BE(r3, 0, t4), null === Jt && (Jt = ut.randomBytes(5)), r3[4] = Jt[0], r3[5] = Jt[1], r3[6] = Jt[2], r3[7] = Jt[3], r3[8] = Jt[4], r3[11] = 255 & e3, r3[10] = e3 >> 8 & 255, r3[9] = e3 >> 16 & 255, r3;
        }
        toString(t4) {
          return "base64" === t4 ? ut.toBase64(this.id) : this.toHexString();
        }
        toJSON() {
          return this.toHexString();
        }
        static is(t4) {
          return null != t4 && "object" == typeof t4 && "_bsontype" in t4 && "ObjectId" === t4._bsontype;
        }
        equals(t4) {
          if (null == t4)
            return false;
          if (Gt.is(t4))
            return this.buffer[11] === t4.buffer[11] && ut.equals(this.buffer, t4.buffer);
          if ("string" == typeof t4)
            return t4.toLowerCase() === this.toHexString();
          if ("object" == typeof t4 && "function" == typeof t4.toHexString) {
            const e3 = t4.toHexString(), r3 = this.toHexString();
            return "string" == typeof e3 && e3.toLowerCase() === r3;
          }
          return false;
        }
        getTimestamp() {
          const t4 = /* @__PURE__ */ new Date(), e3 = Ht.getUint32BE(this.buffer, 0);
          return t4.setTime(1e3 * Math.floor(e3)), t4;
        }
        static createPk() {
          return new Gt();
        }
        serializeInto(t4, e3) {
          return t4[e3] = this.buffer[0], t4[e3 + 1] = this.buffer[1], t4[e3 + 2] = this.buffer[2], t4[e3 + 3] = this.buffer[3], t4[e3 + 4] = this.buffer[4], t4[e3 + 5] = this.buffer[5], t4[e3 + 6] = this.buffer[6], t4[e3 + 7] = this.buffer[7], t4[e3 + 8] = this.buffer[8], t4[e3 + 9] = this.buffer[9], t4[e3 + 10] = this.buffer[10], t4[e3 + 11] = this.buffer[11], 12;
        }
        static createFromTime(t4) {
          const e3 = ut.allocate(12);
          for (let t5 = 11; t5 >= 4; t5--)
            e3[t5] = 0;
          return Ht.setInt32BE(e3, 0, t4), new Gt(e3);
        }
        static createFromHexString(t4) {
          if (24 !== (t4 == null ? void 0 : t4.length))
            throw new q("hex string must be 24 characters");
          return new Gt(ut.fromHex(t4));
        }
        static createFromBase64(t4) {
          if (16 !== (t4 == null ? void 0 : t4.length))
            throw new q("base64 string must be 16 characters");
          return new Gt(ut.fromBase64(t4));
        }
        static isValid(t4) {
          if (null == t4)
            return false;
          try {
            return new Gt(t4), true;
          } catch {
            return false;
          }
        }
        toExtendedJSON() {
          return this.toHexString ? { $oid: this.toHexString() } : { $oid: this.toString("hex") };
        }
        static fromExtendedJSON(t4) {
          return new Gt(t4.$oid);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new ObjectId(${r3(this.toHexString(), e3)})`;
        }
      }
      function Yt(t4, e3, r3) {
        let n2 = 5;
        if (Array.isArray(t4))
          for (let i3 = 0; i3 < t4.length; i3++)
            n2 += Qt(i3.toString(), t4[i3], e3, true, r3);
        else {
          "function" == typeof (t4 == null ? void 0 : t4.toBSON) && (t4 = t4.toBSON());
          for (const i3 of Object.keys(t4))
            n2 += Qt(i3, t4[i3], e3, false, r3);
        }
        return n2;
      }
      function Qt(t4, e3, r3 = false, n2 = false, o2 = false) {
        switch ("function" == typeof (e3 == null ? void 0 : e3.toBSON) && (e3 = e3.toBSON()), typeof e3) {
          case "string":
            return 1 + ut.utf8ByteLength(t4) + 1 + 4 + ut.utf8ByteLength(e3) + 1;
          case "number":
            return Math.floor(e3) === e3 && e3 >= b && e3 <= y2 && e3 >= h2 && e3 <= l ? (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 5 : (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 9;
          case "undefined":
            return n2 || !o2 ? (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 : 0;
          case "boolean":
            return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 2;
          case "object":
            if (null != e3 && "string" == typeof e3._bsontype && e3[Symbol.for("@@mdb.bson.version")] !== f)
              throw new F();
            if (null == e3 || "MinKey" === e3._bsontype || "MaxKey" === e3._bsontype)
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1;
            if ("ObjectId" === e3._bsontype)
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 13;
            if (e3 instanceof Date || c(e3))
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 9;
            if (ArrayBuffer.isView(e3) || e3 instanceof ArrayBuffer || i2(e3))
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 6 + e3.byteLength;
            if ("Long" === e3._bsontype || "Double" === e3._bsontype || "Timestamp" === e3._bsontype)
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 9;
            if ("Decimal128" === e3._bsontype)
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 17;
            if ("Code" === e3._bsontype)
              return null != e3.scope && Object.keys(e3.scope).length > 0 ? (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 + 4 + 4 + ut.utf8ByteLength(e3.code.toString()) + 1 + Yt(e3.scope, r3, o2) : (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 + 4 + ut.utf8ByteLength(e3.code.toString()) + 1;
            if ("Binary" === e3._bsontype) {
              const r4 = e3;
              return r4.sub_type === lt2.SUBTYPE_BYTE_ARRAY ? (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + (r4.position + 1 + 4 + 1 + 4) : (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + (r4.position + 1 + 4 + 1);
            }
            if ("Symbol" === e3._bsontype)
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + ut.utf8ByteLength(e3.value) + 4 + 1 + 1;
            if ("DBRef" === e3._bsontype) {
              const n3 = Object.assign({ $ref: e3.collection, $id: e3.oid }, e3.fields);
              return null != e3.db && (n3.$db = e3.db), (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 + Yt(n3, r3, o2);
            }
            return e3 instanceof RegExp || a(e3) ? (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 + ut.utf8ByteLength(e3.source) + 1 + (e3.global ? 1 : 0) + (e3.ignoreCase ? 1 : 0) + (e3.multiline ? 1 : 0) + 1 : "BSONRegExp" === e3._bsontype ? (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 + ut.utf8ByteLength(e3.pattern) + 1 + ut.utf8ByteLength(e3.options) + 1 : (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + Yt(e3, r3, o2) + 1;
          case "function":
            if (r3)
              return (null != t4 ? ut.utf8ByteLength(t4) + 1 : 0) + 1 + 4 + ut.utf8ByteLength(e3.toString()) + 1;
        }
        return 0;
      }
      Gt.index = Math.floor(16777215 * Math.random());
      class Xt extends ft {
        get _bsontype() {
          return "BSONRegExp";
        }
        constructor(t4, e3) {
          if (super(), this.pattern = t4, this.options = (e3 ?? "").split("").sort().join(""), -1 !== this.pattern.indexOf("\0"))
            throw new q(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
          if (-1 !== this.options.indexOf("\0"))
            throw new q(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
          for (let t5 = 0; t5 < this.options.length; t5++)
            if ("i" !== this.options[t5] && "m" !== this.options[t5] && "x" !== this.options[t5] && "l" !== this.options[t5] && "s" !== this.options[t5] && "u" !== this.options[t5])
              throw new q(`The regular expression option [${this.options[t5]}] is not supported`);
        }
        static parseOptions(t4) {
          return t4 ? t4.split("").sort().join("") : "";
        }
        toExtendedJSON(t4) {
          return (t4 = t4 || {}).legacy ? { $regex: this.pattern, $options: this.options } : { $regularExpression: { pattern: this.pattern, options: this.options } };
        }
        static fromExtendedJSON(t4) {
          if ("$regex" in t4) {
            if ("string" == typeof t4.$regex)
              return new Xt(t4.$regex, Xt.parseOptions(t4.$options));
            if ("BSONRegExp" === t4.$regex._bsontype)
              return t4;
          }
          if ("$regularExpression" in t4)
            return new Xt(t4.$regularExpression.pattern, Xt.parseOptions(t4.$regularExpression.options));
          throw new q(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(t4)}`);
        }
        inspect(t4, e3, r3) {
          const n2 = function(t5) {
            if (null != t5 && "object" == typeof t5 && "stylize" in t5 && "function" == typeof t5.stylize)
              return t5.stylize;
          }(e3) ?? ((t5) => t5);
          return r3 ?? (r3 = u), `new BSONRegExp(${n2(r3(this.pattern), "regexp")}, ${n2(r3(this.options), "regexp")})`;
        }
      }
      class Zt extends ft {
        get _bsontype() {
          return "BSONSymbol";
        }
        constructor(t4) {
          super(), this.value = t4;
        }
        valueOf() {
          return this.value;
        }
        toString() {
          return this.value;
        }
        toJSON() {
          return this.value;
        }
        toExtendedJSON() {
          return { $symbol: this.value };
        }
        static fromExtendedJSON(t4) {
          return new Zt(t4.$symbol);
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new BSONSymbol(${r3(this.value, e3)})`;
        }
      }
      const te = $t;
      class ee extends te {
        get _bsontype() {
          return "Timestamp";
        }
        constructor(t4) {
          if (null == t4)
            super(0, 0, true);
          else if ("bigint" == typeof t4)
            super(t4, true);
          else if ($t.isLong(t4))
            super(t4.low, t4.high, true);
          else {
            if ("object" != typeof t4 || !("t" in t4) || !("i" in t4))
              throw new q("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
            {
              if ("number" != typeof t4.t && ("object" != typeof t4.t || "Int32" !== t4.t._bsontype))
                throw new q("Timestamp constructed from { t, i } must provide t as a number");
              if ("number" != typeof t4.i && ("object" != typeof t4.i || "Int32" !== t4.i._bsontype))
                throw new q("Timestamp constructed from { t, i } must provide i as a number");
              const e3 = Number(t4.t), r3 = Number(t4.i);
              if (e3 < 0 || Number.isNaN(e3))
                throw new q("Timestamp constructed from { t, i } must provide a positive t");
              if (r3 < 0 || Number.isNaN(r3))
                throw new q("Timestamp constructed from { t, i } must provide a positive i");
              if (e3 > 4294967295)
                throw new q("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
              if (r3 > 4294967295)
                throw new q("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
              super(r3, e3, true);
            }
          }
        }
        toJSON() {
          return { $timestamp: this.toString() };
        }
        static fromInt(t4) {
          return new ee($t.fromInt(t4, true));
        }
        static fromNumber(t4) {
          return new ee($t.fromNumber(t4, true));
        }
        static fromBits(t4, e3) {
          return new ee({ i: t4, t: e3 });
        }
        static fromString(t4, e3) {
          return new ee($t.fromString(t4, true, e3));
        }
        toExtendedJSON() {
          return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
        }
        static fromExtendedJSON(t4) {
          const e3 = $t.isLong(t4.$timestamp.i) ? t4.$timestamp.i.getLowBitsUnsigned() : t4.$timestamp.i, r3 = $t.isLong(t4.$timestamp.t) ? t4.$timestamp.t.getLowBitsUnsigned() : t4.$timestamp.t;
          return new ee({ t: r3, i: e3 });
        }
        inspect(t4, e3, r3) {
          return r3 ?? (r3 = u), `new Timestamp({ t: ${r3(this.high >>> 0, e3)}, i: ${r3(this.low >>> 0, e3)} })`;
        }
      }
      ee.MAX_VALUE = $t.MAX_UNSIGNED_VALUE;
      const re2 = $t.fromNumber(y2), ne = $t.fromNumber(b);
      function ie(t4, e3, r3) {
        const n2 = (e3 = null == e3 ? {} : e3) && e3.index ? e3.index : 0, i3 = Ht.getInt32LE(t4, n2);
        if (i3 < 5)
          throw new q(`bson size must be >= 5, is ${i3}`);
        if (e3.allowObjectSmallerThanBufferSize && t4.length < i3)
          throw new q(`buffer length ${t4.length} must be >= bson size ${i3}`);
        if (!e3.allowObjectSmallerThanBufferSize && t4.length !== i3)
          throw new q(`buffer length ${t4.length} must === bson size ${i3}`);
        if (i3 + n2 > t4.byteLength)
          throw new q(`(bson size ${i3} + options.index ${n2} must be <= buffer length ${t4.byteLength})`);
        if (0 !== t4[n2 + i3 - 1])
          throw new q("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
        return ae(t4, n2, e3, r3);
      }
      const oe = /^\$ref$|^\$id$|^\$db$/;
      function ae(t4, e3, r3, n2 = false) {
        const i3 = null == r3.fieldsAsRaw ? null : r3.fieldsAsRaw, o2 = null != r3.raw && r3.raw, a2 = "boolean" == typeof r3.bsonRegExp && r3.bsonRegExp, s3 = r3.promoteBuffers ?? false, c2 = r3.promoteLongs ?? true, u2 = r3.promoteValues ?? true, f2 = r3.useBigInt64 ?? false;
        if (f2 && !u2)
          throw new q("Must either request bigint or Long for int64 deserialization");
        if (f2 && !c2)
          throw new q("Must either request bigint or Long for int64 deserialization");
        const l2 = null == r3.validation ? { utf8: true } : r3.validation;
        let h3, p2, d3 = true;
        const y3 = l2.utf8;
        if ("boolean" == typeof y3)
          h3 = y3;
        else {
          d3 = false;
          const t5 = Object.keys(y3).map(function(t6) {
            return y3[t6];
          });
          if (0 === t5.length)
            throw new q("UTF-8 validation setting cannot be empty");
          if ("boolean" != typeof t5[0])
            throw new q("Invalid UTF-8 validation option, must specify boolean values");
          if (h3 = t5[0], !t5.every((t6) => t6 === h3))
            throw new q("Invalid UTF-8 validation option - keys must be all true or all false");
        }
        if (!d3) {
          p2 = /* @__PURE__ */ new Set();
          for (const t5 of Object.keys(y3))
            p2.add(t5);
        }
        const b2 = e3;
        if (t4.length < 5)
          throw new q("corrupt bson message < 5 bytes long");
        const L2 = Ht.getInt32LE(t4, e3);
        if (e3 += 4, L2 < 5 || L2 > t4.length)
          throw new q("corrupt bson message");
        const C2 = n2 ? [] : {};
        let F2 = 0, V2 = !n2 && null;
        for (; ; ) {
          const y4 = t4[e3++];
          if (0 === y4)
            break;
          let b3 = e3;
          for (; 0 !== t4[b3] && b3 < t4.length; )
            b3++;
          if (b3 >= t4.byteLength)
            throw new q("Bad BSON Document: illegal CString");
          const L3 = n2 ? F2++ : ut.toUTF8(t4, e3, b3, false);
          let z2, K2 = true;
          if (K2 = d3 || (p2 == null ? void 0 : p2.has(L3)) ? h3 : !h3, false !== V2 && "$" === L3[0] && (V2 = oe.test(L3)), e3 = b3 + 1, y4 === v) {
            const r4 = Ht.getInt32LE(t4, e3);
            if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || 0 !== t4[e3 + r4 - 1])
              throw new q("bad string length in bson");
            z2 = ut.toUTF8(t4, e3, e3 + r4 - 1, K2), e3 += r4;
          } else if (y4 === O) {
            const r4 = ut.allocateUnsafe(12);
            for (let n3 = 0; n3 < 12; n3++)
              r4[n3] = t4[e3 + n3];
            z2 = new Gt(r4), e3 += 12;
          } else if (y4 === I && false === u2)
            z2 = new Ct(Ht.getInt32LE(t4, e3)), e3 += 4;
          else if (y4 === I)
            z2 = Ht.getInt32LE(t4, e3), e3 += 4;
          else if (y4 === m2)
            z2 = Ht.getFloat64LE(t4, e3), e3 += 8, false === u2 && (z2 = new Ut(z2));
          else if (y4 === $) {
            const r4 = Ht.getInt32LE(t4, e3), n3 = Ht.getInt32LE(t4, e3 + 4);
            e3 += 8, z2 = new Date(new $t(r4, n3).toNumber());
          } else if (y4 === j) {
            if (0 !== t4[e3] && 1 !== t4[e3])
              throw new q("illegal boolean type value");
            z2 = 1 === t4[e3++];
          } else if (y4 === g) {
            const n3 = e3, i4 = Ht.getInt32LE(t4, e3);
            if (i4 <= 0 || i4 > t4.length - e3)
              throw new q("bad embedded document length in bson");
            if (o2)
              z2 = t4.slice(e3, e3 + i4);
            else {
              let e4 = r3;
              d3 || (e4 = { ...r3, validation: { utf8: K2 } }), z2 = ae(t4, n3, e4, false);
            }
            e3 += i4;
          } else if (y4 === _) {
            const n3 = e3, o3 = Ht.getInt32LE(t4, e3);
            let a3 = r3;
            const s4 = e3 + o3;
            if (i3 && i3[L3] && (a3 = { ...r3, raw: true }), d3 || (a3 = { ...a3, validation: { utf8: K2 } }), z2 = ae(t4, n3, a3, true), 0 !== t4[(e3 += o3) - 1])
              throw new q("invalid array terminator byte");
            if (e3 !== s4)
              throw new q("corrupted array bson");
          } else if (y4 === S)
            z2 = void 0;
          else if (y4 === A)
            z2 = null;
          else if (y4 === T)
            if (f2)
              z2 = Ht.getBigInt64LE(t4, e3), e3 += 8;
            else {
              const r4 = Ht.getInt32LE(t4, e3), n3 = Ht.getInt32LE(t4, e3 + 4);
              e3 += 8;
              const i4 = new $t(r4, n3);
              z2 = c2 && true === u2 && i4.lessThanOrEqual(re2) && i4.greaterThanOrEqual(ne) ? i4.toNumber() : i4;
            }
          else if (y4 === R) {
            const r4 = ut.allocateUnsafe(16);
            for (let n3 = 0; n3 < 16; n3++)
              r4[n3] = t4[e3 + n3];
            e3 += 16, z2 = new Lt(r4);
          } else if (y4 === w2) {
            let r4 = Ht.getInt32LE(t4, e3);
            e3 += 4;
            const n3 = r4, i4 = t4[e3++];
            if (r4 < 0)
              throw new q("Negative binary type element size found");
            if (r4 > t4.byteLength)
              throw new q("Binary type size larger than document size");
            if (null != t4.slice) {
              if (i4 === lt2.SUBTYPE_BYTE_ARRAY) {
                if (r4 = Ht.getInt32LE(t4, e3), e3 += 4, r4 < 0)
                  throw new q("Negative binary type element size found for subtype 0x02");
                if (r4 > n3 - 4)
                  throw new q("Binary type with subtype 0x02 contains too long binary size");
                if (r4 < n3 - 4)
                  throw new q("Binary type with subtype 0x02 contains too short binary size");
              }
              s3 && u2 ? z2 = ut.toLocalBufferType(t4.slice(e3, e3 + r4)) : (z2 = new lt2(t4.slice(e3, e3 + r4), i4), i4 === U && dt.isValid(z2) && (z2 = z2.toUUID()));
            } else {
              if (i4 === lt2.SUBTYPE_BYTE_ARRAY) {
                if (r4 = Ht.getInt32LE(t4, e3), e3 += 4, r4 < 0)
                  throw new q("Negative binary type element size found for subtype 0x02");
                if (r4 > n3 - 4)
                  throw new q("Binary type with subtype 0x02 contains too long binary size");
                if (r4 < n3 - 4)
                  throw new q("Binary type with subtype 0x02 contains too short binary size");
              }
              if (s3 && u2)
                for (z2 = ut.allocateUnsafe(r4), b3 = 0; b3 < r4; b3++)
                  z2[b3] = t4[e3 + b3];
              else
                z2 = new lt2(t4.slice(e3, e3 + r4), i4), i4 === U && dt.isValid(z2) && (z2 = z2.toUUID());
            }
            e3 += r4;
          } else if (y4 === E && false === a2) {
            for (b3 = e3; 0 !== t4[b3] && b3 < t4.length; )
              b3++;
            if (b3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const r4 = ut.toUTF8(t4, e3, b3, false);
            for (b3 = e3 = b3 + 1; 0 !== t4[b3] && b3 < t4.length; )
              b3++;
            if (b3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const n3 = ut.toUTF8(t4, e3, b3, false);
            e3 = b3 + 1;
            const i4 = new Array(n3.length);
            for (b3 = 0; b3 < n3.length; b3++)
              switch (n3[b3]) {
                case "m":
                  i4[b3] = "m";
                  break;
                case "s":
                  i4[b3] = "g";
                  break;
                case "i":
                  i4[b3] = "i";
              }
            z2 = new RegExp(r4, i4.join(""));
          } else if (y4 === E && true === a2) {
            for (b3 = e3; 0 !== t4[b3] && b3 < t4.length; )
              b3++;
            if (b3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const r4 = ut.toUTF8(t4, e3, b3, false);
            for (b3 = e3 = b3 + 1; 0 !== t4[b3] && b3 < t4.length; )
              b3++;
            if (b3 >= t4.length)
              throw new q("Bad BSON Document: illegal CString");
            const n3 = ut.toUTF8(t4, e3, b3, false);
            e3 = b3 + 1, z2 = new Xt(r4, n3);
          } else if (y4 === k) {
            const r4 = Ht.getInt32LE(t4, e3);
            if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || 0 !== t4[e3 + r4 - 1])
              throw new q("bad string length in bson");
            const n3 = ut.toUTF8(t4, e3, e3 + r4 - 1, K2);
            z2 = u2 ? n3 : new Zt(n3), e3 += r4;
          } else if (y4 === B)
            z2 = new ee({ i: Ht.getUint32LE(t4, e3), t: Ht.getUint32LE(t4, e3 + 4) }), e3 += 8;
          else if (y4 === N)
            z2 = new Ft();
          else if (y4 === D)
            z2 = new qt();
          else if (y4 === P) {
            const r4 = Ht.getInt32LE(t4, e3);
            if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || 0 !== t4[e3 + r4 - 1])
              throw new q("bad string length in bson");
            const n3 = ut.toUTF8(t4, e3, e3 + r4 - 1, K2);
            z2 = new yt(n3), e3 += r4;
          } else if (y4 === M) {
            const n3 = Ht.getInt32LE(t4, e3);
            if (e3 += 4, n3 < 13)
              throw new q("code_w_scope total size shorter minimum expected length");
            const i4 = Ht.getInt32LE(t4, e3);
            if (e3 += 4, i4 <= 0 || i4 > t4.length - e3 || 0 !== t4[e3 + i4 - 1])
              throw new q("bad string length in bson");
            const o3 = ut.toUTF8(t4, e3, e3 + i4 - 1, K2), a3 = e3 += i4, s4 = Ht.getInt32LE(t4, e3), c3 = ae(t4, a3, r3, false);
            if (e3 += s4, n3 < 8 + s4 + i4)
              throw new q("code_w_scope total size is too short, truncating scope");
            if (n3 > 8 + s4 + i4)
              throw new q("code_w_scope total size is too long, clips outer document");
            z2 = new yt(o3, c3);
          } else {
            if (y4 !== x)
              throw new q(`Detected unknown BSON type ${y4.toString(16)} for fieldname "${L3}"`);
            {
              const r4 = Ht.getInt32LE(t4, e3);
              if (e3 += 4, r4 <= 0 || r4 > t4.length - e3 || 0 !== t4[e3 + r4 - 1])
                throw new q("bad string length in bson");
              if (null != l2 && l2.utf8 && !tt(t4, e3, e3 + r4 - 1))
                throw new q("Invalid UTF-8 string in BSON document");
              const n3 = ut.toUTF8(t4, e3, e3 + r4 - 1, false);
              e3 += r4;
              const i4 = ut.allocateUnsafe(12);
              for (let r5 = 0; r5 < 12; r5++)
                i4[r5] = t4[e3 + r5];
              const o3 = new Gt(i4);
              e3 += 12, z2 = new mt(n3, o3);
            }
          }
          "__proto__" === L3 ? Object.defineProperty(C2, L3, { value: z2, writable: true, enumerable: true, configurable: true }) : C2[L3] = z2;
        }
        if (L2 !== e3 - b2) {
          if (n2)
            throw new q("corrupt array bson");
          throw new q("corrupt object bson");
        }
        if (!V2)
          return C2;
        if (bt(C2)) {
          const t5 = Object.assign({}, C2);
          return delete t5.$ref, delete t5.$id, delete t5.$db, new mt(C2.$ref, C2.$id, C2.$db, t5);
        }
        return C2;
      }
      const se = /\x00/, ce = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
      function ue(t4, e3, r3, n2) {
        t4[n2++] = v, t4[(n2 = n2 + ut.encodeUTF8Into(t4, e3, n2) + 1) - 1] = 0;
        const i3 = ut.encodeUTF8Into(t4, r3, n2 + 4);
        return Ht.setInt32LE(t4, n2, i3 + 1), n2 = n2 + 4 + i3, t4[n2++] = 0, n2;
      }
      function fe(t4, e3, r3, n2) {
        const i3 = !Object.is(r3, -0) && Number.isSafeInteger(r3) && r3 <= l && r3 >= h2 ? I : m2;
        return t4[n2++] = i3, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + (i3 === I ? Ht.setInt32LE(t4, n2, r3) : Ht.setFloat64LE(t4, n2, r3));
      }
      function le(t4, e3, r3, n2) {
        return t4[n2++] = T, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + Ht.setBigInt64LE(t4, n2, r3);
      }
      function he(t4, e3, r3, n2) {
        return t4[n2++] = A, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2;
      }
      function pe(t4, e3, r3, n2) {
        return t4[n2++] = j, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, t4[n2++] = r3 ? 1 : 0, n2;
      }
      function de(t4, e3, r3, n2) {
        t4[n2++] = $, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const i3 = $t.fromNumber(r3.getTime()), o2 = i3.getLowBits(), a2 = i3.getHighBits();
        return (n2 += Ht.setInt32LE(t4, n2, o2)) + Ht.setInt32LE(t4, n2, a2);
      }
      function ye(t4, e3, r3, n2) {
        if (t4[n2++] = E, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, r3.source && null != r3.source.match(se))
          throw new q("value " + r3.source + " must not contain null bytes");
        return n2 += ut.encodeUTF8Into(t4, r3.source, n2), t4[n2++] = 0, r3.ignoreCase && (t4[n2++] = 105), r3.global && (t4[n2++] = 115), r3.multiline && (t4[n2++] = 109), t4[n2++] = 0, n2;
      }
      function be(t4, e3, r3, n2) {
        if (t4[n2++] = E, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, null != r3.pattern.match(se))
          throw new q("pattern " + r3.pattern + " must not contain null bytes");
        n2 += ut.encodeUTF8Into(t4, r3.pattern, n2), t4[n2++] = 0;
        const i3 = r3.options.split("").sort().join("");
        return n2 += ut.encodeUTF8Into(t4, i3, n2), t4[n2++] = 0, n2;
      }
      function me(t4, e3, r3, n2) {
        return null === r3 ? t4[n2++] = A : "MinKey" === r3._bsontype ? t4[n2++] = N : t4[n2++] = D, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2;
      }
      function ve(t4, e3, r3, n2) {
        return t4[n2++] = O, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + r3.serializeInto(t4, n2);
      }
      function ge(t4, e3, r3, n2) {
        t4[n2++] = w2, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const i3 = r3.length;
        if (n2 += Ht.setInt32LE(t4, n2, i3), t4[n2++] = L, i3 <= 16)
          for (let e4 = 0; e4 < i3; e4++)
            t4[n2 + e4] = r3[e4];
        else
          t4.set(r3, n2);
        return n2 + i3;
      }
      function _e(t4, e3, r3, n2, i3, o2, a2, s3, c2) {
        if (c2.has(r3))
          throw new q("Cannot convert circular structure to BSON");
        c2.add(r3), t4[n2++] = Array.isArray(r3) ? _ : g, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const u2 = ke(t4, r3, i3, n2, o2 + 1, a2, s3, c2);
        return c2.delete(r3), u2;
      }
      function we(t4, e3, r3, n2) {
        t4[n2++] = R, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        for (let e4 = 0; e4 < 16; e4++)
          t4[n2 + e4] = r3.bytes[e4];
        return n2 + 16;
      }
      function Se(t4, e3, r3, n2) {
        t4[n2++] = "Long" === r3._bsontype ? T : B, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const i3 = r3.getLowBits(), o2 = r3.getHighBits();
        return (n2 += Ht.setInt32LE(t4, n2, i3)) + Ht.setInt32LE(t4, n2, o2);
      }
      function Oe(t4, e3, r3, n2) {
        return r3 = r3.valueOf(), t4[n2++] = I, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + Ht.setInt32LE(t4, n2, r3);
      }
      function je(t4, e3, r3, n2) {
        return t4[n2++] = m2, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0, n2 + Ht.setFloat64LE(t4, n2, r3.value);
      }
      function $e(t4, e3, r3, n2) {
        t4[n2++] = P, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const i3 = r3.toString(), o2 = ut.encodeUTF8Into(t4, i3, n2 + 4) + 1;
        return Ht.setInt32LE(t4, n2, o2), n2 = n2 + 4 + o2 - 1, t4[n2++] = 0, n2;
      }
      function Ae(t4, e3, r3, n2, i3 = false, o2 = 0, a2 = false, s3 = true, c2) {
        if (r3.scope && "object" == typeof r3.scope) {
          t4[n2++] = M, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
          let u2 = n2;
          const f2 = r3.code;
          n2 += 4;
          const l2 = ut.encodeUTF8Into(t4, f2, n2 + 4) + 1;
          Ht.setInt32LE(t4, n2, l2), t4[n2 + 4 + l2 - 1] = 0, n2 = n2 + l2 + 4;
          const h3 = ke(t4, r3.scope, i3, n2, o2 + 1, a2, s3, c2);
          n2 = h3 - 1;
          const p2 = h3 - u2;
          u2 += Ht.setInt32LE(t4, u2, p2), t4[n2++] = 0;
        } else {
          t4[n2++] = P, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
          const i4 = r3.code.toString(), o3 = ut.encodeUTF8Into(t4, i4, n2 + 4) + 1;
          Ht.setInt32LE(t4, n2, o3), n2 = n2 + 4 + o3 - 1, t4[n2++] = 0;
        }
        return n2;
      }
      function Ee(t4, e3, r3, n2) {
        t4[n2++] = w2, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const i3 = r3.buffer;
        let o2 = r3.position;
        if (r3.sub_type === lt2.SUBTYPE_BYTE_ARRAY && (o2 += 4), n2 += Ht.setInt32LE(t4, n2, o2), t4[n2++] = r3.sub_type, r3.sub_type === lt2.SUBTYPE_BYTE_ARRAY && (o2 -= 4, n2 += Ht.setInt32LE(t4, n2, o2)), o2 <= 16)
          for (let e4 = 0; e4 < o2; e4++)
            t4[n2 + e4] = i3[e4];
        else
          t4.set(i3, n2);
        return n2 + r3.position;
      }
      function xe(t4, e3, r3, n2) {
        t4[n2++] = k, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        const i3 = ut.encodeUTF8Into(t4, r3.value, n2 + 4) + 1;
        return Ht.setInt32LE(t4, n2, i3), n2 = n2 + 4 + i3 - 1, t4[n2++] = 0, n2;
      }
      function Pe(t4, e3, r3, n2, i3, o2, a2) {
        t4[n2++] = g, n2 += ut.encodeUTF8Into(t4, e3, n2), t4[n2++] = 0;
        let s3 = n2, c2 = { $ref: r3.collection || r3.namespace, $id: r3.oid };
        null != r3.db && (c2.$db = r3.db), c2 = Object.assign(c2, r3.fields);
        const u2 = ke(t4, c2, false, n2, i3 + 1, o2, true, a2), f2 = u2 - s3;
        return s3 += Ht.setInt32LE(t4, n2, f2), u2;
      }
      function ke(t4, e3, r3, n2, u2, l2, h3, p2) {
        if (null == p2) {
          if (null == e3)
            return t4[0] = 5, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, 5;
          if (Array.isArray(e3))
            throw new q("serialize does not support an array as the root input");
          if ("object" != typeof e3)
            throw new q("serialize does not support non-object as the root input");
          if ("_bsontype" in e3 && "string" == typeof e3._bsontype)
            throw new q("BSON types cannot be serialized as a document");
          if (c(e3) || a(e3) || o(e3) || i2(e3))
            throw new q("date, regexp, typedarray, and arraybuffer cannot be BSON documents");
          p2 = /* @__PURE__ */ new Set();
        }
        p2.add(e3);
        let d3 = n2 + 4;
        if (Array.isArray(e3))
          for (let n3 = 0; n3 < e3.length; n3++) {
            const i3 = `${n3}`;
            let s3 = e3[n3];
            if ("function" == typeof (s3 == null ? void 0 : s3.toBSON) && (s3 = s3.toBSON()), "string" == typeof s3)
              d3 = ue(t4, i3, s3, d3);
            else if ("number" == typeof s3)
              d3 = fe(t4, i3, s3, d3);
            else if ("bigint" == typeof s3)
              d3 = le(t4, i3, s3, d3);
            else if ("boolean" == typeof s3)
              d3 = pe(t4, i3, s3, d3);
            else if (s3 instanceof Date || c(s3))
              d3 = de(t4, i3, s3, d3);
            else if (void 0 === s3)
              d3 = he(t4, i3, 0, d3);
            else if (null === s3)
              d3 = he(t4, i3, 0, d3);
            else if (o(s3))
              d3 = ge(t4, i3, s3, d3);
            else if (s3 instanceof RegExp || a(s3))
              d3 = ye(t4, i3, s3, d3);
            else if ("object" == typeof s3 && null == s3._bsontype)
              d3 = _e(t4, i3, s3, d3, r3, u2, l2, h3, p2);
            else {
              if ("object" == typeof s3 && s3[Symbol.for("@@mdb.bson.version")] !== f)
                throw new F();
              if ("ObjectId" === s3._bsontype)
                d3 = ve(t4, i3, s3, d3);
              else if ("Decimal128" === s3._bsontype)
                d3 = we(t4, i3, s3, d3);
              else if ("Long" === s3._bsontype || "Timestamp" === s3._bsontype)
                d3 = Se(t4, i3, s3, d3);
              else if ("Double" === s3._bsontype)
                d3 = je(t4, i3, s3, d3);
              else if ("function" == typeof s3 && l2)
                d3 = $e(t4, i3, s3, d3);
              else if ("Code" === s3._bsontype)
                d3 = Ae(t4, i3, s3, d3, r3, u2, l2, h3, p2);
              else if ("Binary" === s3._bsontype)
                d3 = Ee(t4, i3, s3, d3);
              else if ("BSONSymbol" === s3._bsontype)
                d3 = xe(t4, i3, s3, d3);
              else if ("DBRef" === s3._bsontype)
                d3 = Pe(t4, i3, s3, d3, u2, l2, p2);
              else if ("BSONRegExp" === s3._bsontype)
                d3 = be(t4, i3, s3, d3);
              else if ("Int32" === s3._bsontype)
                d3 = Oe(t4, i3, s3, d3);
              else if ("MinKey" === s3._bsontype || "MaxKey" === s3._bsontype)
                d3 = me(t4, i3, s3, d3);
              else if (void 0 !== s3._bsontype)
                throw new q(`Unrecognized or invalid _bsontype: ${String(s3._bsontype)}`);
            }
          }
        else if (e3 instanceof Map || s2(e3)) {
          const n3 = e3.entries();
          let i3 = false;
          for (; !i3; ) {
            const e4 = n3.next();
            if (i3 = !!e4.done, i3)
              continue;
            const s3 = e4.value[0];
            let y4 = e4.value[1];
            "function" == typeof (y4 == null ? void 0 : y4.toBSON) && (y4 = y4.toBSON());
            const b2 = typeof y4;
            if ("string" == typeof s3 && !ce.has(s3)) {
              if (null != s3.match(se))
                throw new q("key " + s3 + " must not contain null bytes");
              if (r3) {
                if ("$" === s3[0])
                  throw new q("key " + s3 + " must not start with '$'");
                if (s3.includes("."))
                  throw new q("key " + s3 + " must not contain '.'");
              }
            }
            if ("string" === b2)
              d3 = ue(t4, s3, y4, d3);
            else if ("number" === b2)
              d3 = fe(t4, s3, y4, d3);
            else if ("bigint" === b2)
              d3 = le(t4, s3, y4, d3);
            else if ("boolean" === b2)
              d3 = pe(t4, s3, y4, d3);
            else if (y4 instanceof Date || c(y4))
              d3 = de(t4, s3, y4, d3);
            else if (null === y4 || void 0 === y4 && false === h3)
              d3 = he(t4, s3, 0, d3);
            else if (o(y4))
              d3 = ge(t4, s3, y4, d3);
            else if (y4 instanceof RegExp || a(y4))
              d3 = ye(t4, s3, y4, d3);
            else if ("object" === b2 && null == y4._bsontype)
              d3 = _e(t4, s3, y4, d3, r3, u2, l2, h3, p2);
            else {
              if ("object" == typeof y4 && y4[Symbol.for("@@mdb.bson.version")] !== f)
                throw new F();
              if ("ObjectId" === y4._bsontype)
                d3 = ve(t4, s3, y4, d3);
              else if ("object" === b2 && "Decimal128" === y4._bsontype)
                d3 = we(t4, s3, y4, d3);
              else if ("Long" === y4._bsontype || "Timestamp" === y4._bsontype)
                d3 = Se(t4, s3, y4, d3);
              else if ("Double" === y4._bsontype)
                d3 = je(t4, s3, y4, d3);
              else if ("Code" === y4._bsontype)
                d3 = Ae(t4, s3, y4, d3, r3, u2, l2, h3, p2);
              else if ("function" == typeof y4 && l2)
                d3 = $e(t4, s3, y4, d3);
              else if ("Binary" === y4._bsontype)
                d3 = Ee(t4, s3, y4, d3);
              else if ("BSONSymbol" === y4._bsontype)
                d3 = xe(t4, s3, y4, d3);
              else if ("DBRef" === y4._bsontype)
                d3 = Pe(t4, s3, y4, d3, u2, l2, p2);
              else if ("BSONRegExp" === y4._bsontype)
                d3 = be(t4, s3, y4, d3);
              else if ("Int32" === y4._bsontype)
                d3 = Oe(t4, s3, y4, d3);
              else if ("MinKey" === y4._bsontype || "MaxKey" === y4._bsontype)
                d3 = me(t4, s3, y4, d3);
              else if (void 0 !== y4._bsontype)
                throw new q(`Unrecognized or invalid _bsontype: ${String(y4._bsontype)}`);
            }
          }
        } else {
          if ("function" == typeof (e3 == null ? void 0 : e3.toBSON) && null != (e3 = e3.toBSON()) && "object" != typeof e3)
            throw new q("toBSON function did not return an object");
          for (const n3 of Object.keys(e3)) {
            let i3 = e3[n3];
            "function" == typeof (i3 == null ? void 0 : i3.toBSON) && (i3 = i3.toBSON());
            const s3 = typeof i3;
            if ("string" == typeof n3 && !ce.has(n3)) {
              if (null != n3.match(se))
                throw new q("key " + n3 + " must not contain null bytes");
              if (r3) {
                if ("$" === n3[0])
                  throw new q("key " + n3 + " must not start with '$'");
                if (n3.includes("."))
                  throw new q("key " + n3 + " must not contain '.'");
              }
            }
            if ("string" === s3)
              d3 = ue(t4, n3, i3, d3);
            else if ("number" === s3)
              d3 = fe(t4, n3, i3, d3);
            else if ("bigint" === s3)
              d3 = le(t4, n3, i3, d3);
            else if ("boolean" === s3)
              d3 = pe(t4, n3, i3, d3);
            else if (i3 instanceof Date || c(i3))
              d3 = de(t4, n3, i3, d3);
            else if (void 0 === i3)
              false === h3 && (d3 = he(t4, n3, 0, d3));
            else if (null === i3)
              d3 = he(t4, n3, 0, d3);
            else if (o(i3))
              d3 = ge(t4, n3, i3, d3);
            else if (i3 instanceof RegExp || a(i3))
              d3 = ye(t4, n3, i3, d3);
            else if ("object" === s3 && null == i3._bsontype)
              d3 = _e(t4, n3, i3, d3, r3, u2, l2, h3, p2);
            else {
              if ("object" == typeof i3 && i3[Symbol.for("@@mdb.bson.version")] !== f)
                throw new F();
              if ("ObjectId" === i3._bsontype)
                d3 = ve(t4, n3, i3, d3);
              else if ("object" === s3 && "Decimal128" === i3._bsontype)
                d3 = we(t4, n3, i3, d3);
              else if ("Long" === i3._bsontype || "Timestamp" === i3._bsontype)
                d3 = Se(t4, n3, i3, d3);
              else if ("Double" === i3._bsontype)
                d3 = je(t4, n3, i3, d3);
              else if ("Code" === i3._bsontype)
                d3 = Ae(t4, n3, i3, d3, r3, u2, l2, h3, p2);
              else if ("function" == typeof i3 && l2)
                d3 = $e(t4, n3, i3, d3);
              else if ("Binary" === i3._bsontype)
                d3 = Ee(t4, n3, i3, d3);
              else if ("BSONSymbol" === i3._bsontype)
                d3 = xe(t4, n3, i3, d3);
              else if ("DBRef" === i3._bsontype)
                d3 = Pe(t4, n3, i3, d3, u2, l2, p2);
              else if ("BSONRegExp" === i3._bsontype)
                d3 = be(t4, n3, i3, d3);
              else if ("Int32" === i3._bsontype)
                d3 = Oe(t4, n3, i3, d3);
              else if ("MinKey" === i3._bsontype || "MaxKey" === i3._bsontype)
                d3 = me(t4, n3, i3, d3);
              else if (void 0 !== i3._bsontype)
                throw new q(`Unrecognized or invalid _bsontype: ${String(i3._bsontype)}`);
            }
          }
        }
        p2.delete(e3), t4[d3++] = 0;
        const y3 = d3 - n2;
        return n2 += Ht.setInt32LE(t4, n2, y3), d3;
      }
      const Me = { $oid: Gt, $binary: lt2, $uuid: lt2, $symbol: Zt, $numberInt: Ct, $numberDecimal: Lt, $numberDouble: Ut, $numberLong: $t, $minKey: Ft, $maxKey: qt, $regex: Xt, $regularExpression: Xt, $timestamp: ee };
      function Ie(t4, e3 = {}) {
        if ("number" == typeof t4) {
          const r4 = t4 <= l && t4 >= h2, n2 = t4 <= p && t4 >= d2;
          if (e3.relaxed || e3.legacy)
            return t4;
          if (Number.isInteger(t4) && !Object.is(t4, -0)) {
            if (r4)
              return new Ct(t4);
            if (n2)
              return e3.useBigInt64 ? BigInt(t4) : $t.fromNumber(t4);
          }
          return new Ut(t4);
        }
        if (null == t4 || "object" != typeof t4)
          return t4;
        if (t4.$undefined)
          return null;
        const r3 = Object.keys(t4).filter((e4) => e4.startsWith("$") && null != t4[e4]);
        for (let n2 = 0; n2 < r3.length; n2++) {
          const i3 = Me[r3[n2]];
          if (i3)
            return i3.fromExtendedJSON(t4, e3);
        }
        if (null != t4.$date) {
          const r4 = t4.$date, n2 = /* @__PURE__ */ new Date();
          if (e3.legacy)
            if ("number" == typeof r4)
              n2.setTime(r4);
            else if ("string" == typeof r4)
              n2.setTime(Date.parse(r4));
            else {
              if ("bigint" != typeof r4)
                throw new V("Unrecognized type for EJSON date: " + typeof r4);
              n2.setTime(Number(r4));
            }
          else if ("string" == typeof r4)
            n2.setTime(Date.parse(r4));
          else if ($t.isLong(r4))
            n2.setTime(r4.toNumber());
          else if ("number" == typeof r4 && e3.relaxed)
            n2.setTime(r4);
          else {
            if ("bigint" != typeof r4)
              throw new V("Unrecognized type for EJSON date: " + typeof r4);
            n2.setTime(Number(r4));
          }
          return n2;
        }
        if (null != t4.$code) {
          const e4 = Object.assign({}, t4);
          return t4.$scope && (e4.$scope = Ie(t4.$scope)), yt.fromExtendedJSON(t4);
        }
        if (bt(t4) || t4.$dbPointer) {
          const e4 = t4.$ref ? t4 : t4.$dbPointer;
          if (e4 instanceof mt)
            return e4;
          const r4 = Object.keys(e4).filter((t5) => t5.startsWith("$"));
          let n2 = true;
          if (r4.forEach((t5) => {
            -1 === ["$ref", "$id", "$db"].indexOf(t5) && (n2 = false);
          }), n2)
            return mt.fromExtendedJSON(e4);
        }
        return t4;
      }
      function Be(t4) {
        const e3 = t4.toISOString();
        return 0 !== t4.getUTCMilliseconds() ? e3 : e3.slice(0, -5) + "Z";
      }
      function Te(t4, e3) {
        if (t4 instanceof Map || s2(t4)) {
          const r3 = /* @__PURE__ */ Object.create(null);
          for (const [e4, n2] of t4) {
            if ("string" != typeof e4)
              throw new q("Can only serialize maps with string keys");
            r3[e4] = n2;
          }
          return Te(r3, e3);
        }
        if (("object" == typeof t4 || "function" == typeof t4) && null !== t4) {
          const r3 = e3.seenObjects.findIndex((e4) => e4.obj === t4);
          if (-1 !== r3) {
            const t5 = e3.seenObjects.map((t6) => t6.propertyName), n2 = t5.slice(0, r3).map((t6) => `${t6} -> `).join(""), i3 = t5[r3], o2 = " -> " + t5.slice(r3 + 1, t5.length - 1).map((t6) => `${t6} -> `).join(""), a2 = t5[t5.length - 1], s3 = " ".repeat(n2.length + i3.length / 2), c2 = "-".repeat(o2.length + (i3.length + a2.length) / 2 - 1);
            throw new q(`Converting circular structure to EJSON:
    ${n2}${i3}${o2}${a2}
    ${s3}\\${c2}/`);
          }
          e3.seenObjects[e3.seenObjects.length - 1].obj = t4;
        }
        if (Array.isArray(t4))
          return function(t5, e4) {
            return t5.map((t6, r3) => {
              e4.seenObjects.push({ propertyName: `index ${r3}`, obj: null });
              try {
                return Te(t6, e4);
              } finally {
                e4.seenObjects.pop();
              }
            });
          }(t4, e3);
        if (void 0 === t4)
          return null;
        if (t4 instanceof Date || c(t4)) {
          const r3 = t4.getTime(), n2 = r3 > -1 && r3 < 2534023188e5;
          return e3.legacy ? e3.relaxed && n2 ? { $date: t4.getTime() } : { $date: Be(t4) } : e3.relaxed && n2 ? { $date: Be(t4) } : { $date: { $numberLong: t4.getTime().toString() } };
        }
        if (!("number" != typeof t4 || e3.relaxed && isFinite(t4))) {
          if (Number.isInteger(t4) && !Object.is(t4, -0)) {
            if (t4 >= h2 && t4 <= l)
              return { $numberInt: t4.toString() };
            if (t4 >= d2 && t4 <= p)
              return { $numberLong: t4.toString() };
          }
          return { $numberDouble: Object.is(t4, -0) ? "-0.0" : t4.toString() };
        }
        if ("bigint" == typeof t4)
          return e3.relaxed ? Number(BigInt.asIntN(64, t4)) : { $numberLong: BigInt.asIntN(64, t4).toString() };
        if (t4 instanceof RegExp || a(t4)) {
          let r3 = t4.flags;
          if (void 0 === r3) {
            const e4 = t4.toString().match(/[gimuy]*$/);
            e4 && (r3 = e4[0]);
          }
          return new Xt(t4.source, r3).toExtendedJSON(e3);
        }
        return null != t4 && "object" == typeof t4 ? function(t5, e4) {
          if (null == t5 || "object" != typeof t5)
            throw new q("not an object instance");
          const r3 = t5._bsontype;
          if (void 0 === r3) {
            const r4 = {};
            for (const n2 of Object.keys(t5)) {
              e4.seenObjects.push({ propertyName: n2, obj: null });
              try {
                const i3 = Te(t5[n2], e4);
                "__proto__" === n2 ? Object.defineProperty(r4, n2, { value: i3, writable: true, enumerable: true, configurable: true }) : r4[n2] = i3;
              } finally {
                e4.seenObjects.pop();
              }
            }
            return r4;
          }
          if (null != t5 && "object" == typeof t5 && "string" == typeof t5._bsontype && t5[Symbol.for("@@mdb.bson.version")] !== f)
            throw new F();
          if (function(t6) {
            return null != t6 && "object" == typeof t6 && "_bsontype" in t6 && "string" == typeof t6._bsontype;
          }(t5)) {
            let n2 = t5;
            if ("function" != typeof n2.toExtendedJSON) {
              const e5 = Re[t5._bsontype];
              if (!e5)
                throw new q("Unrecognized or invalid _bsontype: " + t5._bsontype);
              n2 = e5(n2);
            }
            return "Code" === r3 && n2.scope ? n2 = new yt(n2.code, Te(n2.scope, e4)) : "DBRef" === r3 && n2.oid && (n2 = new mt(Te(n2.collection, e4), Te(n2.oid, e4), Te(n2.db, e4), Te(n2.fields, e4))), n2.toExtendedJSON(e4);
          }
          throw new q("_bsontype must be a string, but was: " + typeof r3);
        }(t4, e3) : t4;
      }
      const Re = { Binary: (t4) => new lt2(t4.value(), t4.sub_type), Code: (t4) => new yt(t4.code, t4.scope), DBRef: (t4) => new mt(t4.collection || t4.namespace, t4.oid, t4.db, t4.fields), Decimal128: (t4) => new Lt(t4.bytes), Double: (t4) => new Ut(t4.value), Int32: (t4) => new Ct(t4.value), Long: (t4) => $t.fromBits(null != t4.low ? t4.low : t4.low_, null != t4.low ? t4.high : t4.high_, null != t4.low ? t4.unsigned : t4.unsigned_), MaxKey: () => new qt(), MinKey: () => new Ft(), ObjectId: (t4) => new Gt(t4), BSONRegExp: (t4) => new Xt(t4.pattern, t4.options), BSONSymbol: (t4) => new Zt(t4.value), Timestamp: (t4) => ee.fromBits(t4.low, t4.high) };
      function Ne(t4, e3) {
        const r3 = { useBigInt64: (e3 == null ? void 0 : e3.useBigInt64) ?? false, relaxed: (e3 == null ? void 0 : e3.relaxed) ?? true, legacy: (e3 == null ? void 0 : e3.legacy) ?? false };
        return JSON.parse(t4, (t5, e4) => {
          if (-1 !== t5.indexOf("\0"))
            throw new q(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(t5)}`);
          return Ie(e4, r3);
        });
      }
      function De(t4, e3, r3, n2) {
        null != r3 && "object" == typeof r3 && (n2 = r3, r3 = 0), null == e3 || "object" != typeof e3 || Array.isArray(e3) || (n2 = e3, e3 = void 0, r3 = 0);
        const i3 = Te(t4, Object.assign({ relaxed: true, legacy: false }, n2, { seenObjects: [{ propertyName: "(root)", obj: null }] }));
        return JSON.stringify(i3, e3, r3);
      }
      const Le = /* @__PURE__ */ Object.create(null);
      function Ue(t4, e3) {
        try {
          return Ht.getNonnegativeInt32LE(t4, e3);
        } catch (t5) {
          throw new z("BSON size cannot be negative", e3, { cause: t5 });
        }
      }
      function Ce(t4, e3) {
        let r3 = e3;
        for (; 0 !== t4[r3]; r3++)
          ;
        if (r3 === t4.length - 1)
          throw new z("Null terminator not found", e3);
        return r3;
      }
      Le.parse = Ne, Le.stringify = De, Le.serialize = function(t4, e3) {
        return e3 = e3 || {}, JSON.parse(De(t4, e3));
      }, Le.deserialize = function(t4, e3) {
        return e3 = e3 || {}, Ne(JSON.stringify(t4), e3);
      }, Object.freeze(Le);
      const qe = /* @__PURE__ */ Object.create(null);
      qe.parseToElements = function(t4, e3 = 0) {
        if (e3 ?? (e3 = 0), t4.length < 5)
          throw new z(`Input must be at least 5 bytes, got ${t4.length} bytes`, e3);
        const r3 = Ue(t4, e3);
        if (r3 > t4.length - e3)
          throw new z(`Parsed documentSize (${r3} bytes) does not match input length (${t4.length} bytes)`, e3);
        if (0 !== t4[e3 + r3 - 1])
          throw new z("BSON documents must end in 0x00", e3 + r3);
        const n2 = [];
        let i3 = e3 + 4;
        for (; i3 <= r3 + e3; ) {
          const o2 = t4[i3];
          if (i3 += 1, 0 === o2) {
            if (i3 - e3 !== r3)
              throw new z("Invalid 0x00 type byte", i3);
            break;
          }
          const a2 = i3, s3 = Ce(t4, i3) - a2;
          let c2;
          if (i3 += s3 + 1, 1 === o2 || 18 === o2 || 9 === o2 || 17 === o2)
            c2 = 8;
          else if (16 === o2)
            c2 = 4;
          else if (7 === o2)
            c2 = 12;
          else if (19 === o2)
            c2 = 16;
          else if (8 === o2)
            c2 = 1;
          else if (10 === o2 || 6 === o2 || 127 === o2 || 255 === o2)
            c2 = 0;
          else if (11 === o2)
            c2 = Ce(t4, Ce(t4, i3) + 1) + 1 - i3;
          else if (3 === o2 || 4 === o2 || 15 === o2)
            c2 = Ue(t4, i3);
          else {
            if (2 !== o2 && 5 !== o2 && 12 !== o2 && 13 !== o2 && 14 !== o2)
              throw new z(`Invalid 0x${o2.toString(16).padStart(2, "0")} type byte`, i3);
            c2 = Ue(t4, i3) + 4, 5 === o2 && (c2 += 1), 12 === o2 && (c2 += 12);
          }
          if (c2 > r3)
            throw new z("value reports length larger than document", i3);
          n2.push([o2, a2, s3, i3, c2]), i3 += c2;
        }
        return n2;
      }, qe.ByteUtils = ut, qe.NumberUtils = Ht, Object.freeze(qe);
      const Fe = 17825792;
      let Ve = ut.allocate(Fe);
      function ze(t4) {
        Ve.length < t4 && (Ve = ut.allocate(t4));
      }
      function Ke(t4, e3 = {}) {
        const r3 = "boolean" == typeof e3.checkKeys && e3.checkKeys, n2 = "boolean" == typeof e3.serializeFunctions && e3.serializeFunctions, i3 = "boolean" != typeof e3.ignoreUndefined || e3.ignoreUndefined, o2 = "number" == typeof e3.minInternalBufferSize ? e3.minInternalBufferSize : Fe;
        Ve.length < o2 && (Ve = ut.allocate(o2));
        const a2 = ke(Ve, t4, r3, 0, 0, n2, i3, null), s3 = ut.allocateUnsafe(a2);
        return s3.set(Ve.subarray(0, a2), 0), s3;
      }
      function He(t4, e3, r3 = {}) {
        const n2 = "boolean" == typeof r3.checkKeys && r3.checkKeys, i3 = "boolean" == typeof r3.serializeFunctions && r3.serializeFunctions, o2 = "boolean" != typeof r3.ignoreUndefined || r3.ignoreUndefined, a2 = "number" == typeof r3.index ? r3.index : 0, s3 = ke(Ve, t4, n2, 0, 0, i3, o2, null);
        return e3.set(Ve.subarray(0, s3), a2), a2 + s3 - 1;
      }
      function We(t4, e3 = {}) {
        return ie(ut.toLocalBufferType(t4), e3);
      }
      function Je(t4, e3 = {}) {
        return Yt(t4, "boolean" == typeof (e3 = e3 || {}).serializeFunctions && e3.serializeFunctions, "boolean" != typeof e3.ignoreUndefined || e3.ignoreUndefined);
      }
      function Ge(t4, e3, r3, n2, i3, o2) {
        const a2 = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, o2), s3 = ut.toLocalBufferType(t4);
        let c2 = e3;
        for (let t5 = 0; t5 < r3; t5++) {
          const e4 = Ht.getInt32LE(s3, c2);
          a2.index = c2, n2[i3 + t5] = ie(s3, a2), c2 += e4;
        }
        return c2;
      }
      var Ye = Object.freeze({ __proto__: null, BSONError: q, BSONOffsetError: z, BSONRegExp: Xt, BSONRuntimeError: V, BSONSymbol: Zt, BSONType: C, BSONValue: ft, BSONVersionError: F, Binary: lt2, Code: yt, DBRef: mt, Decimal128: Lt, Double: Ut, EJSON: Le, Int32: Ct, Long: $t, MaxKey: qt, MinKey: Ft, ObjectId: Gt, Timestamp: ee, UUID: dt, calculateObjectSize: Je, deserialize: We, deserializeStream: Ge, onDemand: qe, serialize: Ke, serializeWithBufferAndIndex: He, setInternalBufferSize: ze });
      e2.BSON = Ye, e2.BSONError = q, e2.BSONOffsetError = z, e2.BSONRegExp = Xt, e2.BSONRuntimeError = V, e2.BSONSymbol = Zt, e2.BSONType = C, e2.BSONValue = ft, e2.BSONVersionError = F, e2.Binary = lt2, e2.Code = yt, e2.DBRef = mt, e2.Decimal128 = Lt, e2.Double = Ut, e2.EJSON = Le, e2.Int32 = Ct, e2.Long = $t, e2.MaxKey = qt, e2.MinKey = Ft, e2.ObjectId = Gt, e2.Timestamp = ee, e2.UUID = dt, e2.calculateObjectSize = Je, e2.deserialize = We, e2.deserializeStream = Ge, e2.onDemand = qe, e2.serialize = Ke, e2.serializeWithBufferAndIndex = He, e2.setInternalBufferSize = ze;
    }, 3219: (t3) => {
      t3.exports = JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}');
    }, 2951: (t3) => {
      t3.exports = JSON.parse('{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}');
    }, 4589: (t3) => {
      t3.exports = JSON.parse('{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}');
    }, 3241: (t3) => {
      t3.exports = JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}');
    }, 1636: (t3) => {
      t3.exports = { rE: "6.5.5" };
    }, 5579: (t3) => {
      t3.exports = JSON.parse('{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}');
    } }, e = {};
    function r(n) {
      var i2 = e[n];
      if (void 0 !== i2)
        return i2.exports;
      var o = e[n] = { id: n, loaded: false, exports: {} };
      return t2[n].call(o.exports, o, o.exports, r), o.loaded = true, o.exports;
    }
    return r.g = function() {
      if ("object" == typeof globalThis)
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t3) {
        if ("object" == typeof window)
          return window;
      }
    }(), r.nmd = (t3) => (t3.paths = [], t3.children || (t3.children = []), t3), r(4986);
  })());
})(browser_umd);
var browser_umdExports = browser_umd.exports;
const mongoose = /* @__PURE__ */ getDefaultExportFromCjs(browser_umdExports);
var contentPattern = "&&<>&&";
function contentFor(contentName) {
  return contentPattern + contentName + contentPattern;
}
function parseContents(locals) {
  var name2, i2 = 1, str = locals.body, regex = new RegExp("\r?\n?" + contentPattern + ".+?" + contentPattern + "\r?\n?", "g"), split2 = str.split(regex), matches = str.match(regex);
  locals.body = split2[0];
  if (matches !== null) {
    matches.forEach(function(match2) {
      name2 = match2.split(contentPattern)[1];
      locals[name2] = split2[i2];
      i2++;
    });
  }
}
function parseScripts(locals) {
  var str = locals.body, regex = /\<script[\s\S]*?\>[\s\S]*?\<\/script\>/g;
  if (regex.test(str)) {
    locals.body = str.replace(regex, "");
    locals.script = str.match(regex).join("\n");
  }
}
function parseStyles(locals) {
  var str = locals.body, regex = /(?:\<style[\s\S]*?\>[\s\S]*?\<\/style\>)|(?:\<link[\s\S]*?\>(?:\<\/link\>)?)/g;
  if (regex.test(str)) {
    locals.body = str.replace(regex, "");
    locals.style = str.match(regex).join("\n");
  }
}
function parseMetas(locals) {
  var str = locals.body, regex = /\<meta[\s\S]*?\>/g;
  if (regex.test(str)) {
    locals.body = str.replace(regex, "");
    locals.meta = str.match(regex).join("\n");
  }
}
var expressLayouts = function(req2, res2, next) {
  if (!res2.__render)
    res2.__render = res2.render;
  res2.render = function(view2, options2, fn) {
    var layout, self2 = this, app2 = req2.app, defaultLayout = app2.get("layout");
    options2 = options2 || {};
    if (typeof options2 === "function") {
      fn = options2;
      options2 = {};
    }
    if (options2.layout === false || (options2.layout || defaultLayout) === false) {
      res2.__render.call(res2, view2, options2, fn);
      return;
    }
    layout = options2.layout || res2.locals.layout || defaultLayout;
    if (layout === true || layout === void 0) {
      layout = "layout";
    }
    options2.contentFor = contentFor;
    res2.__render.call(res2, view2, options2, function(err, str) {
      var l, locals;
      if (err) {
        return fn ? fn(err) : next(err);
      }
      locals = {
        body: str,
        defineContent: function(contentName) {
          return locals[contentName] || "";
        }
      };
      for (l in options2) {
        if (options2.hasOwnProperty(l) && l !== "layout" && l !== "contentFor") {
          locals[l] = options2[l];
        }
      }
      if (typeof locals.body !== "string") {
        res2.__render.call(self2, view2, locals, fn);
        return;
      }
      if (options2.extractScripts === true || options2.extractScripts === void 0 && app2.get("layout extractScripts") === true) {
        locals.script = "";
        parseScripts(locals);
      }
      if (options2.extractStyles === true || options2.extractStyles === void 0 && app2.get("layout extractStyles") === true) {
        locals.style = "";
        parseStyles(locals);
      }
      if (options2.extractMetas === true || options2.extractMetas === void 0 && app2.get("layout extractMetas") === true) {
        locals.meta = "";
        parseMetas(locals);
      }
      parseContents(locals);
      res2.__render.call(self2, layout, locals, fn);
    });
  };
  next();
};
const expressLayouts$1 = /* @__PURE__ */ getDefaultExportFromCjs(expressLayouts);
var cookieParser$2 = { exports: {} };
var cookie$1 = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie$1.parse = parse$7;
cookie$1.serialize = serialize;
var decode$2 = decodeURIComponent;
var encode2 = encodeURIComponent;
var pairSplitRegExp = /; */;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$7(str, options2) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options2 || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode$2;
  for (var i2 = 0; i2 < pairs.length; i2++) {
    var pair = pairs[i2];
    var eq_idx = pair.indexOf("=");
    if (eq_idx < 0) {
      continue;
    }
    var key = pair.substr(0, eq_idx).trim();
    var val = pair.substr(++eq_idx, pair.length).trim();
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }
    if (void 0 == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }
  return obj;
}
function serialize(name2, val, options2) {
  var opt = options2 || {};
  var enc = opt.encode || encode2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e) {
    return str;
  }
}
/*!
 * cookie-parser
 * Copyright(c) 2014 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var cookie = cookie$1;
var signature = cookieSignature;
cookieParser$2.exports = cookieParser;
cookieParser$2.exports.JSONCookie = JSONCookie;
cookieParser$2.exports.JSONCookies = JSONCookies;
cookieParser$2.exports.signedCookie = signedCookie;
cookieParser$2.exports.signedCookies = signedCookies;
function cookieParser(secret, options2) {
  var secrets = !secret || Array.isArray(secret) ? secret || [] : [secret];
  return function cookieParser2(req2, res2, next) {
    if (req2.cookies) {
      return next();
    }
    var cookies = req2.headers.cookie;
    req2.secret = secrets[0];
    req2.cookies = /* @__PURE__ */ Object.create(null);
    req2.signedCookies = /* @__PURE__ */ Object.create(null);
    if (!cookies) {
      return next();
    }
    req2.cookies = cookie.parse(cookies, options2);
    if (secrets.length !== 0) {
      req2.signedCookies = signedCookies(req2.cookies, secrets);
      req2.signedCookies = JSONCookies(req2.signedCookies);
    }
    req2.cookies = JSONCookies(req2.cookies);
    next();
  };
}
function JSONCookie(str) {
  if (typeof str !== "string" || str.substr(0, 2) !== "j:") {
    return void 0;
  }
  try {
    return JSON.parse(str.slice(2));
  } catch (err) {
    return void 0;
  }
}
function JSONCookies(obj) {
  var cookies = Object.keys(obj);
  var key;
  var val;
  for (var i2 = 0; i2 < cookies.length; i2++) {
    key = cookies[i2];
    val = JSONCookie(obj[key]);
    if (val) {
      obj[key] = val;
    }
  }
  return obj;
}
function signedCookie(str, secret) {
  if (typeof str !== "string") {
    return void 0;
  }
  if (str.substr(0, 2) !== "s:") {
    return str;
  }
  var secrets = !secret || Array.isArray(secret) ? secret || [] : [secret];
  for (var i2 = 0; i2 < secrets.length; i2++) {
    var val = signature.unsign(str.slice(2), secrets[i2]);
    if (val !== false) {
      return val;
    }
  }
  return false;
}
function signedCookies(obj, secret) {
  var cookies = Object.keys(obj);
  var dec;
  var key;
  var ret = /* @__PURE__ */ Object.create(null);
  var val;
  for (var i2 = 0; i2 < cookies.length; i2++) {
    key = cookies[i2];
    val = obj[key];
    dec = signedCookie(val, secret);
    if (val !== dec) {
      ret[key] = dec;
      delete obj[key];
    }
  }
  return ret;
}
var cookieParserExports = cookieParser$2.exports;
const cookieParser$1 = /* @__PURE__ */ getDefaultExportFromCjs(cookieParserExports);
var multer$2 = { exports: {} };
function parseContentType$2(str) {
  if (str.length === 0)
    return;
  const params = /* @__PURE__ */ Object.create(null);
  let i2 = 0;
  for (; i2 < str.length; ++i2) {
    const code = str.charCodeAt(i2);
    if (TOKEN$1[code] !== 1) {
      if (code !== 47 || i2 === 0)
        return;
      break;
    }
  }
  if (i2 === str.length)
    return;
  const type3 = str.slice(0, i2).toLowerCase();
  const subtypeStart = ++i2;
  for (; i2 < str.length; ++i2) {
    const code = str.charCodeAt(i2);
    if (TOKEN$1[code] !== 1) {
      if (i2 === subtypeStart)
        return;
      if (parseContentTypeParams(str, i2, params) === void 0)
        return;
      break;
    }
  }
  if (i2 === subtypeStart)
    return;
  const subtype = str.slice(subtypeStart, i2).toLowerCase();
  return { type: type3, subtype, params };
}
function parseContentTypeParams(str, i2, params) {
  while (i2 < str.length) {
    for (; i2 < str.length; ++i2) {
      const code = str.charCodeAt(i2);
      if (code !== 32 && code !== 9)
        break;
    }
    if (i2 === str.length)
      break;
    if (str.charCodeAt(i2++) !== 59)
      return;
    for (; i2 < str.length; ++i2) {
      const code = str.charCodeAt(i2);
      if (code !== 32 && code !== 9)
        break;
    }
    if (i2 === str.length)
      return;
    let name2;
    const nameStart = i2;
    for (; i2 < str.length; ++i2) {
      const code = str.charCodeAt(i2);
      if (TOKEN$1[code] !== 1) {
        if (code !== 61)
          return;
        break;
      }
    }
    if (i2 === str.length)
      return;
    name2 = str.slice(nameStart, i2);
    ++i2;
    if (i2 === str.length)
      return;
    let value = "";
    let valueStart;
    if (str.charCodeAt(i2) === 34) {
      valueStart = ++i2;
      let escaping = false;
      for (; i2 < str.length; ++i2) {
        const code = str.charCodeAt(i2);
        if (code === 92) {
          if (escaping) {
            valueStart = i2;
            escaping = false;
          } else {
            value += str.slice(valueStart, i2);
            escaping = true;
          }
          continue;
        }
        if (code === 34) {
          if (escaping) {
            valueStart = i2;
            escaping = false;
            continue;
          }
          value += str.slice(valueStart, i2);
          break;
        }
        if (escaping) {
          valueStart = i2 - 1;
          escaping = false;
        }
        if (QDTEXT[code] !== 1)
          return;
      }
      if (i2 === str.length)
        return;
      ++i2;
    } else {
      valueStart = i2;
      for (; i2 < str.length; ++i2) {
        const code = str.charCodeAt(i2);
        if (TOKEN$1[code] !== 1) {
          if (i2 === valueStart)
            return;
          break;
        }
      }
      value = str.slice(valueStart, i2);
    }
    name2 = name2.toLowerCase();
    if (params[name2] === void 0)
      params[name2] = value;
  }
  return params;
}
function parseDisposition$1(str, defDecoder) {
  if (str.length === 0)
    return;
  const params = /* @__PURE__ */ Object.create(null);
  let i2 = 0;
  for (; i2 < str.length; ++i2) {
    const code = str.charCodeAt(i2);
    if (TOKEN$1[code] !== 1) {
      if (parseDispositionParams(str, i2, params, defDecoder) === void 0)
        return;
      break;
    }
  }
  const type3 = str.slice(0, i2).toLowerCase();
  return { type: type3, params };
}
function parseDispositionParams(str, i2, params, defDecoder) {
  while (i2 < str.length) {
    for (; i2 < str.length; ++i2) {
      const code = str.charCodeAt(i2);
      if (code !== 32 && code !== 9)
        break;
    }
    if (i2 === str.length)
      break;
    if (str.charCodeAt(i2++) !== 59)
      return;
    for (; i2 < str.length; ++i2) {
      const code = str.charCodeAt(i2);
      if (code !== 32 && code !== 9)
        break;
    }
    if (i2 === str.length)
      return;
    let name2;
    const nameStart = i2;
    for (; i2 < str.length; ++i2) {
      const code = str.charCodeAt(i2);
      if (TOKEN$1[code] !== 1) {
        if (code === 61)
          break;
        return;
      }
    }
    if (i2 === str.length)
      return;
    let value = "";
    let valueStart;
    let charset3;
    name2 = str.slice(nameStart, i2);
    if (name2.charCodeAt(name2.length - 1) === 42) {
      const charsetStart = ++i2;
      for (; i2 < str.length; ++i2) {
        const code = str.charCodeAt(i2);
        if (CHARSET[code] !== 1) {
          if (code !== 39)
            return;
          break;
        }
      }
      if (i2 === str.length)
        return;
      charset3 = str.slice(charsetStart, i2);
      ++i2;
      for (; i2 < str.length; ++i2) {
        const code = str.charCodeAt(i2);
        if (code === 39)
          break;
      }
      if (i2 === str.length)
        return;
      ++i2;
      if (i2 === str.length)
        return;
      valueStart = i2;
      let encode3 = 0;
      for (; i2 < str.length; ++i2) {
        const code = str.charCodeAt(i2);
        if (EXTENDED_VALUE[code] !== 1) {
          if (code === 37) {
            let hexUpper;
            let hexLower;
            if (i2 + 2 < str.length && (hexUpper = HEX_VALUES$1[str.charCodeAt(i2 + 1)]) !== -1 && (hexLower = HEX_VALUES$1[str.charCodeAt(i2 + 2)]) !== -1) {
              const byteVal = (hexUpper << 4) + hexLower;
              value += str.slice(valueStart, i2);
              value += String.fromCharCode(byteVal);
              i2 += 2;
              valueStart = i2 + 1;
              if (byteVal >= 128)
                encode3 = 2;
              else if (encode3 === 0)
                encode3 = 1;
              continue;
            }
            return;
          }
          break;
        }
      }
      value += str.slice(valueStart, i2);
      value = convertToUTF8$1(value, charset3, encode3);
      if (value === void 0)
        return;
    } else {
      ++i2;
      if (i2 === str.length)
        return;
      if (str.charCodeAt(i2) === 34) {
        valueStart = ++i2;
        let escaping = false;
        for (; i2 < str.length; ++i2) {
          const code = str.charCodeAt(i2);
          if (code === 92) {
            if (escaping) {
              valueStart = i2;
              escaping = false;
            } else {
              value += str.slice(valueStart, i2);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i2;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i2);
            break;
          }
          if (escaping) {
            valueStart = i2 - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i2 === str.length)
          return;
        ++i2;
      } else {
        valueStart = i2;
        for (; i2 < str.length; ++i2) {
          const code = str.charCodeAt(i2);
          if (TOKEN$1[code] !== 1) {
            if (i2 === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i2);
      }
      value = defDecoder(value, 2);
      if (value === void 0)
        return;
    }
    name2 = name2.toLowerCase();
    if (params[name2] === void 0)
      params[name2] = value;
  }
  return params;
}
function getDecoder$2(charset3) {
  let lc;
  while (true) {
    switch (charset3) {
      case "utf-8":
      case "utf8":
        return decoders.utf8;
      case "latin1":
      case "ascii":
      case "us-ascii":
      case "iso-8859-1":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "windows-1252":
      case "iso_8859-1:1987":
      case "cp1252":
      case "x-cp1252":
        return decoders.latin1;
      case "utf16le":
      case "utf-16le":
      case "ucs2":
      case "ucs-2":
        return decoders.utf16le;
      case "base64":
        return decoders.base64;
      default:
        if (lc === void 0) {
          lc = true;
          charset3 = charset3.toLowerCase();
          continue;
        }
        return decoders.other.bind(charset3);
    }
  }
}
const decoders = {
  utf8: (data, hint) => {
    if (data.length === 0)
      return "";
    if (typeof data === "string") {
      if (hint < 2)
        return data;
      data = Buffer.from(data, "latin1");
    }
    return data.utf8Slice(0, data.length);
  },
  latin1: (data, hint) => {
    if (data.length === 0)
      return "";
    if (typeof data === "string")
      return data;
    return data.latin1Slice(0, data.length);
  },
  utf16le: (data, hint) => {
    if (data.length === 0)
      return "";
    if (typeof data === "string")
      data = Buffer.from(data, "latin1");
    return data.ucs2Slice(0, data.length);
  },
  base64: (data, hint) => {
    if (data.length === 0)
      return "";
    if (typeof data === "string")
      data = Buffer.from(data, "latin1");
    return data.base64Slice(0, data.length);
  },
  other: (data, hint) => {
    if (data.length === 0)
      return "";
    if (typeof data === "string")
      data = Buffer.from(data, "latin1");
    try {
      const decoder = new TextDecoder(void 0);
      return decoder.decode(data);
    } catch {
    }
  }
};
function convertToUTF8$1(data, charset3, hint) {
  const decode2 = getDecoder$2(charset3);
  if (decode2)
    return decode2(data, hint);
}
function basename$1(path3) {
  if (typeof path3 !== "string")
    return "";
  for (let i2 = path3.length - 1; i2 >= 0; --i2) {
    switch (path3.charCodeAt(i2)) {
      case 47:
      case 92:
        path3 = path3.slice(i2 + 1);
        return path3 === ".." || path3 === "." ? "" : path3;
    }
  }
  return path3 === ".." || path3 === "." ? "" : path3;
}
const TOKEN$1 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const QDTEXT = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1
];
const CHARSET = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const EXTENDED_VALUE = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const HEX_VALUES$1 = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
];
var utils = {
  basename: basename$1,
  convertToUTF8: convertToUTF8$1,
  getDecoder: getDecoder$2,
  parseContentType: parseContentType$2,
  parseDisposition: parseDisposition$1
};
function memcmp(buf1, pos1, buf2, pos2, num) {
  for (let i2 = 0; i2 < num; ++i2) {
    if (buf1[pos1 + i2] !== buf2[pos2 + i2])
      return false;
  }
  return true;
}
class SBMH {
  constructor(needle, cb) {
    if (typeof cb !== "function")
      throw new Error("Missing match callback");
    if (typeof needle === "string")
      needle = Buffer.from(needle);
    else if (!Buffer.isBuffer(needle))
      throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
    const needleLen = needle.length;
    this.maxMatches = Infinity;
    this.matches = 0;
    this._cb = cb;
    this._lookbehindSize = 0;
    this._needle = needle;
    this._bufPos = 0;
    this._lookbehind = Buffer.allocUnsafe(needleLen);
    this._occ = [
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen
    ];
    if (needleLen > 1) {
      for (let i2 = 0; i2 < needleLen - 1; ++i2)
        this._occ[needle[i2]] = needleLen - 1 - i2;
    }
  }
  reset() {
    this.matches = 0;
    this._lookbehindSize = 0;
    this._bufPos = 0;
  }
  push(chunk, pos) {
    let result;
    if (!Buffer.isBuffer(chunk))
      chunk = Buffer.from(chunk, "latin1");
    const chunkLen = chunk.length;
    this._bufPos = pos || 0;
    while (result !== chunkLen && this.matches < this.maxMatches)
      result = feed(this, chunk);
    return result;
  }
  destroy() {
    const lbSize = this._lookbehindSize;
    if (lbSize)
      this._cb(false, this._lookbehind, 0, lbSize, false);
    this.reset();
  }
}
function feed(self2, data) {
  const len = data.length;
  const needle = self2._needle;
  const needleLen = needle.length;
  let pos = -self2._lookbehindSize;
  const lastNeedleCharPos = needleLen - 1;
  const lastNeedleChar = needle[lastNeedleCharPos];
  const end2 = len - needleLen;
  const occ = self2._occ;
  const lookbehind = self2._lookbehind;
  if (pos < 0) {
    while (pos < 0 && pos <= end2) {
      const nextPos = pos + lastNeedleCharPos;
      const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
      if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
        self2._lookbehindSize = 0;
        ++self2.matches;
        if (pos > -self2._lookbehindSize)
          self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
        else
          self2._cb(true, void 0, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
      ++pos;
    if (pos < 0) {
      const bytesToCutOff = self2._lookbehindSize + pos;
      if (bytesToCutOff > 0) {
        self2._cb(false, lookbehind, 0, bytesToCutOff, false);
      }
      self2._lookbehindSize -= bytesToCutOff;
      lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
      lookbehind.set(data, self2._lookbehindSize);
      self2._lookbehindSize += len;
      self2._bufPos = len;
      return len;
    }
    self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
    self2._lookbehindSize = 0;
  }
  pos += self2._bufPos;
  const firstNeedleChar = needle[0];
  while (pos <= end2) {
    const ch = data[pos + lastNeedleCharPos];
    if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
      ++self2.matches;
      if (pos > 0)
        self2._cb(true, data, self2._bufPos, pos, true);
      else
        self2._cb(true, void 0, 0, 0, true);
      return self2._bufPos = pos + needleLen;
    }
    pos += occ[ch];
  }
  while (pos < len) {
    if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
      ++pos;
      continue;
    }
    data.copy(lookbehind, 0, pos, len);
    self2._lookbehindSize = len - pos;
    break;
  }
  if (pos > 0)
    self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
  self2._bufPos = len;
  return len;
}
function matchNeedle(self2, data, pos, len) {
  const lb = self2._lookbehind;
  const lbSize = self2._lookbehindSize;
  const needle = self2._needle;
  for (let i2 = 0; i2 < len; ++i2, ++pos) {
    const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
    if (ch !== needle[i2])
      return false;
  }
  return true;
}
var sbmh = SBMH;
const { Readable, Writable: Writable$2 } = require$$2$2;
const StreamSearch = sbmh;
const {
  basename,
  convertToUTF8,
  getDecoder: getDecoder$1,
  parseContentType: parseContentType$1,
  parseDisposition
} = utils;
const BUF_CRLF = Buffer.from("\r\n");
const BUF_CR = Buffer.from("\r");
const BUF_DASH = Buffer.from("-");
function noop$2() {
}
const MAX_HEADER_PAIRS = 2e3;
const MAX_HEADER_SIZE = 16 * 1024;
const HPARSER_NAME = 0;
const HPARSER_PRE_OWS = 1;
const HPARSER_VALUE = 2;
class HeaderParser {
  constructor(cb) {
    this.header = /* @__PURE__ */ Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = "";
    this.value = "";
    this.crlf = 0;
    this.cb = cb;
  }
  reset() {
    this.header = /* @__PURE__ */ Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = "";
    this.value = "";
    this.crlf = 0;
  }
  push(chunk, pos, end2) {
    let start = pos;
    while (pos < end2) {
      switch (this.state) {
        case HPARSER_NAME: {
          let done2 = false;
          for (; pos < end2; ++pos) {
            if (this.byteCount === MAX_HEADER_SIZE)
              return -1;
            ++this.byteCount;
            const code = chunk[pos];
            if (TOKEN[code] !== 1) {
              if (code !== 58)
                return -1;
              this.name += chunk.latin1Slice(start, pos);
              if (this.name.length === 0)
                return -1;
              ++pos;
              done2 = true;
              this.state = HPARSER_PRE_OWS;
              break;
            }
          }
          if (!done2) {
            this.name += chunk.latin1Slice(start, pos);
            break;
          }
        }
        case HPARSER_PRE_OWS: {
          let done2 = false;
          for (; pos < end2; ++pos) {
            if (this.byteCount === MAX_HEADER_SIZE)
              return -1;
            ++this.byteCount;
            const code = chunk[pos];
            if (code !== 32 && code !== 9) {
              start = pos;
              done2 = true;
              this.state = HPARSER_VALUE;
              break;
            }
          }
          if (!done2)
            break;
        }
        case HPARSER_VALUE:
          switch (this.crlf) {
            case 0:
              for (; pos < end2; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (FIELD_VCHAR[code] !== 1) {
                  if (code !== 13)
                    return -1;
                  ++this.crlf;
                  break;
                }
              }
              this.value += chunk.latin1Slice(start, pos++);
              break;
            case 1:
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              if (chunk[pos++] !== 10)
                return -1;
              ++this.crlf;
              break;
            case 2: {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code === 32 || code === 9) {
                start = pos;
                this.crlf = 0;
              } else {
                if (++this.pairCount < MAX_HEADER_PAIRS) {
                  this.name = this.name.toLowerCase();
                  if (this.header[this.name] === void 0)
                    this.header[this.name] = [this.value];
                  else
                    this.header[this.name].push(this.value);
                }
                if (code === 13) {
                  ++this.crlf;
                  ++pos;
                } else {
                  start = pos;
                  this.crlf = 0;
                  this.state = HPARSER_NAME;
                  this.name = "";
                  this.value = "";
                }
              }
              break;
            }
            case 3: {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              if (chunk[pos++] !== 10)
                return -1;
              const header3 = this.header;
              this.reset();
              this.cb(header3);
              return pos;
            }
          }
          break;
      }
    }
    return pos;
  }
}
class FileStream extends Readable {
  constructor(opts, owner) {
    super(opts);
    this.truncated = false;
    this._readcb = null;
    this.once("end", () => {
      this._read();
      if (--owner._fileEndsLeft === 0 && owner._finalcb) {
        const cb = owner._finalcb;
        owner._finalcb = null;
        process.nextTick(cb);
      }
    });
  }
  _read(n) {
    const cb = this._readcb;
    if (cb) {
      this._readcb = null;
      cb();
    }
  }
}
const ignoreData = {
  push: (chunk, pos) => {
  },
  destroy: () => {
  }
};
function callAndUnsetCb(self2, err) {
  const cb = self2._writecb;
  self2._writecb = null;
  if (err)
    self2.destroy(err);
  else if (cb)
    cb();
}
function nullDecoder(val, hint) {
  return val;
}
class Multipart extends Writable$2 {
  constructor(cfg) {
    const streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
    };
    super(streamOpts);
    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
      throw new Error("Multipart: Boundary not found");
    const boundary = cfg.conType.params.boundary;
    const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder$1(cfg.defParamCharset) : nullDecoder;
    const defCharset = cfg.defCharset || "utf8";
    const preservePath = cfg.preservePath;
    const fileOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
    };
    const limits = cfg.limits;
    const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
    const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
    const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
    const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
    const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
    let parts = -1;
    let fields = 0;
    let files2 = 0;
    let skipPart = false;
    this._fileEndsLeft = 0;
    this._fileStream = void 0;
    this._complete = false;
    let fileSize = 0;
    let field;
    let fieldSize = 0;
    let partCharset;
    let partEncoding;
    let partType;
    let partName;
    let partTruncated = false;
    let hitFilesLimit = false;
    let hitFieldsLimit = false;
    this._hparser = null;
    const hparser = new HeaderParser((header3) => {
      this._hparser = null;
      skipPart = false;
      partType = "text/plain";
      partCharset = defCharset;
      partEncoding = "7bit";
      partName = void 0;
      partTruncated = false;
      let filename;
      if (!header3["content-disposition"]) {
        skipPart = true;
        return;
      }
      const disp = parseDisposition(
        header3["content-disposition"][0],
        paramDecoder
      );
      if (!disp || disp.type !== "form-data") {
        skipPart = true;
        return;
      }
      if (disp.params) {
        if (disp.params.name)
          partName = disp.params.name;
        if (disp.params["filename*"])
          filename = disp.params["filename*"];
        else if (disp.params.filename)
          filename = disp.params.filename;
        if (filename !== void 0 && !preservePath)
          filename = basename(filename);
      }
      if (header3["content-type"]) {
        const conType = parseContentType$1(header3["content-type"][0]);
        if (conType) {
          partType = `${conType.type}/${conType.subtype}`;
          if (conType.params && typeof conType.params.charset === "string")
            partCharset = conType.params.charset.toLowerCase();
        }
      }
      if (header3["content-transfer-encoding"])
        partEncoding = header3["content-transfer-encoding"][0].toLowerCase();
      if (partType === "application/octet-stream" || filename !== void 0) {
        if (files2 === filesLimit) {
          if (!hitFilesLimit) {
            hitFilesLimit = true;
            this.emit("filesLimit");
          }
          skipPart = true;
          return;
        }
        ++files2;
        if (this.listenerCount("file") === 0) {
          skipPart = true;
          return;
        }
        fileSize = 0;
        this._fileStream = new FileStream(fileOpts, this);
        ++this._fileEndsLeft;
        this.emit(
          "file",
          partName,
          this._fileStream,
          {
            filename,
            encoding: partEncoding,
            mimeType: partType
          }
        );
      } else {
        if (fields === fieldsLimit) {
          if (!hitFieldsLimit) {
            hitFieldsLimit = true;
            this.emit("fieldsLimit");
          }
          skipPart = true;
          return;
        }
        ++fields;
        if (this.listenerCount("field") === 0) {
          skipPart = true;
          return;
        }
        field = [];
        fieldSize = 0;
      }
    });
    let matchPostBoundary = 0;
    const ssCb = (isMatch, data, start, end2, isDataSafe) => {
      retrydata:
        while (data) {
          if (this._hparser !== null) {
            const ret = this._hparser.push(data, start, end2);
            if (ret === -1) {
              this._hparser = null;
              hparser.reset();
              this.emit("error", new Error("Malformed part header"));
              break;
            }
            start = ret;
          }
          if (start === end2)
            break;
          if (matchPostBoundary !== 0) {
            if (matchPostBoundary === 1) {
              switch (data[start]) {
                case 45:
                  matchPostBoundary = 2;
                  ++start;
                  break;
                case 13:
                  matchPostBoundary = 3;
                  ++start;
                  break;
                default:
                  matchPostBoundary = 0;
              }
              if (start === end2)
                return;
            }
            if (matchPostBoundary === 2) {
              matchPostBoundary = 0;
              if (data[start] === 45) {
                this._complete = true;
                this._bparser = ignoreData;
                return;
              }
              const writecb = this._writecb;
              this._writecb = noop$2;
              ssCb(false, BUF_DASH, 0, 1, false);
              this._writecb = writecb;
            } else if (matchPostBoundary === 3) {
              matchPostBoundary = 0;
              if (data[start] === 10) {
                ++start;
                if (parts >= partsLimit)
                  break;
                this._hparser = hparser;
                if (start === end2)
                  break;
                continue retrydata;
              } else {
                const writecb = this._writecb;
                this._writecb = noop$2;
                ssCb(false, BUF_CR, 0, 1, false);
                this._writecb = writecb;
              }
            }
          }
          if (!skipPart) {
            if (this._fileStream) {
              let chunk;
              const actualLen = Math.min(end2 - start, fileSizeLimit - fileSize);
              if (!isDataSafe) {
                chunk = Buffer.allocUnsafe(actualLen);
                data.copy(chunk, 0, start, start + actualLen);
              } else {
                chunk = data.slice(start, start + actualLen);
              }
              fileSize += chunk.length;
              if (fileSize === fileSizeLimit) {
                if (chunk.length > 0)
                  this._fileStream.push(chunk);
                this._fileStream.emit("limit");
                this._fileStream.truncated = true;
                skipPart = true;
              } else if (!this._fileStream.push(chunk)) {
                if (this._writecb)
                  this._fileStream._readcb = this._writecb;
                this._writecb = null;
              }
            } else if (field !== void 0) {
              let chunk;
              const actualLen = Math.min(
                end2 - start,
                fieldSizeLimit - fieldSize
              );
              if (!isDataSafe) {
                chunk = Buffer.allocUnsafe(actualLen);
                data.copy(chunk, 0, start, start + actualLen);
              } else {
                chunk = data.slice(start, start + actualLen);
              }
              fieldSize += actualLen;
              field.push(chunk);
              if (fieldSize === fieldSizeLimit) {
                skipPart = true;
                partTruncated = true;
              }
            }
          }
          break;
        }
      if (isMatch) {
        matchPostBoundary = 1;
        if (this._fileStream) {
          this._fileStream.push(null);
          this._fileStream = null;
        } else if (field !== void 0) {
          let data2;
          switch (field.length) {
            case 0:
              data2 = "";
              break;
            case 1:
              data2 = convertToUTF8(field[0], partCharset, 0);
              break;
            default:
              data2 = convertToUTF8(
                Buffer.concat(field, fieldSize),
                partCharset,
                0
              );
          }
          field = void 0;
          fieldSize = 0;
          this.emit(
            "field",
            partName,
            data2,
            {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            }
          );
        }
        if (++parts === partsLimit)
          this.emit("partsLimit");
      }
    };
    this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
    this._writecb = null;
    this._finalcb = null;
    this.write(BUF_CRLF);
  }
  static detect(conType) {
    return conType.type === "multipart" && conType.subtype === "form-data";
  }
  _write(chunk, enc, cb) {
    this._writecb = cb;
    this._bparser.push(chunk, 0);
    if (this._writecb)
      callAndUnsetCb(this);
  }
  _destroy(err, cb) {
    this._hparser = null;
    this._bparser = ignoreData;
    if (!err)
      err = checkEndState(this);
    const fileStream = this._fileStream;
    if (fileStream) {
      this._fileStream = null;
      fileStream.destroy(err);
    }
    cb(err);
  }
  _final(cb) {
    this._bparser.destroy();
    if (!this._complete)
      return cb(new Error("Unexpected end of form"));
    if (this._fileEndsLeft)
      this._finalcb = finalcb.bind(null, this, cb);
    else
      finalcb(this, cb);
  }
}
function finalcb(self2, cb, err) {
  if (err)
    return cb(err);
  err = checkEndState(self2);
  cb(err);
}
function checkEndState(self2) {
  if (self2._hparser)
    return new Error("Malformed part header");
  const fileStream = self2._fileStream;
  if (fileStream) {
    self2._fileStream = null;
    fileStream.destroy(new Error("Unexpected end of file"));
  }
  if (!self2._complete)
    return new Error("Unexpected end of form");
}
const TOKEN = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const FIELD_VCHAR = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1
];
var multipart = Multipart;
const { Writable: Writable$1 } = require$$2$2;
const { getDecoder } = utils;
class URLEncoded extends Writable$1 {
  constructor(cfg) {
    const streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
    };
    super(streamOpts);
    let charset3 = cfg.defCharset || "utf8";
    if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
      charset3 = cfg.conType.params.charset;
    this.charset = charset3;
    const limits = cfg.limits;
    this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
    this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
    this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
    this._inKey = true;
    this._keyTrunc = false;
    this._valTrunc = false;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._fields = 0;
    this._key = "";
    this._val = "";
    this._byte = -2;
    this._lastPos = 0;
    this._encode = 0;
    this._decoder = getDecoder(charset3);
  }
  static detect(conType) {
    return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
  }
  _write(chunk, enc, cb) {
    if (this._fields >= this.fieldsLimit)
      return cb();
    let i2 = 0;
    const len = chunk.length;
    this._lastPos = 0;
    if (this._byte !== -2) {
      i2 = readPctEnc(this, chunk, i2, len);
      if (i2 === -1)
        return cb(new Error("Malformed urlencoded form"));
      if (i2 >= len)
        return cb();
      if (this._inKey)
        ++this._bytesKey;
      else
        ++this._bytesVal;
    }
    main:
      while (i2 < len) {
        if (this._inKey) {
          i2 = skipKeyBytes(this, chunk, i2, len);
          while (i2 < len) {
            switch (chunk[i2]) {
              case 61:
                if (this._lastPos < i2)
                  this._key += chunk.latin1Slice(this._lastPos, i2);
                this._lastPos = ++i2;
                this._key = this._decoder(this._key, this._encode);
                this._encode = 0;
                this._inKey = false;
                continue main;
              case 38:
                if (this._lastPos < i2)
                  this._key += chunk.latin1Slice(this._lastPos, i2);
                this._lastPos = ++i2;
                this._key = this._decoder(this._key, this._encode);
                this._encode = 0;
                if (this._bytesKey > 0) {
                  this.emit(
                    "field",
                    this._key,
                    "",
                    {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    }
                  );
                }
                this._key = "";
                this._val = "";
                this._keyTrunc = false;
                this._valTrunc = false;
                this._bytesKey = 0;
                this._bytesVal = 0;
                if (++this._fields >= this.fieldsLimit) {
                  this.emit("fieldsLimit");
                  return cb();
                }
                continue;
              case 43:
                if (this._lastPos < i2)
                  this._key += chunk.latin1Slice(this._lastPos, i2);
                this._key += " ";
                this._lastPos = i2 + 1;
                break;
              case 37:
                if (this._encode === 0)
                  this._encode = 1;
                if (this._lastPos < i2)
                  this._key += chunk.latin1Slice(this._lastPos, i2);
                this._lastPos = i2 + 1;
                this._byte = -1;
                i2 = readPctEnc(this, chunk, i2 + 1, len);
                if (i2 === -1)
                  return cb(new Error("Malformed urlencoded form"));
                if (i2 >= len)
                  return cb();
                ++this._bytesKey;
                i2 = skipKeyBytes(this, chunk, i2, len);
                continue;
            }
            ++i2;
            ++this._bytesKey;
            i2 = skipKeyBytes(this, chunk, i2, len);
          }
          if (this._lastPos < i2)
            this._key += chunk.latin1Slice(this._lastPos, i2);
        } else {
          i2 = skipValBytes(this, chunk, i2, len);
          while (i2 < len) {
            switch (chunk[i2]) {
              case 38:
                if (this._lastPos < i2)
                  this._val += chunk.latin1Slice(this._lastPos, i2);
                this._lastPos = ++i2;
                this._inKey = true;
                this._val = this._decoder(this._val, this._encode);
                this._encode = 0;
                if (this._bytesKey > 0 || this._bytesVal > 0) {
                  this.emit(
                    "field",
                    this._key,
                    this._val,
                    {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    }
                  );
                }
                this._key = "";
                this._val = "";
                this._keyTrunc = false;
                this._valTrunc = false;
                this._bytesKey = 0;
                this._bytesVal = 0;
                if (++this._fields >= this.fieldsLimit) {
                  this.emit("fieldsLimit");
                  return cb();
                }
                continue main;
              case 43:
                if (this._lastPos < i2)
                  this._val += chunk.latin1Slice(this._lastPos, i2);
                this._val += " ";
                this._lastPos = i2 + 1;
                break;
              case 37:
                if (this._encode === 0)
                  this._encode = 1;
                if (this._lastPos < i2)
                  this._val += chunk.latin1Slice(this._lastPos, i2);
                this._lastPos = i2 + 1;
                this._byte = -1;
                i2 = readPctEnc(this, chunk, i2 + 1, len);
                if (i2 === -1)
                  return cb(new Error("Malformed urlencoded form"));
                if (i2 >= len)
                  return cb();
                ++this._bytesVal;
                i2 = skipValBytes(this, chunk, i2, len);
                continue;
            }
            ++i2;
            ++this._bytesVal;
            i2 = skipValBytes(this, chunk, i2, len);
          }
          if (this._lastPos < i2)
            this._val += chunk.latin1Slice(this._lastPos, i2);
        }
      }
    cb();
  }
  _final(cb) {
    if (this._byte !== -2)
      return cb(new Error("Malformed urlencoded form"));
    if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
      if (this._inKey)
        this._key = this._decoder(this._key, this._encode);
      else
        this._val = this._decoder(this._val, this._encode);
      this.emit(
        "field",
        this._key,
        this._val,
        {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        }
      );
    }
    cb();
  }
}
function readPctEnc(self2, chunk, pos, len) {
  if (pos >= len)
    return len;
  if (self2._byte === -1) {
    const hexUpper = HEX_VALUES[chunk[pos++]];
    if (hexUpper === -1)
      return -1;
    if (hexUpper >= 8)
      self2._encode = 2;
    if (pos < len) {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
      else
        self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    } else {
      self2._byte = hexUpper;
    }
  } else {
    const hexLower = HEX_VALUES[chunk[pos++]];
    if (hexLower === -1)
      return -1;
    if (self2._inKey)
      self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
    else
      self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
    self2._byte = -2;
    self2._lastPos = pos;
  }
  return pos;
}
function skipKeyBytes(self2, chunk, pos, len) {
  if (self2._bytesKey > self2.fieldNameSizeLimit) {
    if (!self2._keyTrunc) {
      if (self2._lastPos < pos)
        self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
    }
    self2._keyTrunc = true;
    for (; pos < len; ++pos) {
      const code = chunk[pos];
      if (code === 61 || code === 38)
        break;
      ++self2._bytesKey;
    }
    self2._lastPos = pos;
  }
  return pos;
}
function skipValBytes(self2, chunk, pos, len) {
  if (self2._bytesVal > self2.fieldSizeLimit) {
    if (!self2._valTrunc) {
      if (self2._lastPos < pos)
        self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
    }
    self2._valTrunc = true;
    for (; pos < len; ++pos) {
      if (chunk[pos] === 38)
        break;
      ++self2._bytesVal;
    }
    self2._lastPos = pos;
  }
  return pos;
}
const HEX_VALUES = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
];
var urlencoded = URLEncoded;
const { parseContentType } = utils;
function getInstance(cfg) {
  const headers = cfg.headers;
  const conType = parseContentType(headers["content-type"]);
  if (!conType)
    throw new Error("Malformed content type");
  for (const type3 of TYPES) {
    const matched = type3.detect(conType);
    if (!matched)
      continue;
    const instanceCfg = {
      limits: cfg.limits,
      headers,
      conType,
      highWaterMark: void 0,
      fileHwm: void 0,
      defCharset: void 0,
      defParamCharset: void 0,
      preservePath: false
    };
    if (cfg.highWaterMark)
      instanceCfg.highWaterMark = cfg.highWaterMark;
    if (cfg.fileHwm)
      instanceCfg.fileHwm = cfg.fileHwm;
    instanceCfg.defCharset = cfg.defCharset;
    instanceCfg.defParamCharset = cfg.defParamCharset;
    instanceCfg.preservePath = cfg.preservePath;
    return new type3(instanceCfg);
  }
  throw new Error(`Unsupported content type: ${headers["content-type"]}`);
}
const TYPES = [
  multipart,
  urlencoded
].filter(function(typemod) {
  return typeof typemod.detect === "function";
});
var lib$1 = (cfg) => {
  if (typeof cfg !== "object" || cfg === null)
    cfg = {};
  if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
    throw new Error("Missing Content-Type");
  }
  return getInstance(cfg);
};
var immutable = extend$1;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function extend$1() {
  var target = {};
  for (var i2 = 0; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (hasOwnProperty$2.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
var reFirstKey = /^[^\[]*/;
var reDigitPath = /^\[(\d+)\]/;
var reNormalPath = /^\[([^\]]+)\]/;
function parsePath$1(key) {
  function failure() {
    return [{ type: "object", key, last: true }];
  }
  var firstKey = reFirstKey.exec(key)[0];
  if (!firstKey)
    return failure();
  var len = key.length;
  var pos = firstKey.length;
  var tail = { type: "object", key: firstKey };
  var steps = [tail];
  while (pos < len) {
    var m2;
    if (key[pos] === "[" && key[pos + 1] === "]") {
      pos += 2;
      tail.append = true;
      if (pos !== len)
        return failure();
      continue;
    }
    m2 = reDigitPath.exec(key.substring(pos));
    if (m2 !== null) {
      pos += m2[0].length;
      tail.nextType = "array";
      tail = { type: "array", key: parseInt(m2[1], 10) };
      steps.push(tail);
      continue;
    }
    m2 = reNormalPath.exec(key.substring(pos));
    if (m2 !== null) {
      pos += m2[0].length;
      tail.nextType = "object";
      tail = { type: "object", key: m2[1] };
      steps.push(tail);
      continue;
    }
    return failure();
  }
  tail.last = true;
  return steps;
}
var parsePath_1 = parsePath$1;
function valueType(value) {
  if (value === void 0)
    return "undefined";
  if (Array.isArray(value))
    return "array";
  if (typeof value === "object")
    return "object";
  return "scalar";
}
function setLastValue(context, step, currentValue, entryValue) {
  switch (valueType(currentValue)) {
    case "undefined":
      if (step.append) {
        context[step.key] = [entryValue];
      } else {
        context[step.key] = entryValue;
      }
      break;
    case "array":
      context[step.key].push(entryValue);
      break;
    case "object":
      return setLastValue(currentValue, { type: "object", key: "", last: true }, currentValue[""], entryValue);
    case "scalar":
      context[step.key] = [context[step.key], entryValue];
      break;
  }
  return context;
}
function setValue$1(context, step, currentValue, entryValue) {
  if (step.last)
    return setLastValue(context, step, currentValue, entryValue);
  var obj;
  switch (valueType(currentValue)) {
    case "undefined":
      if (step.nextType === "array") {
        context[step.key] = [];
      } else {
        context[step.key] = /* @__PURE__ */ Object.create(null);
      }
      return context[step.key];
    case "object":
      return context[step.key];
    case "array":
      if (step.nextType === "array") {
        return currentValue;
      }
      obj = /* @__PURE__ */ Object.create(null);
      context[step.key] = obj;
      currentValue.forEach(function(item, i2) {
        if (item !== void 0)
          obj["" + i2] = item;
      });
      return obj;
    case "scalar":
      obj = /* @__PURE__ */ Object.create(null);
      obj[""] = currentValue;
      context[step.key] = obj;
      return obj;
  }
}
var setValue_1 = setValue$1;
var parsePath = parsePath_1;
var setValue = setValue_1;
function appendField$1(store, key, value) {
  var steps = parsePath(key);
  steps.reduce(function(context, step) {
    return setValue(context, step, context[step.key], value);
  }, store);
}
var appendField_1 = appendField$1;
var EventEmitter$1 = require$$2$2.EventEmitter;
function Counter$1() {
  EventEmitter$1.call(this);
  this.value = 0;
}
Counter$1.prototype = Object.create(EventEmitter$1.prototype);
Counter$1.prototype.increment = function increment() {
  this.value++;
};
Counter$1.prototype.decrement = function decrement() {
  if (--this.value === 0)
    this.emit("zero");
};
Counter$1.prototype.isZero = function isZero() {
  return this.value === 0;
};
Counter$1.prototype.onceZero = function onceZero(fn) {
  if (this.isZero())
    return fn();
  this.once("zero", fn);
};
var counter = Counter$1;
var util$c = util$f;
var errorMessages = {
  LIMIT_PART_COUNT: "Too many parts",
  LIMIT_FILE_SIZE: "File too large",
  LIMIT_FILE_COUNT: "Too many files",
  LIMIT_FIELD_KEY: "Field name too long",
  LIMIT_FIELD_VALUE: "Field value too long",
  LIMIT_FIELD_COUNT: "Too many fields",
  LIMIT_UNEXPECTED_FILE: "Unexpected field",
  MISSING_FIELD_NAME: "Field name missing"
};
function MulterError$2(code, field) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = errorMessages[code];
  this.code = code;
  if (field)
    this.field = field;
}
util$c.inherits(MulterError$2, Error);
var multerError = MulterError$2;
var objectAssign$1 = objectAssign$2;
function arrayRemove(arr, item) {
  var idx = arr.indexOf(item);
  if (~idx)
    arr.splice(idx, 1);
}
function FileAppender$1(strategy, req2) {
  this.strategy = strategy;
  this.req = req2;
  switch (strategy) {
    case "NONE":
      break;
    case "VALUE":
      break;
    case "ARRAY":
      req2.files = [];
      break;
    case "OBJECT":
      req2.files = /* @__PURE__ */ Object.create(null);
      break;
    default:
      throw new Error("Unknown file strategy: " + strategy);
  }
}
FileAppender$1.prototype.insertPlaceholder = function(file) {
  var placeholder = {
    fieldname: file.fieldname
  };
  switch (this.strategy) {
    case "NONE":
      break;
    case "VALUE":
      break;
    case "ARRAY":
      this.req.files.push(placeholder);
      break;
    case "OBJECT":
      if (this.req.files[file.fieldname]) {
        this.req.files[file.fieldname].push(placeholder);
      } else {
        this.req.files[file.fieldname] = [placeholder];
      }
      break;
  }
  return placeholder;
};
FileAppender$1.prototype.removePlaceholder = function(placeholder) {
  switch (this.strategy) {
    case "NONE":
      break;
    case "VALUE":
      break;
    case "ARRAY":
      arrayRemove(this.req.files, placeholder);
      break;
    case "OBJECT":
      if (this.req.files[placeholder.fieldname].length === 1) {
        delete this.req.files[placeholder.fieldname];
      } else {
        arrayRemove(this.req.files[placeholder.fieldname], placeholder);
      }
      break;
  }
};
FileAppender$1.prototype.replacePlaceholder = function(placeholder, file) {
  if (this.strategy === "VALUE") {
    this.req.file = file;
    return;
  }
  delete placeholder.fieldname;
  objectAssign$1(placeholder, file);
};
var fileAppender = FileAppender$1;
function removeUploadedFiles$1(uploadedFiles, remove, cb) {
  var length2 = uploadedFiles.length;
  var errors = [];
  if (length2 === 0)
    return cb(null, errors);
  function handleFile(idx) {
    var file = uploadedFiles[idx];
    remove(file, function(err) {
      if (err) {
        err.file = file;
        err.field = file.fieldname;
        errors.push(err);
      }
      if (idx < length2 - 1) {
        handleFile(idx + 1);
      } else {
        cb(null, errors);
      }
    });
  }
  handleFile(0);
}
var removeUploadedFiles_1 = removeUploadedFiles$1;
var is2 = typeIsExports;
var Busboy = lib$1;
var extend = immutable;
var appendField = appendField_1;
var Counter = counter;
var MulterError$1 = multerError;
var FileAppender = fileAppender;
var removeUploadedFiles = removeUploadedFiles_1;
function makeMiddleware$1(setup2) {
  return function multerMiddleware(req2, res2, next) {
    if (!is2(req2, ["multipart"]))
      return next();
    var options2 = setup2();
    var limits = options2.limits;
    var storage2 = options2.storage;
    var fileFilter = options2.fileFilter;
    var fileStrategy = options2.fileStrategy;
    var preservePath = options2.preservePath;
    req2.body = /* @__PURE__ */ Object.create(null);
    var busboy;
    try {
      busboy = Busboy({ headers: req2.headers, limits, preservePath });
    } catch (err) {
      return next(err);
    }
    var appender = new FileAppender(fileStrategy, req2);
    var isDone = false;
    var readFinished = false;
    var errorOccured = false;
    var pendingWrites = new Counter();
    var uploadedFiles = [];
    function done2(err) {
      if (isDone)
        return;
      isDone = true;
      req2.unpipe(busboy);
      busboy.removeAllListeners();
      next(err);
    }
    function indicateDone() {
      if (readFinished && pendingWrites.isZero() && !errorOccured)
        done2();
    }
    function abortWithError(uploadError) {
      if (errorOccured)
        return;
      errorOccured = true;
      pendingWrites.onceZero(function() {
        function remove(file, cb) {
          storage2._removeFile(req2, file, cb);
        }
        removeUploadedFiles(uploadedFiles, remove, function(err, storageErrors) {
          if (err)
            return done2(err);
          uploadError.storageErrors = storageErrors;
          done2(uploadError);
        });
      });
    }
    function abortWithCode(code, optionalField) {
      abortWithError(new MulterError$1(code, optionalField));
    }
    busboy.on("field", function(fieldname, value, { nameTruncated, valueTruncated }) {
      if (fieldname == null)
        return abortWithCode("MISSING_FIELD_NAME");
      if (nameTruncated)
        return abortWithCode("LIMIT_FIELD_KEY");
      if (valueTruncated)
        return abortWithCode("LIMIT_FIELD_VALUE", fieldname);
      if (limits && Object.prototype.hasOwnProperty.call(limits, "fieldNameSize")) {
        if (fieldname.length > limits.fieldNameSize)
          return abortWithCode("LIMIT_FIELD_KEY");
      }
      appendField(req2.body, fieldname, value);
    });
    busboy.on("file", function(fieldname, fileStream, { filename, encoding: encoding3, mimeType }) {
      if (!filename)
        return fileStream.resume();
      if (limits && Object.prototype.hasOwnProperty.call(limits, "fieldNameSize")) {
        if (fieldname.length > limits.fieldNameSize)
          return abortWithCode("LIMIT_FIELD_KEY");
      }
      var file = {
        fieldname,
        originalname: filename,
        encoding: encoding3,
        mimetype: mimeType
      };
      var placeholder = appender.insertPlaceholder(file);
      fileFilter(req2, file, function(err, includeFile) {
        if (err) {
          appender.removePlaceholder(placeholder);
          return abortWithError(err);
        }
        if (!includeFile) {
          appender.removePlaceholder(placeholder);
          return fileStream.resume();
        }
        var aborting = false;
        pendingWrites.increment();
        Object.defineProperty(file, "stream", {
          configurable: true,
          enumerable: false,
          value: fileStream
        });
        fileStream.on("error", function(err2) {
          pendingWrites.decrement();
          abortWithError(err2);
        });
        fileStream.on("limit", function() {
          aborting = true;
          abortWithCode("LIMIT_FILE_SIZE", fieldname);
        });
        storage2._handleFile(req2, file, function(err2, info) {
          if (aborting) {
            appender.removePlaceholder(placeholder);
            uploadedFiles.push(extend(file, info));
            return pendingWrites.decrement();
          }
          if (err2) {
            appender.removePlaceholder(placeholder);
            pendingWrites.decrement();
            return abortWithError(err2);
          }
          var fileInfo = extend(file, info);
          appender.replacePlaceholder(placeholder, fileInfo);
          uploadedFiles.push(fileInfo);
          pendingWrites.decrement();
          indicateDone();
        });
      });
    });
    busboy.on("error", function(err) {
      abortWithError(err);
    });
    busboy.on("partsLimit", function() {
      abortWithCode("LIMIT_PART_COUNT");
    });
    busboy.on("filesLimit", function() {
      abortWithCode("LIMIT_FILE_COUNT");
    });
    busboy.on("fieldsLimit", function() {
      abortWithCode("LIMIT_FIELD_COUNT");
    });
    busboy.on("close", function() {
      readFinished = true;
      indicateDone();
    });
    req2.pipe(busboy);
  };
}
var makeMiddleware_1 = makeMiddleware$1;
var path$1 = pathExports;
var fs$1 = require$$2$2;
var _0777 = parseInt("0777", 8);
var mkdirp$1 = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP(p, opts, f, made) {
  if (typeof opts === "function") {
    f = opts;
    opts = {};
  } else if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$1;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made)
    made = null;
  var cb = f || /* istanbul ignore next */
  function() {
  };
  p = path$1.resolve(p);
  xfs.mkdir(p, mode, function(er) {
    if (!er) {
      made = made || p;
      return cb(null, made);
    }
    switch (er.code) {
      case "ENOENT":
        if (path$1.dirname(p) === p)
          return cb(er);
        mkdirP(path$1.dirname(p), opts, function(er2, made2) {
          if (er2)
            cb(er2, made2);
          else
            mkdirP(p, opts, cb, made2);
        });
        break;
      default:
        xfs.stat(p, function(er2, stat) {
          if (er2 || !stat.isDirectory())
            cb(er, made);
          else
            cb(null, made);
        });
        break;
    }
  });
}
mkdirP.sync = function sync(p, opts, made) {
  if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$1;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made)
    made = null;
  p = path$1.resolve(p);
  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case "ENOENT":
        made = sync(path$1.dirname(p), opts, made);
        sync(p, opts, made);
        break;
      default:
        var stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory())
          throw err0;
        break;
    }
  }
  return made;
};
var fs = require$$2$2;
var os$1 = require$$2$2;
var path2 = pathExports;
var crypto$1 = require$$2$2;
var mkdirp = mkdirp$1;
function getFilename(req2, file, cb) {
  crypto$1.randomBytes(16, function(err, raw) {
    cb(err, err ? void 0 : raw.toString("hex"));
  });
}
function getDestination(req2, file, cb) {
  cb(null, os$1.tmpdir());
}
function DiskStorage(opts) {
  this.getFilename = opts.filename || getFilename;
  if (typeof opts.destination === "string") {
    mkdirp.sync(opts.destination);
    this.getDestination = function($0, $1, cb) {
      cb(null, opts.destination);
    };
  } else {
    this.getDestination = opts.destination || getDestination;
  }
}
DiskStorage.prototype._handleFile = function _handleFile(req2, file, cb) {
  var that = this;
  that.getDestination(req2, file, function(err, destination) {
    if (err)
      return cb(err);
    that.getFilename(req2, file, function(err2, filename) {
      if (err2)
        return cb(err2);
      var finalPath = path2.join(destination, filename);
      var outStream = fs.createWriteStream(finalPath);
      file.stream.pipe(outStream);
      outStream.on("error", cb);
      outStream.on("finish", function() {
        cb(null, {
          destination,
          filename,
          path: finalPath,
          size: outStream.bytesWritten
        });
      });
    });
  });
};
DiskStorage.prototype._removeFile = function _removeFile(req2, file, cb) {
  var path3 = file.path;
  delete file.destination;
  delete file.filename;
  delete file.path;
  fs.unlink(path3, cb);
};
var disk = function(opts) {
  return new DiskStorage(opts);
};
var readableBrowser$1 = { exports: {} };
var processNextickArgs = { exports: {} };
if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
  processNextickArgs.exports = { nextTick };
} else {
  processNextickArgs.exports = process;
}
function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== "function") {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i2;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i2 = 0;
      while (i2 < args.length) {
        args[i2++] = arguments[i2];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports;
var toString$3 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$3.call(arr) == "[object Array]";
};
var streamBrowser$1 = require$$2$2.EventEmitter;
var safeBuffer = { exports: {} };
(function(module, exports2) {
  var buffer2 = require$$2$2;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length2) {
    return Buffer2(arg, encodingOrOffset, length2);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length2);
  };
  SafeBuffer.alloc = function(size, fill, encoding3) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var util$b = {};
function isArray$2(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString$7(arg) === "[object Array]";
}
util$b.isArray = isArray$2;
function isBoolean$2(arg) {
  return typeof arg === "boolean";
}
util$b.isBoolean = isBoolean$2;
function isNull(arg) {
  return arg === null;
}
util$b.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
util$b.isNullOrUndefined = isNullOrUndefined;
function isNumber$2(arg) {
  return typeof arg === "number";
}
util$b.isNumber = isNumber$2;
function isString$3(arg) {
  return typeof arg === "string";
}
util$b.isString = isString$3;
function isSymbol$3(arg) {
  return typeof arg === "symbol";
}
util$b.isSymbol = isSymbol$3;
function isUndefined(arg) {
  return arg === void 0;
}
util$b.isUndefined = isUndefined;
function isRegExp2(re2) {
  return objectToString$7(re2) === "[object RegExp]";
}
util$b.isRegExp = isRegExp2;
function isObject$4(arg) {
  return typeof arg === "object" && arg !== null;
}
util$b.isObject = isObject$4;
function isDate(d2) {
  return objectToString$7(d2) === "[object Date]";
}
util$b.isDate = isDate;
function isError(e) {
  return objectToString$7(e) === "[object Error]" || e instanceof Error;
}
util$b.isError = isError;
function isFunction$1(arg) {
  return typeof arg === "function";
}
util$b.isFunction = isFunction$1;
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
util$b.isPrimitive = isPrimitive;
util$b.isBuffer = require$$2$2.Buffer.isBuffer;
function objectToString$7(o) {
  return Object.prototype.toString.call(o);
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList)
    return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = safeBufferExports.Buffer;
    var util2 = require$$2$2;
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push2(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift2(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy$1(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT$1, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT$1, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT$1, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT$1, _this, err2);
      }
    } else if (cb) {
      cb(err2);
    }
  });
  return this;
}
function undestroy$1() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT$1(self2, err) {
  self2.emit("error", err);
}
var destroy_1$1 = {
  destroy: destroy$1,
  undestroy: undestroy$1
};
var browser$1 = deprecate;
function deprecate(fn, msg) {
  if (config("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config("throwDeprecation")) {
        throw new Error(msg);
      } else if (config("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config(name2) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
var _stream_writable$1;
var hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1;
  var pna2 = processNextickArgsExports;
  _stream_writable$1 = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna2.nextTick;
  var Duplex2;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(util$b);
  util2.inherits = inherits_browserExports;
  var internalUtil = {
    deprecate: browser$1
  };
  var Stream2 = streamBrowser$1;
  var Buffer2 = safeBufferExports.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1$1;
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options2, stream3) {
    Duplex2 = Duplex2 || require_stream_duplex$1();
    options2 = options2 || {};
    var isDuplex = stream3 instanceof Duplex2;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.writableObjectMode;
    var hwm = options2.highWaterMark;
    var writableHwm = options2.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream3, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable2)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable2(options2) {
    Duplex2 = Duplex2 || require_stream_duplex$1();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex2)) {
      return new Writable2(options2);
    }
    this._writableState = new WritableState(options2, this);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function")
        this._write = options2.write;
      if (typeof options2.writev === "function")
        this._writev = options2.writev;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
      if (typeof options2.final === "function")
        this._final = options2.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream3, cb) {
    var er = new Error("write after end");
    stream3.emit("error", er);
    pna2.nextTick(cb, er);
  }
  function validChunk(stream3, state2, chunk, cb) {
    var valid2 = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream3.emit("error", er);
      pna2.nextTick(cb, er);
      valid2 = false;
    }
    return valid2;
  }
  Writable2.prototype.write = function(chunk, encoding3, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding3 === "function") {
      cb = encoding3;
      encoding3 = null;
    }
    if (isBuf)
      encoding3 = "buffer";
    else if (!encoding3)
      encoding3 = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding3, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding3) {
    if (typeof encoding3 === "string")
      encoding3 = encoding3.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding3 + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding3);
    this._writableState.defaultEncoding = encoding3;
    return this;
  };
  function decodeChunk(state2, chunk, encoding3) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding3);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream3, state2, isBuf, chunk, encoding3, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding3);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding3 = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding: encoding3,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream3, state2, false, len, chunk, encoding3, cb);
    }
    return ret;
  }
  function doWrite(stream3, state2, writev, len, chunk, encoding3, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev)
      stream3._writev(chunk, state2.onwrite);
    else
      stream3._write(chunk, encoding3, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream3, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      pna2.nextTick(cb, er);
      pna2.nextTick(finishMaybe, stream3, state2);
      stream3._writableState.errorEmitted = true;
      stream3.emit("error", er);
    } else {
      cb(er);
      stream3._writableState.errorEmitted = true;
      stream3.emit("error", er);
      finishMaybe(stream3, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream3, er) {
    var state2 = stream3._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream3, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream3, state2);
      }
      if (sync3) {
        asyncWrite(afterWrite, stream3, state2, finished, cb);
      } else {
        afterWrite(stream3, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream3, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream3, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream3, state2);
  }
  function onwriteDrain(stream3, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream3.emit("drain");
    }
  }
  function clearBuffer(stream3, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream3._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream3, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding3 = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream3, state2, false, len, chunk, encoding3, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding3, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding3, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding3 = null;
    } else if (typeof encoding3 === "function") {
      cb = encoding3;
      encoding3 = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding3);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream3, state2) {
    stream3._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream3.emit("error", err);
      }
      state2.prefinished = true;
      stream3.emit("prefinish");
      finishMaybe(stream3, state2);
    });
  }
  function prefinish2(stream3, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream3._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna2.nextTick(callFinal, stream3, state2);
      } else {
        state2.prefinished = true;
        stream3.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream3, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream3, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream3.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream3, state2, cb) {
    state2.ending = true;
    finishMaybe(stream3, state2);
    if (cb) {
      if (state2.finished)
        pna2.nextTick(cb);
      else
        stream3.once("finish", cb);
    }
    state2.ended = true;
    stream3.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$1;
}
var _stream_duplex$1;
var hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var pna2 = processNextickArgsExports;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key in obj) {
      keys3.push(key);
    }
    return keys3;
  };
  _stream_duplex$1 = Duplex2;
  var util2 = Object.create(util$b);
  util2.inherits = inherits_browserExports;
  var Readable2 = require_stream_readable$1();
  var Writable2 = require_stream_writable$1();
  util2.inherits(Duplex2, Readable2);
  {
    var keys2 = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys2.length; v++) {
      var method = keys2[v];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex2(options2) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options2);
    Readable2.call(this, options2);
    Writable2.call(this, options2);
    if (options2 && options2.readable === false)
      this.readable = false;
    if (options2 && options2.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options2 && options2.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna2.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex2.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna2.nextTick(cb, err);
  };
  return _stream_duplex$1;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = safeBufferExports.Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding3) {
    encoding3 = "" + encoding3;
    switch (encoding3 && encoding3.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding3) {
    this.encoding = normalizeEncoding(encoding3);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i2;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i2 = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i2 = 0;
    }
    if (i2 < buf.length)
      return r ? r + this.text(buf, i2) : this.text(buf, i2);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i2) {
    var j = buf.length - 1;
    if (j < i2)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i2 || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i2) {
    var total = utf8CheckIncomplete(this, buf, i2);
    if (!this.lastNeed)
      return buf.toString("utf8", i2);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i2, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i2) {
    if ((buf.length - i2) % 2 === 0) {
      var r = buf.toString("utf16le", i2);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i2, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i2) {
    var n = (buf.length - i2) % 3;
    if (n === 0)
      return buf.toString("base64", i2);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i2, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable$1;
var hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1;
  var pna2 = processNextickArgsExports;
  _stream_readable$1 = Readable2;
  var isArray2 = isarray;
  var Duplex2;
  Readable2.ReadableState = ReadableState;
  require$$2$2.EventEmitter;
  var EElistenerCount = function(emitter, type3) {
    return emitter.listeners(type3).length;
  };
  var Stream2 = streamBrowser$1;
  var Buffer2 = safeBufferExports.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(util$b);
  util2.inherits = inherits_browserExports;
  var debugUtil = require$$2$2;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = destroy_1$1;
  var StringDecoder;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray2(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream3) {
    Duplex2 = Duplex2 || require_stream_duplex$1();
    options2 = options2 || {};
    var isDuplex = stream3 instanceof Duplex2;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.readableObjectMode;
    var hwm = options2.highWaterMark;
    var readableHwm = options2.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable2(options2) {
    Duplex2 = Duplex2 || require_stream_duplex$1();
    if (!(this instanceof Readable2))
      return new Readable2(options2);
    this._readableState = new ReadableState(options2, this);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function")
        this._read = options2.read;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding3) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding3 = encoding3 || state2.defaultEncoding;
        if (encoding3 !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding3);
          encoding3 = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding3, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream3, chunk, encoding3, addToFront, skipChunkCheck) {
    var state2 = stream3._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream3, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        stream3.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            stream3.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream3, state2, chunk, true);
        } else if (state2.ended) {
          stream3.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding3) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream3, state2, chunk, false);
            else
              maybeReadMore(stream3, state2);
          } else {
            addChunk(stream3, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream3, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream3.emit("data", chunk);
      stream3.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream3);
    }
    maybeReadMore(stream3, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream3, state2) {
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream3);
  }
  function emitReadable(stream3) {
    var state2 = stream3._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync)
        pna2.nextTick(emitReadable_, stream3);
      else
        emitReadable_(stream3);
    }
  }
  function emitReadable_(stream3) {
    debug2("emit readable");
    stream3.emit("readable");
    flow(stream3);
  }
  function maybeReadMore(stream3, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna2.nextTick(maybeReadMore_, stream3, state2);
    }
  }
  function maybeReadMore_(stream3, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream3.read(0);
      if (len === state2.length)
        break;
      else
        len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe2;
    if (state2.endEmitted)
      pna2.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe2);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe2();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe2();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe2();
    }
    dest.once("finish", onfinish);
    function unpipe2() {
      debug2("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug2("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state2 = src._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len; i2++) {
        dests[i2].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res2 = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna2.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res2;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume2(this, state2);
    }
    return this;
  };
  function resume2(stream3, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna2.nextTick(resume_, stream3, state2);
    }
  }
  function resume_(stream3, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream3.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream3.emit("resume");
    flow(stream3);
    if (state2.flowing && !state2.reading)
      stream3.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream3) {
    var state2 = stream3._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream3.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream3) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream3.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream3.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream3.pause();
      }
    });
    for (var i2 in stream3) {
      if (this[i2] === void 0 && typeof stream3[i2] === "function") {
        this[i2] = /* @__PURE__ */ function(method) {
          return function() {
            return stream3[method].apply(stream3, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream3.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream3.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.head.data;
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream3) {
    var state2 = stream3._readableState;
    if (state2.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna2.nextTick(endReadableNT, state2, stream3);
    }
  }
  function endReadableNT(state2, stream3) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream3.readable = false;
      stream3.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x)
        return i2;
    }
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1 = Transform$3;
var Duplex$1 = require_stream_duplex$1();
var util$a = Object.create(util$b);
util$a.inherits = inherits_browserExports;
util$a.inherits(Transform$3, Duplex$1);
function afterTransform$1(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) {
    return this.emit("error", new Error("write callback called multiple times"));
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$3(options2) {
  if (!(this instanceof Transform$3))
    return new Transform$3(options2);
  Duplex$1.call(this, options2);
  this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var _this = this;
  if (typeof this._flush === "function") {
    this._flush(function(er, data) {
      done$1(_this, er, data);
    });
  } else {
    done$1(this, null, null);
  }
}
Transform$3.prototype.push = function(chunk, encoding3) {
  this._transformState.needTransform = false;
  return Duplex$1.prototype.push.call(this, chunk, encoding3);
};
Transform$3.prototype._transform = function(chunk, encoding3, cb) {
  throw new Error("_transform() is not implemented");
};
Transform$3.prototype._write = function(chunk, encoding3, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding3;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$3.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$3.prototype._destroy = function(err, cb) {
  var _this2 = this;
  Duplex$1.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
    _this2.emit("close");
  });
};
function done$1(stream3, er, data) {
  if (er)
    return stream3.emit("error", er);
  if (data != null)
    stream3.push(data);
  if (stream3._writableState.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (stream3._transformState.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream3.push(null);
}
var _stream_passthrough$1 = PassThrough$1;
var Transform$2 = _stream_transform$1;
var util$9 = Object.create(util$b);
util$9.inherits = inherits_browserExports;
util$9.inherits(PassThrough$1, Transform$2);
function PassThrough$1(options2) {
  if (!(this instanceof PassThrough$1))
    return new PassThrough$1(options2);
  Transform$2.call(this, options2);
}
PassThrough$1.prototype._transform = function(chunk, encoding3, cb) {
  cb(null, chunk);
};
(function(module, exports2) {
  exports2 = module.exports = require_stream_readable$1();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable$1();
  exports2.Duplex = require_stream_duplex$1();
  exports2.Transform = _stream_transform$1;
  exports2.PassThrough = _stream_passthrough$1;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports;
var toString$2 = Object.prototype.toString;
var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
function isArrayBuffer(input) {
  return toString$2.call(input).slice(8, -1) === "ArrayBuffer";
}
function fromArrayBuffer(obj, byteOffset, length2) {
  byteOffset >>>= 0;
  var maxLength = obj.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (length2 === void 0) {
    length2 = maxLength;
  } else {
    length2 >>>= 0;
    if (length2 > maxLength) {
      throw new RangeError("'length' is out of bounds");
    }
  }
  return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length2)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length2)));
}
function fromString(string, encoding3) {
  if (typeof encoding3 !== "string" || encoding3 === "") {
    encoding3 = "utf8";
  }
  if (!Buffer.isEncoding(encoding3)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  return isModern ? Buffer.from(string, encoding3) : new Buffer(string, encoding3);
}
function bufferFrom$1(value, encodingOrOffset, length2) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length2);
  }
  if (typeof value === "string") {
    return fromString(value, encodingOrOffset);
  }
  return isModern ? Buffer.from(value) : new Buffer(value);
}
var bufferFrom_1 = bufferFrom$1;
var typedarray = {};
var hasRequiredTypedarray;
function requireTypedarray() {
  if (hasRequiredTypedarray)
    return typedarray;
  hasRequiredTypedarray = 1;
  (function(exports2) {
    var undefined$12 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = /* @__PURE__ */ function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2, abs = Math.abs, floor = Math.floor, log2 = Math.log, min = Math.min, pow = Math.pow, round = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i2;
        for (i2 = 0; i2 < props.length; i2 += 1) {
          defineProp(obj, props[i2], {
            value: obj[props[i2]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o))
          throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o))
        throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH)
        throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index2) {
        defineProp(obj, index2, {
          "get": function() {
            return obj._getter(index2);
          },
          "set": function(v) {
            obj._setter(index2, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i2;
      for (i2 = 0; i2 < obj.length; i2 += 1) {
        makeArrayAccessor(i2);
      }
    }
    function as_signed(value, bits) {
      var s2 = 32 - bits;
      return value << s2 >> s2;
    }
    function as_unsigned(value, bits) {
      var s2 = 32 - bits;
      return value << s2 >>> s2;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes2) {
      return as_signed(bytes2[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes2) {
      return as_unsigned(bytes2[0], 8);
    }
    function packU8Clamped(n) {
      n = round(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes2) {
      return as_signed(bytes2[0] << 8 | bytes2[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes2) {
      return as_unsigned(bytes2[0] << 8 | bytes2[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes2) {
      return as_signed(bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes2) {
      return as_unsigned(bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s2, e, f, i2, bits, str, bytes2;
      function roundToEven(n) {
        var w2 = floor(n), f2 = n - w2;
        if (f2 < 0.5)
          return w2;
        if (f2 > 0.5)
          return w2 + 1;
        return w2 % 2 ? w2 + 1 : w2;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s2 = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s2 = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s2 = 1 / v === -Infinity ? 1 : 0;
      } else {
        s2 = v < 0;
        v = abs(v);
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log2(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i2 = fbits; i2; i2 -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i2 = ebits; i2; i2 -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s2 ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes2 = [];
      while (str.length) {
        bytes2.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes2;
    }
    function unpackIEEE754(bytes2, ebits, fbits) {
      var bits = [], i2, j, b, str, bias, s2, e, f;
      for (i2 = bytes2.length; i2; i2 -= 1) {
        b = bytes2[i2 - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s2 = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s2 * Infinity;
      } else if (e > 0) {
        return s2 * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        return s2 * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s2 < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function ArrayBuffer3(length2) {
        length2 = ECMAScript.ToInt32(length2);
        if (length2 < 0)
          throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length2;
        this._bytes = [];
        this._bytes.length = length2;
        var i2;
        for (i2 = 0; i2 < this.byteLength; i2 += 1) {
          this._bytes[i2] = 0;
        }
        configureProperties(this);
      };
      exports2.ArrayBuffer = exports2.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer2, byteOffset, length2) {
          var array, sequence, i2, s2;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length2 < 0)
              throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i2 = 0; i2 < this.length; i2 += 1) {
              this._setter(i2, array._getter(i2));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i2 = 0; i2 < this.length; i2 += 1) {
              s2 = sequence[i2];
              this._setter(i2, Number(s2));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer2;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length2);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index2) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          index2 = ECMAScript.ToUint32(index2);
          if (index2 >= this.length) {
            return undefined$12;
          }
          var bytes2 = [], i2, o;
          for (i2 = 0, o = this.byteOffset + index2 * this.BYTES_PER_ELEMENT; i2 < this.BYTES_PER_ELEMENT; i2 += 1, o += 1) {
            bytes2.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes2);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index2, value) {
          if (arguments.length < 2)
            throw new SyntaxError("Not enough arguments");
          index2 = ECMAScript.ToUint32(index2);
          if (index2 >= this.length) {
            return undefined$12;
          }
          var bytes2 = this._pack(value), i2, o;
          for (i2 = 0, o = this.byteOffset + index2 * this.BYTES_PER_ELEMENT; i2 < this.BYTES_PER_ELEMENT; i2 += 1, o += 1) {
            this.buffer._bytes[o] = bytes2[i2];
          }
        };
        ctor.prototype.set = function(index2, value) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i2, s2, d2, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i2 = 0, s2 = array.byteOffset; i2 < byteLength; i2 += 1, s2 += 1) {
                tmp[i2] = array.buffer._bytes[s2];
              }
              for (i2 = 0, d2 = byteOffset; i2 < byteLength; i2 += 1, d2 += 1) {
                this.buffer._bytes[d2] = tmp[i2];
              }
            } else {
              for (i2 = 0, s2 = array.byteOffset, d2 = byteOffset; i2 < byteLength; i2 += 1, s2 += 1, d2 += 1) {
                this.buffer._bytes[d2] = array.buffer._bytes[s2];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i2 = 0; i2 < len; i2 += 1) {
              s2 = sequence[i2];
              this._setter(offset + i2, Number(s2));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end2) {
          function clamp(v, min2, max2) {
            return v < min2 ? min2 : v > max2 ? max2 : v;
          }
          start = ECMAScript.ToInt32(start);
          end2 = ECMAScript.ToInt32(end2);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end2 = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end2 < 0) {
            end2 = this.length + end2;
          }
          start = clamp(start, 0, this.length);
          end2 = clamp(end2, 0, this.length);
          var len = end2 - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports2.Int8Array = exports2.Int8Array || Int8Array2;
      exports2.Uint8Array = exports2.Uint8Array || Uint8Array2;
      exports2.Uint8ClampedArray = exports2.Uint8ClampedArray || Uint8ClampedArray2;
      exports2.Int16Array = exports2.Int16Array || Int16Array2;
      exports2.Uint16Array = exports2.Uint16Array || Uint16Array2;
      exports2.Int32Array = exports2.Int32Array || Int32Array2;
      exports2.Uint32Array = exports2.Uint32Array || Uint32Array2;
      exports2.Float32Array = exports2.Float32Array || Float32Array2;
      exports2.Float64Array = exports2.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index2) {
        return ECMAScript.IsCallable(array.get) ? array.get(index2) : array[index2];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports2.Uint16Array([4660]), u8array = new exports2.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView2 = function DataView3(buffer2, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer2 = new exports2.ArrayBuffer(0);
        } else if (!(buffer2 instanceof exports2.ArrayBuffer || ECMAScript.Class(buffer2) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer2 || new exports2.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes2 = [], i2;
          for (i2 = 0; i2 < arrayType.BYTES_PER_ELEMENT; i2 += 1) {
            bytes2.push(r(uint8Array, i2));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes2.reverse();
          }
          return r(new arrayType(new exports2.Uint8Array(bytes2).buffer), 0);
        };
      }
      DataView2.prototype.getUint8 = makeGetter(exports2.Uint8Array);
      DataView2.prototype.getInt8 = makeGetter(exports2.Int8Array);
      DataView2.prototype.getUint16 = makeGetter(exports2.Uint16Array);
      DataView2.prototype.getInt16 = makeGetter(exports2.Int16Array);
      DataView2.prototype.getUint32 = makeGetter(exports2.Uint32Array);
      DataView2.prototype.getInt32 = makeGetter(exports2.Int32Array);
      DataView2.prototype.getFloat32 = makeGetter(exports2.Float32Array);
      DataView2.prototype.getFloat64 = makeGetter(exports2.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray2 = new exports2.Uint8Array(typeArray.buffer), bytes2 = [], i2, byteView;
          for (i2 = 0; i2 < arrayType.BYTES_PER_ELEMENT; i2 += 1) {
            bytes2.push(r(byteArray2, i2));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes2.reverse();
          }
          byteView = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes2);
        };
      }
      DataView2.prototype.setUint8 = makeSetter(exports2.Uint8Array);
      DataView2.prototype.setInt8 = makeSetter(exports2.Int8Array);
      DataView2.prototype.setUint16 = makeSetter(exports2.Uint16Array);
      DataView2.prototype.setInt16 = makeSetter(exports2.Int16Array);
      DataView2.prototype.setUint32 = makeSetter(exports2.Uint32Array);
      DataView2.prototype.setInt32 = makeSetter(exports2.Int32Array);
      DataView2.prototype.setFloat32 = makeSetter(exports2.Float32Array);
      DataView2.prototype.setFloat64 = makeSetter(exports2.Float64Array);
      exports2.DataView = exports2.DataView || DataView2;
    })();
  })(typedarray);
  return typedarray;
}
var Writable = readableBrowserExports$1.Writable;
var inherits = inherits_browserExports;
var bufferFrom = bufferFrom_1;
if (typeof Uint8Array === "undefined") {
  var U8 = requireTypedarray().Uint8Array;
} else {
  var U8 = Uint8Array;
}
function ConcatStream(opts, cb) {
  if (!(this instanceof ConcatStream))
    return new ConcatStream(opts, cb);
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  if (!opts)
    opts = {};
  var encoding3 = opts.encoding;
  var shouldInferEncoding = false;
  if (!encoding3) {
    shouldInferEncoding = true;
  } else {
    encoding3 = String(encoding3).toLowerCase();
    if (encoding3 === "u8" || encoding3 === "uint8") {
      encoding3 = "uint8array";
    }
  }
  Writable.call(this, { objectMode: true });
  this.encoding = encoding3;
  this.shouldInferEncoding = shouldInferEncoding;
  if (cb)
    this.on("finish", function() {
      cb(this.getBody());
    });
  this.body = [];
}
var concatStream = ConcatStream;
inherits(ConcatStream, Writable);
ConcatStream.prototype._write = function(chunk, enc, next) {
  this.body.push(chunk);
  next();
};
ConcatStream.prototype.inferEncoding = function(buff) {
  var firstBuffer = buff === void 0 ? this.body[0] : buff;
  if (Buffer.isBuffer(firstBuffer))
    return "buffer";
  if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
    return "uint8array";
  if (Array.isArray(firstBuffer))
    return "array";
  if (typeof firstBuffer === "string")
    return "string";
  if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
    return "object";
  return "buffer";
};
ConcatStream.prototype.getBody = function() {
  if (!this.encoding && this.body.length === 0)
    return [];
  if (this.shouldInferEncoding)
    this.encoding = this.inferEncoding();
  if (this.encoding === "array")
    return arrayConcat(this.body);
  if (this.encoding === "string")
    return stringConcat(this.body);
  if (this.encoding === "buffer")
    return bufferConcat(this.body);
  if (this.encoding === "uint8array")
    return u8Concat(this.body);
  return this.body;
};
function isArrayish(arr) {
  return /Array\]$/.test(Object.prototype.toString.call(arr));
}
function isBufferish(p) {
  return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
}
function stringConcat(parts) {
  var strings = [];
  for (var i2 = 0; i2 < parts.length; i2++) {
    var p = parts[i2];
    if (typeof p === "string") {
      strings.push(p);
    } else if (Buffer.isBuffer(p)) {
      strings.push(p);
    } else if (isBufferish(p)) {
      strings.push(bufferFrom(p));
    } else {
      strings.push(bufferFrom(String(p)));
    }
  }
  if (Buffer.isBuffer(parts[0])) {
    strings = Buffer.concat(strings);
    strings = strings.toString("utf8");
  } else {
    strings = strings.join("");
  }
  return strings;
}
function bufferConcat(parts) {
  var bufs = [];
  for (var i2 = 0; i2 < parts.length; i2++) {
    var p = parts[i2];
    if (Buffer.isBuffer(p)) {
      bufs.push(p);
    } else if (isBufferish(p)) {
      bufs.push(bufferFrom(p));
    } else {
      bufs.push(bufferFrom(String(p)));
    }
  }
  return Buffer.concat(bufs);
}
function arrayConcat(parts) {
  var res2 = [];
  for (var i2 = 0; i2 < parts.length; i2++) {
    res2.push.apply(res2, parts[i2]);
  }
  return res2;
}
function u8Concat(parts) {
  var len = 0;
  for (var i2 = 0; i2 < parts.length; i2++) {
    if (typeof parts[i2] === "string") {
      parts[i2] = bufferFrom(parts[i2]);
    }
    len += parts[i2].length;
  }
  var u8 = new U8(len);
  for (var i2 = 0, offset = 0; i2 < parts.length; i2++) {
    var part = parts[i2];
    for (var j = 0; j < part.length; j++) {
      u8[offset++] = part[j];
    }
  }
  return u8;
}
var concat = concatStream;
function MemoryStorage(opts) {
}
MemoryStorage.prototype._handleFile = function _handleFile2(req2, file, cb) {
  file.stream.pipe(concat({ encoding: "buffer" }, function(data) {
    cb(null, {
      buffer: data,
      size: data.length
    });
  }));
};
MemoryStorage.prototype._removeFile = function _removeFile2(req2, file, cb) {
  delete file.buffer;
  cb(null);
};
var memory = function(opts) {
  return new MemoryStorage();
};
var makeMiddleware = makeMiddleware_1;
var diskStorage = disk;
var memoryStorage = memory;
var MulterError = multerError;
function allowAll(req2, file, cb) {
  cb(null, true);
}
function Multer(options2) {
  if (options2.storage) {
    this.storage = options2.storage;
  } else if (options2.dest) {
    this.storage = diskStorage({ destination: options2.dest });
  } else {
    this.storage = memoryStorage();
  }
  this.limits = options2.limits;
  this.preservePath = options2.preservePath;
  this.fileFilter = options2.fileFilter || allowAll;
}
Multer.prototype._makeMiddleware = function(fields, fileStrategy) {
  function setup2() {
    var fileFilter = this.fileFilter;
    var filesLeft = /* @__PURE__ */ Object.create(null);
    fields.forEach(function(field) {
      if (typeof field.maxCount === "number") {
        filesLeft[field.name] = field.maxCount;
      } else {
        filesLeft[field.name] = Infinity;
      }
    });
    function wrappedFileFilter(req2, file, cb) {
      if ((filesLeft[file.fieldname] || 0) <= 0) {
        return cb(new MulterError("LIMIT_UNEXPECTED_FILE", file.fieldname));
      }
      filesLeft[file.fieldname] -= 1;
      fileFilter(req2, file, cb);
    }
    return {
      limits: this.limits,
      preservePath: this.preservePath,
      storage: this.storage,
      fileFilter: wrappedFileFilter,
      fileStrategy
    };
  }
  return makeMiddleware(setup2.bind(this));
};
Multer.prototype.single = function(name2) {
  return this._makeMiddleware([{ name: name2, maxCount: 1 }], "VALUE");
};
Multer.prototype.array = function(name2, maxCount) {
  return this._makeMiddleware([{ name: name2, maxCount }], "ARRAY");
};
Multer.prototype.fields = function(fields) {
  return this._makeMiddleware(fields, "OBJECT");
};
Multer.prototype.none = function() {
  return this._makeMiddleware([], "NONE");
};
Multer.prototype.any = function() {
  function setup2() {
    return {
      limits: this.limits,
      preservePath: this.preservePath,
      storage: this.storage,
      fileFilter: this.fileFilter,
      fileStrategy: "ARRAY"
    };
  }
  return makeMiddleware(setup2.bind(this));
};
function multer(options2) {
  if (options2 === void 0) {
    return new Multer({});
  }
  if (typeof options2 === "object" && options2 !== null) {
    return new Multer(options2);
  }
  throw new TypeError("Expected object for argument options");
}
multer$2.exports = multer;
multer$2.exports.diskStorage = diskStorage;
multer$2.exports.memoryStorage = memoryStorage;
multer$2.exports.MulterError = MulterError;
var multerExports = multer$2.exports;
const multer$1 = /* @__PURE__ */ getDefaultExportFromCjs(multerExports);
var jws$3 = {};
var Buffer$7 = safeBufferExports$1.Buffer;
var Stream$2 = require$$2$2;
var util$8 = util$f;
function DataStream$2(data) {
  this.buffer = null;
  this.writable = true;
  this.readable = true;
  if (!data) {
    this.buffer = Buffer$7.alloc(0);
    return this;
  }
  if (typeof data.pipe === "function") {
    this.buffer = Buffer$7.alloc(0);
    data.pipe(this);
    return this;
  }
  if (data.length || typeof data === "object") {
    this.buffer = data;
    this.writable = false;
    process.nextTick((function() {
      this.emit("end", data);
      this.readable = false;
      this.emit("close");
    }).bind(this));
    return this;
  }
  throw new TypeError("Unexpected data type (" + typeof data + ")");
}
util$8.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function write(data) {
  this.buffer = Buffer$7.concat([this.buffer, Buffer$7.from(data)]);
  this.emit("data", data);
};
DataStream$2.prototype.end = function end(data) {
  if (data)
    this.write(data);
  this.emit("end", data);
  this.emit("close");
  this.writable = false;
  this.readable = false;
};
var dataStream = DataStream$2;
var Buffer$6 = require$$2$2.Buffer;
var SlowBuffer = require$$2$2.SlowBuffer;
var bufferEqualConstantTime = bufferEq;
function bufferEq(a, b) {
  if (!Buffer$6.isBuffer(a) || !Buffer$6.isBuffer(b)) {
    return false;
  }
  if (a.length !== b.length) {
    return false;
  }
  var c = 0;
  for (var i2 = 0; i2 < a.length; i2++) {
    c |= a[i2] ^ b[i2];
  }
  return c === 0;
}
bufferEq.install = function() {
  Buffer$6.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
    return bufferEq(this, that);
  };
};
var origBufEqual = Buffer$6.prototype.equal;
var origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer$6.prototype.equal = origBufEqual;
  SlowBuffer.prototype.equal = origSlowBufEqual;
};
function getParamSize(keySize) {
  var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
  return result;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(alg) {
  var paramBytes = paramBytesForAlg[alg];
  if (paramBytes) {
    return paramBytes;
  }
  throw new Error('Unknown algorithm "' + alg + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1;
var Buffer$5 = safeBufferExports$1.Buffer;
var getParamBytesForAlg = paramBytesForAlg_1;
var MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(signature2) {
  if (Buffer$5.isBuffer(signature2)) {
    return signature2;
  } else if ("string" === typeof signature2) {
    return Buffer$5.from(signature2, "base64");
  }
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(signature2, alg) {
  signature2 = signatureAsBuffer(signature2);
  var paramBytes = getParamBytesForAlg(alg);
  var maxEncodedParamLength = paramBytes + 1;
  var inputLength = signature2.length;
  var offset = 0;
  if (signature2[offset++] !== ENCODED_TAG_SEQ) {
    throw new Error('Could not find expected "seq"');
  }
  var seqLength = signature2[offset++];
  if (seqLength === (MAX_OCTET | 1)) {
    seqLength = signature2[offset++];
  }
  if (inputLength - offset < seqLength) {
    throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
  }
  if (signature2[offset++] !== ENCODED_TAG_INT) {
    throw new Error('Could not find expected "int" for "r"');
  }
  var rLength = signature2[offset++];
  if (inputLength - offset - 2 < rLength) {
    throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
  }
  if (maxEncodedParamLength < rLength) {
    throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
  }
  var rOffset = offset;
  offset += rLength;
  if (signature2[offset++] !== ENCODED_TAG_INT) {
    throw new Error('Could not find expected "int" for "s"');
  }
  var sLength = signature2[offset++];
  if (inputLength - offset !== sLength) {
    throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
  }
  if (maxEncodedParamLength < sLength) {
    throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
  }
  var sOffset = offset;
  offset += sLength;
  if (offset !== inputLength) {
    throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
  }
  var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
  var dst = Buffer$5.allocUnsafe(rPadding + rLength + sPadding + sLength);
  for (offset = 0; offset < rPadding; ++offset) {
    dst[offset] = 0;
  }
  signature2.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
  offset = paramBytes;
  for (var o = offset; offset < o + sPadding; ++offset) {
    dst[offset] = 0;
  }
  signature2.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
  dst = dst.toString("base64");
  dst = base64Url(dst);
  return dst;
}
function countPadding(buf, start, stop) {
  var padding = 0;
  while (start + padding < stop && buf[start + padding] === 0) {
    ++padding;
  }
  var needsSign = buf[start + padding] >= MAX_OCTET;
  if (needsSign) {
    --padding;
  }
  return padding;
}
function joseToDer(signature2, alg) {
  signature2 = signatureAsBuffer(signature2);
  var paramBytes = getParamBytesForAlg(alg);
  var signatureBytes = signature2.length;
  if (signatureBytes !== paramBytes * 2) {
    throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
  }
  var rPadding = countPadding(signature2, 0, paramBytes);
  var sPadding = countPadding(signature2, paramBytes, signature2.length);
  var rLength = paramBytes - rPadding;
  var sLength = paramBytes - sPadding;
  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
  var shortLength = rsBytes < MAX_OCTET;
  var dst = Buffer$5.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
  var offset = 0;
  dst[offset++] = ENCODED_TAG_SEQ;
  if (shortLength) {
    dst[offset++] = rsBytes;
  } else {
    dst[offset++] = MAX_OCTET | 1;
    dst[offset++] = rsBytes & 255;
  }
  dst[offset++] = ENCODED_TAG_INT;
  dst[offset++] = rLength;
  if (rPadding < 0) {
    dst[offset++] = 0;
    offset += signature2.copy(dst, offset, 0, paramBytes);
  } else {
    offset += signature2.copy(dst, offset, rPadding, paramBytes);
  }
  dst[offset++] = ENCODED_TAG_INT;
  dst[offset++] = sLength;
  if (sPadding < 0) {
    dst[offset++] = 0;
    signature2.copy(dst, offset, paramBytes);
  } else {
    signature2.copy(dst, offset, paramBytes + sPadding);
  }
  return dst;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
};
var bufferEqual = bufferEqualConstantTime;
var Buffer$4 = safeBufferExports$1.Buffer;
var crypto = require$$2$2;
var formatEcdsa = ecdsaSigFormatter;
var util$7 = util$f;
var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
var MSG_INVALID_SECRET = "secret must be a string or buffer";
var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
var supportsKeyObjects = typeof crypto.createPublicKey === "function";
if (supportsKeyObjects) {
  MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
  MSG_INVALID_SECRET += "or a KeyObject";
}
function checkIsPublicKey(key) {
  if (Buffer$4.isBuffer(key)) {
    return;
  }
  if (typeof key === "string") {
    return;
  }
  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key !== "object") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key.type !== "string") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key.asymmetricKeyType !== "string") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
  if (typeof key.export !== "function") {
    throw typeError(MSG_INVALID_VERIFIER_KEY);
  }
}
function checkIsPrivateKey(key) {
  if (Buffer$4.isBuffer(key)) {
    return;
  }
  if (typeof key === "string") {
    return;
  }
  if (typeof key === "object") {
    return;
  }
  throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(key) {
  if (Buffer$4.isBuffer(key)) {
    return;
  }
  if (typeof key === "string") {
    return key;
  }
  if (!supportsKeyObjects) {
    throw typeError(MSG_INVALID_SECRET);
  }
  if (typeof key !== "object") {
    throw typeError(MSG_INVALID_SECRET);
  }
  if (key.type !== "secret") {
    throw typeError(MSG_INVALID_SECRET);
  }
  if (typeof key.export !== "function") {
    throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(base64url2) {
  base64url2 = base64url2.toString();
  var padding = 4 - base64url2.length % 4;
  if (padding !== 4) {
    for (var i2 = 0; i2 < padding; ++i2) {
      base64url2 += "=";
    }
  }
  return base64url2.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(template) {
  var args = [].slice.call(arguments, 1);
  var errMsg = util$7.format.bind(util$7, template).apply(null, args);
  return new TypeError(errMsg);
}
function bufferOrString(obj) {
  return Buffer$4.isBuffer(obj) || typeof obj === "string";
}
function normalizeInput(thing) {
  if (!bufferOrString(thing))
    thing = JSON.stringify(thing);
  return thing;
}
function createHmacSigner(bits) {
  return function sign3(thing, secret) {
    checkIsSecretKey(secret);
    thing = normalizeInput(thing);
    var hmac = crypto.createHmac("sha" + bits, secret);
    var sig = (hmac.update(thing), hmac.digest("base64"));
    return fromBase64(sig);
  };
}
function createHmacVerifier(bits) {
  return function verify3(thing, signature2, secret) {
    var computedSig = createHmacSigner(bits)(thing, secret);
    return bufferEqual(Buffer$4.from(signature2), Buffer$4.from(computedSig));
  };
}
function createKeySigner(bits) {
  return function sign3(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto.createSign("RSA-SHA" + bits);
    var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
    return fromBase64(sig);
  };
}
function createKeyVerifier(bits) {
  return function verify3(thing, signature2, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature2 = toBase64(signature2);
    var verifier = crypto.createVerify("RSA-SHA" + bits);
    verifier.update(thing);
    return verifier.verify(publicKey, signature2, "base64");
  };
}
function createPSSKeySigner(bits) {
  return function sign3(thing, privateKey) {
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto.createSign("RSA-SHA" + bits);
    var sig = (signer.update(thing), signer.sign({
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(sig);
  };
}
function createPSSKeyVerifier(bits) {
  return function verify3(thing, signature2, publicKey) {
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature2 = toBase64(signature2);
    var verifier = crypto.createVerify("RSA-SHA" + bits);
    verifier.update(thing);
    return verifier.verify({
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
    }, signature2, "base64");
  };
}
function createECDSASigner(bits) {
  var inner = createKeySigner(bits);
  return function sign3() {
    var signature2 = inner.apply(null, arguments);
    signature2 = formatEcdsa.derToJose(signature2, "ES" + bits);
    return signature2;
  };
}
function createECDSAVerifer(bits) {
  var inner = createKeyVerifier(bits);
  return function verify3(thing, signature2, publicKey) {
    signature2 = formatEcdsa.joseToDer(signature2, "ES" + bits).toString("base64");
    var result = inner(thing, signature2, publicKey);
    return result;
  };
}
function createNoneSigner() {
  return function sign3() {
    return "";
  };
}
function createNoneVerifier() {
  return function verify3(thing, signature2) {
    return signature2 === "";
  };
}
var jwa$2 = function jwa(algorithm) {
  var signerFactories = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  };
  var verifierFactories = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  };
  var match2 = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!match2)
    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
  var algo = (match2[1] || match2[3]).toLowerCase();
  var bits = match2[2];
  return {
    sign: signerFactories[algo](bits),
    verify: verifierFactories[algo](bits)
  };
};
var Buffer$3 = require$$2$2.Buffer;
var tostring = function toString(obj) {
  if (typeof obj === "string")
    return obj;
  if (typeof obj === "number" || Buffer$3.isBuffer(obj))
    return obj.toString();
  return JSON.stringify(obj);
};
var Buffer$2 = safeBufferExports$1.Buffer;
var DataStream$1 = dataStream;
var jwa$1 = jwa$2;
var Stream$1 = require$$2$2;
var toString$1 = tostring;
var util$6 = util$f;
function base64url(string, encoding3) {
  return Buffer$2.from(string, encoding3).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(header3, payload, encoding3) {
  encoding3 = encoding3 || "utf8";
  var encodedHeader = base64url(toString$1(header3), "binary");
  var encodedPayload = base64url(toString$1(payload), encoding3);
  return util$6.format("%s.%s", encodedHeader, encodedPayload);
}
function jwsSign(opts) {
  var header3 = opts.header;
  var payload = opts.payload;
  var secretOrKey = opts.secret || opts.privateKey;
  var encoding3 = opts.encoding;
  var algo = jwa$1(header3.alg);
  var securedInput = jwsSecuredInput(header3, payload, encoding3);
  var signature2 = algo.sign(securedInput, secretOrKey);
  return util$6.format("%s.%s", securedInput, signature2);
}
function SignStream$1(opts) {
  var secret = opts.secret || opts.privateKey || opts.key;
  var secretStream = new DataStream$1(secret);
  this.readable = true;
  this.header = opts.header;
  this.encoding = opts.encoding;
  this.secret = this.privateKey = this.key = secretStream;
  this.payload = new DataStream$1(opts.payload);
  this.secret.once("close", (function() {
    if (!this.payload.writable && this.readable)
      this.sign();
  }).bind(this));
  this.payload.once("close", (function() {
    if (!this.secret.writable && this.readable)
      this.sign();
  }).bind(this));
}
util$6.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function sign() {
  try {
    var signature2 = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    this.emit("done", signature2);
    this.emit("data", signature2);
    this.emit("end");
    this.readable = false;
    return signature2;
  } catch (e) {
    this.readable = false;
    this.emit("error", e);
    this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1;
var Buffer$1 = safeBufferExports$1.Buffer;
var DataStream = dataStream;
var jwa2 = jwa$2;
var Stream = require$$2$2;
var toString2 = tostring;
var util$5 = util$f;
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$3(thing) {
  return Object.prototype.toString.call(thing) === "[object Object]";
}
function safeJsonParse(thing) {
  if (isObject$3(thing))
    return thing;
  try {
    return JSON.parse(thing);
  } catch (e) {
    return void 0;
  }
}
function headerFromJWS(jwsSig) {
  var encodedHeader = jwsSig.split(".", 1)[0];
  return safeJsonParse(Buffer$1.from(encodedHeader, "base64").toString("binary"));
}
function securedInputFromJWS(jwsSig) {
  return jwsSig.split(".", 2).join(".");
}
function signatureFromJWS(jwsSig) {
  return jwsSig.split(".")[2];
}
function payloadFromJWS(jwsSig, encoding3) {
  encoding3 = encoding3 || "utf8";
  var payload = jwsSig.split(".")[1];
  return Buffer$1.from(payload, "base64").toString(encoding3);
}
function isValidJws(string) {
  return JWS_REGEX.test(string) && !!headerFromJWS(string);
}
function jwsVerify(jwsSig, algorithm, secretOrKey) {
  if (!algorithm) {
    var err = new Error("Missing algorithm parameter for jws.verify");
    err.code = "MISSING_ALGORITHM";
    throw err;
  }
  jwsSig = toString2(jwsSig);
  var signature2 = signatureFromJWS(jwsSig);
  var securedInput = securedInputFromJWS(jwsSig);
  var algo = jwa2(algorithm);
  return algo.verify(securedInput, signature2, secretOrKey);
}
function jwsDecode(jwsSig, opts) {
  opts = opts || {};
  jwsSig = toString2(jwsSig);
  if (!isValidJws(jwsSig))
    return null;
  var header3 = headerFromJWS(jwsSig);
  if (!header3)
    return null;
  var payload = payloadFromJWS(jwsSig);
  if (header3.typ === "JWT" || opts.json)
    payload = JSON.parse(payload, opts.encoding);
  return {
    header: header3,
    payload,
    signature: signatureFromJWS(jwsSig)
  };
}
function VerifyStream$1(opts) {
  opts = opts || {};
  var secretOrKey = opts.secret || opts.publicKey || opts.key;
  var secretStream = new DataStream(secretOrKey);
  this.readable = true;
  this.algorithm = opts.algorithm;
  this.encoding = opts.encoding;
  this.secret = this.publicKey = this.key = secretStream;
  this.signature = new DataStream(opts.signature);
  this.secret.once("close", (function() {
    if (!this.signature.writable && this.readable)
      this.verify();
  }).bind(this));
  this.signature.once("close", (function() {
    if (!this.secret.writable && this.readable)
      this.verify();
  }).bind(this));
}
util$5.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function verify() {
  try {
    var valid2 = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
    var obj = jwsDecode(this.signature.buffer, this.encoding);
    this.emit("done", valid2, obj);
    this.emit("data", valid2);
    this.emit("end");
    this.readable = false;
    return valid2;
  } catch (e) {
    this.readable = false;
    this.emit("error", e);
    this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1;
var SignStream = signStream;
var VerifyStream = verifyStream;
var ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function createSign(opts) {
  return new SignStream(opts);
};
jws$3.createVerify = function createVerify(opts) {
  return new VerifyStream(opts);
};
var jws$2 = jws$3;
var decode$1 = function(jwt2, options2) {
  options2 = options2 || {};
  var decoded = jws$2.decode(jwt2, options2);
  if (!decoded) {
    return null;
  }
  var payload = decoded.payload;
  if (typeof payload === "string") {
    try {
      var obj = JSON.parse(payload);
      if (obj !== null && typeof obj === "object") {
        payload = obj;
      }
    } catch (e) {
    }
  }
  if (options2.complete === true) {
    return {
      header: decoded.header,
      payload,
      signature: decoded.signature
    };
  }
  return payload;
};
var JsonWebTokenError$3 = function(message, error3) {
  Error.call(this, message);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }
  this.name = "JsonWebTokenError";
  this.message = message;
  if (error3)
    this.inner = error3;
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3;
var JsonWebTokenError$2 = JsonWebTokenError_1;
var NotBeforeError$1 = function(message, date) {
  JsonWebTokenError$2.call(this, message);
  this.name = "NotBeforeError";
  this.date = date;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1;
var JsonWebTokenError$1 = JsonWebTokenError_1;
var TokenExpiredError$1 = function(message, expiredAt) {
  JsonWebTokenError$1.call(this, message);
  this.name = "TokenExpiredError";
  this.expiredAt = expiredAt;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1;
var ms = ms$3;
var timespan$2 = function(time, iat) {
  var timestamp = iat || Math.floor(Date.now() / 1e3);
  if (typeof time === "string") {
    var milliseconds = ms(time);
    if (typeof milliseconds === "undefined") {
      return;
    }
    return Math.floor(timestamp + milliseconds / 1e3);
  } else if (typeof time === "number") {
    return timestamp + time;
  } else {
    return;
  }
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
var define_process_env_default$4 = {};
const debug$1 = typeof process === "object" && define_process_env_default$4 && define_process_env_default$4.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default$4.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module, exports2) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports2 = module.exports = {};
  const re2 = exports2.re = [];
  const safeRe = exports2.safeRe = [];
  const src = exports2.src = [];
  const t2 = exports2.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index2 = R++;
    debug2(name2, index2, value);
    t2[name2] = index2;
    src[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options2) => {
  if (!options2) {
    return emptyOpts;
  }
  if (typeof options2 !== "object") {
    return looseOption;
  }
  return options2;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1 } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version2, options2) {
    options2 = parseOptions(options2);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options2.loose && version2.includePrerelease === !!options2.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version2, options2);
    this.options = options2;
    this.loose = !!options2.loose;
    this.includePrerelease = !!options2.includePrerelease;
    const m2 = version2.trim().match(options2.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER$1 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER$1 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER$1 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER$1) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$4 = SemVer$d;
const SemVer$c = semver$4;
const parse$6 = (version2, options2, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options2);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version2, options2) => {
  const v = parse$5(version2, options2);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version2, options2) => {
  const s2 = parse$4(version2.trim().replace(/^[=v]+/, ""), options2);
  return s2 ? s2.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$4;
const inc$1 = (version2, release, options2, identifier, identifierBase) => {
  if (typeof options2 === "string") {
    identifierBase = identifier;
    identifier = options2;
    options2 = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options2
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix2 = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix2 + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix2 + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix2 + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$4;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$4;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$4;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version2, options2) => {
  const parsed = parse$2(version2, options2);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$4;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$4;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$4;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version2, options2) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options2 = options2 || {};
  let match2 = null;
  if (!options2.rtl) {
    match2 = version2.match(options2.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options2.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
      if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
        match2 = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match2 === null) {
    return null;
  }
  const major2 = match2[2];
  const minor2 = match2[3] || "0";
  const patch2 = match2[4] || "0";
  const prerelease2 = options2.includePrerelease && match2[5] ? `-${match2[5]}` : "";
  const build = options2.includePrerelease && match2[6] ? `+${match2[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options2);
};
var coerce_1 = coerce$1;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      self2.push(arguments[i2]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev2 = node.prev;
  if (next) {
    next.prev = prev2;
  }
  if (prev2) {
    prev2.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev2;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    push(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    unshift(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res2 = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res2;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res2 = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res2;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i2 = 0; walker !== null; i2++) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++) {
    walker = walker.next;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++) {
    walker = walker.prev;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res2 = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res2.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res2;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res2 = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res2.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res2;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = 0; walker !== null; i2++) {
    acc = fn(acc, walker.value, i2);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = this.length - 1; walker !== null; i2--) {
    acc = fn(acc, walker.value, i2);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.head; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
    walker = walker.next;
  }
  for (; walker !== null && i2 < to; i2++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
    walker = walker.prev;
  }
  for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i2 = 0; walker && i2 < deleteCount; i2++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i2 = 0; i2 < nodes.length; i2++) {
    walker = insert(this, walker, nodes[i2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev2, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev2, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev2) {
    prev2.next = this;
    this.prev = prev2;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options2) {
    if (typeof options2 === "number")
      options2 = { max: options2 };
    if (!options2)
      options2 = {};
    if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options2.max || Infinity;
    const lc = options2.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options2.stale || false;
    if (options2.maxAge && typeof options2.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options2.maxAge || 0;
    this[DISPOSE] = options2.dispose;
    this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev2 = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev2;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev2 = walker.prev;
      del(self2, walker);
      walker = prev2;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length2, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length2;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
var range2;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range2;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range3, options2) {
      options2 = parseOptions2(options2);
      if (range3 instanceof Range2) {
        if (range3.loose === !!options2.loose && range3.includePrerelease === !!options2.includePrerelease) {
          return range3;
        } else {
          return new Range2(range3.raw, options2);
        }
      }
      if (range3 instanceof Comparator2) {
        this.raw = range3.value;
        this.set = [[range3]];
        this.format();
        return this;
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range3.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range3) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range3;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range3 = range3.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range3);
      range3 = range3.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range3);
      range3 = range3.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range3);
      range3 = range3.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range3);
      let rangeList = range3.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range3, options2) {
      if (!(range3 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options2) && range3.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range2 = Range2;
  const LRU = lruCache;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$4;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options2) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options2);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options2) => {
    debug2("comp", comp, options2);
    comp = replaceCarets(comp, options2);
    debug2("caret", comp);
    comp = replaceTildes(comp, options2);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options2);
    debug2("xrange", comp);
    comp = replaceStars(comp, options2);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
  };
  const replaceTilde = (comp, options2) => {
    const r = options2.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m2, p, pr) => {
      debug2("tilde", comp, _, M, m2, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options2) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
  };
  const replaceCaret = (comp, options2) => {
    debug2("caret", comp, options2);
    const r = options2.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options2.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m2, p, pr) => {
      debug2("caret", comp, _, M, m2, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options2) => {
    debug2("replaceXRanges", comp, options2);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
  };
  const replaceXRange = (comp, options2) => {
    comp = comp.trim();
    const r = options2.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m2, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m2);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options2.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options2) => {
    debug2("replaceStars", comp, options2);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options2) => {
    debug2("replaceGTE0", comp, options2);
    return comp.trim().replace(re2[options2.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version2, options2) => {
    for (let i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options2.includePrerelease) {
      for (let i2 = 0; i2 < set.length; i2++) {
        debug2(set[i2].semver);
        if (set[i2].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          const allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range2;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options2) {
      options2 = parseOptions2(options2);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m2 = comp.match(r);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options2) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options2).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options2).test(comp.semver);
      }
      options2 = parseOptions2(options2);
      if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$4;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range3, options2) => {
  try {
    range3 = new Range$9(range3, options2);
  } catch (er) {
    return false;
  }
  return range3.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range3, options2) => new Range$8(range3, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$4;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range3, options2) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range3, options2);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options2);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$4;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range3, options2) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range3, options2);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$3(min, options2);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$4;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range3, loose) => {
  range3 = new Range$5(range3, loose);
  let minver = new SemVer$2("0.0.0");
  if (range3.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range3.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range3.set.length; ++i2) {
    const comparators = range3.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range3.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range3, options2) => {
  try {
    return new Range$4(range3, options2).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$4;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range3, hilo, options2) => {
  version2 = new SemVer$1(version2, options2);
  range3 = new Range$3(range3, options2);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range3, options2)) {
    return false;
  }
  for (let i2 = 0; i2 < range3.set.length; ++i2) {
    const comparators = range3.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options2)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options2)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range3, options2) => outside$2(version2, range3, ">", options2);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range3, options2) => outside$1(version2, range3, "<", options2);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options2) => {
  r1 = new Range$2(r1, options2);
  r2 = new Range$2(r2, options2);
  return r1.intersects(r2, options2);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range3, options2) => {
  const set = [];
  let first2 = null;
  let prev2 = null;
  const v = versions.sort((a, b) => compare$2(a, b, options2));
  for (const version2 of v) {
    const included = satisfies$2(version2, range3, options2);
    if (included) {
      prev2 = version2;
      if (!first2) {
        first2 = version2;
      }
    } else {
      if (prev2) {
        set.push([first2, prev2]);
      }
      prev2 = null;
      first2 = null;
    }
  }
  if (first2) {
    set.push([first2, null]);
  }
  const ranges = [];
  for (const [min, max2] of set) {
    if (min === max2) {
      ranges.push(min);
    } else if (!max2 && min === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range3.raw === "string" ? range3.raw : String(range3);
  return simplified.length < original.length ? simplified : range3;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options2 = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options2);
  dom = new Range$1(dom, options2);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options2);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options2) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options2.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options2.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options2);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options2);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options2);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options2)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options2)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options2)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options2.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options2.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options2);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options2)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options2);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options2)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options2) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options2);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options2) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options2);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$4;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver$3 = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const semver$2 = semver$3;
var asymmetricKeyDetailsSupported = semver$2.satisfies(process.version, ">=15.7.0");
const semver$1 = semver$3;
var rsaPssKeyDetailsSupported = semver$1.satisfies(process.version, ">=16.9.0");
const ASYMMETRIC_KEY_DETAILS_SUPPORTED = asymmetricKeyDetailsSupported;
const RSA_PSS_KEY_DETAILS_SUPPORTED = rsaPssKeyDetailsSupported;
const allowedAlgorithmsForKeys = {
  "ec": ["ES256", "ES384", "ES512"],
  "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
  "rsa-pss": ["PS256", "PS384", "PS512"]
};
const allowedCurves = {
  ES256: "prime256v1",
  ES384: "secp384r1",
  ES512: "secp521r1"
};
var validateAsymmetricKey$2 = function(algorithm, key) {
  if (!algorithm || !key)
    return;
  const keyType = key.asymmetricKeyType;
  if (!keyType)
    return;
  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
  if (!allowedAlgorithms) {
    throw new Error(`Unknown key type "${keyType}".`);
  }
  if (!allowedAlgorithms.includes(algorithm)) {
    throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
  }
  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
    switch (keyType) {
      case "ec":
        const keyCurve = key.asymmetricKeyDetails.namedCurve;
        const allowedCurve = allowedCurves[algorithm];
        if (keyCurve !== allowedCurve) {
          throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
        }
        break;
      case "rsa-pss":
        if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
          const length2 = parseInt(algorithm.slice(-3), 10);
          const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
          if (hashAlgorithm !== `sha${length2}` || mgf1HashAlgorithm !== hashAlgorithm) {
            throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
          }
          if (saltLength !== void 0 && saltLength > length2 >> 3) {
            throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
          }
        }
        break;
    }
  }
};
var semver = semver$3;
var psSupported = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
const JsonWebTokenError = JsonWebTokenError_1;
const NotBeforeError = NotBeforeError_1;
const TokenExpiredError = TokenExpiredError_1;
const decode = decode$1;
const timespan$1 = timespan$2;
const validateAsymmetricKey$1 = validateAsymmetricKey$2;
const PS_SUPPORTED$1 = psSupported;
const jws$1 = jws$3;
const { KeyObject: KeyObject$1, createSecretKey: createSecretKey$1, createPublicKey } = require$$2$2;
const PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
const EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
const RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
const HS_ALGS = ["HS256", "HS384", "HS512"];
if (PS_SUPPORTED$1) {
  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
}
var verify2 = function(jwtString, secretOrPublicKey, options2, callback) {
  if (typeof options2 === "function" && !callback) {
    callback = options2;
    options2 = {};
  }
  if (!options2) {
    options2 = {};
  }
  options2 = Object.assign({}, options2);
  let done2;
  if (callback) {
    done2 = callback;
  } else {
    done2 = function(err, data) {
      if (err)
        throw err;
      return data;
    };
  }
  if (options2.clockTimestamp && typeof options2.clockTimestamp !== "number") {
    return done2(new JsonWebTokenError("clockTimestamp must be a number"));
  }
  if (options2.nonce !== void 0 && (typeof options2.nonce !== "string" || options2.nonce.trim() === "")) {
    return done2(new JsonWebTokenError("nonce must be a non-empty string"));
  }
  if (options2.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options2.allowInvalidAsymmetricKeyTypes !== "boolean") {
    return done2(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
  }
  const clockTimestamp = options2.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!jwtString) {
    return done2(new JsonWebTokenError("jwt must be provided"));
  }
  if (typeof jwtString !== "string") {
    return done2(new JsonWebTokenError("jwt must be a string"));
  }
  const parts = jwtString.split(".");
  if (parts.length !== 3) {
    return done2(new JsonWebTokenError("jwt malformed"));
  }
  let decodedToken;
  try {
    decodedToken = decode(jwtString, { complete: true });
  } catch (err) {
    return done2(err);
  }
  if (!decodedToken) {
    return done2(new JsonWebTokenError("invalid token"));
  }
  const header3 = decodedToken.header;
  let getSecret;
  if (typeof secretOrPublicKey === "function") {
    if (!callback) {
      return done2(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    }
    getSecret = secretOrPublicKey;
  } else {
    getSecret = function(header4, secretCallback) {
      return secretCallback(null, secretOrPublicKey);
    };
  }
  return getSecret(header3, function(err, secretOrPublicKey2) {
    if (err) {
      return done2(new JsonWebTokenError("error in secret or public key callback: " + err.message));
    }
    const hasSignature = parts[2].trim() !== "";
    if (!hasSignature && secretOrPublicKey2) {
      return done2(new JsonWebTokenError("jwt signature is required"));
    }
    if (hasSignature && !secretOrPublicKey2) {
      return done2(new JsonWebTokenError("secret or public key must be provided"));
    }
    if (!hasSignature && !options2.algorithms) {
      return done2(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
    }
    if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject$1)) {
      try {
        secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
      } catch (_) {
        try {
          secretOrPublicKey2 = createSecretKey$1(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
        } catch (_2) {
          return done2(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
        }
      }
    }
    if (!options2.algorithms) {
      if (secretOrPublicKey2.type === "secret") {
        options2.algorithms = HS_ALGS;
      } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
        options2.algorithms = RSA_KEY_ALGS;
      } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
        options2.algorithms = EC_KEY_ALGS;
      } else {
        options2.algorithms = PUB_KEY_ALGS;
      }
    }
    if (options2.algorithms.indexOf(decodedToken.header.alg) === -1) {
      return done2(new JsonWebTokenError("invalid algorithm"));
    }
    if (header3.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
      return done2(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header3.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header3.alg) && secretOrPublicKey2.type !== "public") {
      return done2(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header3.alg}`));
    }
    if (!options2.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey$1(header3.alg, secretOrPublicKey2);
      } catch (e) {
        return done2(e);
      }
    }
    let valid2;
    try {
      valid2 = jws$1.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
    } catch (e) {
      return done2(e);
    }
    if (!valid2) {
      return done2(new JsonWebTokenError("invalid signature"));
    }
    const payload = decodedToken.payload;
    if (typeof payload.nbf !== "undefined" && !options2.ignoreNotBefore) {
      if (typeof payload.nbf !== "number") {
        return done2(new JsonWebTokenError("invalid nbf value"));
      }
      if (payload.nbf > clockTimestamp + (options2.clockTolerance || 0)) {
        return done2(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
      }
    }
    if (typeof payload.exp !== "undefined" && !options2.ignoreExpiration) {
      if (typeof payload.exp !== "number") {
        return done2(new JsonWebTokenError("invalid exp value"));
      }
      if (clockTimestamp >= payload.exp + (options2.clockTolerance || 0)) {
        return done2(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
      }
    }
    if (options2.audience) {
      const audiences = Array.isArray(options2.audience) ? options2.audience : [options2.audience];
      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
      const match2 = target.some(function(targetAudience) {
        return audiences.some(function(audience) {
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
        });
      });
      if (!match2) {
        return done2(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
      }
    }
    if (options2.issuer) {
      const invalid_issuer = typeof options2.issuer === "string" && payload.iss !== options2.issuer || Array.isArray(options2.issuer) && options2.issuer.indexOf(payload.iss) === -1;
      if (invalid_issuer) {
        return done2(new JsonWebTokenError("jwt issuer invalid. expected: " + options2.issuer));
      }
    }
    if (options2.subject) {
      if (payload.sub !== options2.subject) {
        return done2(new JsonWebTokenError("jwt subject invalid. expected: " + options2.subject));
      }
    }
    if (options2.jwtid) {
      if (payload.jti !== options2.jwtid) {
        return done2(new JsonWebTokenError("jwt jwtid invalid. expected: " + options2.jwtid));
      }
    }
    if (options2.nonce) {
      if (payload.nonce !== options2.nonce) {
        return done2(new JsonWebTokenError("jwt nonce invalid. expected: " + options2.nonce));
      }
    }
    if (options2.maxAge) {
      if (typeof payload.iat !== "number") {
        return done2(new JsonWebTokenError("iat required when maxAge is specified"));
      }
      const maxAgeTimestamp = timespan$1(options2.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === "undefined") {
        return done2(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
      if (clockTimestamp >= maxAgeTimestamp + (options2.clockTolerance || 0)) {
        return done2(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
      }
    }
    if (options2.complete === true) {
      const signature2 = decodedToken.signature;
      return done2(null, {
        header: header3,
        payload,
        signature: signature2
      });
    }
    return done2(null, payload);
  });
};
var INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = 0 / 0;
var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
var reTrim$2 = /^\s+|\s+$/g;
var reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$2 = /^0b[01]+$/i;
var reIsOctal$2 = /^0o[0-7]+$/i;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeParseInt$2 = parseInt;
function arrayMap(array, iteratee) {
  var index2 = -1, length2 = array ? array.length : 0, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$1 = objectProto$6.hasOwnProperty;
var objectToString$6 = objectProto$6.toString;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(value, inherited) {
  var result = isArray$1(value) || isArguments$1(value) ? baseTimes(value.length, String) : [];
  var length2 = result.length, skipIndexes = !!length2;
  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$1.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isIndex(value, length2) {
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto2;
}
function includes$2(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = fromIndex && !guard ? toInteger$2(fromIndex) : 0;
  var length2 = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length2 + fromIndex, 0);
  }
  return isString$2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
}
function isArguments$1(value) {
  return isArrayLikeObject(value) && hasOwnProperty$1.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString$6.call(value) == argsTag);
}
var isArray$1 = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike$6(value) && isArrayLike(value);
}
function isFunction(value) {
  var tag = isObject$2(value) ? objectToString$6.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject$2(value) {
  var type3 = typeof value;
  return !!value && (type3 == "object" || type3 == "function");
}
function isObjectLike$6(value) {
  return !!value && typeof value == "object";
}
function isString$2(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$6(value) && objectToString$6.call(value) == stringTag$1;
}
function isSymbol$2(value) {
  return typeof value == "symbol" || isObjectLike$6(value) && objectToString$6.call(value) == symbolTag$2;
}
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$2(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign3 = value < 0 ? -1 : 1;
    return sign3 * MAX_INTEGER$2;
  }
  return value === value ? value : 0;
}
function toInteger$2(value) {
  var result = toFinite$2(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN$2;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$2, "");
  var isBinary2 = reIsBinary$2.test(value);
  return isBinary2 || reIsOctal$2.test(value) ? freeParseInt$2(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex$2.test(value) ? NAN$2 : +value;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function values(object) {
  return object ? baseValues(object, keys(object)) : [];
}
var lodash_includes = includes$2;
var boolTag = "[object Boolean]";
var objectProto$5 = Object.prototype;
var objectToString$5 = objectProto$5.toString;
function isBoolean$1(value) {
  return value === true || value === false || isObjectLike$5(value) && objectToString$5.call(value) == boolTag;
}
function isObjectLike$5(value) {
  return !!value && typeof value == "object";
}
var lodash_isboolean = isBoolean$1;
var INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = 0 / 0;
var symbolTag$1 = "[object Symbol]";
var reTrim$1 = /^\s+|\s+$/g;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
var objectProto$4 = Object.prototype;
var objectToString$4 = objectProto$4.toString;
function isInteger$1(value) {
  return typeof value == "number" && value == toInteger$1(value);
}
function isObject$1(value) {
  var type3 = typeof value;
  return !!value && (type3 == "object" || type3 == "function");
}
function isObjectLike$4(value) {
  return !!value && typeof value == "object";
}
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$4(value) && objectToString$4.call(value) == symbolTag$1;
}
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$1(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign3 = value < 0 ? -1 : 1;
    return sign3 * MAX_INTEGER$1;
  }
  return value === value ? value : 0;
}
function toInteger$1(value) {
  var result = toFinite$1(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, "");
  var isBinary2 = reIsBinary$1.test(value);
  return isBinary2 || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var lodash_isinteger = isInteger$1;
var numberTag = "[object Number]";
var objectProto$3 = Object.prototype;
var objectToString$3 = objectProto$3.toString;
function isObjectLike$3(value) {
  return !!value && typeof value == "object";
}
function isNumber$1(value) {
  return typeof value == "number" || isObjectLike$3(value) && objectToString$3.call(value) == numberTag;
}
var lodash_isnumber = isNumber$1;
var objectTag = "[object Object]";
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto$2.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
var objectToString$2 = objectProto$2.toString;
var getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(value) {
  return !!value && typeof value == "object";
}
function isPlainObject$1(value) {
  if (!isObjectLike$2(value) || objectToString$2.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto2 = getPrototype(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$1;
var stringTag = "[object String]";
var objectProto$1 = Object.prototype;
var objectToString$1 = objectProto$1.toString;
var isArray = Array.isArray;
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isString$1(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike$1(value) && objectToString$1.call(value) == stringTag;
}
var lodash_isstring = isString$1;
var FUNC_ERROR_TEXT = "Expected a function";
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
function before(n, func) {
  var result;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result;
  };
}
function once$4(func) {
  return before(2, func);
}
function isObject(value) {
  var type3 = typeof value;
  return !!value && (type3 == "object" || type3 == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign3 = value < 0 ? -1 : 1;
    return sign3 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary2 = reIsBinary.test(value);
  return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_once = once$4;
const timespan = timespan$2;
const PS_SUPPORTED = psSupported;
const validateAsymmetricKey = validateAsymmetricKey$2;
const jws = jws$3;
const includes$1 = lodash_includes;
const isBoolean = lodash_isboolean;
const isInteger = lodash_isinteger;
const isNumber = lodash_isnumber;
const isPlainObject = lodash_isplainobject;
const isString = lodash_isstring;
const once$3 = lodash_once;
const { KeyObject, createSecretKey, createPrivateKey } = require$$2$2;
const SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
if (PS_SUPPORTED) {
  SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
}
const sign_options_schema = {
  expiresIn: { isValid: function(value) {
    return isInteger(value) || isString(value) && value;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(value) {
    return isInteger(value) || isString(value) && value;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(value) {
    return isString(value) || Array.isArray(value);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes$1.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject, message: '"header" must be an object' },
  encoding: { isValid: isString, message: '"encoding" must be a string' },
  issuer: { isValid: isString, message: '"issuer" must be a string' },
  subject: { isValid: isString, message: '"subject" must be a string' },
  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
  allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
};
const registered_claims_schema = {
  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
};
function validate$4(schema, allowUnknown, object, parameterName) {
  if (!isPlainObject(object)) {
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
  }
  Object.keys(object).forEach(function(key) {
    const validator = schema[key];
    if (!validator) {
      if (!allowUnknown) {
        throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
      }
      return;
    }
    if (!validator.isValid(object[key])) {
      throw new Error(validator.message);
    }
  });
}
function validateOptions(options2) {
  return validate$4(sign_options_schema, false, options2, "options");
}
function validatePayload(payload) {
  return validate$4(registered_claims_schema, true, payload, "payload");
}
const options_to_payload = {
  "audience": "aud",
  "issuer": "iss",
  "subject": "sub",
  "jwtid": "jti"
};
const options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
];
var sign2 = function(payload, secretOrPrivateKey, options2, callback) {
  if (typeof options2 === "function") {
    callback = options2;
    options2 = {};
  } else {
    options2 = options2 || {};
  }
  const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
  const header3 = Object.assign({
    alg: options2.algorithm || "HS256",
    typ: isObjectPayload ? "JWT" : void 0,
    kid: options2.keyid
  }, options2.header);
  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }
  if (!secretOrPrivateKey && options2.algorithm !== "none") {
    return failure(new Error("secretOrPrivateKey must have a value"));
  }
  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
    try {
      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
    } catch (_) {
      try {
        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
      } catch (_2) {
        return failure(new Error("secretOrPrivateKey is not valid key material"));
      }
    }
  }
  if (header3.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
    return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header3.alg}`));
  } else if (/^(?:RS|PS|ES)/.test(header3.alg)) {
    if (secretOrPrivateKey.type !== "private") {
      return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header3.alg}`));
    }
    if (!options2.allowInsecureKeySizes && !header3.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
    secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header3.alg}`));
    }
  }
  if (typeof payload === "undefined") {
    return failure(new Error("payload is required"));
  } else if (isObjectPayload) {
    try {
      validatePayload(payload);
    } catch (error3) {
      return failure(error3);
    }
    if (!options2.mutatePayload) {
      payload = Object.assign({}, payload);
    }
  } else {
    const invalid_options = options_for_objects.filter(function(opt) {
      return typeof options2[opt] !== "undefined";
    });
    if (invalid_options.length > 0) {
      return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
    }
  }
  if (typeof payload.exp !== "undefined" && typeof options2.expiresIn !== "undefined") {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }
  if (typeof payload.nbf !== "undefined" && typeof options2.notBefore !== "undefined") {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }
  try {
    validateOptions(options2);
  } catch (error3) {
    return failure(error3);
  }
  if (!options2.allowInvalidAsymmetricKeyTypes) {
    try {
      validateAsymmetricKey(header3.alg, secretOrPrivateKey);
    } catch (error3) {
      return failure(error3);
    }
  }
  const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
  if (options2.noTimestamp) {
    delete payload.iat;
  } else if (isObjectPayload) {
    payload.iat = timestamp;
  }
  if (typeof options2.notBefore !== "undefined") {
    try {
      payload.nbf = timespan(options2.notBefore, timestamp);
    } catch (err) {
      return failure(err);
    }
    if (typeof payload.nbf === "undefined") {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }
  if (typeof options2.expiresIn !== "undefined" && typeof payload === "object") {
    try {
      payload.exp = timespan(options2.expiresIn, timestamp);
    } catch (err) {
      return failure(err);
    }
    if (typeof payload.exp === "undefined") {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }
  Object.keys(options_to_payload).forEach(function(key) {
    const claim = options_to_payload[key];
    if (typeof options2[key] !== "undefined") {
      if (typeof payload[claim] !== "undefined") {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options2[key];
    }
  });
  const encoding3 = options2.encoding || "utf8";
  if (typeof callback === "function") {
    callback = callback && once$3(callback);
    jws.createSign({
      header: header3,
      privateKey: secretOrPrivateKey,
      payload,
      encoding: encoding3
    }).once("error", callback).once("done", function(signature2) {
      if (!options2.allowInsecureKeySizes && /^(?:RS|PS)/.test(header3.alg) && signature2.length < 256) {
        return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header3.alg}`));
      }
      callback(null, signature2);
    });
  } else {
    let signature2 = jws.sign({ header: header3, payload, secret: secretOrPrivateKey, encoding: encoding3 });
    if (!options2.allowInsecureKeySizes && /^(?:RS|PS)/.test(header3.alg) && signature2.length < 256) {
      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header3.alg}`);
    }
    return signature2;
  }
};
var jsonwebtoken = {
  decode: decode$1,
  verify: verify2,
  sign: sign2,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
};
const jwt = /* @__PURE__ */ getDefaultExportFromCjs(jsonwebtoken);
const Schema$1 = mongoose.Schema;
const userSchema = new Schema$1({
  username: {
    type: String,
    required: true
  },
  email: {
    type: String,
    required: true
  },
  password: {
    type: String,
    required: true
  },
  avatar: {
    type: String
  },
  room: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Room"
  },
  socketId: {
    type: String
  }
});
const User$1 = mongoose.model("User", userSchema);
var define_process_env_default$3 = {};
const authenticate = async (req2, res2, next) => {
  try {
    const accessToken = req2.cookies.token;
    const refreshToken = req2.cookies.refreshToken;
    if (!accessToken || !refreshToken) {
      return res2.redirect("/");
    }
    jwt.verify(
      accessToken,
      define_process_env_default$3.JWT_SECRET,
      async (accessTokenErr, decoded) => {
        if (accessTokenErr) {
          jwt.verify(
            refreshToken,
            define_process_env_default$3.JWT_REFRESH_SECRET,
            async (refreshTokenErr, decodedRefresh) => {
              if (refreshTokenErr) {
                return res2.redirect("/");
              } else {
                const newAccessToken = jwt.sign(
                  { userId: decodedRefresh.userId },
                  define_process_env_default$3.JWT_SECRET,
                  { expiresIn: "30s" }
                );
                req2.accessToken = newAccessToken;
                const user = await User$1.findById(
                  decodedRefresh.userId
                );
                if (!user) {
                  res2.redirect("/");
                }
                req2.user = user;
                next();
              }
            }
          );
        } else {
          req2.userId = decoded.userId;
          const user = await User$1.findById(decoded.userId);
          if (!user) {
            throw new Error("User not found");
          }
          req2.user = user;
          next();
        }
      }
    );
  } catch (error3) {
    console.error(error3);
    res2.status(500).json({ error: "Internal Server Error" });
  }
};
var bcrypt$1 = { exports: {} };
var nodePreGyp = { exports: {} };
var s3_setup = { exports: {} };
(function(module, exports2) {
  var define_process_env_default2 = {};
  module.exports = exports2;
  const url2 = require$$2$2;
  const fs2 = require$$2$2;
  const path3 = pathExports;
  module.exports.detect = function(opts, config2) {
    const to = opts.hosted_path;
    const uri2 = url2.parse(to);
    config2.prefix = !uri2.pathname || uri2.pathname === "/" ? "" : uri2.pathname.replace("/", "");
    if (opts.bucket && opts.region) {
      config2.bucket = opts.bucket;
      config2.region = opts.region;
      config2.endpoint = opts.host;
      config2.s3ForcePathStyle = opts.s3ForcePathStyle;
    } else {
      const parts = uri2.hostname.split(".s3");
      const bucket = parts[0];
      if (!bucket) {
        return;
      }
      if (!config2.bucket) {
        config2.bucket = bucket;
      }
      if (!config2.region) {
        const region = parts[1].slice(1).split(".")[0];
        if (region === "amazonaws") {
          config2.region = "us-east-1";
        } else {
          config2.region = region;
        }
      }
    }
  };
  module.exports.get_s3 = function(config2) {
    if (define_process_env_default2.node_pre_gyp_mock_s3) {
      const AWSMock = require$$3$1;
      const os2 = require$$2$2;
      AWSMock.config.basePath = `${os2.tmpdir()}/mock`;
      const s32 = AWSMock.S3();
      const wcb = (fn) => (err, ...args) => {
        if (err && err.code === "ENOENT") {
          err.code = "NotFound";
        }
        return fn(err, ...args);
      };
      return {
        listObjects(params, callback) {
          return s32.listObjects(params, wcb(callback));
        },
        headObject(params, callback) {
          return s32.headObject(params, wcb(callback));
        },
        deleteObject(params, callback) {
          return s32.deleteObject(params, wcb(callback));
        },
        putObject(params, callback) {
          return s32.putObject(params, wcb(callback));
        }
      };
    }
    const AWS = require$$5$2;
    AWS.config.update(config2);
    const s3 = new AWS.S3();
    return {
      listObjects(params, callback) {
        return s3.listObjects(params, callback);
      },
      headObject(params, callback) {
        return s3.headObject(params, callback);
      },
      deleteObject(params, callback) {
        return s3.deleteObject(params, callback);
      },
      putObject(params, callback) {
        return s3.putObject(params, callback);
      }
    };
  };
  module.exports.get_mockS3Http = function() {
    let mock_s3 = false;
    if (!define_process_env_default2.node_pre_gyp_mock_s3) {
      return () => mock_s3;
    }
    const nock = require$$6$1;
    const host2 = "https://mapbox-node-pre-gyp-public-testing-bucket.s3.us-east-1.amazonaws.com";
    const mockDir = define_process_env_default2.node_pre_gyp_mock_s3 + "/mapbox-node-pre-gyp-public-testing-bucket";
    const mock_http = () => {
      function get2(uri2, requestBody) {
        const filepath = path3.join(mockDir, uri2.replace("%2B", "+"));
        try {
          fs2.accessSync(filepath, fs2.constants.R_OK);
        } catch (e) {
          return [404, "not found\n"];
        }
        return [200, fs2.createReadStream(filepath)];
      }
      return nock(host2).persist().get(() => mock_s3).reply(get2);
    };
    mock_http();
    const mockS3Http = (action) => {
      const previous = mock_s3;
      if (action === "off") {
        mock_s3 = false;
      } else if (action === "on") {
        mock_s3 = true;
      } else if (action !== "get") {
        throw new Error(`illegal action for setMockHttp ${action}`);
      }
      return previous;
    };
    return mockS3Http;
  };
})(s3_setup, s3_setup.exports);
var s3_setupExports = s3_setup.exports;
var nopt = { exports: {} };
var abbrev = { exports: {} };
(function(module, exports2) {
  module.exports = abbrev2.abbrev = abbrev2;
  abbrev2.monkeyPatch = monkeyPatch;
  function monkeyPatch() {
    Object.defineProperty(Array.prototype, "abbrev", {
      value: function() {
        return abbrev2(this);
      },
      enumerable: false,
      configurable: true,
      writable: true
    });
    Object.defineProperty(Object.prototype, "abbrev", {
      value: function() {
        return abbrev2(Object.keys(this));
      },
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  function abbrev2(list) {
    if (arguments.length !== 1 || !Array.isArray(list)) {
      list = Array.prototype.slice.call(arguments, 0);
    }
    for (var i2 = 0, l = list.length, args = []; i2 < l; i2++) {
      args[i2] = typeof list[i2] === "string" ? list[i2] : String(list[i2]);
    }
    args = args.sort(lexSort);
    var abbrevs = {}, prev2 = "";
    for (var i2 = 0, l = args.length; i2 < l; i2++) {
      var current = args[i2], next = args[i2 + 1] || "", nextMatches = true, prevMatches = true;
      if (current === next)
        continue;
      for (var j = 0, cl = current.length; j < cl; j++) {
        var curChar = current.charAt(j);
        nextMatches = nextMatches && curChar === next.charAt(j);
        prevMatches = prevMatches && curChar === prev2.charAt(j);
        if (!nextMatches && !prevMatches) {
          j++;
          break;
        }
      }
      prev2 = current;
      if (j === cl) {
        abbrevs[current] = current;
        continue;
      }
      for (var a = current.substr(0, j); j <= cl; j++) {
        abbrevs[a] = current;
        a += current.charAt(j);
      }
    }
    return abbrevs;
  }
  function lexSort(a, b) {
    return a === b ? 0 : a > b ? 1 : -1;
  }
})(abbrev);
var abbrevExports = abbrev.exports;
(function(module, exports2) {
  var define_process_env_default2 = {};
  var debug2 = define_process_env_default2.DEBUG_NOPT || define_process_env_default2.NOPT_DEBUG ? function() {
    console.error.apply(console, arguments);
  } : function() {
  };
  var url2 = require$$2$2, path3 = pathExports, Stream2 = require$$2$2.Stream, abbrev2 = abbrevExports, os2 = require$$2$2;
  module.exports = exports2 = nopt2;
  exports2.clean = clean2;
  exports2.typeDefs = {
    String: { type: String, validate: validateString },
    Boolean: { type: Boolean, validate: validateBoolean },
    url: { type: url2, validate: validateUrl },
    Number: { type: Number, validate: validateNumber },
    path: { type: path3, validate: validatePath },
    Stream: { type: Stream2, validate: validateStream },
    Date: { type: Date, validate: validateDate }
  };
  function nopt2(types2, shorthands, args, slice2) {
    args = args || process.argv;
    types2 = types2 || {};
    shorthands = shorthands || {};
    if (typeof slice2 !== "number")
      slice2 = 2;
    debug2(types2, shorthands, args, slice2);
    args = args.slice(slice2);
    var data = {}, argv = {
      remain: [],
      cooked: args,
      original: args.slice(0)
    };
    parse2(args, data, argv.remain, types2, shorthands);
    clean2(data, types2, exports2.typeDefs);
    data.argv = argv;
    Object.defineProperty(data.argv, "toString", { value: function() {
      return this.original.map(JSON.stringify).join(" ");
    }, enumerable: false });
    return data;
  }
  function clean2(data, types2, typeDefs) {
    typeDefs = typeDefs || exports2.typeDefs;
    var remove = {}, typeDefault = [false, true, null, String, Array];
    Object.keys(data).forEach(function(k) {
      if (k === "argv")
        return;
      var val = data[k], isArray2 = Array.isArray(val), type3 = types2[k];
      if (!isArray2)
        val = [val];
      if (!type3)
        type3 = typeDefault;
      if (type3 === Array)
        type3 = typeDefault.concat(Array);
      if (!Array.isArray(type3))
        type3 = [type3];
      debug2("val=%j", val);
      debug2("types=", type3);
      val = val.map(function(val2) {
        if (typeof val2 === "string") {
          debug2("string %j", val2);
          val2 = val2.trim();
          if (val2 === "null" && ~type3.indexOf(null) || val2 === "true" && (~type3.indexOf(true) || ~type3.indexOf(Boolean)) || val2 === "false" && (~type3.indexOf(false) || ~type3.indexOf(Boolean))) {
            val2 = JSON.parse(val2);
            debug2("jsonable %j", val2);
          } else if (~type3.indexOf(Number) && !isNaN(val2)) {
            debug2("convert to number", val2);
            val2 = +val2;
          } else if (~type3.indexOf(Date) && !isNaN(Date.parse(val2))) {
            debug2("convert to date", val2);
            val2 = new Date(val2);
          }
        }
        if (!types2.hasOwnProperty(k)) {
          return val2;
        }
        if (val2 === false && ~type3.indexOf(null) && !(~type3.indexOf(false) || ~type3.indexOf(Boolean))) {
          val2 = null;
        }
        var d2 = {};
        d2[k] = val2;
        debug2("prevalidated val", d2, val2, types2[k]);
        if (!validate2(d2, k, val2, types2[k], typeDefs)) {
          if (exports2.invalidHandler) {
            exports2.invalidHandler(k, val2, types2[k], data);
          } else if (exports2.invalidHandler !== false) {
            debug2("invalid: " + k + "=" + val2, types2[k]);
          }
          return remove;
        }
        debug2("validated val", d2, val2, types2[k]);
        return d2[k];
      }).filter(function(val2) {
        return val2 !== remove;
      });
      if (!val.length && type3.indexOf(Array) === -1) {
        debug2("VAL HAS NO LENGTH, DELETE IT", val, k, type3.indexOf(Array));
        delete data[k];
      } else if (isArray2) {
        debug2(isArray2, data[k], val);
        data[k] = val;
      } else
        data[k] = val[0];
      debug2("k=%s val=%j", k, val, data[k]);
    });
  }
  function validateString(data, k, val) {
    data[k] = String(val);
  }
  function validatePath(data, k, val) {
    if (val === true)
      return false;
    if (val === null)
      return true;
    val = String(val);
    var isWin = process.platform === "win32", homePattern = isWin ? /^~(\/|\\)/ : /^~\//, home = os2.homedir();
    if (home && val.match(homePattern)) {
      data[k] = path3.resolve(home, val.substr(2));
    } else {
      data[k] = path3.resolve(val);
    }
    return true;
  }
  function validateNumber(data, k, val) {
    debug2("validate Number %j %j %j", k, val, isNaN(val));
    if (isNaN(val))
      return false;
    data[k] = +val;
  }
  function validateDate(data, k, val) {
    var s2 = Date.parse(val);
    debug2("validate Date %j %j %j", k, val, s2);
    if (isNaN(s2))
      return false;
    data[k] = new Date(val);
  }
  function validateBoolean(data, k, val) {
    if (val instanceof Boolean)
      val = val.valueOf();
    else if (typeof val === "string") {
      if (!isNaN(val))
        val = !!+val;
      else if (val === "null" || val === "false")
        val = false;
      else
        val = true;
    } else
      val = !!val;
    data[k] = val;
  }
  function validateUrl(data, k, val) {
    val = url2.parse(String(val));
    if (!val.host)
      return false;
    data[k] = val.href;
  }
  function validateStream(data, k, val) {
    if (!(val instanceof Stream2))
      return false;
    data[k] = val;
  }
  function validate2(data, k, val, type3, typeDefs) {
    if (Array.isArray(type3)) {
      for (var i2 = 0, l = type3.length; i2 < l; i2++) {
        if (type3[i2] === Array)
          continue;
        if (validate2(data, k, val, type3[i2], typeDefs))
          return true;
      }
      delete data[k];
      return false;
    }
    if (type3 === Array)
      return true;
    if (type3 !== type3) {
      debug2("Poison NaN", k, val, type3);
      delete data[k];
      return false;
    }
    if (val === type3) {
      debug2("Explicitly allowed %j", val);
      data[k] = val;
      return true;
    }
    var ok = false, types2 = Object.keys(typeDefs);
    for (var i2 = 0, l = types2.length; i2 < l; i2++) {
      debug2("test type %j %j %j", k, val, types2[i2]);
      var t2 = typeDefs[types2[i2]];
      if (t2 && (type3 && type3.name && t2.type && t2.type.name ? type3.name === t2.type.name : type3 === t2.type)) {
        var d2 = {};
        ok = false !== t2.validate(d2, k, val);
        val = d2[k];
        if (ok) {
          data[k] = val;
          break;
        }
      }
    }
    debug2("OK? %j (%j %j %j)", ok, k, val, types2[i2]);
    if (!ok)
      delete data[k];
    return ok;
  }
  function parse2(args, data, remain, types2, shorthands) {
    debug2("parse", args, data, remain);
    var abbrevs = abbrev2(Object.keys(types2)), shortAbbr = abbrev2(Object.keys(shorthands));
    for (var i2 = 0; i2 < args.length; i2++) {
      var arg = args[i2];
      debug2("arg", arg);
      if (arg.match(/^-{2,}$/)) {
        remain.push.apply(remain, args.slice(i2 + 1));
        args[i2] = "--";
        break;
      }
      var hadEq = false;
      if (arg.charAt(0) === "-" && arg.length > 1) {
        var at = arg.indexOf("=");
        if (at > -1) {
          hadEq = true;
          var v = arg.substr(at + 1);
          arg = arg.substr(0, at);
          args.splice(i2, 1, arg, v);
        }
        var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);
        debug2("arg=%j shRes=%j", arg, shRes);
        if (shRes) {
          debug2(arg, shRes);
          args.splice.apply(args, [i2, 1].concat(shRes));
          if (arg !== shRes[0]) {
            i2--;
            continue;
          }
        }
        arg = arg.replace(/^-+/, "");
        var no = null;
        while (arg.toLowerCase().indexOf("no-") === 0) {
          no = !no;
          arg = arg.substr(3);
        }
        if (abbrevs[arg])
          arg = abbrevs[arg];
        var argType = types2[arg];
        var isTypeArray = Array.isArray(argType);
        if (isTypeArray && argType.length === 1) {
          isTypeArray = false;
          argType = argType[0];
        }
        var isArray2 = argType === Array || isTypeArray && argType.indexOf(Array) !== -1;
        if (!types2.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
          if (!Array.isArray(data[arg]))
            data[arg] = [data[arg]];
          isArray2 = true;
        }
        var val, la = args[i2 + 1];
        var isBool = typeof no === "boolean" || argType === Boolean || isTypeArray && argType.indexOf(Boolean) !== -1 || typeof argType === "undefined" && !hadEq || la === "false" && (argType === null || isTypeArray && ~argType.indexOf(null));
        if (isBool) {
          val = !no;
          if (la === "true" || la === "false") {
            val = JSON.parse(la);
            la = null;
            if (no)
              val = !val;
            i2++;
          }
          if (isTypeArray && la) {
            if (~argType.indexOf(la)) {
              val = la;
              i2++;
            } else if (la === "null" && ~argType.indexOf(null)) {
              val = null;
              i2++;
            } else if (!la.match(/^-{2,}[^-]/) && !isNaN(la) && ~argType.indexOf(Number)) {
              val = +la;
              i2++;
            } else if (!la.match(/^-[^-]/) && ~argType.indexOf(String)) {
              val = la;
              i2++;
            }
          }
          if (isArray2)
            (data[arg] = data[arg] || []).push(val);
          else
            data[arg] = val;
          continue;
        }
        if (argType === String) {
          if (la === void 0) {
            la = "";
          } else if (la.match(/^-{1,2}[^-]+/)) {
            la = "";
            i2--;
          }
        }
        if (la && la.match(/^-{2,}$/)) {
          la = void 0;
          i2--;
        }
        val = la === void 0 ? true : la;
        if (isArray2)
          (data[arg] = data[arg] || []).push(val);
        else
          data[arg] = val;
        i2++;
        continue;
      }
      remain.push(arg);
    }
  }
  function resolveShort(arg, shorthands, shortAbbr, abbrevs) {
    arg = arg.replace(/^-+/, "");
    if (abbrevs[arg] === arg)
      return null;
    if (shorthands[arg]) {
      if (shorthands[arg] && !Array.isArray(shorthands[arg]))
        shorthands[arg] = shorthands[arg].split(/\s+/);
      return shorthands[arg];
    }
    var singles = shorthands.___singles;
    if (!singles) {
      singles = Object.keys(shorthands).filter(function(s2) {
        return s2.length === 1;
      }).reduce(function(l, r) {
        l[r] = true;
        return l;
      }, {});
      shorthands.___singles = singles;
      debug2("shorthand singles", singles);
    }
    var chrs = arg.split("").filter(function(c) {
      return singles[c];
    });
    if (chrs.join("") === arg)
      return chrs.map(function(c) {
        return shorthands[c];
      }).reduce(function(l, r) {
        return l.concat(r);
      }, []);
    if (abbrevs[arg] && !shorthands[arg])
      return null;
    if (shortAbbr[arg])
      arg = shortAbbr[arg];
    if (shorthands[arg] && !Array.isArray(shorthands[arg]))
      shorthands[arg] = shorthands[arg].split(/\s+/);
    return shorthands[arg];
  }
})(nopt, nopt.exports);
var noptExports = nopt.exports;
var log = { exports: {} };
var lib = {};
var trackerGroup = { exports: {} };
var trackerBase = { exports: {} };
var EventEmitter = require$$2$2.EventEmitter;
var util$4 = util$f;
var trackerId = 0;
var TrackerBase$2 = trackerBase.exports = function(name2) {
  EventEmitter.call(this);
  this.id = ++trackerId;
  this.name = name2;
};
util$4.inherits(TrackerBase$2, EventEmitter);
var trackerBaseExports = trackerBase.exports;
var tracker = { exports: {} };
var util$3 = util$f;
var TrackerBase$1 = trackerBaseExports;
var Tracker$2 = tracker.exports = function(name2, todo) {
  TrackerBase$1.call(this, name2);
  this.workDone = 0;
  this.workTodo = todo || 0;
};
util$3.inherits(Tracker$2, TrackerBase$1);
Tracker$2.prototype.completed = function() {
  return this.workTodo === 0 ? 0 : this.workDone / this.workTodo;
};
Tracker$2.prototype.addWork = function(work) {
  this.workTodo += work;
  this.emit("change", this.name, this.completed(), this);
};
Tracker$2.prototype.completeWork = function(work) {
  this.workDone += work;
  if (this.workDone > this.workTodo) {
    this.workDone = this.workTodo;
  }
  this.emit("change", this.name, this.completed(), this);
};
Tracker$2.prototype.finish = function() {
  this.workTodo = this.workDone = 1;
  this.emit("change", this.name, 1, this);
};
var trackerExports = tracker.exports;
var trackerStream = { exports: {} };
var readableBrowser = { exports: {} };
var streamBrowser = require$$2$2.EventEmitter;
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res2 = prim.call(input, hint || "default");
      if (typeof res2 !== "object")
        return res2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = require$$2$2, Buffer2 = _require.Buffer;
  var _require2 = require$$2$2, inspect2 = _require2.inspect;
  var custom = inspect2 && inspect2.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push2(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift2(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s2) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next)
          ret += s2 + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i2 = 0;
        while (p) {
          copyBuffer(p.data, ret, i2);
          i2 += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first2() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_, options2) {
        return inspect2(this, _objectSpread(_objectSpread({}, options2), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy(stream3, err) {
  var rState = stream3._readableState;
  var wState = stream3._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream3.destroy(err);
  else
    stream3.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i2) {
      return String(i2);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes(str, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
  return 'The value "' + value + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith(name2, " argument")) {
    msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type3 = includes(name2, ".") ? "property" : "argument";
    msg = 'The "'.concat(name2, '" ').concat(type3, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options2, isDuplex, duplexKey) {
  return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
}
function getHighWaterMark(state2, options2, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
};
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex2;
  Writable2.WritableState = WritableState;
  var internalUtil = {
    deprecate: browser$1
  };
  var Stream2 = streamBrowser;
  var Buffer2 = require$$2$2.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK2 = _require$codes2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED2 = _require$codes2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes2.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  inherits_browserExports(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options2, stream3, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream3 instanceof Duplex2;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.writableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options2, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options2.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream3, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable2)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable2(options2) {
    Duplex2 = Duplex2 || require_stream_duplex();
    var isDuplex = this instanceof Duplex2;
    if (!isDuplex && !realHasInstance.call(Writable2, this))
      return new Writable2(options2);
    this._writableState = new WritableState(options2, this, isDuplex);
    this.writable = true;
    if (options2) {
      if (typeof options2.write === "function")
        this._write = options2.write;
      if (typeof options2.writev === "function")
        this._writev = options2.writev;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
      if (typeof options2.final === "function")
        this._final = options2.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream3, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy2(stream3, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream3, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy2(stream3, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable2.prototype.write = function(chunk, encoding3, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding3 === "function") {
      cb = encoding3;
      encoding3 = null;
    }
    if (isBuf)
      encoding3 = "buffer";
    else if (!encoding3)
      encoding3 = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding3, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding3) {
    if (typeof encoding3 === "string")
      encoding3 = encoding3.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding3 + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding3);
    this._writableState.defaultEncoding = encoding3;
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding3) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding3);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream3, state2, isBuf, chunk, encoding3, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding3);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding3 = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding: encoding3,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream3, state2, false, len, chunk, encoding3, cb);
    }
    return ret;
  }
  function doWrite(stream3, state2, writev, len, chunk, encoding3, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed)
      state2.onwrite(new ERR_STREAM_DESTROYED2("write"));
    else if (writev)
      stream3._writev(chunk, state2.onwrite);
    else
      stream3._write(chunk, encoding3, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream3, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream3, state2);
      stream3._writableState.errorEmitted = true;
      errorOrDestroy2(stream3, er);
    } else {
      cb(er);
      stream3._writableState.errorEmitted = true;
      errorOrDestroy2(stream3, er);
      finishMaybe(stream3, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream3, er) {
    var state2 = stream3._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK2();
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream3, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2) || stream3.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream3, state2);
      }
      if (sync3) {
        process.nextTick(afterWrite, stream3, state2, finished, cb);
      } else {
        afterWrite(stream3, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream3, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream3, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream3, state2);
  }
  function onwriteDrain(stream3, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream3.emit("drain");
    }
  }
  function clearBuffer(stream3, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream3._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream3, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding3 = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream3, state2, false, len, chunk, encoding3, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding3, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED2("_write()"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding3, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding3 = null;
    } else if (typeof encoding3 === "function") {
      cb = encoding3;
      encoding3 = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding3);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream3, state2) {
    stream3._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy2(stream3, err);
      }
      state2.prefinished = true;
      stream3.emit("prefinish");
      finishMaybe(stream3, state2);
    });
  }
  function prefinish2(stream3, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream3._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream3, state2);
      } else {
        state2.prefinished = true;
        stream3.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream3, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish2(stream3, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream3.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream3._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream3.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream3, state2, cb) {
    state2.ending = true;
    finishMaybe(stream3, state2);
    if (cb) {
      if (state2.finished)
        process.nextTick(cb);
      else
        stream3.once("finish", cb);
    }
    state2.ended = true;
    stream3.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key in obj)
      keys3.push(key);
    return keys3;
  };
  _stream_duplex = Duplex2;
  var Readable2 = require_stream_readable();
  var Writable2 = require_stream_writable();
  inherits_browserExports(Duplex2, Readable2);
  {
    var keys2 = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys2.length; v++) {
      var method = keys2[v];
      if (!Duplex2.prototype[method])
        Duplex2.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex2(options2) {
    if (!(this instanceof Duplex2))
      return new Duplex2(options2);
    Readable2.call(this, options2);
    Writable2.call(this, options2);
    this.allowHalfOpen = true;
    if (options2) {
      if (options2.readable === false)
        this.readable = false;
      if (options2.writable === false)
        this.writable = false;
      if (options2.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$2(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream3) {
  return stream3.setHeader && typeof stream3.abort === "function";
}
function eos$1(stream3, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream3, null, opts);
  if (!opts)
    opts = {};
  callback = once$2(callback || noop$1);
  var readable = opts.readable || opts.readable !== false && stream3.readable;
  var writable = opts.writable || opts.writable !== false && stream3.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream3.writable)
      onfinish();
  };
  var writableEnded = stream3._writableState && stream3._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream3);
  };
  var readableEnded = stream3._readableState && stream3._readableState.endEmitted;
  var onend = function onend2() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream3);
  };
  var onerror = function onerror2(err) {
    callback.call(stream3, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream3._readableState || !stream3._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream3, err);
    }
    if (writable && !writableEnded) {
      if (!stream3._writableState || !stream3._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream3, err);
    }
  };
  var onrequest = function onrequest2() {
    stream3.req.on("finish", onfinish);
  };
  if (isRequest$1(stream3)) {
    stream3.on("complete", onfinish);
    stream3.on("abort", onclose);
    if (stream3.req)
      onrequest();
    else
      stream3.on("request", onrequest);
  } else if (writable && !stream3._writableState) {
    stream3.on("end", onlegacyfinish);
    stream3.on("close", onlegacyfinish);
  }
  stream3.on("end", onend);
  stream3.on("finish", onfinish);
  if (opts.error !== false)
    stream3.on("error", onerror);
  stream3.on("close", onclose);
  return function() {
    stream3.removeListener("complete", onfinish);
    stream3.removeListener("abort", onclose);
    stream3.removeListener("request", onrequest);
    if (stream3.req)
      stream3.req.removeListener("finish", onfinish);
    stream3.removeListener("end", onlegacyfinish);
    stream3.removeListener("close", onlegacyfinish);
    stream3.removeListener("finish", onfinish);
    stream3.removeListener("end", onend);
    stream3.removeListener("error", onerror);
    stream3.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res2 = prim.call(input, hint || "default");
      if (typeof res2 !== "object")
        return res2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError2 = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done2) {
    return {
      value,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error3 = this[kError2];
      if (error3 !== null) {
        return Promise.reject(error3);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          process.nextTick(function() {
            if (_this[kError2]) {
              reject(_this[kError2]);
            } else {
              resolve3(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve3(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream3) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream3,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError2, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream3._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve3, reject) {
        var data = iterator2[kStream].read();
        if (data) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve3(createIterResult(data, false));
        } else {
          iterator2[kLastResolve] = resolve3;
          iterator2[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream3, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator2[kLastReject];
        if (reject !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject(err);
        }
        iterator2[kError2] = err;
        return;
      }
      var resolve3 = iterator2[kLastResolve];
      if (resolve3 !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve3(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream3.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser)
    return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable2;
  var Duplex2;
  Readable2.ReadableState = ReadableState;
  require$$2$2.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type3) {
    return emitter.listeners(type3).length;
  };
  var Stream2 = streamBrowser;
  var Buffer2 = require$$2$2.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$2$2;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = destroy_1;
  var _require = state, getHighWaterMark2 = _require.getHighWaterMark;
  var _require$codes2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED2 = _require$codes2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  inherits_browserExports(Readable2, Stream2);
  var errorOrDestroy2 = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options2, stream3, isDuplex) {
    Duplex2 = Duplex2 || require_stream_duplex();
    options2 = options2 || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream3 instanceof Duplex2;
    this.objectMode = !!options2.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options2.readableObjectMode;
    this.highWaterMark = getHighWaterMark2(this, options2, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options2.emitClose !== false;
    this.autoDestroy = !!options2.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options2.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options2.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder$1().StringDecoder;
      this.decoder = new StringDecoder(options2.encoding);
      this.encoding = options2.encoding;
    }
  }
  function Readable2(options2) {
    Duplex2 = Duplex2 || require_stream_duplex();
    if (!(this instanceof Readable2))
      return new Readable2(options2);
    var isDuplex = this instanceof Duplex2;
    this._readableState = new ReadableState(options2, this, isDuplex);
    this.readable = true;
    if (options2) {
      if (typeof options2.read === "function")
        this._read = options2.read;
      if (typeof options2.destroy === "function")
        this._destroy = options2.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding3) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding3 = encoding3 || state2.defaultEncoding;
        if (encoding3 !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding3);
          encoding3 = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding3, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream3, chunk, encoding3, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream3._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream3, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy2(stream3, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            errorOrDestroy2(stream3, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream3, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy2(stream3, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding3) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream3, state2, chunk, false);
            else
              maybeReadMore(stream3, state2);
          } else {
            addChunk(stream3, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream3, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream3, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream3.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream3);
    }
    maybeReadMore(stream3, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder$1().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream3, state2) {
    debug2("onEofChunk");
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream3);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream3);
      }
    }
  }
  function emitReadable(stream3) {
    var state2 = stream3._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream3);
    }
  }
  function emitReadable_(stream3) {
    var state2 = stream3._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream3.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream3);
  }
  function maybeReadMore(stream3, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream3, state2);
    }
  }
  function maybeReadMore_(stream3, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug2("maybeReadMore read 0");
      stream3.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    errorOrDestroy2(this, new ERR_METHOD_NOT_IMPLEMENTED2("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe2;
    if (state2.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug2("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe2);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe2();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy2(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe2();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe2();
    }
    dest.once("finish", onfinish);
    function unpipe2() {
      debug2("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug2("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i2 = 0; i2 < len; i2++)
        dests[i2].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1)
      return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res2 = Stream2.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res2;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res2 = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res2;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res2 = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res2;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume2(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume2(stream3, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream3, state2);
    }
  }
  function resume_(stream3, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream3.read(0);
    }
    state2.resumeScheduled = false;
    stream3.emit("resume");
    flow(stream3);
    if (state2.flowing && !state2.reading)
      stream3.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream3) {
    var state2 = stream3._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream3.read() !== null)
      ;
  }
  Readable2.prototype.wrap = function(stream3) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream3.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream3.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream3.pause();
      }
    });
    for (var i2 in stream3) {
      if (this[i2] === void 0 && typeof stream3[i2] === "function") {
        this[i2] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream3[method].apply(stream3, arguments);
          };
        }(i2);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream3.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream3.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.first();
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream3) {
    var state2 = stream3._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream3);
    }
  }
  function endReadableNT(state2, stream3) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream3.readable = false;
      stream3.emit("end");
      if (state2.autoDestroy) {
        var wState = stream3._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream3.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf2(xs, x) {
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x)
        return i2;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options2) {
  if (!(this instanceof Transform$1))
    return new Transform$1(options2);
  Duplex.call(this, options2);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options2) {
    if (typeof options2.transform === "function")
      this._transform = options2.transform;
    if (typeof options2.flush === "function")
      this._flush = options2.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding3) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding3);
};
Transform$1.prototype._transform = function(chunk, encoding3, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding3, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding3;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err, cb) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
  });
};
function done(stream3, er, data) {
  if (er)
    return stream3.emit("error", er);
  if (data != null)
    stream3.push(data);
  if (stream3._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream3._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream3.push(null);
}
var _stream_passthrough = PassThrough;
var Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(options2) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options2);
  Transform.call(this, options2);
}
PassThrough.prototype._transform = function(chunk, encoding3, cb) {
  cb(null, chunk);
};
var eos;
function once$1(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  if (err)
    throw err;
}
function isRequest(stream3) {
  return stream3.setHeader && typeof stream3.abort === "function";
}
function destroyer(stream3, reading, writing, callback) {
  callback = once$1(callback);
  var closed = false;
  stream3.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream3, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream3))
      return stream3.abort();
    if (typeof stream3.destroy === "function")
      return stream3.destroy();
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe2(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop;
  if (typeof streams[streams.length - 1] !== "function")
    return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error3;
  var destroys = streams.map(function(stream3, i2) {
    var reading = i2 < streams.length - 1;
    var writing = i2 > 0;
    return destroyer(stream3, reading, writing, function(err) {
      if (!error3)
        error3 = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error3);
    });
  });
  return streams.reduce(pipe2);
}
var pipeline_1 = pipeline;
(function(module, exports2) {
  exports2 = module.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = _stream_transform;
  exports2.PassThrough = _stream_passthrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
var delegates = Delegator;
function Delegator(proto2, target) {
  if (!(this instanceof Delegator))
    return new Delegator(proto2, target);
  this.proto = proto2;
  this.target = target;
  this.methods = [];
  this.getters = [];
  this.setters = [];
  this.fluents = [];
}
Delegator.prototype.method = function(name2) {
  var proto2 = this.proto;
  var target = this.target;
  this.methods.push(name2);
  proto2[name2] = function() {
    return this[target][name2].apply(this[target], arguments);
  };
  return this;
};
Delegator.prototype.access = function(name2) {
  return this.getter(name2).setter(name2);
};
Delegator.prototype.getter = function(name2) {
  var proto2 = this.proto;
  var target = this.target;
  this.getters.push(name2);
  proto2.__defineGetter__(name2, function() {
    return this[target][name2];
  });
  return this;
};
Delegator.prototype.setter = function(name2) {
  var proto2 = this.proto;
  var target = this.target;
  this.setters.push(name2);
  proto2.__defineSetter__(name2, function(val) {
    return this[target][name2] = val;
  });
  return this;
};
Delegator.prototype.fluent = function(name2) {
  var proto2 = this.proto;
  var target = this.target;
  this.fluents.push(name2);
  proto2[name2] = function(val) {
    if ("undefined" != typeof val) {
      this[target][name2] = val;
      return this;
    } else {
      return this[target][name2];
    }
  };
  return this;
};
var util$2 = util$f;
var stream2 = readableBrowserExports;
var delegate = delegates;
var Tracker$1 = trackerExports;
var TrackerStream$1 = trackerStream.exports = function(name2, size, options2) {
  stream2.Transform.call(this, options2);
  this.tracker = new Tracker$1(name2, size);
  this.name = name2;
  this.id = this.tracker.id;
  this.tracker.on("change", delegateChange(this));
};
util$2.inherits(TrackerStream$1, stream2.Transform);
function delegateChange(trackerStream2) {
  return function(name2, completion, tracker2) {
    trackerStream2.emit("change", name2, completion, trackerStream2);
  };
}
TrackerStream$1.prototype._transform = function(data, encoding3, cb) {
  this.tracker.completeWork(data.length ? data.length : 1);
  this.push(data);
  cb();
};
TrackerStream$1.prototype._flush = function(cb) {
  this.tracker.finish();
  cb();
};
delegate(TrackerStream$1.prototype, "tracker").method("completed").method("addWork").method("finish");
var trackerStreamExports = trackerStream.exports;
var util$1 = util$f;
var TrackerBase = trackerBaseExports;
var Tracker = trackerExports;
var TrackerStream = trackerStreamExports;
var TrackerGroup = trackerGroup.exports = function(name2) {
  TrackerBase.call(this, name2);
  this.parentGroup = null;
  this.trackers = [];
  this.completion = {};
  this.weight = {};
  this.totalWeight = 0;
  this.finished = false;
  this.bubbleChange = bubbleChange(this);
};
util$1.inherits(TrackerGroup, TrackerBase);
function bubbleChange(trackerGroup2) {
  return function(name2, completed, tracker2) {
    trackerGroup2.completion[tracker2.id] = completed;
    if (trackerGroup2.finished) {
      return;
    }
    trackerGroup2.emit("change", name2 || trackerGroup2.name, trackerGroup2.completed(), trackerGroup2);
  };
}
TrackerGroup.prototype.nameInTree = function() {
  var names = [];
  var from = this;
  while (from) {
    names.unshift(from.name);
    from = from.parentGroup;
  }
  return names.join("/");
};
TrackerGroup.prototype.addUnit = function(unit, weight) {
  if (unit.addUnit) {
    var toTest = this;
    while (toTest) {
      if (unit === toTest) {
        throw new Error(
          "Attempted to add tracker group " + unit.name + " to tree that already includes it " + this.nameInTree(this)
        );
      }
      toTest = toTest.parentGroup;
    }
    unit.parentGroup = this;
  }
  this.weight[unit.id] = weight || 1;
  this.totalWeight += this.weight[unit.id];
  this.trackers.push(unit);
  this.completion[unit.id] = unit.completed();
  unit.on("change", this.bubbleChange);
  if (!this.finished) {
    this.emit("change", unit.name, this.completion[unit.id], unit);
  }
  return unit;
};
TrackerGroup.prototype.completed = function() {
  if (this.trackers.length === 0) {
    return 0;
  }
  var valPerWeight = 1 / this.totalWeight;
  var completed = 0;
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var trackerId2 = this.trackers[ii].id;
    completed += valPerWeight * this.weight[trackerId2] * this.completion[trackerId2];
  }
  return completed;
};
TrackerGroup.prototype.newGroup = function(name2, weight) {
  return this.addUnit(new TrackerGroup(name2), weight);
};
TrackerGroup.prototype.newItem = function(name2, todo, weight) {
  return this.addUnit(new Tracker(name2, todo), weight);
};
TrackerGroup.prototype.newStream = function(name2, todo, weight) {
  return this.addUnit(new TrackerStream(name2, todo), weight);
};
TrackerGroup.prototype.finish = function() {
  this.finished = true;
  if (!this.trackers.length) {
    this.addUnit(new Tracker(), 1, true);
  }
  for (var ii = 0; ii < this.trackers.length; ii++) {
    var tracker2 = this.trackers[ii];
    tracker2.finish();
    tracker2.removeListener("change", this.bubbleChange);
  }
  this.emit("change", this.name, 1, this);
};
var buffer = "                                  ";
TrackerGroup.prototype.debug = function(depth) {
  depth = depth || 0;
  var indent = depth ? buffer.substr(0, depth) : "";
  var output = indent + (this.name || "top") + ": " + this.completed() + "\n";
  this.trackers.forEach(function(tracker2) {
    if (tracker2 instanceof TrackerGroup) {
      output += tracker2.debug(depth + 1);
    } else {
      output += indent + " " + tracker2.name + ": " + tracker2.completed() + "\n";
    }
  });
  return output;
};
var trackerGroupExports = trackerGroup.exports;
lib.TrackerGroup = trackerGroupExports;
lib.Tracker = trackerExports;
lib.TrackerStream = trackerStreamExports;
var plumbing = { exports: {} };
var consoleControlStrings = {};
var prefix = "\x1B[";
consoleControlStrings.up = function up(num) {
  return prefix + (num || "") + "A";
};
consoleControlStrings.down = function down(num) {
  return prefix + (num || "") + "B";
};
consoleControlStrings.forward = function forward(num) {
  return prefix + (num || "") + "C";
};
consoleControlStrings.back = function back(num) {
  return prefix + (num || "") + "D";
};
consoleControlStrings.nextLine = function nextLine(num) {
  return prefix + (num || "") + "E";
};
consoleControlStrings.previousLine = function previousLine(num) {
  return prefix + (num || "") + "F";
};
consoleControlStrings.horizontalAbsolute = function horizontalAbsolute(num) {
  if (num == null)
    throw new Error("horizontalAboslute requires a column to position to");
  return prefix + num + "G";
};
consoleControlStrings.eraseData = function eraseData() {
  return prefix + "J";
};
consoleControlStrings.eraseLine = function eraseLine() {
  return prefix + "K";
};
consoleControlStrings.goto = function(x, y2) {
  return prefix + y2 + ";" + x + "H";
};
consoleControlStrings.gotoSOL = function() {
  return "\r";
};
consoleControlStrings.beep = function() {
  return "\x07";
};
consoleControlStrings.hideCursor = function hideCursor() {
  return prefix + "?25l";
};
consoleControlStrings.showCursor = function showCursor() {
  return prefix + "?25h";
};
var colors = {
  reset: 0,
  // styles
  bold: 1,
  italic: 3,
  underline: 4,
  inverse: 7,
  // resets
  stopBold: 22,
  stopItalic: 23,
  stopUnderline: 24,
  stopInverse: 27,
  // colors
  white: 37,
  black: 30,
  blue: 34,
  cyan: 36,
  green: 32,
  magenta: 35,
  red: 31,
  yellow: 33,
  bgWhite: 47,
  bgBlack: 40,
  bgBlue: 44,
  bgCyan: 46,
  bgGreen: 42,
  bgMagenta: 45,
  bgRed: 41,
  bgYellow: 43,
  grey: 90,
  brightBlack: 90,
  brightRed: 91,
  brightGreen: 92,
  brightYellow: 93,
  brightBlue: 94,
  brightMagenta: 95,
  brightCyan: 96,
  brightWhite: 97,
  bgGrey: 100,
  bgBrightBlack: 100,
  bgBrightRed: 101,
  bgBrightGreen: 102,
  bgBrightYellow: 103,
  bgBrightBlue: 104,
  bgBrightMagenta: 105,
  bgBrightCyan: 106,
  bgBrightWhite: 107
};
consoleControlStrings.color = function color(colorWith) {
  if (arguments.length !== 1 || !Array.isArray(colorWith)) {
    colorWith = Array.prototype.slice.call(arguments);
  }
  return prefix + colorWith.map(colorNameToCode).join(";") + "m";
};
function colorNameToCode(color3) {
  if (colors[color3] != null)
    return colors[color3];
  throw new Error("Unknown color or style name: " + color3);
}
var renderTemplate$3 = { exports: {} };
var align$1 = {};
var stringWidth$5 = { exports: {} };
var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
};
const ansiRegex = ansiRegex$1;
var stripAnsi$2 = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
var isFullwidthCodePoint$2 = { exports: {} };
const isFullwidthCodePoint$1 = (codePoint) => {
  if (Number.isNaN(codePoint)) {
    return false;
  }
  if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
  codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
  43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
  44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
  63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
  65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
  110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
  127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= codePoint && codePoint <= 262141)) {
    return true;
  }
  return false;
};
isFullwidthCodePoint$2.exports = isFullwidthCodePoint$1;
isFullwidthCodePoint$2.exports.default = isFullwidthCodePoint$1;
var isFullwidthCodePointExports = isFullwidthCodePoint$2.exports;
var emojiRegex$1 = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
const stripAnsi$1 = stripAnsi$2;
const isFullwidthCodePoint = isFullwidthCodePointExports;
const emojiRegex = emojiRegex$1;
const stringWidth$4 = (string) => {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  string = stripAnsi$1(string);
  if (string.length === 0) {
    return 0;
  }
  string = string.replace(emojiRegex(), "  ");
  let width = 0;
  for (let i2 = 0; i2 < string.length; i2++) {
    const code = string.codePointAt(i2);
    if (code <= 31 || code >= 127 && code <= 159) {
      continue;
    }
    if (code >= 768 && code <= 879) {
      continue;
    }
    if (code > 65535) {
      i2++;
    }
    width += isFullwidthCodePoint(code) ? 2 : 1;
  }
  return width;
};
stringWidth$5.exports = stringWidth$4;
stringWidth$5.exports.default = stringWidth$4;
var stringWidthExports = stringWidth$5.exports;
var stringWidth$3 = stringWidthExports;
align$1.center = alignCenter;
align$1.left = alignLeft;
align$1.right = alignRight;
function createPadding(width) {
  var result = "";
  var string = " ";
  var n = width;
  do {
    if (n % 2) {
      result += string;
    }
    n = Math.floor(n / 2);
    string += string;
  } while (n);
  return result;
}
function alignLeft(str, width) {
  var trimmed = str.trimRight();
  if (trimmed.length === 0 && str.length >= width)
    return str;
  var padding = "";
  var strWidth = stringWidth$3(trimmed);
  if (strWidth < width) {
    padding = createPadding(width - strWidth);
  }
  return trimmed + padding;
}
function alignRight(str, width) {
  var trimmed = str.trimLeft();
  if (trimmed.length === 0 && str.length >= width)
    return str;
  var padding = "";
  var strWidth = stringWidth$3(trimmed);
  if (strWidth < width) {
    padding = createPadding(width - strWidth);
  }
  return padding + trimmed;
}
function alignCenter(str, width) {
  var trimmed = str.trim();
  if (trimmed.length === 0 && str.length >= width)
    return str;
  var padLeft = "";
  var padRight = "";
  var strWidth = stringWidth$3(trimmed);
  if (strWidth < width) {
    var padLeftBy = parseInt((width - strWidth) / 2, 10);
    padLeft = createPadding(padLeftBy);
    padRight = createPadding(width - (strWidth + padLeftBy));
  }
  return padLeft + trimmed + padRight;
}
var aproba = validate$3;
function isArguments(thingy) {
  return thingy != null && typeof thingy === "object" && thingy.hasOwnProperty("callee");
}
const types = {
  "*": { label: "any", check: () => true },
  A: { label: "array", check: (_) => Array.isArray(_) || isArguments(_) },
  S: { label: "string", check: (_) => typeof _ === "string" },
  N: { label: "number", check: (_) => typeof _ === "number" },
  F: { label: "function", check: (_) => typeof _ === "function" },
  O: { label: "object", check: (_) => typeof _ === "object" && _ != null && !types.A.check(_) && !types.E.check(_) },
  B: { label: "boolean", check: (_) => typeof _ === "boolean" },
  E: { label: "error", check: (_) => _ instanceof Error },
  Z: { label: "null", check: (_) => _ == null }
};
function addSchema(schema, arity) {
  const group = arity[schema.length] = arity[schema.length] || [];
  if (group.indexOf(schema) === -1)
    group.push(schema);
}
function validate$3(rawSchemas, args) {
  if (arguments.length !== 2)
    throw wrongNumberOfArgs(["SA"], arguments.length);
  if (!rawSchemas)
    throw missingRequiredArg(0);
  if (!args)
    throw missingRequiredArg(1);
  if (!types.S.check(rawSchemas))
    throw invalidType(0, ["string"], rawSchemas);
  if (!types.A.check(args))
    throw invalidType(1, ["array"], args);
  const schemas = rawSchemas.split("|");
  const arity = {};
  schemas.forEach((schema) => {
    for (let ii = 0; ii < schema.length; ++ii) {
      const type3 = schema[ii];
      if (!types[type3])
        throw unknownType(ii, type3);
    }
    if (/E.*E/.test(schema))
      throw moreThanOneError(schema);
    addSchema(schema, arity);
    if (/E/.test(schema)) {
      addSchema(schema.replace(/E.*$/, "E"), arity);
      addSchema(schema.replace(/E/, "Z"), arity);
      if (schema.length === 1)
        addSchema("", arity);
    }
  });
  let matching = arity[args.length];
  if (!matching) {
    throw wrongNumberOfArgs(Object.keys(arity), args.length);
  }
  for (let ii = 0; ii < args.length; ++ii) {
    let newMatching = matching.filter((schema) => {
      const type3 = schema[ii];
      const typeCheck = types[type3].check;
      return typeCheck(args[ii]);
    });
    if (!newMatching.length) {
      const labels = matching.map((_) => types[_[ii]].label).filter((_) => _ != null);
      throw invalidType(ii, labels, args[ii]);
    }
    matching = newMatching;
  }
}
function missingRequiredArg(num) {
  return newException("EMISSINGARG", "Missing required argument #" + (num + 1));
}
function unknownType(num, type3) {
  return newException("EUNKNOWNTYPE", "Unknown type " + type3 + " in argument #" + (num + 1));
}
function invalidType(num, expectedTypes, value) {
  let valueType2;
  Object.keys(types).forEach((typeCode) => {
    if (types[typeCode].check(value))
      valueType2 = types[typeCode].label;
  });
  return newException("EINVALIDTYPE", "Argument #" + (num + 1) + ": Expected " + englishList(expectedTypes) + " but got " + valueType2);
}
function englishList(list) {
  return list.join(", ").replace(/, ([^,]+)$/, " or $1");
}
function wrongNumberOfArgs(expected, got) {
  const english = englishList(expected);
  const args = expected.every((ex) => ex.length === 1) ? "argument" : "arguments";
  return newException("EWRONGARGCOUNT", "Expected " + english + " " + args + " but got " + got);
}
function moreThanOneError(schema) {
  return newException(
    "ETOOMANYERRORTYPES",
    'Only one error type per argument signature is allowed, more than one found in "' + schema + '"'
  );
}
function newException(code, msg) {
  const err = new Error(msg);
  err.code = code;
  if (Error.captureStackTrace)
    Error.captureStackTrace(err, validate$3);
  return err;
}
var stringWidth$2 = stringWidthExports;
var stripAnsi = stripAnsi$2;
var wideTruncate_1 = wideTruncate$2;
function wideTruncate$2(str, target) {
  if (stringWidth$2(str) === 0)
    return str;
  if (target <= 0)
    return "";
  if (stringWidth$2(str) <= target)
    return str;
  var noAnsi = stripAnsi(str);
  var ansiSize = str.length + noAnsi.length;
  var truncated = str.slice(0, target + ansiSize);
  while (stringWidth$2(truncated) > target) {
    truncated = truncated.slice(0, -1);
  }
  return truncated;
}
var error$1 = {};
var util = util$f;
var User = error$1.User = function User2(msg) {
  var err = new Error(msg);
  Error.captureStackTrace(err, User2);
  err.code = "EGAUGE";
  return err;
};
error$1.MissingTemplateValue = function MissingTemplateValue(item, values2) {
  var err = new User(util.format('Missing template value "%s"', item.type));
  Error.captureStackTrace(err, MissingTemplateValue);
  err.template = item;
  err.values = values2;
  return err;
};
error$1.Internal = function Internal(msg) {
  var err = new Error(msg);
  Error.captureStackTrace(err, Internal);
  err.code = "EGAUGEINTERNAL";
  return err;
};
var stringWidth$1 = stringWidthExports;
var templateItem = TemplateItem$1;
function isPercent(num) {
  if (typeof num !== "string")
    return false;
  return num.slice(-1) === "%";
}
function percent(num) {
  return Number(num.slice(0, -1)) / 100;
}
function TemplateItem$1(values2, outputLength) {
  this.overallOutputLength = outputLength;
  this.finished = false;
  this.type = null;
  this.value = null;
  this.length = null;
  this.maxLength = null;
  this.minLength = null;
  this.kerning = null;
  this.align = "left";
  this.padLeft = 0;
  this.padRight = 0;
  this.index = null;
  this.first = null;
  this.last = null;
  if (typeof values2 === "string") {
    this.value = values2;
  } else {
    for (var prop in values2)
      this[prop] = values2[prop];
  }
  if (isPercent(this.length)) {
    this.length = Math.round(this.overallOutputLength * percent(this.length));
  }
  if (isPercent(this.minLength)) {
    this.minLength = Math.round(this.overallOutputLength * percent(this.minLength));
  }
  if (isPercent(this.maxLength)) {
    this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength));
  }
  return this;
}
TemplateItem$1.prototype = {};
TemplateItem$1.prototype.getBaseLength = function() {
  var length2 = this.length;
  if (length2 == null && typeof this.value === "string" && this.maxLength == null && this.minLength == null) {
    length2 = stringWidth$1(this.value);
  }
  return length2;
};
TemplateItem$1.prototype.getLength = function() {
  var length2 = this.getBaseLength();
  if (length2 == null)
    return null;
  return length2 + this.padLeft + this.padRight;
};
TemplateItem$1.prototype.getMaxLength = function() {
  if (this.maxLength == null)
    return null;
  return this.maxLength + this.padLeft + this.padRight;
};
TemplateItem$1.prototype.getMinLength = function() {
  if (this.minLength == null)
    return null;
  return this.minLength + this.padLeft + this.padRight;
};
var align = align$1;
var validate$2 = aproba;
var wideTruncate$1 = wideTruncate_1;
var error2 = error$1;
var TemplateItem = templateItem;
function renderValueWithValues(values2) {
  return function(item) {
    return renderValue(item, values2);
  };
}
var renderTemplate$2 = renderTemplate$3.exports = function(width, template, values2) {
  var items = prepareItems(width, template, values2);
  var rendered = items.map(renderValueWithValues(values2)).join("");
  return align.left(wideTruncate$1(rendered, width), width);
};
function preType(item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
  return "pre" + cappedTypeName;
}
function postType(item) {
  var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
  return "post" + cappedTypeName;
}
function hasPreOrPost(item, values2) {
  if (!item.type)
    return;
  return values2[preType(item)] || values2[postType(item)];
}
function generatePreAndPost(baseItem, parentValues) {
  var item = Object.assign({}, baseItem);
  var values2 = Object.create(parentValues);
  var template = [];
  var pre = preType(item);
  var post = postType(item);
  if (values2[pre]) {
    template.push({ value: values2[pre] });
    values2[pre] = null;
  }
  item.minLength = null;
  item.length = null;
  item.maxLength = null;
  template.push(item);
  values2[item.type] = values2[item.type];
  if (values2[post]) {
    template.push({ value: values2[post] });
    values2[post] = null;
  }
  return function($1, $2, length2) {
    return renderTemplate$2(length2, template, values2);
  };
}
function prepareItems(width, template, values2) {
  function cloneAndObjectify(item, index2, arr) {
    var cloned = new TemplateItem(item, width);
    var type3 = cloned.type;
    if (cloned.value == null) {
      if (!(type3 in values2)) {
        if (cloned.default == null) {
          throw new error2.MissingTemplateValue(cloned, values2);
        } else {
          cloned.value = cloned.default;
        }
      } else {
        cloned.value = values2[type3];
      }
    }
    if (cloned.value == null || cloned.value === "")
      return null;
    cloned.index = index2;
    cloned.first = index2 === 0;
    cloned.last = index2 === arr.length - 1;
    if (hasPreOrPost(cloned, values2))
      cloned.value = generatePreAndPost(cloned, values2);
    return cloned;
  }
  var output = template.map(cloneAndObjectify).filter(function(item) {
    return item != null;
  });
  var remainingSpace = width;
  var variableCount = output.length;
  function consumeSpace(length2) {
    if (length2 > remainingSpace)
      length2 = remainingSpace;
    remainingSpace -= length2;
  }
  function finishSizing(item, length2) {
    if (item.finished)
      throw new error2.Internal("Tried to finish template item that was already finished");
    if (length2 === Infinity)
      throw new error2.Internal("Length of template item cannot be infinity");
    if (length2 != null)
      item.length = length2;
    item.minLength = null;
    item.maxLength = null;
    --variableCount;
    item.finished = true;
    if (item.length == null)
      item.length = item.getBaseLength();
    if (item.length == null)
      throw new error2.Internal("Finished template items must have a length");
    consumeSpace(item.getLength());
  }
  output.forEach(function(item) {
    if (!item.kerning)
      return;
    var prevPadRight = item.first ? 0 : output[item.index - 1].padRight;
    if (!item.first && prevPadRight < item.kerning)
      item.padLeft = item.kerning - prevPadRight;
    if (!item.last)
      item.padRight = item.kerning;
  });
  output.forEach(function(item) {
    if (item.getBaseLength() == null)
      return;
    finishSizing(item);
  });
  var resized = 0;
  var resizing;
  var hunkSize;
  do {
    resizing = false;
    hunkSize = Math.round(remainingSpace / variableCount);
    output.forEach(function(item) {
      if (item.finished)
        return;
      if (!item.maxLength)
        return;
      if (item.getMaxLength() < hunkSize) {
        finishSizing(item, item.maxLength);
        resizing = true;
      }
    });
  } while (resizing && resized++ < output.length);
  if (resizing)
    throw new error2.Internal("Resize loop iterated too many times while determining maxLength");
  resized = 0;
  do {
    resizing = false;
    hunkSize = Math.round(remainingSpace / variableCount);
    output.forEach(function(item) {
      if (item.finished)
        return;
      if (!item.minLength)
        return;
      if (item.getMinLength() >= hunkSize) {
        finishSizing(item, item.minLength);
        resizing = true;
      }
    });
  } while (resizing && resized++ < output.length);
  if (resizing)
    throw new error2.Internal("Resize loop iterated too many times while determining minLength");
  hunkSize = Math.round(remainingSpace / variableCount);
  output.forEach(function(item) {
    if (item.finished)
      return;
    finishSizing(item, hunkSize);
  });
  return output;
}
function renderFunction(item, values2, length2) {
  validate$2("OON", arguments);
  if (item.type) {
    return item.value(values2, values2[item.type + "Theme"] || {}, length2);
  } else {
    return item.value(values2, {}, length2);
  }
}
function renderValue(item, values2) {
  var length2 = item.getBaseLength();
  var value = typeof item.value === "function" ? renderFunction(item, values2, length2) : item.value;
  if (value == null || value === "")
    return "";
  var alignWith = align[item.align] || align.left;
  var leftPadding = item.padLeft ? align.left("", item.padLeft) : "";
  var rightPadding = item.padRight ? align.right("", item.padRight) : "";
  var truncated = wideTruncate$1(String(value), length2);
  var aligned = alignWith(truncated, length2);
  return leftPadding + aligned + rightPadding;
}
var renderTemplateExports = renderTemplate$3.exports;
var consoleControl = consoleControlStrings;
var renderTemplate$1 = renderTemplateExports;
var validate$1 = aproba;
var Plumbing$1 = plumbing.exports = function(theme, template, width) {
  if (!width)
    width = 80;
  validate$1("OAN", [theme, template, width]);
  this.showing = false;
  this.theme = theme;
  this.width = width;
  this.template = template;
};
Plumbing$1.prototype = {};
Plumbing$1.prototype.setTheme = function(theme) {
  validate$1("O", [theme]);
  this.theme = theme;
};
Plumbing$1.prototype.setTemplate = function(template) {
  validate$1("A", [template]);
  this.template = template;
};
Plumbing$1.prototype.setWidth = function(width) {
  validate$1("N", [width]);
  this.width = width;
};
Plumbing$1.prototype.hide = function() {
  return consoleControl.gotoSOL() + consoleControl.eraseLine();
};
Plumbing$1.prototype.hideCursor = consoleControl.hideCursor;
Plumbing$1.prototype.showCursor = consoleControl.showCursor;
Plumbing$1.prototype.show = function(status3) {
  var values2 = Object.create(this.theme);
  for (var key in status3) {
    values2[key] = status3[key];
  }
  return renderTemplate$1(this.width, this.template, values2).trim() + consoleControl.color("reset") + consoleControl.eraseLine() + consoleControl.gotoSOL();
};
var plumbingExports = plumbing.exports;
var hasUnicode$1 = { exports: {} };
var define_process_env_default$2 = {};
var os = require$$2$2;
hasUnicode$1.exports = function() {
  if (os.type() == "Windows_NT") {
    return false;
  }
  var isUTF8 = /UTF-?8$/i;
  var ctype = define_process_env_default$2.LC_ALL || define_process_env_default$2.LC_CTYPE || define_process_env_default$2.LANG;
  return isUTF8.test(ctype);
};
var hasUnicodeExports = hasUnicode$1.exports;
var browser = colorSupport$1({ alwaysReturn: true }, colorSupport$1);
function colorSupport$1(options2, obj) {
  obj = obj || {};
  options2 = options2 || {};
  obj.level = 0;
  obj.hasBasic = false;
  obj.has256 = false;
  obj.has16m = false;
  if (!options2.alwaysReturn) {
    return false;
  }
  return obj;
}
var colorSupport = browser;
var hasColor$1 = colorSupport().hasBasic;
var signalExit = { exports: {} };
var signals$1 = { exports: {} };
var hasRequiredSignals;
function requireSignals() {
  if (hasRequiredSignals)
    return signals$1.exports;
  hasRequiredSignals = 1;
  (function(module) {
    module.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  })(signals$1);
  return signals$1.exports;
}
var process$3 = commonjsGlobal.process;
const processOk = function(process2) {
  return process2 && typeof process2 === "object" && typeof process2.removeListener === "function" && typeof process2.emit === "function" && typeof process2.reallyExit === "function" && typeof process2.listeners === "function" && typeof process2.kill === "function" && typeof process2.pid === "number" && typeof process2.on === "function";
};
if (!processOk(process$3)) {
  signalExit.exports = function() {
    return function() {
    };
  };
} else {
  var assert = require$$2$2;
  var signals = requireSignals();
  var isWin = /^win/i.test(process$3.platform);
  var EE = require$$2$2;
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process$3.__signal_exit_emitter__) {
    emitter = process$3.__signal_exit_emitter__;
  } else {
    emitter = process$3.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  signalExit.exports = function(cb, opts) {
    if (!processOk(commonjsGlobal.process)) {
      return function() {
      };
    }
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove;
  };
  var unload = function unload2() {
    if (!loaded || !processOk(commonjsGlobal.process)) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process$3.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process$3.emit = originalProcessEmit;
    process$3.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  };
  signalExit.exports.unload = unload;
  var emit = function emit2(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  };
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener2() {
      if (!processOk(commonjsGlobal.process)) {
        return;
      }
      var listeners = process$3.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process$3.kill(process$3.pid, sig);
      }
    };
  });
  signalExit.exports.signals = function() {
    return signals;
  };
  var loaded = false;
  var load = function load2() {
    if (loaded || !processOk(commonjsGlobal.process)) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process$3.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process$3.emit = processEmit;
    process$3.reallyExit = processReallyExit;
  };
  signalExit.exports.load = load;
  var originalProcessReallyExit = process$3.reallyExit;
  var processReallyExit = function processReallyExit2(code) {
    if (!processOk(commonjsGlobal.process)) {
      return;
    }
    process$3.exitCode = code || /* istanbul ignore next */
    0;
    emit("exit", process$3.exitCode, null);
    emit("afterexit", process$3.exitCode, null);
    originalProcessReallyExit.call(process$3, process$3.exitCode);
  };
  var originalProcessEmit = process$3.emit;
  var processEmit = function processEmit2(ev, arg) {
    if (ev === "exit" && processOk(commonjsGlobal.process)) {
      if (arg !== void 0) {
        process$3.exitCode = arg;
      }
      var ret = originalProcessEmit.apply(this, arguments);
      emit("exit", process$3.exitCode, null);
      emit("afterexit", process$3.exitCode, null);
      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  };
}
var signalExitExports = signalExit.exports;
var themes$1 = { exports: {} };
var spin$1 = function spin(spinstr, spun) {
  return spinstr[spun % spinstr.length];
};
var validate = aproba;
var renderTemplate = renderTemplateExports;
var wideTruncate = wideTruncate_1;
var stringWidth = stringWidthExports;
var progressBar$1 = function(theme, width, completed) {
  validate("ONN", [theme, width, completed]);
  if (completed < 0)
    completed = 0;
  if (completed > 1)
    completed = 1;
  if (width <= 0)
    return "";
  var sofar = Math.round(width * completed);
  var rest = width - sofar;
  var template = [
    { type: "complete", value: repeat2(theme.complete, sofar), length: sofar },
    { type: "remaining", value: repeat2(theme.remaining, rest), length: rest }
  ];
  return renderTemplate(width, template, theme);
};
function repeat2(string, width) {
  var result = "";
  var n = width;
  do {
    if (n % 2) {
      result += string;
    }
    n = Math.floor(n / 2);
    string += string;
  } while (n && stringWidth(result) < width);
  return wideTruncate(result, width);
}
var spin2 = spin$1;
var progressBar = progressBar$1;
var baseTheme = {
  activityIndicator: function(values2, theme, width) {
    if (values2.spun == null)
      return;
    return spin2(theme, values2.spun);
  },
  progressbar: function(values2, theme, width) {
    if (values2.completed == null)
      return;
    return progressBar(theme, width, values2.completed);
  }
};
var objectAssign = objectAssign$2;
var themeSet = function() {
  return ThemeSetProto.newThemeSet();
};
var ThemeSetProto = {};
ThemeSetProto.baseTheme = baseTheme;
ThemeSetProto.newTheme = function(parent, theme) {
  if (!theme) {
    theme = parent;
    parent = this.baseTheme;
  }
  return objectAssign({}, parent, theme);
};
ThemeSetProto.getThemeNames = function() {
  return Object.keys(this.themes);
};
ThemeSetProto.addTheme = function(name2, parent, theme) {
  this.themes[name2] = this.newTheme(parent, theme);
};
ThemeSetProto.addToAllThemes = function(theme) {
  var themes2 = this.themes;
  Object.keys(themes2).forEach(function(name2) {
    objectAssign(themes2[name2], theme);
  });
  objectAssign(this.baseTheme, theme);
};
ThemeSetProto.getTheme = function(name2) {
  if (!this.themes[name2])
    throw this.newMissingThemeError(name2);
  return this.themes[name2];
};
ThemeSetProto.setDefault = function(opts, name2) {
  if (name2 == null) {
    name2 = opts;
    opts = {};
  }
  var platform = opts.platform == null ? "fallback" : opts.platform;
  var hasUnicode2 = !!opts.hasUnicode;
  var hasColor2 = !!opts.hasColor;
  if (!this.defaults[platform])
    this.defaults[platform] = { true: {}, false: {} };
  this.defaults[platform][hasUnicode2][hasColor2] = name2;
};
ThemeSetProto.getDefault = function(opts) {
  if (!opts)
    opts = {};
  var platformName = opts.platform || process.platform;
  var platform = this.defaults[platformName] || this.defaults.fallback;
  var hasUnicode2 = !!opts.hasUnicode;
  var hasColor2 = !!opts.hasColor;
  if (!platform)
    throw this.newMissingDefaultThemeError(platformName, hasUnicode2, hasColor2);
  if (!platform[hasUnicode2][hasColor2]) {
    if (hasUnicode2 && hasColor2 && platform[!hasUnicode2][hasColor2]) {
      hasUnicode2 = false;
    } else if (hasUnicode2 && hasColor2 && platform[hasUnicode2][!hasColor2]) {
      hasColor2 = false;
    } else if (hasUnicode2 && hasColor2 && platform[!hasUnicode2][!hasColor2]) {
      hasUnicode2 = false;
      hasColor2 = false;
    } else if (hasUnicode2 && !hasColor2 && platform[!hasUnicode2][hasColor2]) {
      hasUnicode2 = false;
    } else if (!hasUnicode2 && hasColor2 && platform[hasUnicode2][!hasColor2]) {
      hasColor2 = false;
    } else if (platform === this.defaults.fallback) {
      throw this.newMissingDefaultThemeError(platformName, hasUnicode2, hasColor2);
    }
  }
  if (platform[hasUnicode2][hasColor2]) {
    return this.getTheme(platform[hasUnicode2][hasColor2]);
  } else {
    return this.getDefault(objectAssign({}, opts, { platform: "fallback" }));
  }
};
ThemeSetProto.newMissingThemeError = function newMissingThemeError(name2) {
  var err = new Error('Could not find a gauge theme named "' + name2 + '"');
  Error.captureStackTrace.call(err, newMissingThemeError);
  err.theme = name2;
  err.code = "EMISSINGTHEME";
  return err;
};
ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError(platformName, hasUnicode2, hasColor2) {
  var err = new Error(
    "Could not find a gauge theme for your platform/unicode/color use combo:\n    platform = " + platformName + "\n    hasUnicode = " + hasUnicode2 + "\n    hasColor = " + hasColor2
  );
  Error.captureStackTrace.call(err, newMissingDefaultThemeError);
  err.platform = platformName;
  err.hasUnicode = hasUnicode2;
  err.hasColor = hasColor2;
  err.code = "EMISSINGTHEME";
  return err;
};
ThemeSetProto.newThemeSet = function() {
  var themeset = function(opts) {
    return themeset.getDefault(opts);
  };
  return objectAssign(themeset, ThemeSetProto, {
    themes: objectAssign({}, this.themes),
    baseTheme: objectAssign({}, this.baseTheme),
    defaults: JSON.parse(JSON.stringify(this.defaults || {}))
  });
};
var color2 = consoleControlStrings.color;
var ThemeSet = themeSet;
var themes = themes$1.exports = new ThemeSet();
themes.addTheme("ASCII", {
  preProgressbar: "[",
  postProgressbar: "]",
  progressbarTheme: {
    complete: "#",
    remaining: "."
  },
  activityIndicatorTheme: "-\\|/",
  preSubsection: ">"
});
themes.addTheme("colorASCII", themes.getTheme("ASCII"), {
  progressbarTheme: {
    preComplete: color2("bgBrightWhite", "brightWhite"),
    complete: "#",
    postComplete: color2("reset"),
    preRemaining: color2("bgBrightBlack", "brightBlack"),
    remaining: ".",
    postRemaining: color2("reset")
  }
});
themes.addTheme("brailleSpinner", {
  preProgressbar: "",
  postProgressbar: "",
  progressbarTheme: {
    complete: "#",
    remaining: ""
  },
  activityIndicatorTheme: "",
  preSubsection: ">"
});
themes.addTheme("colorBrailleSpinner", themes.getTheme("brailleSpinner"), {
  progressbarTheme: {
    preComplete: color2("bgBrightWhite", "brightWhite"),
    complete: "#",
    postComplete: color2("reset"),
    preRemaining: color2("bgBrightBlack", "brightBlack"),
    remaining: "",
    postRemaining: color2("reset")
  }
});
themes.setDefault({}, "ASCII");
themes.setDefault({ hasColor: true }, "colorASCII");
themes.setDefault({ platform: "darwin", hasUnicode: true }, "brailleSpinner");
themes.setDefault({ platform: "darwin", hasUnicode: true, hasColor: true }, "colorBrailleSpinner");
themes.setDefault({ platform: "linux", hasUnicode: true }, "brailleSpinner");
themes.setDefault({ platform: "linux", hasUnicode: true, hasColor: true }, "colorBrailleSpinner");
var themesExports = themes$1.exports;
var setInterval_1 = setInterval;
var process_1$1 = process;
var setImmediate$2 = { exports: {} };
var process$2 = process_1$1;
try {
  setImmediate$2.exports = setImmediate;
} catch (ex) {
  setImmediate$2.exports = process$2.nextTick;
}
var setImmediateExports = setImmediate$2.exports;
var Plumbing = plumbingExports;
var hasUnicode = hasUnicodeExports;
var hasColor = hasColor$1;
var onExit = signalExitExports;
var defaultThemes = themesExports;
var setInterval$1 = setInterval_1;
var process$1 = process_1$1;
var setImmediate$1 = setImmediateExports;
var gauge = Gauge;
function callWith(obj, method) {
  return function() {
    return method.call(obj);
  };
}
function Gauge(arg1, arg2) {
  var options2, writeTo;
  if (arg1 && arg1.write) {
    writeTo = arg1;
    options2 = arg2 || {};
  } else if (arg2 && arg2.write) {
    writeTo = arg2;
    options2 = arg1 || {};
  } else {
    writeTo = process$1.stderr;
    options2 = arg1 || arg2 || {};
  }
  this._status = {
    spun: 0,
    section: "",
    subsection: ""
  };
  this._paused = false;
  this._disabled = true;
  this._showing = false;
  this._onScreen = false;
  this._needsRedraw = false;
  this._hideCursor = options2.hideCursor == null ? true : options2.hideCursor;
  this._fixedFramerate = options2.fixedFramerate == null ? !/^v0\.8\./.test(process$1.version) : options2.fixedFramerate;
  this._lastUpdateAt = null;
  this._updateInterval = options2.updateInterval == null ? 50 : options2.updateInterval;
  this._themes = options2.themes || defaultThemes;
  this._theme = options2.theme;
  var theme = this._computeTheme(options2.theme);
  var template = options2.template || [
    { type: "progressbar", length: 20 },
    { type: "activityIndicator", kerning: 1, length: 1 },
    { type: "section", kerning: 1, default: "" },
    { type: "subsection", kerning: 1, default: "" }
  ];
  this.setWriteTo(writeTo, options2.tty);
  var PlumbingClass = options2.Plumbing || Plumbing;
  this._gauge = new PlumbingClass(theme, template, this.getWidth());
  this._$$doRedraw = callWith(this, this._doRedraw);
  this._$$handleSizeChange = callWith(this, this._handleSizeChange);
  this._cleanupOnExit = options2.cleanupOnExit == null || options2.cleanupOnExit;
  this._removeOnExit = null;
  if (options2.enabled || options2.enabled == null && this._tty && this._tty.isTTY) {
    this.enable();
  } else {
    this.disable();
  }
}
Gauge.prototype = {};
Gauge.prototype.isEnabled = function() {
  return !this._disabled;
};
Gauge.prototype.setTemplate = function(template) {
  this._gauge.setTemplate(template);
  if (this._showing)
    this._requestRedraw();
};
Gauge.prototype._computeTheme = function(theme) {
  if (!theme)
    theme = {};
  if (typeof theme === "string") {
    theme = this._themes.getTheme(theme);
  } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
    var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;
    var useColor = theme.hasColor == null ? hasColor : theme.hasColor;
    theme = this._themes.getDefault({ hasUnicode: useUnicode, hasColor: useColor, platform: theme.platform });
  }
  return theme;
};
Gauge.prototype.setThemeset = function(themes2) {
  this._themes = themes2;
  this.setTheme(this._theme);
};
Gauge.prototype.setTheme = function(theme) {
  this._gauge.setTheme(this._computeTheme(theme));
  if (this._showing)
    this._requestRedraw();
  this._theme = theme;
};
Gauge.prototype._requestRedraw = function() {
  this._needsRedraw = true;
  if (!this._fixedFramerate)
    this._doRedraw();
};
Gauge.prototype.getWidth = function() {
  return (this._tty && this._tty.columns || 80) - 1;
};
Gauge.prototype.setWriteTo = function(writeTo, tty) {
  var enabled = !this._disabled;
  if (enabled)
    this.disable();
  this._writeTo = writeTo;
  this._tty = tty || writeTo === process$1.stderr && process$1.stdout.isTTY && process$1.stdout || writeTo.isTTY && writeTo || this._tty;
  if (this._gauge)
    this._gauge.setWidth(this.getWidth());
  if (enabled)
    this.enable();
};
Gauge.prototype.enable = function() {
  if (!this._disabled)
    return;
  this._disabled = false;
  if (this._tty)
    this._enableEvents();
  if (this._showing)
    this.show();
};
Gauge.prototype.disable = function() {
  if (this._disabled)
    return;
  if (this._showing) {
    this._lastUpdateAt = null;
    this._showing = false;
    this._doRedraw();
    this._showing = true;
  }
  this._disabled = true;
  if (this._tty)
    this._disableEvents();
};
Gauge.prototype._enableEvents = function() {
  if (this._cleanupOnExit) {
    this._removeOnExit = onExit(callWith(this, this.disable));
  }
  this._tty.on("resize", this._$$handleSizeChange);
  if (this._fixedFramerate) {
    this.redrawTracker = setInterval$1(this._$$doRedraw, this._updateInterval);
    if (this.redrawTracker.unref)
      this.redrawTracker.unref();
  }
};
Gauge.prototype._disableEvents = function() {
  this._tty.removeListener("resize", this._$$handleSizeChange);
  if (this._fixedFramerate)
    clearInterval(this.redrawTracker);
  if (this._removeOnExit)
    this._removeOnExit();
};
Gauge.prototype.hide = function(cb) {
  if (this._disabled)
    return cb && process$1.nextTick(cb);
  if (!this._showing)
    return cb && process$1.nextTick(cb);
  this._showing = false;
  this._doRedraw();
  cb && setImmediate$1(cb);
};
Gauge.prototype.show = function(section, completed) {
  this._showing = true;
  if (typeof section === "string") {
    this._status.section = section;
  } else if (typeof section === "object") {
    var sectionKeys = Object.keys(section);
    for (var ii = 0; ii < sectionKeys.length; ++ii) {
      var key = sectionKeys[ii];
      this._status[key] = section[key];
    }
  }
  if (completed != null)
    this._status.completed = completed;
  if (this._disabled)
    return;
  this._requestRedraw();
};
Gauge.prototype.pulse = function(subsection) {
  this._status.subsection = subsection || "";
  this._status.spun++;
  if (this._disabled)
    return;
  if (!this._showing)
    return;
  this._requestRedraw();
};
Gauge.prototype._handleSizeChange = function() {
  this._gauge.setWidth(this._tty.columns - 1);
  this._requestRedraw();
};
Gauge.prototype._doRedraw = function() {
  if (this._disabled || this._paused)
    return;
  if (!this._fixedFramerate) {
    var now = Date.now();
    if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval)
      return;
    this._lastUpdateAt = now;
  }
  if (!this._showing && this._onScreen) {
    this._onScreen = false;
    var result = this._gauge.hide();
    if (this._hideCursor) {
      result += this._gauge.showCursor();
    }
    return this._writeTo.write(result);
  }
  if (!this._showing && !this._onScreen)
    return;
  if (this._showing && !this._onScreen) {
    this._onScreen = true;
    this._needsRedraw = true;
    if (this._hideCursor) {
      this._writeTo.write(this._gauge.hideCursor());
    }
  }
  if (!this._needsRedraw)
    return;
  if (!this._writeTo.write(this._gauge.show(this._status))) {
    this._paused = true;
    this._writeTo.on("drain", callWith(this, function() {
      this._paused = false;
      this._doRedraw();
    }));
  }
};
var setBlocking = function(blocking) {
  [process.stdout, process.stderr].forEach(function(stream3) {
    if (stream3._handle && stream3.isTTY && typeof stream3._handle.setBlocking === "function") {
      stream3._handle.setBlocking(blocking);
    }
  });
};
(function(module, exports2) {
  var Progress = lib;
  var Gauge2 = gauge;
  var EE = require$$2$2.EventEmitter;
  var log2 = module.exports = new EE();
  var util2 = util$f;
  var setBlocking$1 = setBlocking;
  var consoleControl2 = consoleControlStrings;
  setBlocking$1(true);
  var stream3 = process.stderr;
  Object.defineProperty(log2, "stream", {
    set: function(newStream) {
      stream3 = newStream;
      if (this.gauge) {
        this.gauge.setWriteTo(stream3, stream3);
      }
    },
    get: function() {
      return stream3;
    }
  });
  var colorEnabled;
  log2.useColor = function() {
    return colorEnabled != null ? colorEnabled : stream3.isTTY;
  };
  log2.enableColor = function() {
    colorEnabled = true;
    this.gauge.setTheme({ hasColor: colorEnabled, hasUnicode: unicodeEnabled });
  };
  log2.disableColor = function() {
    colorEnabled = false;
    this.gauge.setTheme({ hasColor: colorEnabled, hasUnicode: unicodeEnabled });
  };
  log2.level = "info";
  log2.gauge = new Gauge2(stream3, {
    enabled: false,
    // no progress bars unless asked
    theme: { hasColor: log2.useColor() },
    template: [
      { type: "progressbar", length: 20 },
      { type: "activityIndicator", kerning: 1, length: 1 },
      { type: "section", default: "" },
      ":",
      { type: "logline", kerning: 1, default: "" }
    ]
  });
  log2.tracker = new Progress.TrackerGroup();
  log2.progressEnabled = log2.gauge.isEnabled();
  var unicodeEnabled;
  log2.enableUnicode = function() {
    unicodeEnabled = true;
    this.gauge.setTheme({ hasColor: this.useColor(), hasUnicode: unicodeEnabled });
  };
  log2.disableUnicode = function() {
    unicodeEnabled = false;
    this.gauge.setTheme({ hasColor: this.useColor(), hasUnicode: unicodeEnabled });
  };
  log2.setGaugeThemeset = function(themes2) {
    this.gauge.setThemeset(themes2);
  };
  log2.setGaugeTemplate = function(template) {
    this.gauge.setTemplate(template);
  };
  log2.enableProgress = function() {
    if (this.progressEnabled) {
      return;
    }
    this.progressEnabled = true;
    this.tracker.on("change", this.showProgress);
    if (this._paused) {
      return;
    }
    this.gauge.enable();
  };
  log2.disableProgress = function() {
    if (!this.progressEnabled) {
      return;
    }
    this.progressEnabled = false;
    this.tracker.removeListener("change", this.showProgress);
    this.gauge.disable();
  };
  var trackerConstructors = ["newGroup", "newItem", "newStream"];
  var mixinLog = function(tracker2) {
    Object.keys(log2).forEach(function(P) {
      if (P[0] === "_") {
        return;
      }
      if (trackerConstructors.filter(function(C) {
        return C === P;
      }).length) {
        return;
      }
      if (tracker2[P]) {
        return;
      }
      if (typeof log2[P] !== "function") {
        return;
      }
      var func = log2[P];
      tracker2[P] = function() {
        return func.apply(log2, arguments);
      };
    });
    if (tracker2 instanceof Progress.TrackerGroup) {
      trackerConstructors.forEach(function(C) {
        var func = tracker2[C];
        tracker2[C] = function() {
          return mixinLog(func.apply(tracker2, arguments));
        };
      });
    }
    return tracker2;
  };
  trackerConstructors.forEach(function(C) {
    log2[C] = function() {
      return mixinLog(this.tracker[C].apply(this.tracker, arguments));
    };
  });
  log2.clearProgress = function(cb) {
    if (!this.progressEnabled) {
      return cb && process.nextTick(cb);
    }
    this.gauge.hide(cb);
  };
  log2.showProgress = (function(name2, completed) {
    if (!this.progressEnabled) {
      return;
    }
    var values2 = {};
    if (name2) {
      values2.section = name2;
    }
    var last = log2.record[log2.record.length - 1];
    if (last) {
      values2.subsection = last.prefix;
      var disp = log2.disp[last.level] || last.level;
      var logline = this._format(disp, log2.style[last.level]);
      if (last.prefix) {
        logline += " " + this._format(last.prefix, this.prefixStyle);
      }
      logline += " " + last.message.split(/\r?\n/)[0];
      values2.logline = logline;
    }
    values2.completed = completed || this.tracker.completed();
    this.gauge.show(values2);
  }).bind(log2);
  log2.pause = function() {
    this._paused = true;
    if (this.progressEnabled) {
      this.gauge.disable();
    }
  };
  log2.resume = function() {
    if (!this._paused) {
      return;
    }
    this._paused = false;
    var b = this._buffer;
    this._buffer = [];
    b.forEach(function(m2) {
      this.emitLog(m2);
    }, this);
    if (this.progressEnabled) {
      this.gauge.enable();
    }
  };
  log2._buffer = [];
  var id = 0;
  log2.record = [];
  log2.maxRecordSize = 1e4;
  log2.log = (function(lvl, prefix2, message) {
    var l = this.levels[lvl];
    if (l === void 0) {
      return this.emit("error", new Error(util2.format(
        "Undefined log level: %j",
        lvl
      )));
    }
    var a = new Array(arguments.length - 2);
    var stack = null;
    for (var i2 = 2; i2 < arguments.length; i2++) {
      var arg = a[i2 - 2] = arguments[i2];
      if (typeof arg === "object" && arg instanceof Error && arg.stack) {
        Object.defineProperty(arg, "stack", {
          value: stack = arg.stack + "",
          enumerable: true,
          writable: true
        });
      }
    }
    if (stack) {
      a.unshift(stack + "\n");
    }
    message = util2.format.apply(util2, a);
    var m2 = {
      id: id++,
      level: lvl,
      prefix: String(prefix2 || ""),
      message,
      messageRaw: a
    };
    this.emit("log", m2);
    this.emit("log." + lvl, m2);
    if (m2.prefix) {
      this.emit(m2.prefix, m2);
    }
    this.record.push(m2);
    var mrs = this.maxRecordSize;
    var n = this.record.length - mrs;
    if (n > mrs / 10) {
      var newSize = Math.floor(mrs * 0.9);
      this.record = this.record.slice(-1 * newSize);
    }
    this.emitLog(m2);
  }).bind(log2);
  log2.emitLog = function(m2) {
    if (this._paused) {
      this._buffer.push(m2);
      return;
    }
    if (this.progressEnabled) {
      this.gauge.pulse(m2.prefix);
    }
    var l = this.levels[m2.level];
    if (l === void 0) {
      return;
    }
    if (l < this.levels[this.level]) {
      return;
    }
    if (l > 0 && !isFinite(l)) {
      return;
    }
    var disp = log2.disp[m2.level] != null ? log2.disp[m2.level] : m2.level;
    this.clearProgress();
    m2.message.split(/\r?\n/).forEach(function(line) {
      if (this.heading) {
        this.write(this.heading, this.headingStyle);
        this.write(" ");
      }
      this.write(disp, log2.style[m2.level]);
      var p = m2.prefix || "";
      if (p) {
        this.write(" ");
      }
      this.write(p, this.prefixStyle);
      this.write(" " + line + "\n");
    }, this);
    this.showProgress();
  };
  log2._format = function(msg, style) {
    if (!stream3) {
      return;
    }
    var output = "";
    if (this.useColor()) {
      style = style || {};
      var settings = [];
      if (style.fg) {
        settings.push(style.fg);
      }
      if (style.bg) {
        settings.push("bg" + style.bg[0].toUpperCase() + style.bg.slice(1));
      }
      if (style.bold) {
        settings.push("bold");
      }
      if (style.underline) {
        settings.push("underline");
      }
      if (style.inverse) {
        settings.push("inverse");
      }
      if (settings.length) {
        output += consoleControl2.color(settings);
      }
      if (style.beep) {
        output += consoleControl2.beep();
      }
    }
    output += msg;
    if (this.useColor()) {
      output += consoleControl2.color("reset");
    }
    return output;
  };
  log2.write = function(msg, style) {
    if (!stream3) {
      return;
    }
    stream3.write(this._format(msg, style));
  };
  log2.addLevel = function(lvl, n, style, disp) {
    if (disp == null) {
      disp = lvl;
    }
    this.levels[lvl] = n;
    this.style[lvl] = style;
    if (!this[lvl]) {
      this[lvl] = (function() {
        var a = new Array(arguments.length + 1);
        a[0] = lvl;
        for (var i2 = 0; i2 < arguments.length; i2++) {
          a[i2 + 1] = arguments[i2];
        }
        return this.log.apply(this, a);
      }).bind(this);
    }
    this.disp[lvl] = disp;
  };
  log2.prefixStyle = { fg: "magenta" };
  log2.headingStyle = { fg: "white", bg: "black" };
  log2.style = {};
  log2.levels = {};
  log2.disp = {};
  log2.addLevel("silly", -Infinity, { inverse: true }, "sill");
  log2.addLevel("verbose", 1e3, { fg: "blue", bg: "black" }, "verb");
  log2.addLevel("info", 2e3, { fg: "green" });
  log2.addLevel("timing", 2500, { fg: "green", bg: "black" });
  log2.addLevel("http", 3e3, { fg: "green", bg: "black" });
  log2.addLevel("notice", 3500, { fg: "blue", bg: "black" });
  log2.addLevel("warn", 4e3, { fg: "black", bg: "yellow" }, "WARN");
  log2.addLevel("error", 5e3, { fg: "red", bg: "black" }, "ERR!");
  log2.addLevel("silent", Infinity);
  log2.on("error", function() {
  });
})(log);
var logExports = log.exports;
var napi = { exports: {} };
var old = {};
var hasRequiredOld;
function requireOld() {
  if (hasRequiredOld)
    return old;
  hasRequiredOld = 1;
  var define_process_env_default2 = {};
  var pathModule = pathExports;
  var isWindows2 = process.platform === "win32";
  var fs2 = require$$2$2;
  var DEBUG = define_process_env_default2.NODE_DEBUG && /fs/.test(define_process_env_default2.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  pathModule.normalize;
  if (isWindows2) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  if (isWindows2) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    var splitRootRe = /^[\/]*/;
  }
  old.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows2 && !knownHard[base]) {
        fs2.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs2.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows2) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs2.statSync(base);
          linkTarget = fs2.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows2)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  old.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m2 = splitRootRe.exec(p);
      pos = m2[0].length;
      current = m2[0];
      base = m2[0];
      previous = "";
      if (isWindows2 && !knownHard[base]) {
        fs2.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs2.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows2) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs2.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs2.readlink(base, function(err3, target) {
          if (!isWindows2)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
  return old;
}
var fs_realpath;
var hasRequiredFs_realpath;
function requireFs_realpath() {
  if (hasRequiredFs_realpath)
    return fs_realpath;
  hasRequiredFs_realpath = 1;
  fs_realpath = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require$$2$2;
  var origRealpath = fs2.realpath;
  var origRealpathSync = fs2.realpathSync;
  var version2 = process.version;
  var ok = /^v[0-5]\./.test(version2);
  var old2 = requireOld();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old2.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old2.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath;
    fs2.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath;
    fs2.realpathSync = origRealpathSync;
  }
  return fs_realpath;
}
var concatMap;
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap)
    return concatMap;
  hasRequiredConcatMap = 1;
  concatMap = function(xs, fn) {
    var res2 = [];
    for (var i2 = 0; i2 < xs.length; i2++) {
      var x = fn(xs[i2], i2);
      if (isArray2(x))
        res2.push.apply(res2, x);
      else
        res2.push(x);
    }
    return res2;
  };
  var isArray2 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap;
}
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch)
    return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range3(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range3;
  function range3(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i2 = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i2 >= 0 && !result) {
        if (i2 == ai) {
          begs.push(i2);
          ai = str.indexOf(a, i2 + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i2 + 1);
        }
        i2 = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion)
    return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var concatMap2 = requireConcatMap();
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric2(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte2(i2, y2) {
    return i2 <= y2;
  }
  function gte2(i2, y2) {
    return i2 >= y2;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,.*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m2.body.split(/\.\./);
    } else {
      n = parseCommaParts(m2.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m2.post.length ? expand(m2.post, false) : [""];
          return post.map(function(p) {
            return m2.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric2(n[0]);
      var y2 = numeric2(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric2(n[2])) : 1;
      var test2 = lte2;
      var reverse = y2 < x;
      if (reverse) {
        incr *= -1;
        test2 = gte2;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i2 = x; test2(i2, y2); i2 += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i2);
          if (c === "\\")
            c = "";
        } else {
          c = String(i2);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i2 < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap2(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch)
    return minimatch_1;
  hasRequiredMinimatch = 1;
  minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path3 = function() {
    try {
      return pathExports;
    } catch (e) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path3.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = requireBraceExpansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s2) {
    return s2.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options2) {
    options2 = options2 || {};
    return function(p, i2, list) {
      return minimatch(p, pattern, options2);
    };
  }
  function ext(a, b) {
    b = b || {};
    var t2 = {};
    Object.keys(a).forEach(function(k) {
      t2[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t2[k] = b[k];
    });
    return t2;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m2 = function minimatch2(p, pattern, options2) {
      return orig(p, pattern, ext(def, options2));
    };
    m2.Minimatch = function Minimatch2(pattern, options2) {
      return new orig.Minimatch(pattern, ext(def, options2));
    };
    m2.Minimatch.defaults = function defaults2(options2) {
      return orig.defaults(ext(def, options2)).Minimatch;
    };
    m2.filter = function filter2(pattern, options2) {
      return orig.filter(pattern, ext(def, options2));
    };
    m2.defaults = function defaults2(options2) {
      return orig.defaults(ext(def, options2));
    };
    m2.makeRe = function makeRe2(pattern, options2) {
      return orig.makeRe(pattern, ext(def, options2));
    };
    m2.braceExpand = function braceExpand2(pattern, options2) {
      return orig.braceExpand(pattern, ext(def, options2));
    };
    m2.match = function(list, pattern, options2) {
      return orig.match(list, pattern, ext(def, options2));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options2) {
    assertValidPattern(pattern);
    if (!options2)
      options2 = {};
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options2).match(p);
  }
  function Minimatch(pattern, options2) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options2);
    }
    assertValidPattern(pattern);
    if (!options2)
      options2 = {};
    pattern = pattern.trim();
    if (!options2.allowWindowsEscape && path3.sep !== "/") {
      pattern = pattern.split(path3.sep).join("/");
    }
    this.options = options2;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options2.debug)
      this.debug = function debug2() {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s2) {
      return s2.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s2, si, set2) {
      return s2.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s2) {
      return s2.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options2 = this.options;
    var negateOffset = 0;
    if (options2.nonegate)
      return;
    for (var i2 = 0, l = pattern.length; i2 < l && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options2) {
    return braceExpand(pattern, options2);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options2) {
    if (!options2) {
      if (this instanceof Minimatch) {
        options2 = this.options;
      } else {
        options2 = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    assertValidPattern(pattern);
    var options2 = this.options;
    if (pattern === "**") {
      if (!options2.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "")
      return "";
    var re2 = "";
    var hasMagic = !!options2.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re2 += star;
            hasMagic = true;
            break;
          case "?":
            re2 += qmark;
            hasMagic = true;
            break;
          default:
            re2 += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re2);
        stateChar = false;
      }
    }
    for (var i2 = 0, len = pattern.length, c; i2 < len && (c = pattern.charAt(i2)); i2++) {
      this.debug("%s	%s %s %j", pattern, i2, re2, c);
      if (escaping && reSpecials[c]) {
        re2 += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i2, re2, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i2 === classStart + 1)
              c = "^";
            re2 += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options2.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re2 += "(";
            continue;
          }
          if (!stateChar) {
            re2 += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i2 - 1,
            reStart: re2.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re2);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re2 += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re2 += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re2.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re2 += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re2 += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re2 += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i2;
          reClassStart = re2.length;
          re2 += c;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re2 += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i2);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re2 += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re2 += "\\";
          }
          re2 += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re2.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re2, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re2);
      var t2 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re2 = re2.slice(0, pl.reStart) + t2 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re2 += "\\\\";
    }
    var addPatternStart = false;
    switch (re2.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re2.slice(0, nl.reStart);
      var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re2.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i2 = 0; i2 < openParensBefore; i2++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re2 = newRe;
    }
    if (re2 !== "" && hasMagic) {
      re2 = "(?=.)" + re2;
    }
    if (addPatternStart) {
      re2 = patternStart + re2;
    }
    if (isSub === SUBPARSE) {
      return [re2, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re2 + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re2;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options2) {
    return new Minimatch(pattern, options2 || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options2 = this.options;
    var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
    var flags = options2.nocase ? "i" : "";
    var re2 = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re2 = "^(?:" + re2 + ")$";
    if (this.negate)
      re2 = "^(?!" + re2 + ").*$";
    try {
      this.regexp = new RegExp(re2, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch(pattern, options2);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match2(f, partial) {
    if (typeof partial === "undefined")
      partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options2 = this.options;
    if (path3.sep !== "/") {
      f = f.split(path3.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i2;
    for (i2 = f.length - 1; i2 >= 0; i2--) {
      filename = f[i2];
      if (filename)
        break;
    }
    for (i2 = 0; i2 < set.length; i2++) {
      var pattern = set[i2];
      var file = f;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options2.flipNegate)
      return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { "this": this, file, pattern }
    );
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s2) {
    return s2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s2) {
    return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1;
}
var pathIsAbsolute = { exports: {} };
var hasRequiredPathIsAbsolute;
function requirePathIsAbsolute() {
  if (hasRequiredPathIsAbsolute)
    return pathIsAbsolute.exports;
  hasRequiredPathIsAbsolute = 1;
  function posix2(path3) {
    return path3.charAt(0) === "/";
  }
  function win322(path3) {
    var splitDeviceRe2 = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe2.exec(path3);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  pathIsAbsolute.exports = process.platform === "win32" ? win322 : posix2;
  pathIsAbsolute.exports.posix = posix2;
  pathIsAbsolute.exports.win32 = win322;
  return pathIsAbsolute.exports;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  common.setopts = setopts;
  common.ownProp = ownProp;
  common.makeAbs = makeAbs;
  common.finish = finish;
  common.mark = mark;
  common.isIgnored = isIgnored;
  common.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var fs2 = require$$2$2;
  var path3 = pathExports;
  var minimatch = requireMinimatch();
  var isAbsolute2 = requirePathIsAbsolute();
  var Minimatch = minimatch.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options2) {
    self2.ignore = options2.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, { dot: true });
    }
    return {
      matcher: new Minimatch(pattern, { dot: true }),
      gmatcher
    };
  }
  function setopts(self2, pattern, options2) {
    if (!options2)
      options2 = {};
    if (options2.matchBase && -1 === pattern.indexOf("/")) {
      if (options2.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options2.silent;
    self2.pattern = pattern;
    self2.strict = options2.strict !== false;
    self2.realpath = !!options2.realpath;
    self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null);
    self2.follow = !!options2.follow;
    self2.dot = !!options2.dot;
    self2.mark = !!options2.mark;
    self2.nodir = !!options2.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options2.sync;
    self2.nounique = !!options2.nounique;
    self2.nonull = !!options2.nonull;
    self2.nosort = !!options2.nosort;
    self2.nocase = !!options2.nocase;
    self2.stat = !!options2.stat;
    self2.noprocess = !!options2.noprocess;
    self2.absolute = !!options2.absolute;
    self2.fs = options2.fs || fs2;
    self2.maxLength = options2.maxLength || Infinity;
    self2.cache = options2.cache || /* @__PURE__ */ Object.create(null);
    self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null);
    self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null);
    setupIgnores(self2, options2);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options2, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path3.resolve(options2.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options2.root || path3.resolve(self2.cwd, "/");
    self2.root = path3.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options2.nomount;
    options2.nonegate = true;
    options2.nocomment = true;
    options2.allowWindowsEscape = false;
    self2.minimatch = new Minimatch(pattern, options2);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all2 = nou ? [] : /* @__PURE__ */ Object.create(null);
    for (var i2 = 0, l = self2.matches.length; i2 < l; i2++) {
      var matches = self2.matches[i2];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i2];
          if (nou)
            all2.push(literal);
          else
            all2[literal] = true;
        }
      } else {
        var m2 = Object.keys(matches);
        if (nou)
          all2.push.apply(all2, m2);
        else
          m2.forEach(function(m3) {
            all2[m3] = true;
          });
      }
    }
    if (!nou)
      all2 = Object.keys(all2);
    if (!self2.nosort)
      all2 = all2.sort(alphasort);
    if (self2.mark) {
      for (var i2 = 0; i2 < all2.length; i2++) {
        all2[i2] = self2._mark(all2[i2]);
      }
      if (self2.nodir) {
        all2 = all2.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all2 = all2.filter(function(m3) {
        return !isIgnored(self2, m3);
      });
    self2.found = all2;
  }
  function mark(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m2 = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m2 += "/";
      else if (!isDir && slash)
        m2 = m2.slice(0, -1);
      if (m2 !== p) {
        var mabs = makeAbs(self2, m2);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m2;
  }
  function makeAbs(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path3.join(self2.root, f);
    } else if (isAbsolute2(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path3.resolve(self2.cwd, f);
    } else {
      abs = path3.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self2, path4) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path4) || !!(item.gmatcher && item.gmatcher.match(path4));
    });
  }
  function childrenIgnored(self2, path4) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path4));
    });
  }
  return common;
}
var sync2;
var hasRequiredSync;
function requireSync() {
  if (hasRequiredSync)
    return sync2;
  hasRequiredSync = 1;
  sync2 = globSync;
  globSync.GlobSync = GlobSync;
  var rp = requireFs_realpath();
  var minimatch = requireMinimatch();
  minimatch.Minimatch;
  requireGlob().Glob;
  var path3 = pathExports;
  var assert = require$$2$2;
  var isAbsolute2 = requirePathIsAbsolute();
  var common2 = requireCommon();
  var setopts = common2.setopts;
  var ownProp = common2.ownProp;
  var childrenIgnored = common2.childrenIgnored;
  var isIgnored = common2.isIgnored;
  function globSync(pattern, options2) {
    if (typeof options2 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options2).found;
  }
  function GlobSync(pattern, options2) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options2 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options2);
    setopts(this, pattern, options2);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i2 = 0; i2 < n; i2++) {
      this._process(this.minimatch.set[i2], i2, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index2) {
        var set = self2.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common2.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index2, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix2;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index2);
        return;
      case 0:
        prefix2 = null;
        break;
      default:
        prefix2 = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix2 === null)
      read = ".";
    else if (isAbsolute2(prefix2) || isAbsolute2(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix2 || !isAbsolute2(prefix2))
        prefix2 = "/" + prefix2;
      read = prefix2;
    } else
      read = prefix2;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix2, read, abs, remain, index2, inGlobStar);
    else
      this._processReaddir(prefix2, read, abs, remain, index2, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix2, read, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i2 = 0; i2 < entries.length; i2++) {
      var e = entries[i2];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix2) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i2 = 0; i2 < len; i2++) {
        var e = matchedEntries[i2];
        if (prefix2) {
          if (prefix2.slice(-1) !== "/")
            e = prefix2 + "/" + e;
          else
            e = prefix2 + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path3.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return;
    }
    remain.shift();
    for (var i2 = 0; i2 < len; i2++) {
      var e = matchedEntries[i2];
      var newPattern;
      if (prefix2)
        newPattern = [prefix2, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index2, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index2, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index2][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    try {
      lstat = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e = entries[i2];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error3 = new Error(er.code + " invalid cwd " + this.cwd);
          error3.path = this.cwd;
          error3.code = er.code;
          throw error3;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix2, read, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix2 ? [prefix2] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i2 = 0; i2 < len; i2++) {
      var e = entries[i2];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
      this._process(instead, index2, true);
      var below = gspref.concat(entries[i2], remain);
      this._process(below, index2, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix2, index2) {
    var exists = this._stat(prefix2);
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return;
    if (prefix2 && isAbsolute2(prefix2) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix2);
      if (prefix2.charAt(0) === "/") {
        prefix2 = path3.join(this.root, prefix2);
      } else {
        prefix2 = path3.resolve(this.root, prefix2);
        if (trail)
          prefix2 += "/";
      }
    }
    if (process.platform === "win32")
      prefix2 = prefix2.replace(/\\/g, "/");
    this._emitMatch(index2, prefix2);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = this.fs.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  return sync2;
}
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy)
    return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
  return wrappy_1;
}
var once = { exports: {} };
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce)
    return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$12);
  once.exports.strict = wrappy(onceStrict);
  once$12.proto = once$12(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$12(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once$12(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name2 = fn.name || "Function wrapped with `once`";
    f.onceError = name2 + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  return once.exports;
}
var inflight_1;
var hasRequiredInflight;
function requireInflight() {
  if (hasRequiredInflight)
    return inflight_1;
  hasRequiredInflight = 1;
  var wrappy = requireWrappy();
  var reqs = /* @__PURE__ */ Object.create(null);
  var once2 = requireOnce();
  inflight_1 = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once2(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice2(arguments);
      try {
        for (var i2 = 0; i2 < len; i2++) {
          cbs[i2].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice2(args) {
    var length2 = args.length;
    var array = [];
    for (var i2 = 0; i2 < length2; i2++)
      array[i2] = args[i2];
    return array;
  }
  return inflight_1;
}
var glob_1;
var hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob)
    return glob_1;
  hasRequiredGlob = 1;
  glob_1 = glob;
  var rp = requireFs_realpath();
  var minimatch = requireMinimatch();
  minimatch.Minimatch;
  var inherits2 = inherits_browserExports;
  var EE = require$$2$2.EventEmitter;
  var path3 = pathExports;
  var assert = require$$2$2;
  var isAbsolute2 = requirePathIsAbsolute();
  var globSync = requireSync();
  var common2 = requireCommon();
  var setopts = common2.setopts;
  var ownProp = common2.ownProp;
  var inflight = requireInflight();
  var childrenIgnored = common2.childrenIgnored;
  var isIgnored = common2.isIgnored;
  var once2 = requireOnce();
  function glob(pattern, options2, cb) {
    if (typeof options2 === "function")
      cb = options2, options2 = {};
    if (!options2)
      options2 = {};
    if (options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options2);
    }
    return new Glob(pattern, options2, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend2(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys2 = Object.keys(add);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add[keys2[i2]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options2 = extend2({}, options_);
    options2.noprocess = true;
    var g = new Glob(pattern, options2);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits2(Glob, EE);
  function Glob(pattern, options2, cb) {
    if (typeof options2 === "function") {
      cb = options2;
      options2 = null;
    }
    if (options2 && options2.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options2);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options2, cb);
    setopts(this, pattern, options2);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once2(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done2();
    var sync3 = true;
    for (var i2 = 0; i2 < n; i2++) {
      this._process(this.minimatch.set[i2], i2, false, done2);
    }
    sync3 = false;
    function done2() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync3) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common2.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i2 = 0; i2 < this.matches.length; i2++)
      this._realpathSet(i2, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index2, cb) {
    var matchset = this.matches[index2];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index2] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i2) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index2] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq2 = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i2 = 0; i2 < eq2.length; i2++) {
          var e = eq2[i2];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i2 = 0; i2 < pq.length; i2++) {
          var p = pq[i2];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index2, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index2, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix2;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index2, cb);
        return;
      case 0:
        prefix2 = null;
        break;
      default:
        prefix2 = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix2 === null)
      read = ".";
    else if (isAbsolute2(prefix2) || isAbsolute2(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix2 || !isAbsolute2(prefix2))
        prefix2 = "/" + prefix2;
      read = prefix2;
    } else
      read = prefix2;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix2, read, abs, remain, index2, inGlobStar, cb);
    else
      this._processReaddir(prefix2, read, abs, remain, index2, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix2, read, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix2, read, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix2, read, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i2 = 0; i2 < entries.length; i2++) {
      var e = entries[i2];
      if (e.charAt(0) !== "." || dotOk) {
        var m2;
        if (negate && !prefix2) {
          m2 = !e.match(pn);
        } else {
          m2 = e.match(pn);
        }
        if (m2)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i2 = 0; i2 < len; i2++) {
        var e = matchedEntries[i2];
        if (prefix2) {
          if (prefix2 !== "/")
            e = prefix2 + "/" + e;
          else
            e = prefix2 + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path3.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return cb();
    }
    remain.shift();
    for (var i2 = 0; i2 < len; i2++) {
      var e = matchedEntries[i2];
      if (prefix2) {
        if (prefix2 !== "/")
          e = prefix2 + "/" + e;
        else
          e = prefix2 + e;
      }
      this._process([e].concat(remain), index2, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index2, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index2, e]);
      return;
    }
    var abs = isAbsolute2(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index2][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e = entries[i2];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error3 = new Error(er.code + " invalid cwd " + this.cwd);
          error3.path = this.cwd;
          error3.code = er.code;
          this.emit("error", error3);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix2, read, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix2, read, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix2, read, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix2 ? [prefix2] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i2 = 0; i2 < len; i2++) {
      var e = entries[i2];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
      this._process(instead, index2, true, cb);
      var below = gspref.concat(entries[i2], remain);
      this._process(below, index2, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix2, index2, cb) {
    var self2 = this;
    this._stat(prefix2, function(er, exists) {
      self2._processSimple2(prefix2, index2, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix2, index2, er, exists, cb) {
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return cb();
    if (prefix2 && isAbsolute2(prefix2) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix2);
      if (prefix2.charAt(0) === "/") {
        prefix2 = path3.join(this.root, prefix2);
      } else {
        prefix2 = path3.resolve(this.root, prefix2);
        if (trail)
          prefix2 += "/";
      }
    }
    if (process.platform === "win32")
      prefix2 = prefix2.replace(/\\/g, "/");
    this._emitMatch(index2, prefix2);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type3 = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type3 === "FILE")
          return cb();
        else
          return cb(null, type3, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
  return glob_1;
}
var rimraf_1;
var hasRequiredRimraf;
function requireRimraf() {
  if (hasRequiredRimraf)
    return rimraf_1;
  hasRequiredRimraf = 1;
  const assert = require$$2$2;
  const path3 = pathExports;
  const fs2 = require$$2$2;
  let glob = void 0;
  try {
    glob = requireGlob();
  } catch (_err) {
  }
  const defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  let timeout = 0;
  const isWindows2 = process.platform === "win32";
  const defaults2 = (options2) => {
    const methods2 = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods2.forEach((m2) => {
      options2[m2] = options2[m2] || fs2[m2];
      m2 = m2 + "Sync";
      options2[m2] = options2[m2] || fs2[m2];
    });
    options2.maxBusyTries = options2.maxBusyTries || 3;
    options2.emfileWait = options2.emfileWait || 1e3;
    if (options2.glob === false) {
      options2.disableGlob = true;
    }
    if (options2.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options2.disableGlob = options2.disableGlob || false;
    options2.glob = options2.glob || defaultGlobOpts;
  };
  const rimraf = (p, options2, cb) => {
    if (typeof options2 === "function") {
      cb = options2;
      options2 = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options2, "rimraf: invalid options argument provided");
    assert.equal(typeof options2, "object", "rimraf: options should be object");
    defaults2(options2);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results) => {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options2.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options2, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options2.emfileWait) {
              return setTimeout(() => rimraf_(p2, options2, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options2, CB);
      });
    };
    if (options2.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options2.lstat(p, (er, stat) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options2.glob, afterGlob);
    });
  };
  const rimraf_ = (p, options2, cb) => {
    assert(p);
    assert(options2);
    assert(typeof cb === "function");
    options2.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows2)
        fixWinEPERM(p, options2, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options2, er, cb);
      options2.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows2 ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options2, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  const fixWinEPERM = (p, options2, er, cb) => {
    assert(p);
    assert(options2);
    assert(typeof cb === "function");
    options2.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options2.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options2, er, cb);
          else
            options2.unlink(p, cb);
        });
    });
  };
  const fixWinEPERMSync = (p, options2, er) => {
    assert(p);
    assert(options2);
    try {
      options2.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options2.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options2, er);
    else
      options2.unlinkSync(p);
  };
  const rmdir = (p, options2, originalEr, cb) => {
    assert(p);
    assert(options2);
    assert(typeof cb === "function");
    options2.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options2, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  const rmkids = (p, options2, cb) => {
    assert(p);
    assert(options2);
    assert(typeof cb === "function");
    options2.readdir(p, (er, files2) => {
      if (er)
        return cb(er);
      let n = files2.length;
      if (n === 0)
        return options2.rmdir(p, cb);
      let errState;
      files2.forEach((f) => {
        rimraf(path3.join(p, f), options2, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options2.rmdir(p, cb);
        });
      });
    });
  };
  const rimrafSync = (p, options2) => {
    options2 = options2 || {};
    defaults2(options2);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options2, "rimraf: missing options");
    assert.equal(typeof options2, "object", "rimraf: options should be object");
    let results;
    if (options2.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options2.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options2.glob);
      }
    }
    if (!results.length)
      return;
    for (let i2 = 0; i2 < results.length; i2++) {
      const p2 = results[i2];
      let st;
      try {
        st = options2.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows2)
          fixWinEPERMSync(p2, options2, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options2, null);
        else
          options2.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows2 ? fixWinEPERMSync(p2, options2, er) : rmdirSync(p2, options2, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options2, er);
      }
    }
  };
  const rmdirSync = (p, options2, originalEr) => {
    assert(p);
    assert(options2);
    try {
      options2.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options2);
    }
  };
  const rmkidsSync = (p, options2) => {
    assert(p);
    assert(options2);
    options2.readdirSync(p).forEach((f) => rimrafSync(path3.join(p, f), options2));
    const retries = isWindows2 ? 100 : 1;
    let i2 = 0;
    do {
      let threw = true;
      try {
        const ret = options2.rmdirSync(p, options2);
        threw = false;
        return ret;
      } finally {
        if (++i2 < retries && threw)
          continue;
      }
    } while (true);
  };
  rimraf_1 = rimraf;
  rimraf.sync = rimrafSync;
  return rimraf_1;
}
napi.exports;
var hasRequiredNapi;
function requireNapi() {
  if (hasRequiredNapi)
    return napi.exports;
  hasRequiredNapi = 1;
  (function(module, exports2) {
    const fs2 = require$$2$2;
    module.exports = exports2;
    const versionArray = process.version.substr(1).replace(/-.*$/, "").split(".").map((item) => {
      return +item;
    });
    const napi_multiple_commands = [
      "build",
      "clean",
      "configure",
      "package",
      "publish",
      "reveal",
      "testbinary",
      "testpackage",
      "unpublish"
    ];
    const napi_build_version_tag = "napi_build_version=";
    module.exports.get_napi_version = function() {
      let version2 = process.versions.napi;
      if (!version2) {
        if (versionArray[0] === 9 && versionArray[1] >= 3)
          version2 = 2;
        else if (versionArray[0] === 8)
          version2 = 1;
      }
      return version2;
    };
    module.exports.get_napi_version_as_string = function(target) {
      const version2 = module.exports.get_napi_version(target);
      return version2 ? "" + version2 : "";
    };
    module.exports.validate_package_json = function(package_json, opts) {
      const binary2 = package_json.binary;
      const module_path_ok = pathOK(binary2.module_path);
      const remote_path_ok = pathOK(binary2.remote_path);
      const package_name_ok = pathOK(binary2.package_name);
      const napi_build_versions = module.exports.get_napi_build_versions(package_json, opts, true);
      const napi_build_versions_raw = module.exports.get_napi_build_versions_raw(package_json);
      if (napi_build_versions) {
        napi_build_versions.forEach((napi_build_version) => {
          if (!(parseInt(napi_build_version, 10) === napi_build_version && napi_build_version > 0)) {
            throw new Error("All values specified in napi_versions must be positive integers.");
          }
        });
      }
      if (napi_build_versions && (!module_path_ok || !remote_path_ok && !package_name_ok)) {
        throw new Error("When napi_versions is specified; module_path and either remote_path or package_name must contain the substitution string '{napi_build_version}`.");
      }
      if ((module_path_ok || remote_path_ok || package_name_ok) && !napi_build_versions_raw) {
        throw new Error("When the substitution string '{napi_build_version}` is specified in module_path, remote_path, or package_name; napi_versions must also be specified.");
      }
      if (napi_build_versions && !module.exports.get_best_napi_build_version(package_json, opts) && module.exports.build_napi_only(package_json)) {
        throw new Error(
          "The Node-API version of this Node instance is " + module.exports.get_napi_version(opts ? opts.target : void 0) + ". This module supports Node-API version(s) " + module.exports.get_napi_build_versions_raw(package_json) + ". This Node instance cannot run this module."
        );
      }
      if (napi_build_versions_raw && !napi_build_versions && module.exports.build_napi_only(package_json)) {
        throw new Error(
          "The Node-API version of this Node instance is " + module.exports.get_napi_version(opts ? opts.target : void 0) + ". This module supports Node-API version(s) " + module.exports.get_napi_build_versions_raw(package_json) + ". This Node instance cannot run this module."
        );
      }
    };
    function pathOK(path3) {
      return path3 && (path3.indexOf("{napi_build_version}") !== -1 || path3.indexOf("{node_napi_label}") !== -1);
    }
    module.exports.expand_commands = function(package_json, opts, commands) {
      const expanded_commands = [];
      const napi_build_versions = module.exports.get_napi_build_versions(package_json, opts);
      commands.forEach((command) => {
        if (napi_build_versions && command.name === "install") {
          const napi_build_version = module.exports.get_best_napi_build_version(package_json, opts);
          const args = napi_build_version ? [napi_build_version_tag + napi_build_version] : [];
          expanded_commands.push({ name: command.name, args });
        } else if (napi_build_versions && napi_multiple_commands.indexOf(command.name) !== -1) {
          napi_build_versions.forEach((napi_build_version) => {
            const args = command.args.slice();
            args.push(napi_build_version_tag + napi_build_version);
            expanded_commands.push({ name: command.name, args });
          });
        } else {
          expanded_commands.push(command);
        }
      });
      return expanded_commands;
    };
    module.exports.get_napi_build_versions = function(package_json, opts, warnings) {
      const log2 = logExports;
      let napi_build_versions = [];
      const supported_napi_version = module.exports.get_napi_version(opts ? opts.target : void 0);
      if (package_json.binary && package_json.binary.napi_versions) {
        package_json.binary.napi_versions.forEach((napi_version) => {
          const duplicated = napi_build_versions.indexOf(napi_version) !== -1;
          if (!duplicated && supported_napi_version && napi_version <= supported_napi_version) {
            napi_build_versions.push(napi_version);
          } else if (warnings && !duplicated && supported_napi_version) {
            log2.info("This Node instance does not support builds for Node-API version", napi_version);
          }
        });
      }
      if (opts && opts["build-latest-napi-version-only"]) {
        let latest_version = 0;
        napi_build_versions.forEach((napi_version) => {
          if (napi_version > latest_version)
            latest_version = napi_version;
        });
        napi_build_versions = latest_version ? [latest_version] : [];
      }
      return napi_build_versions.length ? napi_build_versions : void 0;
    };
    module.exports.get_napi_build_versions_raw = function(package_json) {
      const napi_build_versions = [];
      if (package_json.binary && package_json.binary.napi_versions) {
        package_json.binary.napi_versions.forEach((napi_version) => {
          if (napi_build_versions.indexOf(napi_version) === -1) {
            napi_build_versions.push(napi_version);
          }
        });
      }
      return napi_build_versions.length ? napi_build_versions : void 0;
    };
    module.exports.get_command_arg = function(napi_build_version) {
      return napi_build_version_tag + napi_build_version;
    };
    module.exports.get_napi_build_version_from_command_args = function(command_args) {
      for (let i2 = 0; i2 < command_args.length; i2++) {
        const arg = command_args[i2];
        if (arg.indexOf(napi_build_version_tag) === 0) {
          return parseInt(arg.substr(napi_build_version_tag.length), 10);
        }
      }
      return void 0;
    };
    module.exports.swap_build_dir_out = function(napi_build_version) {
      if (napi_build_version) {
        const rm = requireRimraf();
        rm.sync(module.exports.get_build_dir(napi_build_version));
        fs2.renameSync("build", module.exports.get_build_dir(napi_build_version));
      }
    };
    module.exports.swap_build_dir_in = function(napi_build_version) {
      if (napi_build_version) {
        const rm = requireRimraf();
        rm.sync("build");
        fs2.renameSync(module.exports.get_build_dir(napi_build_version), "build");
      }
    };
    module.exports.get_build_dir = function(napi_build_version) {
      return "build-tmp-napi-v" + napi_build_version;
    };
    module.exports.get_best_napi_build_version = function(package_json, opts) {
      let best_napi_build_version = 0;
      const napi_build_versions = module.exports.get_napi_build_versions(package_json, opts);
      if (napi_build_versions) {
        const our_napi_version = module.exports.get_napi_version(opts ? opts.target : void 0);
        napi_build_versions.forEach((napi_build_version) => {
          if (napi_build_version > best_napi_build_version && napi_build_version <= our_napi_version) {
            best_napi_build_version = napi_build_version;
          }
        });
      }
      return best_napi_build_version === 0 ? void 0 : best_napi_build_version;
    };
    module.exports.build_napi_only = function(package_json) {
      return package_json.binary && package_json.binary.package_name && package_json.binary.package_name.indexOf("{node_napi_label}") === -1;
    };
  })(napi, napi.exports);
  return napi.exports;
}
var preBinding = { exports: {} };
var versioning = { exports: {} };
var process_1;
var hasRequiredProcess;
function requireProcess() {
  if (hasRequiredProcess)
    return process_1;
  hasRequiredProcess = 1;
  const isLinux = () => process.platform === "linux";
  let report = null;
  const getReport = () => {
    if (!report) {
      if (isLinux() && process.report) {
        const orig = process.report.excludeNetwork;
        process.report.excludeNetwork = true;
        report = process.report.getReport();
        process.report.excludeNetwork = orig;
      } else {
        report = {};
      }
    }
    return report;
  };
  process_1 = { isLinux, getReport };
  return process_1;
}
var filesystem;
var hasRequiredFilesystem;
function requireFilesystem() {
  if (hasRequiredFilesystem)
    return filesystem;
  hasRequiredFilesystem = 1;
  const fs2 = require$$2$2;
  const LDD_PATH = "/usr/bin/ldd";
  const readFileSync = (path3) => fs2.readFileSync(path3, "utf-8");
  const readFile = (path3) => new Promise((resolve3, reject) => {
    fs2.readFile(path3, "utf-8", (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve3(data);
      }
    });
  });
  filesystem = {
    LDD_PATH,
    readFileSync,
    readFile
  };
  return filesystem;
}
var detectLibc;
var hasRequiredDetectLibc;
function requireDetectLibc() {
  if (hasRequiredDetectLibc)
    return detectLibc;
  hasRequiredDetectLibc = 1;
  const childProcess = require$$2$2;
  const { isLinux, getReport } = requireProcess();
  const { LDD_PATH, readFile, readFileSync } = requireFilesystem();
  let cachedFamilyFilesystem;
  let cachedVersionFilesystem;
  const command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
  let commandOut = "";
  const safeCommand = () => {
    if (!commandOut) {
      return new Promise((resolve3) => {
        childProcess.exec(command, (err, out) => {
          commandOut = err ? " " : out;
          resolve3(commandOut);
        });
      });
    }
    return commandOut;
  };
  const safeCommandSync = () => {
    if (!commandOut) {
      try {
        commandOut = childProcess.execSync(command, { encoding: "utf8" });
      } catch (_err) {
        commandOut = " ";
      }
    }
    return commandOut;
  };
  const GLIBC = "glibc";
  const RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
  const MUSL = "musl";
  const isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
  const familyFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return GLIBC;
    }
    if (Array.isArray(report.sharedObjects)) {
      if (report.sharedObjects.some(isFileMusl)) {
        return MUSL;
      }
    }
    return null;
  };
  const familyFromCommand = (out) => {
    const [getconf, ldd1] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return GLIBC;
    }
    if (ldd1 && ldd1.includes(MUSL)) {
      return MUSL;
    }
    return null;
  };
  const getFamilyFromLddContent = (content) => {
    if (content.includes("musl")) {
      return MUSL;
    }
    if (content.includes("GNU C Library")) {
      return GLIBC;
    }
    return null;
  };
  const familyFromFilesystem = async () => {
    if (cachedFamilyFilesystem !== void 0) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {
    }
    return cachedFamilyFilesystem;
  };
  const familyFromFilesystemSync = () => {
    if (cachedFamilyFilesystem !== void 0) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = readFileSync(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {
    }
    return cachedFamilyFilesystem;
  };
  const family = async () => {
    let family2 = null;
    if (isLinux()) {
      family2 = await familyFromFilesystem();
      if (!family2) {
        family2 = familyFromReport();
      }
      if (!family2) {
        const out = await safeCommand();
        family2 = familyFromCommand(out);
      }
    }
    return family2;
  };
  const familySync = () => {
    let family2 = null;
    if (isLinux()) {
      family2 = familyFromFilesystemSync();
      if (!family2) {
        family2 = familyFromReport();
      }
      if (!family2) {
        const out = safeCommandSync();
        family2 = familyFromCommand(out);
      }
    }
    return family2;
  };
  const isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;
  const isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;
  const versionFromFilesystem = async () => {
    if (cachedVersionFilesystem !== void 0) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {
    }
    return cachedVersionFilesystem;
  };
  const versionFromFilesystemSync = () => {
    if (cachedVersionFilesystem !== void 0) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = readFileSync(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {
    }
    return cachedVersionFilesystem;
  };
  const versionFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return report.header.glibcVersionRuntime;
    }
    return null;
  };
  const versionSuffix = (s2) => s2.trim().split(/\s+/)[1];
  const versionFromCommand = (out) => {
    const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return versionSuffix(getconf);
    }
    if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
      return versionSuffix(ldd2);
    }
    return null;
  };
  const version2 = async () => {
    let version3 = null;
    if (isLinux()) {
      version3 = await versionFromFilesystem();
      if (!version3) {
        version3 = versionFromReport();
      }
      if (!version3) {
        const out = await safeCommand();
        version3 = versionFromCommand(out);
      }
    }
    return version3;
  };
  const versionSync = () => {
    let version3 = null;
    if (isLinux()) {
      version3 = versionFromFilesystemSync();
      if (!version3) {
        version3 = versionFromReport();
      }
      if (!version3) {
        const out = safeCommandSync();
        version3 = versionFromCommand(out);
      }
    }
    return version3;
  };
  detectLibc = {
    GLIBC,
    MUSL,
    family,
    familySync,
    isNonGlibcLinux,
    isNonGlibcLinuxSync,
    version: version2,
    versionSync
  };
  return detectLibc;
}
const require$$5 = {
  "0.1.14": {
    node_abi: null,
    v8: "1.3"
  },
  "0.1.15": {
    node_abi: null,
    v8: "1.3"
  },
  "0.1.16": {
    node_abi: null,
    v8: "1.3"
  },
  "0.1.17": {
    node_abi: null,
    v8: "1.3"
  },
  "0.1.18": {
    node_abi: null,
    v8: "1.3"
  },
  "0.1.19": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.20": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.21": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.22": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.23": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.24": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.25": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.26": {
    node_abi: null,
    v8: "2.0"
  },
  "0.1.27": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.28": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.29": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.30": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.31": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.32": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.33": {
    node_abi: null,
    v8: "2.1"
  },
  "0.1.90": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.91": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.92": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.93": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.94": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.95": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.96": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.97": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.98": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.99": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.100": {
    node_abi: null,
    v8: "2.2"
  },
  "0.1.101": {
    node_abi: null,
    v8: "2.3"
  },
  "0.1.102": {
    node_abi: null,
    v8: "2.3"
  },
  "0.1.103": {
    node_abi: null,
    v8: "2.3"
  },
  "0.1.104": {
    node_abi: null,
    v8: "2.3"
  },
  "0.2.0": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.2.1": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.2.2": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.2.3": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.2.4": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.2.5": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.2.6": {
    node_abi: 1,
    v8: "2.3"
  },
  "0.3.0": {
    node_abi: 1,
    v8: "2.5"
  },
  "0.3.1": {
    node_abi: 1,
    v8: "2.5"
  },
  "0.3.2": {
    node_abi: 1,
    v8: "3.0"
  },
  "0.3.3": {
    node_abi: 1,
    v8: "3.0"
  },
  "0.3.4": {
    node_abi: 1,
    v8: "3.0"
  },
  "0.3.5": {
    node_abi: 1,
    v8: "3.0"
  },
  "0.3.6": {
    node_abi: 1,
    v8: "3.0"
  },
  "0.3.7": {
    node_abi: 1,
    v8: "3.0"
  },
  "0.3.8": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.0": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.1": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.2": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.3": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.4": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.5": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.6": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.7": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.8": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.9": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.10": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.11": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.4.12": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.5.0": {
    node_abi: 1,
    v8: "3.1"
  },
  "0.5.1": {
    node_abi: 1,
    v8: "3.4"
  },
  "0.5.2": {
    node_abi: 1,
    v8: "3.4"
  },
  "0.5.3": {
    node_abi: 1,
    v8: "3.4"
  },
  "0.5.4": {
    node_abi: 1,
    v8: "3.5"
  },
  "0.5.5": {
    node_abi: 1,
    v8: "3.5"
  },
  "0.5.6": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.5.7": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.5.8": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.5.9": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.5.10": {
    node_abi: 1,
    v8: "3.7"
  },
  "0.6.0": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.1": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.2": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.3": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.4": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.5": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.6": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.7": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.8": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.9": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.10": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.11": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.12": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.13": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.14": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.15": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.16": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.17": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.18": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.19": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.20": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.6.21": {
    node_abi: 1,
    v8: "3.6"
  },
  "0.7.0": {
    node_abi: 1,
    v8: "3.8"
  },
  "0.7.1": {
    node_abi: 1,
    v8: "3.8"
  },
  "0.7.2": {
    node_abi: 1,
    v8: "3.8"
  },
  "0.7.3": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.4": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.5": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.6": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.7": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.8": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.9": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.7.10": {
    node_abi: 1,
    v8: "3.9"
  },
  "0.7.11": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.7.12": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.0": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.1": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.2": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.3": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.4": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.5": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.6": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.7": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.8": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.9": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.10": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.11": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.12": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.13": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.14": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.15": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.16": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.17": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.18": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.19": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.20": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.21": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.22": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.23": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.24": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.25": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.26": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.27": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.8.28": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.9.0": {
    node_abi: 1,
    v8: "3.11"
  },
  "0.9.1": {
    node_abi: 10,
    v8: "3.11"
  },
  "0.9.2": {
    node_abi: 10,
    v8: "3.11"
  },
  "0.9.3": {
    node_abi: 10,
    v8: "3.13"
  },
  "0.9.4": {
    node_abi: 10,
    v8: "3.13"
  },
  "0.9.5": {
    node_abi: 10,
    v8: "3.13"
  },
  "0.9.6": {
    node_abi: 10,
    v8: "3.15"
  },
  "0.9.7": {
    node_abi: 10,
    v8: "3.15"
  },
  "0.9.8": {
    node_abi: 10,
    v8: "3.15"
  },
  "0.9.9": {
    node_abi: 11,
    v8: "3.15"
  },
  "0.9.10": {
    node_abi: 11,
    v8: "3.15"
  },
  "0.9.11": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.9.12": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.0": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.1": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.2": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.3": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.4": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.5": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.6": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.7": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.8": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.9": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.10": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.11": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.12": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.13": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.14": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.15": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.16": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.17": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.18": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.19": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.20": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.21": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.22": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.23": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.24": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.25": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.26": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.27": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.28": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.29": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.30": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.31": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.32": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.33": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.34": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.35": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.36": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.37": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.38": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.39": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.40": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.41": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.42": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.43": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.44": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.45": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.46": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.47": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.10.48": {
    node_abi: 11,
    v8: "3.14"
  },
  "0.11.0": {
    node_abi: 12,
    v8: "3.17"
  },
  "0.11.1": {
    node_abi: 12,
    v8: "3.18"
  },
  "0.11.2": {
    node_abi: 12,
    v8: "3.19"
  },
  "0.11.3": {
    node_abi: 12,
    v8: "3.19"
  },
  "0.11.4": {
    node_abi: 12,
    v8: "3.20"
  },
  "0.11.5": {
    node_abi: 12,
    v8: "3.20"
  },
  "0.11.6": {
    node_abi: 12,
    v8: "3.20"
  },
  "0.11.7": {
    node_abi: 12,
    v8: "3.20"
  },
  "0.11.8": {
    node_abi: 13,
    v8: "3.21"
  },
  "0.11.9": {
    node_abi: 13,
    v8: "3.22"
  },
  "0.11.10": {
    node_abi: 13,
    v8: "3.22"
  },
  "0.11.11": {
    node_abi: 14,
    v8: "3.22"
  },
  "0.11.12": {
    node_abi: 14,
    v8: "3.22"
  },
  "0.11.13": {
    node_abi: 14,
    v8: "3.25"
  },
  "0.11.14": {
    node_abi: 14,
    v8: "3.26"
  },
  "0.11.15": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.11.16": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.0": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.1": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.2": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.3": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.4": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.5": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.6": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.7": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.8": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.9": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.10": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.11": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.12": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.13": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.14": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.15": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.16": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.17": {
    node_abi: 14,
    v8: "3.28"
  },
  "0.12.18": {
    node_abi: 14,
    v8: "3.28"
  },
  "1.0.0": {
    node_abi: 42,
    v8: "3.31"
  },
  "1.0.1": {
    node_abi: 42,
    v8: "3.31"
  },
  "1.0.2": {
    node_abi: 42,
    v8: "3.31"
  },
  "1.0.3": {
    node_abi: 42,
    v8: "4.1"
  },
  "1.0.4": {
    node_abi: 42,
    v8: "4.1"
  },
  "1.1.0": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.2.0": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.3.0": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.4.1": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.4.2": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.4.3": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.5.0": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.5.1": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.6.0": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.6.1": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.6.2": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.6.3": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.6.4": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.7.1": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.8.1": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.8.2": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.8.3": {
    node_abi: 43,
    v8: "4.1"
  },
  "1.8.4": {
    node_abi: 43,
    v8: "4.1"
  },
  "2.0.0": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.0.1": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.0.2": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.1.0": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.2.0": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.2.1": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.3.0": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.3.1": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.3.2": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.3.3": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.3.4": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.4.0": {
    node_abi: 44,
    v8: "4.2"
  },
  "2.5.0": {
    node_abi: 44,
    v8: "4.2"
  },
  "3.0.0": {
    node_abi: 45,
    v8: "4.4"
  },
  "3.1.0": {
    node_abi: 45,
    v8: "4.4"
  },
  "3.2.0": {
    node_abi: 45,
    v8: "4.4"
  },
  "3.3.0": {
    node_abi: 45,
    v8: "4.4"
  },
  "3.3.1": {
    node_abi: 45,
    v8: "4.4"
  },
  "4.0.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.1.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.1.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.1.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.3": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.4": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.5": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.2.6": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.3.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.3.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.3.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.3": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.4": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.5": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.6": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.4.7": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.5.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.6.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.6.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.6.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.7.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.7.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.7.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.7.3": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.2": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.3": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.4": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.5": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.6": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.8.7": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.9.0": {
    node_abi: 46,
    v8: "4.5"
  },
  "4.9.1": {
    node_abi: 46,
    v8: "4.5"
  },
  "5.0.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.1.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.1.1": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.2.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.3.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.4.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.4.1": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.5.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.6.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.7.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.7.1": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.8.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.9.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.9.1": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.10.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.10.1": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.11.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.11.1": {
    node_abi: 47,
    v8: "4.6"
  },
  "5.12.0": {
    node_abi: 47,
    v8: "4.6"
  },
  "6.0.0": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.1.0": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.2.0": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.2.1": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.2.2": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.3.0": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.3.1": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.4.0": {
    node_abi: 48,
    v8: "5.0"
  },
  "6.5.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.6.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.7.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.8.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.8.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.9.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.9.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.9.2": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.9.3": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.9.4": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.9.5": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.10.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.10.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.10.2": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.10.3": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.11.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.11.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.11.2": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.11.3": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.11.4": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.11.5": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.12.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.12.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.12.2": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.12.3": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.13.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.13.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.14.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.14.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.14.2": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.14.3": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.14.4": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.15.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.15.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.16.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.17.0": {
    node_abi: 48,
    v8: "5.1"
  },
  "6.17.1": {
    node_abi: 48,
    v8: "5.1"
  },
  "7.0.0": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.1.0": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.2.0": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.2.1": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.3.0": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.4.0": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.5.0": {
    node_abi: 51,
    v8: "5.4"
  },
  "7.6.0": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.7.0": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.7.1": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.7.2": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.7.3": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.7.4": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.8.0": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.9.0": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.10.0": {
    node_abi: 51,
    v8: "5.5"
  },
  "7.10.1": {
    node_abi: 51,
    v8: "5.5"
  },
  "8.0.0": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.1.0": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.1.1": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.1.2": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.1.3": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.1.4": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.2.0": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.2.1": {
    node_abi: 57,
    v8: "5.8"
  },
  "8.3.0": {
    node_abi: 57,
    v8: "6.0"
  },
  "8.4.0": {
    node_abi: 57,
    v8: "6.0"
  },
  "8.5.0": {
    node_abi: 57,
    v8: "6.0"
  },
  "8.6.0": {
    node_abi: 57,
    v8: "6.0"
  },
  "8.7.0": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.8.0": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.8.1": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.9.0": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.9.1": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.9.2": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.9.3": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.9.4": {
    node_abi: 57,
    v8: "6.1"
  },
  "8.10.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.11.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.11.1": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.11.2": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.11.3": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.11.4": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.12.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.13.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.14.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.14.1": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.15.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.15.1": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.16.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.16.1": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.16.2": {
    node_abi: 57,
    v8: "6.2"
  },
  "8.17.0": {
    node_abi: 57,
    v8: "6.2"
  },
  "9.0.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.1.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.2.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.2.1": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.3.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.4.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.5.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.6.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.6.1": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.7.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.7.1": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.8.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.9.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.10.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.10.1": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.11.0": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.11.1": {
    node_abi: 59,
    v8: "6.2"
  },
  "9.11.2": {
    node_abi: 59,
    v8: "6.2"
  },
  "10.0.0": {
    node_abi: 64,
    v8: "6.6"
  },
  "10.1.0": {
    node_abi: 64,
    v8: "6.6"
  },
  "10.2.0": {
    node_abi: 64,
    v8: "6.6"
  },
  "10.2.1": {
    node_abi: 64,
    v8: "6.6"
  },
  "10.3.0": {
    node_abi: 64,
    v8: "6.6"
  },
  "10.4.0": {
    node_abi: 64,
    v8: "6.7"
  },
  "10.4.1": {
    node_abi: 64,
    v8: "6.7"
  },
  "10.5.0": {
    node_abi: 64,
    v8: "6.7"
  },
  "10.6.0": {
    node_abi: 64,
    v8: "6.7"
  },
  "10.7.0": {
    node_abi: 64,
    v8: "6.7"
  },
  "10.8.0": {
    node_abi: 64,
    v8: "6.7"
  },
  "10.9.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.10.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.11.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.12.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.13.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.14.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.14.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.14.2": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.15.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.15.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.15.2": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.15.3": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.16.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.16.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.16.2": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.16.3": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.17.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.18.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.18.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.19.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.20.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.20.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.21.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.22.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.22.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.23.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.23.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.23.2": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.23.3": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.24.0": {
    node_abi: 64,
    v8: "6.8"
  },
  "10.24.1": {
    node_abi: 64,
    v8: "6.8"
  },
  "11.0.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.1.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.2.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.3.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.4.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.5.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.6.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.7.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.8.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.9.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.10.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.10.1": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.11.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.12.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.13.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.14.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "11.15.0": {
    node_abi: 67,
    v8: "7.0"
  },
  "12.0.0": {
    node_abi: 72,
    v8: "7.4"
  },
  "12.1.0": {
    node_abi: 72,
    v8: "7.4"
  },
  "12.2.0": {
    node_abi: 72,
    v8: "7.4"
  },
  "12.3.0": {
    node_abi: 72,
    v8: "7.4"
  },
  "12.3.1": {
    node_abi: 72,
    v8: "7.4"
  },
  "12.4.0": {
    node_abi: 72,
    v8: "7.4"
  },
  "12.5.0": {
    node_abi: 72,
    v8: "7.5"
  },
  "12.6.0": {
    node_abi: 72,
    v8: "7.5"
  },
  "12.7.0": {
    node_abi: 72,
    v8: "7.5"
  },
  "12.8.0": {
    node_abi: 72,
    v8: "7.5"
  },
  "12.8.1": {
    node_abi: 72,
    v8: "7.5"
  },
  "12.9.0": {
    node_abi: 72,
    v8: "7.6"
  },
  "12.9.1": {
    node_abi: 72,
    v8: "7.6"
  },
  "12.10.0": {
    node_abi: 72,
    v8: "7.6"
  },
  "12.11.0": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.11.1": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.12.0": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.13.0": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.13.1": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.14.0": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.14.1": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.15.0": {
    node_abi: 72,
    v8: "7.7"
  },
  "12.16.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.16.1": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.16.2": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.16.3": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.17.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.18.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.18.1": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.18.2": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.18.3": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.18.4": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.19.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.19.1": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.20.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.20.1": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.20.2": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.21.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.0": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.1": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.2": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.3": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.4": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.5": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.6": {
    node_abi: 72,
    v8: "7.8"
  },
  "12.22.7": {
    node_abi: 72,
    v8: "7.8"
  },
  "13.0.0": {
    node_abi: 79,
    v8: "7.8"
  },
  "13.0.1": {
    node_abi: 79,
    v8: "7.8"
  },
  "13.1.0": {
    node_abi: 79,
    v8: "7.8"
  },
  "13.2.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.3.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.4.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.5.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.6.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.7.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.8.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.9.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.10.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.10.1": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.11.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.12.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.13.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "13.14.0": {
    node_abi: 79,
    v8: "7.9"
  },
  "14.0.0": {
    node_abi: 83,
    v8: "8.1"
  },
  "14.1.0": {
    node_abi: 83,
    v8: "8.1"
  },
  "14.2.0": {
    node_abi: 83,
    v8: "8.1"
  },
  "14.3.0": {
    node_abi: 83,
    v8: "8.1"
  },
  "14.4.0": {
    node_abi: 83,
    v8: "8.1"
  },
  "14.5.0": {
    node_abi: 83,
    v8: "8.3"
  },
  "14.6.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.7.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.8.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.9.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.10.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.10.1": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.11.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.12.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.13.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.13.1": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.14.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.15.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.15.1": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.15.2": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.15.3": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.15.4": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.15.5": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.16.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.16.1": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.1": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.2": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.3": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.4": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.5": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.17.6": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.18.0": {
    node_abi: 83,
    v8: "8.4"
  },
  "14.18.1": {
    node_abi: 83,
    v8: "8.4"
  },
  "15.0.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.0.1": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.1.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.2.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.2.1": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.3.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.4.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.5.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.5.1": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.6.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.7.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.8.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.9.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.10.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.11.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.12.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.13.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "15.14.0": {
    node_abi: 88,
    v8: "8.6"
  },
  "16.0.0": {
    node_abi: 93,
    v8: "9.0"
  },
  "16.1.0": {
    node_abi: 93,
    v8: "9.0"
  },
  "16.2.0": {
    node_abi: 93,
    v8: "9.0"
  },
  "16.3.0": {
    node_abi: 93,
    v8: "9.0"
  },
  "16.4.0": {
    node_abi: 93,
    v8: "9.1"
  },
  "16.4.1": {
    node_abi: 93,
    v8: "9.1"
  },
  "16.4.2": {
    node_abi: 93,
    v8: "9.1"
  },
  "16.5.0": {
    node_abi: 93,
    v8: "9.1"
  },
  "16.6.0": {
    node_abi: 93,
    v8: "9.2"
  },
  "16.6.1": {
    node_abi: 93,
    v8: "9.2"
  },
  "16.6.2": {
    node_abi: 93,
    v8: "9.2"
  },
  "16.7.0": {
    node_abi: 93,
    v8: "9.2"
  },
  "16.8.0": {
    node_abi: 93,
    v8: "9.2"
  },
  "16.9.0": {
    node_abi: 93,
    v8: "9.3"
  },
  "16.9.1": {
    node_abi: 93,
    v8: "9.3"
  },
  "16.10.0": {
    node_abi: 93,
    v8: "9.3"
  },
  "16.11.0": {
    node_abi: 93,
    v8: "9.4"
  },
  "16.11.1": {
    node_abi: 93,
    v8: "9.4"
  },
  "16.12.0": {
    node_abi: 93,
    v8: "9.4"
  },
  "16.13.0": {
    node_abi: 93,
    v8: "9.4"
  },
  "17.0.0": {
    node_abi: 102,
    v8: "9.5"
  },
  "17.0.1": {
    node_abi: 102,
    v8: "9.5"
  },
  "17.1.0": {
    node_abi: 102,
    v8: "9.5"
  }
};
var hasRequiredVersioning;
function requireVersioning() {
  if (hasRequiredVersioning)
    return versioning.exports;
  hasRequiredVersioning = 1;
  (function(module, exports2) {
    var define_process_env_default2 = {};
    module.exports = exports2;
    const path3 = pathExports;
    const semver2 = semver$3;
    const url2 = require$$2$2;
    const detect_libc = requireDetectLibc();
    const napi2 = requireNapi();
    let abi_crosswalk;
    if (define_process_env_default2.NODE_PRE_GYP_ABI_CROSSWALK) {
      abi_crosswalk = commonjsRequire(define_process_env_default2.NODE_PRE_GYP_ABI_CROSSWALK);
    } else {
      abi_crosswalk = require$$5;
    }
    const major_versions = {};
    Object.keys(abi_crosswalk).forEach((v) => {
      const major2 = v.split(".")[0];
      if (!major_versions[major2]) {
        major_versions[major2] = v;
      }
    });
    function get_electron_abi(runtime, target_version) {
      if (!runtime) {
        throw new Error("get_electron_abi requires valid runtime arg");
      }
      if (typeof target_version === "undefined") {
        throw new Error("Empty target version is not supported if electron is the target.");
      }
      const sem_ver = semver2.parse(target_version);
      return runtime + "-v" + sem_ver.major + "." + sem_ver.minor;
    }
    module.exports.get_electron_abi = get_electron_abi;
    function get_node_webkit_abi(runtime, target_version) {
      if (!runtime) {
        throw new Error("get_node_webkit_abi requires valid runtime arg");
      }
      if (typeof target_version === "undefined") {
        throw new Error("Empty target version is not supported if node-webkit is the target.");
      }
      return runtime + "-v" + target_version;
    }
    module.exports.get_node_webkit_abi = get_node_webkit_abi;
    function get_node_abi(runtime, versions) {
      if (!runtime) {
        throw new Error("get_node_abi requires valid runtime arg");
      }
      if (!versions) {
        throw new Error("get_node_abi requires valid process.versions object");
      }
      const sem_ver = semver2.parse(versions.node);
      if (sem_ver.major === 0 && sem_ver.minor % 2) {
        return runtime + "-v" + versions.node;
      } else {
        return versions.modules ? runtime + "-v" + +versions.modules : "v8-" + versions.v8.split(".").slice(0, 2).join(".");
      }
    }
    module.exports.get_node_abi = get_node_abi;
    function get_runtime_abi(runtime, target_version) {
      if (!runtime) {
        throw new Error("get_runtime_abi requires valid runtime arg");
      }
      if (runtime === "node-webkit") {
        return get_node_webkit_abi(runtime, target_version || process.versions["node-webkit"]);
      } else if (runtime === "electron") {
        return get_electron_abi(runtime, target_version || process.versions.electron);
      } else {
        if (runtime !== "node") {
          throw new Error("Unknown Runtime: '" + runtime + "'");
        }
        if (!target_version) {
          return get_node_abi(runtime, process.versions);
        } else {
          let cross_obj;
          if (abi_crosswalk[target_version]) {
            cross_obj = abi_crosswalk[target_version];
          } else {
            const target_parts = target_version.split(".").map((i2) => {
              return +i2;
            });
            if (target_parts.length !== 3) {
              throw new Error("Unknown target version: " + target_version);
            }
            const major2 = target_parts[0];
            let minor2 = target_parts[1];
            let patch2 = target_parts[2];
            if (major2 === 1) {
              while (true) {
                if (minor2 > 0)
                  --minor2;
                if (patch2 > 0)
                  --patch2;
                const new_iojs_target = "" + major2 + "." + minor2 + "." + patch2;
                if (abi_crosswalk[new_iojs_target]) {
                  cross_obj = abi_crosswalk[new_iojs_target];
                  console.log("Warning: node-pre-gyp could not find exact match for " + target_version);
                  console.log("Warning: but node-pre-gyp successfully choose " + new_iojs_target + " as ABI compatible target");
                  break;
                }
                if (minor2 === 0 && patch2 === 0) {
                  break;
                }
              }
            } else if (major2 >= 2) {
              if (major_versions[major2]) {
                cross_obj = abi_crosswalk[major_versions[major2]];
                console.log("Warning: node-pre-gyp could not find exact match for " + target_version);
                console.log("Warning: but node-pre-gyp successfully choose " + major_versions[major2] + " as ABI compatible target");
              }
            } else if (major2 === 0) {
              if (target_parts[1] % 2 === 0) {
                while (--patch2 > 0) {
                  const new_node_target = "" + major2 + "." + minor2 + "." + patch2;
                  if (abi_crosswalk[new_node_target]) {
                    cross_obj = abi_crosswalk[new_node_target];
                    console.log("Warning: node-pre-gyp could not find exact match for " + target_version);
                    console.log("Warning: but node-pre-gyp successfully choose " + new_node_target + " as ABI compatible target");
                    break;
                  }
                }
              }
            }
          }
          if (!cross_obj) {
            throw new Error("Unsupported target version: " + target_version);
          }
          const versions_obj = {
            node: target_version,
            v8: cross_obj.v8 + ".0",
            // abi_crosswalk uses 1 for node versions lacking process.versions.modules
            // process.versions.modules added in >= v0.10.4 and v0.11.7
            modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : void 0
          };
          return get_node_abi(runtime, versions_obj);
        }
      }
    }
    module.exports.get_runtime_abi = get_runtime_abi;
    const required_parameters = [
      "module_name",
      "module_path",
      "host"
    ];
    function validate_config(package_json, opts) {
      const msg = package_json.name + " package.json is not node-pre-gyp ready:\n";
      const missing = [];
      if (!package_json.main) {
        missing.push("main");
      }
      if (!package_json.version) {
        missing.push("version");
      }
      if (!package_json.name) {
        missing.push("name");
      }
      if (!package_json.binary) {
        missing.push("binary");
      }
      const o = package_json.binary;
      if (o) {
        required_parameters.forEach((p) => {
          if (!o[p] || typeof o[p] !== "string") {
            missing.push("binary." + p);
          }
        });
      }
      if (missing.length >= 1) {
        throw new Error(msg + "package.json must declare these properties: \n" + missing.join("\n"));
      }
      if (o) {
        const protocol2 = url2.parse(o.host).protocol;
        if (protocol2 === "http:") {
          throw new Error("'host' protocol (" + protocol2 + ") is invalid - only 'https:' is accepted");
        }
      }
      napi2.validate_package_json(package_json, opts);
    }
    module.exports.validate_config = validate_config;
    function eval_template(template, opts) {
      Object.keys(opts).forEach((key) => {
        const pattern = "{" + key + "}";
        while (template.indexOf(pattern) > -1) {
          template = template.replace(pattern, opts[key]);
        }
      });
      return template;
    }
    function fix_slashes(pathname) {
      if (pathname.slice(-1) !== "/") {
        return pathname + "/";
      }
      return pathname;
    }
    function drop_double_slashes(pathname) {
      return pathname.replace(/\/\//g, "/");
    }
    function get_process_runtime(versions) {
      let runtime = "node";
      if (versions["node-webkit"]) {
        runtime = "node-webkit";
      } else if (versions.electron) {
        runtime = "electron";
      }
      return runtime;
    }
    module.exports.get_process_runtime = get_process_runtime;
    const default_package_name = "{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz";
    const default_remote_path = "";
    module.exports.evaluate = function(package_json, options2, napi_build_version) {
      options2 = options2 || {};
      validate_config(package_json, options2);
      const v = package_json.version;
      const module_version = semver2.parse(v);
      const runtime = options2.runtime || get_process_runtime(process.versions);
      const opts = {
        name: package_json.name,
        configuration: options2.debug ? "Debug" : "Release",
        debug: options2.debug,
        module_name: package_json.binary.module_name,
        version: module_version.version,
        prerelease: module_version.prerelease.length ? module_version.prerelease.join(".") : "",
        build: module_version.build.length ? module_version.build.join(".") : "",
        major: module_version.major,
        minor: module_version.minor,
        patch: module_version.patch,
        runtime,
        node_abi: get_runtime_abi(runtime, options2.target),
        node_abi_napi: napi2.get_napi_version(options2.target) ? "napi" : get_runtime_abi(runtime, options2.target),
        napi_version: napi2.get_napi_version(options2.target),
        // non-zero numeric, undefined if unsupported
        napi_build_version: napi_build_version || "",
        node_napi_label: napi_build_version ? "napi-v" + napi_build_version : get_runtime_abi(runtime, options2.target),
        target: options2.target || "",
        platform: options2.target_platform || process.platform,
        target_platform: options2.target_platform || process.platform,
        arch: options2.target_arch || process.arch,
        target_arch: options2.target_arch || process.arch,
        libc: options2.target_libc || detect_libc.familySync() || "unknown",
        module_main: package_json.main,
        toolset: options2.toolset || "",
        // address https://github.com/mapbox/node-pre-gyp/issues/119
        bucket: package_json.binary.bucket,
        region: package_json.binary.region,
        s3ForcePathStyle: package_json.binary.s3ForcePathStyle || false
      };
      const validModuleName = opts.module_name.replace("-", "_");
      const host2 = define_process_env_default2["npm_config_" + validModuleName + "_binary_host_mirror"] || package_json.binary.host;
      opts.host = fix_slashes(eval_template(host2, opts));
      opts.module_path = eval_template(package_json.binary.module_path, opts);
      if (options2.module_root) {
        opts.module_path = path3.join(options2.module_root, opts.module_path);
      } else {
        opts.module_path = path3.resolve(opts.module_path);
      }
      opts.module = path3.join(opts.module_path, opts.module_name + ".node");
      opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path, opts))) : default_remote_path;
      const package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;
      opts.package_name = eval_template(package_name, opts);
      opts.staged_tarball = path3.join("build/stage", opts.remote_path, opts.package_name);
      opts.hosted_path = url2.resolve(opts.host, opts.remote_path);
      opts.hosted_tarball = url2.resolve(opts.hosted_path, opts.package_name);
      return opts;
    };
  })(versioning, versioning.exports);
  return versioning.exports;
}
var hasRequiredPreBinding;
function requirePreBinding() {
  if (hasRequiredPreBinding)
    return preBinding.exports;
  hasRequiredPreBinding = 1;
  (function(module, exports2) {
    const npg = requireNodePreGyp();
    const versioning2 = requireVersioning();
    const napi2 = requireNapi();
    const existsSync = require$$2$2.existsSync || pathExports.existsSync;
    const path3 = pathExports;
    module.exports = exports2;
    exports2.usage = "Finds the require path for the node-pre-gyp installed module";
    exports2.validate = function(package_json, opts) {
      versioning2.validate_config(package_json, opts);
    };
    exports2.find = function(package_json_path, opts) {
      if (!existsSync(package_json_path)) {
        throw new Error(package_json_path + "does not exist");
      }
      const prog = new npg.Run({ package_json_path, argv: process.argv });
      prog.setBinaryHostProperty();
      const package_json = prog.package_json;
      versioning2.validate_config(package_json, opts);
      let napi_build_version;
      if (napi2.get_napi_build_versions(package_json, opts)) {
        napi_build_version = napi2.get_best_napi_build_version(package_json, opts);
      }
      opts = opts || {};
      if (!opts.module_root)
        opts.module_root = path3.dirname(package_json_path);
      const meta = versioning2.evaluate(package_json, opts, napi_build_version);
      return meta.module;
    };
  })(preBinding, preBinding.exports);
  return preBinding.exports;
}
const name = "@mapbox/node-pre-gyp";
const description = "Node.js native addon binary install tool";
const version = "1.0.11";
const keywords = [
  "native",
  "addon",
  "module",
  "c",
  "c++",
  "bindings",
  "binary"
];
const license = "BSD-3-Clause";
const author = "Dane Springmeyer <dane@mapbox.com>";
const repository = {
  type: "git",
  url: "git://github.com/mapbox/node-pre-gyp.git"
};
const bin = "./bin/node-pre-gyp";
const main = "./lib/node-pre-gyp.js";
const dependencies = {
  "detect-libc": "^2.0.0",
  "https-proxy-agent": "^5.0.0",
  "make-dir": "^3.1.0",
  "node-fetch": "^2.6.7",
  nopt: "^5.0.0",
  npmlog: "^5.0.1",
  rimraf: "^3.0.2",
  semver: "^7.3.5",
  tar: "^6.1.11"
};
const devDependencies = {
  "@mapbox/cloudfriend": "^5.1.0",
  "@mapbox/eslint-config-mapbox": "^3.0.0",
  "aws-sdk": "^2.1087.0",
  codecov: "^3.8.3",
  eslint: "^7.32.0",
  "eslint-plugin-node": "^11.1.0",
  "mock-aws-s3": "^4.0.2",
  nock: "^12.0.3",
  "node-addon-api": "^4.3.0",
  nyc: "^15.1.0",
  tape: "^5.5.2",
  "tar-fs": "^2.1.1"
};
const nyc = {
  all: true,
  "skip-full": false,
  exclude: [
    "test/**"
  ]
};
const scripts = {
  coverage: "nyc --all --include index.js --include lib/ npm test",
  "upload-coverage": "nyc report --reporter json && codecov --clear --flags=unit --file=./coverage/coverage-final.json",
  lint: "eslint bin/node-pre-gyp lib/*js lib/util/*js test/*js scripts/*js",
  fix: "npm run lint -- --fix",
  "update-crosswalk": "node scripts/abi_crosswalk.js",
  test: "tape test/*test.js"
};
const require$$9 = {
  name,
  description,
  version,
  keywords,
  license,
  author,
  repository,
  bin,
  main,
  dependencies,
  devDependencies,
  nyc,
  scripts
};
var hasRequiredNodePreGyp;
function requireNodePreGyp() {
  if (hasRequiredNodePreGyp)
    return nodePreGyp.exports;
  hasRequiredNodePreGyp = 1;
  (function(module, exports2) {
    var define_process_env_default2 = {};
    module.exports = exports2;
    exports2.mockS3Http = s3_setupExports.get_mockS3Http();
    exports2.mockS3Http("on");
    const mocking = exports2.mockS3Http("get");
    const fs2 = require$$2$2;
    const path3 = pathExports;
    const nopt2 = noptExports;
    const log2 = logExports;
    log2.disableProgress();
    const napi2 = requireNapi();
    const EE = require$$2$2.EventEmitter;
    const inherits2 = util$f.inherits;
    const cli_commands = [
      "clean",
      "install",
      "reinstall",
      "build",
      "rebuild",
      "package",
      "testpackage",
      "publish",
      "unpublish",
      "info",
      "testbinary",
      "reveal",
      "configure"
    ];
    const aliases = {};
    log2.heading = "node-pre-gyp";
    if (mocking) {
      log2.warn(`mocking s3 to ${define_process_env_default2.node_pre_gyp_mock_s3}`);
    }
    Object.defineProperty(exports2, "find", {
      get: function() {
        return requirePreBinding().find;
      },
      enumerable: true
    });
    function Run({ package_json_path = "./package.json", argv }) {
      this.package_json_path = package_json_path;
      this.commands = {};
      const self2 = this;
      cli_commands.forEach((command) => {
        self2.commands[command] = function(argvx, callback) {
          log2.verbose("command", command, argvx);
          return commonjsRequire("./" + command)(self2, argvx, callback);
        };
      });
      this.parseArgv(argv);
      this.binaryHostSet = false;
    }
    inherits2(Run, EE);
    exports2.Run = Run;
    const proto2 = Run.prototype;
    proto2.package = require$$9;
    proto2.configDefs = {
      help: Boolean,
      // everywhere
      arch: String,
      // 'configure'
      debug: Boolean,
      // 'build'
      directory: String,
      // bin
      proxy: String,
      // 'install'
      loglevel: String
      // everywhere
    };
    proto2.shorthands = {
      release: "--no-debug",
      C: "--directory",
      debug: "--debug",
      j: "--jobs",
      silent: "--loglevel=silent",
      silly: "--loglevel=silly",
      verbose: "--loglevel=verbose"
    };
    proto2.aliases = aliases;
    proto2.parseArgv = function parseOpts(argv) {
      this.opts = nopt2(this.configDefs, this.shorthands, argv);
      this.argv = this.opts.argv.remain.slice();
      const commands = this.todo = [];
      argv = this.argv.map((arg) => {
        if (arg in this.aliases) {
          arg = this.aliases[arg];
        }
        return arg;
      });
      argv.slice().forEach((arg) => {
        if (arg in this.commands) {
          const args = argv.splice(0, argv.indexOf(arg));
          argv.shift();
          if (commands.length > 0) {
            commands[commands.length - 1].args = args;
          }
          commands.push({ name: arg, args: [] });
        }
      });
      if (commands.length > 0) {
        commands[commands.length - 1].args = argv.splice(0);
      }
      let package_json_path = this.package_json_path;
      if (this.opts.directory) {
        package_json_path = path3.join(this.opts.directory, package_json_path);
      }
      this.package_json = JSON.parse(fs2.readFileSync(package_json_path));
      this.todo = napi2.expand_commands(this.package_json, this.opts, commands);
      const npm_config_prefix = "npm_config_";
      Object.keys(define_process_env_default2).forEach((name2) => {
        if (name2.indexOf(npm_config_prefix) !== 0)
          return;
        const val = define_process_env_default2[name2];
        if (name2 === npm_config_prefix + "loglevel") {
          log2.level = val;
        } else {
          name2 = name2.substring(npm_config_prefix.length);
          if (name2 === "argv") {
            if (this.opts.argv && this.opts.argv.remain && this.opts.argv.remain.length)
              ;
            else {
              this.opts[name2] = val;
            }
          } else {
            this.opts[name2] = val;
          }
        }
      });
      if (this.opts.loglevel) {
        log2.level = this.opts.loglevel;
      }
      log2.resume();
    };
    proto2.setBinaryHostProperty = function(command) {
      if (this.binaryHostSet) {
        return this.package_json.binary.host;
      }
      const p = this.package_json;
      if (!p || !p.binary || p.binary.host) {
        return "";
      }
      if (!p.binary.staging_host || !p.binary.production_host) {
        return "";
      }
      let target = "production_host";
      if (command === "publish" || command === "unpublish") {
        target = "staging_host";
      }
      const npg_s3_host = define_process_env_default2.node_pre_gyp_s3_host;
      if (npg_s3_host === "staging" || npg_s3_host === "production") {
        target = `${npg_s3_host}_host`;
      } else if (this.opts["s3_host"] === "staging" || this.opts["s3_host"] === "production") {
        target = `${this.opts["s3_host"]}_host`;
      } else if (this.opts["s3_host"] || npg_s3_host) {
        throw new Error(`invalid s3_host ${this.opts["s3_host"] || npg_s3_host}`);
      }
      p.binary.host = p.binary[target];
      this.binaryHostSet = true;
      return p.binary.host;
    };
    proto2.usage = function usage() {
      const str = [
        "",
        "  Usage: node-pre-gyp <command> [options]",
        "",
        "  where <command> is one of:",
        cli_commands.map((c) => {
          return "    - " + c + " - " + commonjsRequire("./" + c).usage;
        }).join("\n"),
        "",
        "node-pre-gyp@" + this.version + "  " + path3.resolve(__dirname, ".."),
        "node@" + process.versions.node
      ].join("\n");
      return str;
    };
    Object.defineProperty(proto2, "version", {
      get: function() {
        return this.package.version;
      },
      enumerable: true
    });
  })(nodePreGyp, nodePreGyp.exports);
  return nodePreGyp.exports;
}
var promises = {};
var hasRequiredPromises;
function requirePromises() {
  if (hasRequiredPromises)
    return promises;
  hasRequiredPromises = 1;
  var Promise2 = commonjsGlobal.Promise;
  promises.promise = function(fn, context, args) {
    if (!Array.isArray(args)) {
      args = Array.prototype.slice.call(args);
    }
    if (typeof fn !== "function") {
      return Promise2.reject(new Error("fn must be a function"));
    }
    return new Promise2(function(resolve3, reject) {
      args.push(function(err, data) {
        if (err) {
          reject(err);
        } else {
          resolve3(data);
        }
      });
      fn.apply(context, args);
    });
  };
  promises.reject = function(err) {
    return Promise2.reject(err);
  };
  promises.use = function(promise) {
    Promise2 = promise;
  };
  return promises;
}
(function(module) {
  var nodePreGyp2 = requireNodePreGyp();
  var path3 = pathExports;
  var binding_path = nodePreGyp2.find(path3.resolve(path3.join(__dirname, "./package.json")));
  var bindings = commonjsRequire(binding_path);
  var crypto2 = require$$2$2;
  var promises2 = requirePromises();
  module.exports.genSaltSync = function genSaltSync(rounds, minor2) {
    if (!rounds) {
      rounds = 10;
    } else if (typeof rounds !== "number") {
      throw new Error("rounds must be a number");
    }
    if (!minor2) {
      minor2 = "b";
    } else if (minor2 !== "b" && minor2 !== "a") {
      throw new Error('minor must be either "a" or "b"');
    }
    return bindings.gen_salt_sync(minor2, rounds, crypto2.randomBytes(16));
  };
  module.exports.genSalt = function genSalt(rounds, minor2, cb) {
    var error3;
    if (typeof arguments[0] === "function") {
      cb = arguments[0];
      rounds = 10;
      minor2 = "b";
    } else if (typeof arguments[1] === "function") {
      cb = arguments[1];
      minor2 = "b";
    }
    if (!cb) {
      return promises2.promise(genSalt, this, [rounds, minor2]);
    }
    if (!rounds) {
      rounds = 10;
    } else if (typeof rounds !== "number") {
      error3 = new Error("rounds must be a number");
      return process.nextTick(function() {
        cb(error3);
      });
    }
    if (!minor2) {
      minor2 = "b";
    } else if (minor2 !== "b" && minor2 !== "a") {
      error3 = new Error('minor must be either "a" or "b"');
      return process.nextTick(function() {
        cb(error3);
      });
    }
    crypto2.randomBytes(16, function(error4, randomBytes2) {
      if (error4) {
        cb(error4);
        return;
      }
      bindings.gen_salt(minor2, rounds, randomBytes2, cb);
    });
  };
  module.exports.hashSync = function hashSync(data, salt) {
    if (data == null || salt == null) {
      throw new Error("data and salt arguments required");
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof salt !== "string" && typeof salt !== "number") {
      throw new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
    }
    if (typeof salt === "number") {
      salt = module.exports.genSaltSync(salt);
    }
    return bindings.encrypt_sync(data, salt);
  };
  module.exports.hash = function hash(data, salt, cb) {
    var error3;
    if (typeof data === "function") {
      error3 = new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
      return process.nextTick(function() {
        data(error3);
      });
    }
    if (typeof salt === "function") {
      error3 = new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
      return process.nextTick(function() {
        salt(error3);
      });
    }
    if (cb && typeof cb !== "function") {
      return promises2.reject(new Error("cb must be a function or null to return a Promise"));
    }
    if (!cb) {
      return promises2.promise(hash, this, [data, salt]);
    }
    if (data == null || salt == null) {
      error3 = new Error("data and salt arguments required");
      return process.nextTick(function() {
        cb(error3);
      });
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof salt !== "string" && typeof salt !== "number") {
      error3 = new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
      return process.nextTick(function() {
        cb(error3);
      });
    }
    if (typeof salt === "number") {
      return module.exports.genSalt(salt, function(err, salt2) {
        return bindings.encrypt(data, salt2, cb);
      });
    }
    return bindings.encrypt(data, salt, cb);
  };
  module.exports.compareSync = function compareSync(data, hash) {
    if (data == null || hash == null) {
      throw new Error("data and hash arguments required");
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof hash !== "string") {
      throw new Error("data must be a string or Buffer and hash must be a string");
    }
    return bindings.compare_sync(data, hash);
  };
  module.exports.compare = function compare2(data, hash, cb) {
    var error3;
    if (typeof data === "function") {
      error3 = new Error("data and hash arguments required");
      return process.nextTick(function() {
        data(error3);
      });
    }
    if (typeof hash === "function") {
      error3 = new Error("data and hash arguments required");
      return process.nextTick(function() {
        hash(error3);
      });
    }
    if (cb && typeof cb !== "function") {
      return promises2.reject(new Error("cb must be a function or null to return a Promise"));
    }
    if (!cb) {
      return promises2.promise(compare2, this, [data, hash]);
    }
    if (data == null || hash == null) {
      error3 = new Error("data and hash arguments required");
      return process.nextTick(function() {
        cb(error3);
      });
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof hash !== "string") {
      error3 = new Error("data and hash must be strings");
      return process.nextTick(function() {
        cb(error3);
      });
    }
    return bindings.compare(data, hash, cb);
  };
  module.exports.getRounds = function getRounds(hash) {
    if (hash == null) {
      throw new Error("hash argument required");
    }
    if (typeof hash !== "string") {
      throw new Error("hash must be a string");
    }
    return bindings.get_rounds(hash);
  };
})(bcrypt$1);
var bcryptExports = bcrypt$1.exports;
const bcrypt = /* @__PURE__ */ getDefaultExportFromCjs(bcryptExports);
var define_process_env_default$1 = {};
const loginUser = async (req2, res2) => {
  const { email, password } = req2.body;
  try {
    const user = await User$1.findOne({ email });
    if (!user) {
      return res2.render("login", { error: "User not found" });
    }
    if (!await bcrypt.compare(password, user.password)) {
      return res2.render("login", { error: "Passwords do not match" });
    }
    const token = jwt.sign({ userId: user._id }, define_process_env_default$1.JWT_SECRET, {
      expiresIn: "30s"
    });
    const refreshToken = jwt.sign(
      { userId: user._id },
      define_process_env_default$1.JWT_REFRESH_SECRET,
      {
        expiresIn: "1d"
      }
    );
    res2.cookie("token", token, { httpOnly: true });
    res2.cookie("refreshToken", refreshToken, { httpOnly: true });
    res2.redirect("/rooms");
  } catch (error3) {
    console.error(error3);
    res2.status(500).json({ error: "Internal Server Error" });
  }
};
const registerUser = async (req2, res2) => {
  const { username, email, password } = req2.body;
  const hashedPassword = await bcrypt.hash(password, 10);
  const user = new User$1({ username, email, password: hashedPassword });
  try {
    await user.save();
    console.log("User registered successfully:", user);
    res2.redirect("/");
  } catch (err) {
    console.error("Error registering user:", err);
    res2.status(500).send("Error registering user");
  }
};
const deleteUser = async (req2, res2) => {
  try {
    const userId = req2.user._id;
    await User$1.findByIdAndDelete(userId);
    console.log("Deleted user: ", userId);
    res2.redirect("/register");
  } catch (error3) {
    console.error(error3);
    res2.status(500).json({ error: "Internal Server Error" });
  }
};
const Schema = mongoose.Schema;
const roomSchema = new Schema({
  name: {
    type: String,
    required: true
  },
  slug: {
    type: String,
    required: true
  },
  users: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }]
});
const Room = mongoose.model("Room", roomSchema);
const getAllRooms = async (req2, res2) => {
  try {
    const rooms = await Room.find();
    console.log(rooms);
    res2.render("rooms", { rooms });
  } catch (e) {
    console.error(e);
    return [];
  }
};
const getUsersInRoomController = async (req2, res2) => {
  try {
    const roomId = req2.params.roomId;
    const loggedInUser = req2.user;
    const room = await Room.findOne({ name: roomId });
    res2.render("room", { layout: "layouts/chatLayout", room, loggedInUser });
  } catch (e) {
    console.error("Error fetching users in room:", e);
  }
};
const router = express$1.Router();
router.post("/login", loginUser).get("/register", (req2, res2) => {
  res2.render("register");
}).post("/register", registerUser).get("/", (req2, res2) => {
  res2.render("index");
}).post("/logout", (req2, res2) => {
  res2.clearCookie("token");
  res2.clearCookie("refreshToken");
  res2.redirect("/");
}).get("/profile/:userId", authenticate, (req2, res2) => {
  const user = req2.user;
  res2.render("profile", { user });
}).post("/delete", authenticate, deleteUser).get("/rooms", authenticate, getAllRooms).get("/rooms/:roomId", authenticate, getUsersInRoomController);
const buildMsg = (name2, text) => {
  return {
    name: name2,
    text,
    time: new Intl.DateTimeFormat("default", {
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    }).format(/* @__PURE__ */ new Date())
  };
};
var define_process_env_default = {};
const app = express$1();
const port = define_process_env_default.PORT || 3e3;
const db = mongoose.connection;
const admin = "Admin";
const __dirname$1 = import.meta.dirname;
app.set("view engine", "ejs");
app.set("views", path$7.join(__dirname$1, "src", "views"));
app.set("layout", "layouts/main");
app.use(express$1.static(path$7.join(__dirname$1, "src", "public")));
app.use(express$1.urlencoded({ extended: false }));
app.use(express$1.json());
app.use(cors());
app.use(expressLayouts$1);
app.use(cookieParser$1());
app.use(router);
const connectDB = async () => {
  try {
    await mongoose.connect(define_process_env_default.DB_URL);
  } catch (e) {
    console.error(e);
  }
};
connectDB();
const storage = multer$1.diskStorage({
  destination: function(req2, file, cb) {
    cb(null, "src/uploads/avatars");
  },
  filename: function(req2, file, cb) {
    cb(
      null,
      file.fieldname + "-" + Date.now() + path$7.extname(file.originalname)
    );
  }
});
const upload = multer$1({ storage });
app.post("/upload", authenticate, upload.single("avatar"), async (req2, res2) => {
  try {
    const userId = req2.user._id;
    const avatarPath = req2.file.path;
    await User$1.findByIdAndUpdate(userId, { avatar: avatarPath });
    res2.redirect("/profile/:userId");
  } catch (err) {
    console.error(err);
    res2.status(500).send("Internal Server Error");
  }
});
const expressServer = app.listen(port, () => {
  console.log(`listening on port: ${port}`);
});
db.once("open", () => {
  console.log("Connected to MongoDB");
});
const io = new Server2(expressServer, {
  cors: {
    origin: false
  }
});
io.on("connection", (socket2) => {
  console.log("New connection:", socket2.id);
  socket2.emit("message", buildMsg(admin, "Welcome to Chat App!"));
  socket2.on("joinRoom", (roomId) => {
    socket2.join(roomId);
    console.log(`Socket ${socket2.id} joined room ${roomId}`);
  });
});
app.use((req2, res2) => {
  res2.status(404).send(
    "We`re sorry, we were not able to find the page you were looking for"
  );
});
